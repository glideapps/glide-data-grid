{"version":3,"file":"main.e85a534b.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACZA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AADA;AASA;AACA;AADA;;;ACXA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AApEA;AAsEA;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AASA;;AAaA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AADA;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAFA;;AAOA;AAAA;AAAA;AAAA;AAwBA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AApBA;AAsBA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAFA;AAJA;AAAA;AA3BA;AA6CA;AACA;AACA;AAEA;AAFA;AAIA;AAnDA;AAsDA;;;;AChIA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAnHA;AAsHA;;AC5HA;AAQA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AAQA;AACA;AACA;AAcA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyDA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;;AACA;AAAA;;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AA5CA;AA8CA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAFA;AAPA;AACA;AAiBA;AACA;AAAA;AAAA;AAFA;AArBA;AALA;AAhDA;AAsFA;AAEA;AAFA;AAtFA;AAmGA;;;;ACtLA;AACA;AAmBA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAMA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAFA;AAFA;AALA;AAeA;AACA;AAEA;AAFA;AAvEA;AA6EA;;;;;;;;AClGA;AAQA;AACA;AACA;;AAIA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAHA;;AAeA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AAGA;AACA;AAFA;AAOA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAHA;AADA;AAOA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAFA;AAdA;AAsCA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AALA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAFA;AAvDA;AAAA;AApBA;;AAwFA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAMA;AAbA;AAeA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAFA;AAHA;AAHA;AAYA;AAEA;AAFA;AA3BA;AAiCA;;;;AC3KA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AACA;AAGA;AACA;;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAjBA;AAmBA;AAEA;AAFA;AA9CA;AAoDA;;AC1DA;AAOA;AACA;AAeA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAKA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAFA;AAFA;AAOA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAYA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AA1GA;AA6GA;;AChJA;AAQA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAQA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AA5BA;AA+BA;;ACvCA;AACA;AAWA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;;AACA;AAEA;AAEA;AAFA;AAFA;AAOA;AAbA;AAgBA;AACA;AACA;;AACA;AACA;AACA;;AAIA;AAEA;AAFA;AAIA;AAlDA;AAqDA;;ACjEA;AAQA;AACA;;AAoBA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;;AACA;AAAA;;AACA;AACA;AACA;;AACA;AAhBA;AAkBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AAEA;AA7DA;AAgEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAFA;AAFA;AAJA;AAcA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AAEA;AAFA;AAFA;AA3BA;AACA;AADA;AAsCA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AAFA;AAFA;AALA;AAAA;AA1GA;AA4HA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAFA;AAIA;AAnIA;AAsIA;AAAA;AAAA;AAAA;;AA2FA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AAUA;AACA;AACA;AACA;AACA;AALA;AAAA;AASA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AA1DA;;AAwEA;;;;AChXA;AAOA;;AAgBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;AApDA;AAuDA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAcA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;AACA;AACA;AACA;AAGA;AACA;AAOA;AAEA;AACA;AAKA;AAAA;AAAA;AAAA;;AAaA;AACA;AAEA;AAAA;AAHA;;AAQA;AACA;AAEA;AAHA;AAYA;AAAA;AAAA;AAAA;;AA2CA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AADA;AAXA;;AAyBA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAMA;AACA;AAEA;AACA;AAAA;AAAA;AAIA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AADA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AALA;AAJA;AAHA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAJA;AAFA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAHA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAJA;AAHA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAUA;AAbA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAJA;AAcA;AAlBA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAJA;AASA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAJA;AAQA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AARA;AAJA;AAmBA;AAtBA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AADA;AAfA;AAmBA;AACA;;AACA;AA1MA;AA4MA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AA9PA;AALA;AAwQA;AACA;AACA;AADA;AADA;AAMA;AACA;AAEA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;;AACA;AACA;AACA;AARA;AAUA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAdA;AAyBA;AAEA;AACA;AAFA;AAKA;AA/BA;AAbA;AAiDA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;ACxeA;AAGA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;;AATA;;AAYA;AACA;AACA;;AAGA;AACA;AAMA;;;;;;;;;;;;;;;ACxBA;AAKA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AAgCA;AAsCA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAxCA;AA4CA;AACA;AACA;AAGA;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACjIA;;AAIA;AAAA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1DA;AACA;AAEA;AAMA;AAEA;AAMA;AACA;AAGA;AACA;;AAGA;AAAA;;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AAEA;AAAA;;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAMA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAQA;AACA;AAEA;;AACA;AAEA;AACA;;AACA;AAEA;AAEA;AACA;AAKA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5NA;AAKA;AAAA;AAAA;AAAA;;AAAA;AAcA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AAzBA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAgBA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAIA;;AAlCA;;;;;;;;ACLA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ACRA;;AAEA;AACA;AACA;AACA;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAFA;AAIA;;AC5DA;AACA;AAEA;AACA;AAEA;AAYA;AAEA;;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAIA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;;AAEA;AAAA;AAAA;AAGA;;AACA;AAEA;AAGA;AACA;;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAUA;AAAA;AAAA;AAQA;;AAEA;;;;ACrOA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ACDA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAWA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AA2BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AAEA;AACA;AAOA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAKA;AAEA;AAEA;AACA;AAEA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAIA;AACA;;AACA;AACA;AACA;AArBA;;AAwBA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAIA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;;AACA;AACA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AADA;AAIA;AAEA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AALA;AASA;AACA;AACA;AACA;AACA;AALA;AAUA;AACA;AACA;AACA;AACA;AALA;AAYA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAKA;AAeA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AAiFA;;AAEA;;;;;;;;AC9dA;AACA;AAEA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAMA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AAZA;AAcA;AAdA;AArBA;;;;AC3BA;AAIA;AAWA;;AAEA;AAKA;;AACA;AAEA;AACA;AACA;;AAEA;AAWA;;AACA;AACA;AAGA;;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAIA;AAGA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAJA;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAFA;AAIA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AAEA;AAFA;AAIA;;AAEA;AACA;AAEA;AAFA;AAIA;;AAEA;AAWA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AAEA;AAEA;AACA;AAHA;AAKA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AC3NA;;AAYA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAnBA;AAqBA;;AAEA;AAGA;;AC3DA;AACA;AAQA;AASA;AAMA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAFA;AASA;;AACA;AACA;AACA;AACA;AACA;AAKA;AAFA;AAIA;AACA;AATA;AAYA;;AACA;AACA;AAEA;AAEA;AAFA;AAFA;AAOA;;AACA;AACA;AAIA;AACA;;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AACA;AACA;AAIA;AACA;;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AACA;AACA;AAIA;AACA;;AC3HA;AAEA;AAIA;AAMA;AACA;;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AACA;AACA;AAGA;AAEA;AAEA;AACA;AAEA;AAFA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AAAA;AAAA;AAGA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;AAIA;AAEA;AACA;;ACtEA;AAEA;AASA;AAOA;AACA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AARA;AAUA;AACA;AAZA;AAcA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAAA;;AAAA;AACA;AAAA;AAAA;AADA;;AAOA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAlCA;;AAqCA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AAdA;AAgBA;;AAEA;AAIA;;AACA;AAAA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AAtBA;AAwBA;;AAEA;;AAEA;AAAA;;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAKA;AACA;AAEA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;;AAEA;AACA;;;;ACrTA;AACA;;AAOA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAHA;;;;;;ACxCA;AAGA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AA+DA;AACA;AAIA;;AAAA;AAAA;AAGA;;AAEA;AACA;AAGA;AACA;AAIA;AACA;AAEA;AAFA;AAIA;AAEA;AAFA;AANA;AAWA;AACA;AAhBA;AAkBA;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAkcA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAHA;;AAMA;AAAA;;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvFA;AA0FA;AACA;AACA;AAEA;AACA;AAIA;AAFA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAOA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAKA;AAIA;AACA;AAKA;AAIA;AACA;AAKA;AAGA;;AACA;AAAA;AAAA;AACA;AAKA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAIA;AASA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AAIA;AAYA;AACA;AACA;AAEA;AAEA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AASA;AAEA;AACA;AAIA;AAaA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;;AAAA;AACA;AACA;AACA;AACA;AAEA;AANA;AAAA;AAWA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAKA;AAFA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAHA;AAKA;AAPA;AASA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAAA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AAEA;AACA;;AAMA;AACA;AACA;AACA;AAFA;AAIA;AACA;;AACA;;AACA;AACA;AAEA;AAFA;AAIA;;AACA;AACA;AACA;AAiBA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAFA;AAJA;AANA;AAiBA;;AACA;AACA;AAIA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAIA;AAIA;AAEA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAFA;AAIA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AAhBA;AAkBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAAA;;AACA;AAEA;AACA;AAEA;AAFA;AAFA;AAQA;AAAA;AAAA;AACA;AACA;AAIA;AACA;;AACA;;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAIA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AAEA;AACA;AAHA;AAKA;;AACA;AACA;AAEA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAVA;;AAaA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAVA;;AAaA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAcA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AAEA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAJA;AAMA;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAOA;;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;;AAEA;AACA;AACA;AAEA;;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;;AASA;AACA;AACA;AACA;;AACA;AAEA;;AAGA;AAOA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAaA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA2BA;AACA;AACA;AAMA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AAEA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AACA;AACA;AAIA;AAMA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAFA;AAIA;AACA;;AAEA;AAEA;AAEA;AADA;AAIA;AAIA;AACA;AAEA;;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AAEA;AAFA;AAIA;AACA;AAIA;AACA;;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AAcA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAFA;AAIA;;AACA;AACA;AACA;AAAA;;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;;AASA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AADA;AAIA;AACA;;AACA;AAKA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AACA;AAEA;AACA;;AAEA;AAAA;;AACA;AAKA;AAEA;AAFA;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAwBA;AAEA;AAEA;AAFA;AAIA;AACA;AAAA;;AACA;AACA;AAGA;AACA;AAIA;AAEA;AAEA;AACA;AAIA;AACA;AASA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAJA;AALA;AAPA;AAoBA;AACA;AACA;AACA;AAYA;AAIA;;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;;AACA;AAEA;AAFA;;AAKA;AACA;AACA;;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AAMA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAGA;AAFA;AAQA;;AAEA;AAAA;AAAA;AACA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AAAA;AACA;AACA;AA3CA;AA6CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AACA;AACA;;AACA;AAEA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAaA;AAIA;AAEA;AACA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAFA;AAUA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAQA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AAaA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAEA;AADA;AAIA;AACA;;AACA;AACA;AAEA;;AACA;AACA;AAEA;AAMA;;AACA;AACA;AAaA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAJA;AAMA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AARA;AAHA;AAgBA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AAGA;;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;;AACA;AACA;;AACA;AACA;;AAQA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAIA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAFA;AAIA;AACA;;AACA;AACA;AAEA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAIA;AACA;;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;AA+CA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAIA;AACA;AACA;AAFA;AAIA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAFA;AAOA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AAIA;;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AACA;AACA;AAAA;;AACA;AACA;;AAKA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAKA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AADA;AAIA;AACA;AAcA;AAKA;AACA;;AACA;AACA;AAKA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAAA;;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AAGA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AAGA;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAnDA;AAqDA;AACA;AAnEA;AAwEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAQA;AACA;AAIA;AACA;AAEA;AACA;AAGA;AACA;;AAGA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAaA;AACA;AAEA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;;AACA;AAEA;AAIA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlFA;AAwFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAeA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;ACz6GA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAHA;;AAeA;AAQA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAFA;AAIA;AAIA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AADA;AAGA;AACA;;AACA;AACA;AAIA;AAEA;AACA;AACA;;AAEA;AAIA;AACA;;AAEA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AAMA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAFA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClNA;AAEA;AAeA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAaA;AAGA;AACA;AAEA;AAHA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAnBA;AAkCA;AACA;AACA;AADA;AADA;AAWA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AANA;AAfA;AA0BA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AAOA;AACA;AACA;AACA;AACA;AAHA;AADA;AARA;AAgBA;AACA;AACA;AAFA;AAIA;AACA;AACA;AADA;AADA;;AAMA;AACA;AACA;AAAA;AACA;AAEA;AAFA;AAIA;;AACA;AAAA;AACA;AAEA;AACA;AAHA;AAKA;;AACA;AACA;AAAA;AACA;AAEA;AAFA;AAIA;;AACA;AACA;AAAA;AACA;AAEA;AAFA;AAIA;;AACA;AAAA;AACA;AAEA;AACA;AAHA;AAKA;;AACA;AAAA;AACA;AAEA;AACA;AAHA;AAKA;AAzCA;;AA2CA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AANA;AASA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAdA;AA5BA;AA+CA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAJA;AAeA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AA1BA;AAwCA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAHA;AAKA;;AACA;AAnBA;AAAA;AAdA;AAuCA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAEA;AAEA;;AACA;AACA;AAEA;AAFA;AAIA;;AAEA;AAVA;AAeA;AACA;;AACA;AACA;AACA;AACA;;AACA;AANA;AASA;AAEA;AACA;AAFA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAfA;AA5CA;AAgEA;AACA;AACA;AADA;AADA;AAMA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAHA;AAMA;AACA;AADA;AAIA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AANA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AADA;AAaA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAXA;AApCA;AAoDA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAZA;AAeA;AAEA;AACA;AAFA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAZA;AA9BA;AA+CA;AACA;AACA;AADA;AADA;AASA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAZA;AAeA;AAEA;AACA;AAFA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAZA;AAnCA;AAoDA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AADA;AASA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;;AACA;AADA;AAIA;AACA;;AACA;AACA;AACA;AACA;;AACA;AANA;AASA;AAEA;AACA;AAOA;AAAA;AATA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAbA;AAlCA;AAoDA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AANA;AAZA;AAuBA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AAPA;AAPA;AAmBA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AAPA;AAZA;AAwBA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAgBA;AACA;AACA;AACA;AALA;AApBA;AA8BA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AALA;AAZA;AAsBA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AALA;AAPA;AAiBA;AACA;AACA;AADA;AADA;AAWA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAWA;AACA;AACA;AACA;AACA;AANA;AAbA;AAwBA;AACA;AACA;AAFA;AAIA;AACA;AACA;AADA;AADA;AAeA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AAZA;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AAhBA;AAoBA;AACA;AACA;AADA;AADA;AAUA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AANA;AAZA;AAuBA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AADA;AASA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAFA;AAKA;AACA;;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AAEA;AAFA;AARA;AAcA;AAEA;AACA;AACA;AAHA;AAQA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAzCA;AA6DA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAgBA;AACA;AACA;AACA;AALA;AAlBA;AA4BA;AACA;AACA;AADA;AADA;AAMA;AAKA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AADA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;AACA;AAdA;AAmBA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAPA;AAtCA;AAoDA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AACA;AACA;AACA;AAHA;AADA;AAJA;AAYA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AALA;AAXA;AAqBA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAtBA;AAwBA;AAxBA;AAZA;AAyCA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AACA;AACA;AACA;AAHA;AAQA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAjCA;AA8CA;AACA;AACA;AADA;AADA;AAUA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAfA;AA4BA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AAOA;AACA;AACA;AACA;AACA;AAHA;AADA;AARA;AAgBA;AACA;AACA;AADA;AADA;AAMA;AAAA;AAAA;AAAA;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAgBA;AACA;AACA;AACA;AACA;AANA;AAlBA;AA6BA;AACA;AACA;AADA;AADA;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAXA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAXA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAVA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAfA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAbA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAZA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAHA;AAKA;AAjBA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAXA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAZA;AAcA;AApBA;AAuBA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AAPA;AADA;AAYA;AACA;AADA;AAIA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAVA;AAeA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AAEA;AAFA;;AAKA;AACA;AACA;AACA;AAhBA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAUA;AAjBA;AAXA;AAiCA;AACA;AACA;AADA;AADA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAhCA;AAoCA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAhCA;AAoCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;AARA;AAWA;AAEA;AACA;AAMA;AAAA;AACA;AAAA;AACA;AAAA;AAVA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAZA;AAjCA;AAkDA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAFA;AAWA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAFA;AAWA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAFA;AAUA;AA5CA;AA+CA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AACA;AANA;AA1DA;AAqEA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAIA;AACA;AAFA;AAKA;AACA;AACA;AApBA;AAdA;AAuCA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AADA;AAIA;AAEA;AACA;AAFA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAxBA;AAqCA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAFA;AAKA;AAGA;AACA;AACA;AACA;AACA;AALA;AAYA;AAEA;AACA;AAFA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAtCA;AAsDA;AACA;AACA;AADA;AADA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;;AACA;AACA;AACA;AAFA;AADA;;AAOA;AAEA;AACA;AAOA;AAAA;AATA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AA1BA;AAuCA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AADA;AANA;AAUA;AACA;AACA;AADA;AADA;AAMA;AAAA;AAAA;AAAA;AAkCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAFA;AADA;AAOA;AAMA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AADA;AANA;AAkBA;AACA;AAAA;AAAA;AAAA;AADA;AAIA;AAEA;AAFA;AAKA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAcA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAzEA;AAiFA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAJA;AAMA;AARA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AADA;AAeA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AACA;AAPA;AAxCA;AAoDA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;AARA;AAWA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AADA;AAhBA;AA3BA;AAiEA;AACA;AACA;AADA;AADA;AAMA;;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;;AAEA;AAAA;;AACA;AAGA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAFA;AAKA;AACA;AAFA;AAIA;AACA;AAfA;AAiBA;AAAA;AAAA;AACA;;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AAnCA;;AAsCA;AAEA;AACA;AADA;AA3CA;AAgDA;AAEA;AACA;AAQA;AAAA;AAVA;AAiBA;AACA;AACA;AACA;AACA;AANA;AAxEA;AAmFA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AAQA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AATA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAtBA;AAmCA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AATA;AAbA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAjCA;AA+CA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAZA;AAyBA;AACA;AACA;AADA;AADA;AAMA;AACA;AAGA;AACA;AAFA;AAKA;AACA;AAFA;AAQA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAYA;AACA;AACA;AACA;AACA;AACA;AAJA;AADA;AASA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AANA;AAnDA;AA8DA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAXA;AAXA;AA2BA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AADA;AAIA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAVA;AAlBA;AAiCA;AACA;AACA;AADA;AADA;;AAMA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAJA;AASA;AAEA;AACA;AAEA;AAHA;AAMA;AACA;AAAA;;AACA;AAGA;AAFA;AAIA;AAEA;AACA;AAHA;AANA;AADA;AAeA;AAAA;AAAA;AAAA;AAIA;AAJA;AAMA;;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AAFA;AAcA;AACA;AACA;AACA;AANA;AAjBA;AA4BA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AASA;AACA;AACA;AACA;AACA;AANA;AAXA;AAsBA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;;AACA;AACA;AAEA;AAFA;AAIA;;AACA;AACA;AAEA;AAFA;AAIA;;AACA;AAfA;AAoBA;AAEA;AACA;AAFA;AAQA;AAAA;AAAA;AAAA;AAhCA;AAqCA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAFA;AAKA;AAEA;AACA;AACA;AACA;AAFA;AAHA;AAWA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AAPA;AA9BA;AA2CA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AACA;AArBA;AA0BA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAZA;AAiBA;AAEA;AACA;AAFA;AAeA;AACA;AACA;AACA;AACA;AACA;AAPA;AA5DA;AAwEA;AACA;AACA;AADA;AADA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;AAFA;AADA;AAHA;AAkBA;AACA;AACA;AACA;AAtBA;AAyBA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;AADA;AALA;AAUA;AAGA;AACA;AACA;AAHA;AAWA;AACA;AACA;AACA;AALA;AAYA;AAEA;AACA;AACA;AACA;AACA;AANA;AAFA;AAlEA;AAkFA;AACA;AACA;AADA;AADA;AAMA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAFA;AAKA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AARA;AAFA;AAAA;AAPA;AAAA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AARA;AAFA;AAAA;AAPA;AAAA;AA5BA;AAsDA;AACA;AACA;AACA;AACA;AACA;AAPA;AA7DA;AA0EA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AASA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AAdA;AAbA;AAiCA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AANA;AAhBA;AA2BA;AACA;AACA;AADA;AADA;AAWA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AANA;AAfA;AA0BA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AAOA;AACA;AACA;AACA;AACA;AAHA;AADA;AARA;AAgBA;AACA;AACA;AAFA;AAIA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AARA;AAWA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAdA;AA0BA;AAEA;AACA;AAFA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AA3CA;AA2DA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AACA;AACA;AACA;AACA;AANA;AAQA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AANA;AAQA;AAAA;AAAA;AAAA;AAjCA;AAsCA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAAA;AAdA;AA+BA;AACA;AACA;AAAA;AAAA;AAAA;AADA;AADA;AAKA;AACA;AADA;AAGA;AACA;AACA;AADA;AADA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAFA;AAWA;AACA;AACA;AACA;AALA;AAbA;AAuBA;AACA;AACA;AADA;AADA;AAOA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAJA;AAUA;AAjCA;AAsCA;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAFA;AAaA;AACA;AAhCA;AAqCA;AACA;AADA;AAIA;AAEA;AACA;AAFA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AA7GA;AA6HA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;ACzhHA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AALA;;AAYA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;;AAOA;;AAEA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;;AAOA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AALA;;AAQA;AACA;AADA;;AAIA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1GA;AAEA;AACA;AAEA;AASA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AALA;;AAYA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AACA;AACA;AACA;AACA;AAYA;AAdA;AAgBA;;AACA;AACA;AACA;AACA;AAIA;AACA;AAPA;AASA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AANA;AAQA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAIA;AAAA;AAEA;AATA;AAWA;;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAJA;AAOA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAIA;AAAA;AACA;AAAA;AAEA;AAVA;AAYA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;;AACA;AACA;AAEA;AAFA;AAKA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAiBA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AACA;AACA;AADA;AAIA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAMA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAEA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;AAgCA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAMA;AAAA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AA3BA;AA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzsBA;AAEA;AAaA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;;AAKA;AACA;;AACA;AACA;AAEA;AAFA;AADA;AAOA;AAAA;AAAA;;AACA;AACA;AAEA;AAFA;AAIA;;AACA;AAEA;AAFA;AAIA;;AACA;AAAA;AACA;AACA;AAEA;AAFA;AADA;AAMA;AAEA;AAFA;AAIA;;AACA;AAEA;AAFA;AAIA;;AACA;AAAA;AAAA;;AACA;AACA;AAEA;AAFA;AAIA;;AACA;AAEA;AAFA;AAIA;;AACA;AAAA;AACA;AAEA;AAFA;AAIA;;AACA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAEA;AAFA;AAIA;;AAEA;AAEA;AAFA;AAIA;;AACA;AAAA;AACA;AACA;AAhEA;;AAmEA;AACA;AAMA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAyBA;AAAA;AAAA;AAAA;AAuDA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAyBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AADA;AAXA;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAhBA;AAkBA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAfA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAfA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAhBA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAfA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAfA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAfA;;AAmBA;AACA;AACA;;AAEA;AAGA;AAIA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AArBA;AAwBA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AAPA;AADA;AAYA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;;AACA;AAVA;AAeA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAZA;AAiBA;AAAA;AACA;AADA;AAIA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AAHA;AAKA;AAbA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC9fA;AACA;AAiBA;AACA;AACA;AAEA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAKA;AAEA;AAFA;AAIA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAIA;AAFA;AAIA;AAzCA;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AAEA;AAAA;AAAA;AAAA;;;;ACFA;AACA;;AAMA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAGA;;AACA;;;;ACnBA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAbA;;ACNA;AACA;AAEA;AAAA;AAAA;AAAA;;AA6CA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AANA;;AAaA;;;;AC7DA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAlBA;;ACPA;AAEA;AAAA;AAAA;AAAA;;;;;;;;ACFA;AACA;AACA;AACA;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAMA;;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAIA;AAGA;AAAA;AAAA;AAMA;;ACjDA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AATA;AAYA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAFA;AAIA;AAlDA;;ACPA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;;;ACHA;AAEA;AAAA;AAAA;AAAA;;;;ACFA;AACA;AAEA;AASA;AAAA;AAAA;AAAA;;AAAA;AA+BA;AACA;AACA;AAjCA;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AAOA;AAIA;AACA;AAAA;AAAA;AACA;;AAzCA;;ACZA;AAEA;AAAA;AAAA;AAAA;AAmCA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;;;;;;;;ACzDA;AAEA;AACA;AAYA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AAIA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;;AClEA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ACPA;AACA;AACA;AACA;AACA;AAgBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAAA;AAAA;AAKA;;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAGA;;AC7DA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAFA;AAKA;AACA;AAbA;AAgBA;AACA;AAAA;AAAA;AA3CA;;ACPA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;AAEA;AAFA;AAIA;;AACA;AACA;AACA;AAvBA;;ACJA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;;ACHA;AACA;AACA;AAGA;AAIA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAGA;AAFA;AADA;AALA;AAcA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AApCA;;ACVA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;;ACJA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAFA;AAPA;AAcA;AACA;AA3BA;;ACLA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAFA;AARA;AAeA;AACA;AAAA;AAAA;AAnCA;;ACPA;AAEA;AAAA;AAAA;AAAA;;;;ACFA;AACA;AACA;AACA;;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAIA;AAAA;AAAA;AAGA;;AAEA;;ACjDA;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAFA;AANA;AAaA;AACA;AAAA;AAAA;AA9BA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AAWA;AACA;AAEA;AACA;AAOA;AAIA;AAIA;AACA;AAHA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAKA;;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AAOA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAFA;AAIA;AACA;;AACA;AACA;;AAEA;AAOA;AACA;;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AAUA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAKA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AAYA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAFA;AAKA;AACA;;AAGA;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AAQA;;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAMA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AACA;AAGA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAWA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAlDA;AAoDA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;;AAUA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAEA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AASA;AAQA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;;AAEA;;AACA;AACA;AAQA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAIA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAiBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;AACA;AAGA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAGA;AAKA;AAKA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AAGA;AACA;AAGA;AASA;AACA;AACA;;AACA;AACA;AAEA;AAiBA;AACA;AACA;AACA;AACA;AAJA;AAOA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AAKA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AAKA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7rCA;AACA;AAoDA;AAEA;AAiCA;AAUA;AAUA;AAoEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCA;AAEA;AAEA;AAEA;AAqBA;AACA;AACA;AAcA;AACA;AACA;AACA;AAwBA;AACA;AAOA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AAUA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;;AAEA;AAQA;AACA;;AACA;AACA;AAoHA;AAGA;AACA;AAwCA;AAAA;;AACA;AACA;AAwBA;;AAAA;AAAA;AAAA;AAAA;;AA4BA;AACA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAyHA;AAtHA;AACA;AAAA;;AAAA;AAWA;AACA;AACA;AACA;;AAdA;AAiBA;AAEA;AAEA;AACA;;AAtBA;AAyBA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AA7CA;AAgDA;AACA;AACA;;AAlDA;AAqDA;AACA;AACA;;AAvDA;AA0DA;AACA;AACA;AACA;;AACA;AACA;;AA/DA;AAkEA;AACA;AACA;;AACA;AACA;;AAtEA;AAyEA;AACA;AACA;;AACA;AACA;;AA7EA;AAgFA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AA5FA;AAmGA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AA1GA;;AA4GA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5HA;;AAAA;AAGA;;AACA;AACA;;AALA;AAQA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/lBA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAPA;AAgBA;AACA;AACA;AACA;AAHA;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AA1EA;AA6EA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAOA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAKA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAhFA;AAmFA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAOA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AA+EA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AAOA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AA+EA;;;;;;;;;;;;;;;;;;;;;ACnYA;AASA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAKA;AACA;AACA;AACA;AAJA;AAJA;;AAAA;AAcA;AACA;AACA;AACA;AACA;AACA;;AAnBA;AAAA;AA6BA;AACA;AACA;;AA/BA;AAkCA;;AACA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtDA;;AAuBA;AACA;AACA;;AA+BA;AACA;AAQA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAeA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AA/HA;;AAkIA;;;;;;AChKA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;;AC/RA;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAFA;AAIA;;AAEA;AASA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AAhEA;;;;;;;;;;;;;ACpBA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;AChGA;AAqBA;AAEA;AAeA;AAEA;AAmCA;AACA;AACA;AAFA;AAmBA;AAsBA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;;AACA;AACA;;AACA;AAAA;;AACA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAmBA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AAMA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;AAYA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;;AACA;AAGA;AACA;;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAFA;AAIA;;AAEA;AAeA;;AAIA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;;AAGA;AAmBA;;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAGA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAEA;AACA;AACA;;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AAEA;AACA;AACA;AACA;;AAEA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAaA;;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;;AACA;AACA;AASA;AACA;;AACA;;AAMA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AASA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AAgBA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AAFA;AAIA;;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AAEA;;AACA;AACA;;AACA;AACA;AACA;;AACA;;AAEA;AACA;AASA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAQA;AACA;AACA;AACA;;AAEA;AAoBA;;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAgBA;AACA;;AAEA;AACA;AAcA;AACA;;AAEA;AACA;AACA;;AAEA;AAgBA;AAEA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAQA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AAQA;;AACA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AACA;;AAeA;AAgCA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAGA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AAOA;;AACA;;AAiBA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AAGA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AAMA;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AAAA;;AACA;;AACA;AACA;AACA;AACA;;AACA;AAsBA;;AAEA;AACA;AACA;;AACA;;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;;AAEA;AAoBA;AAKA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAOA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;;AAEA;AAUA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAiBA;AACA;AACA;AACA;AACA;;AAiBA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAiBA;AAAA;;AACA;AAiBA;AAkBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAWA;AAAA;;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAWA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;;AACA;AAIA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAiBA;;AACA;AAAA;;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAOA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAGA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AAEA;AACA;;AAEA;AAWA;AACA;AAOA;AAQA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;;AAmDA;AACA;;AACA;AAmBA;AACA;;AACA;AACA;AAGA;AACA;;AAGA;;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;AACA;AAEA;AACA;;AACA;AACA;;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7CA;AA+CA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AASA;;AACA;AACA;AACA;AADA;AAGA;;AACA;AACA;AADA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AADA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;;AACA;AAAA;;AACA;AAsBA;AAqBA;AACA;AACA;AACA;AAIA;;AAEA;AACA;AAkBA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AAiBA;AACA;AAEA;;AAkCA;AAIA;;AAAA;AAAA;AAEA;AAkBA;AACA;;AAEA;AACA;AAgBA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAMA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAmBA;AACA;AACA;AACA;AACA;AAYA;;AAEA;AAaA;AAqBA;AAkBA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAkCA;AAqBA;AAoBA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAYA;AAEA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;;AAUA;AASA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAUA;AAQA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;AAOA;AACA;;AACA;AAAA;;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AAKA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;;AC9kFA;AAOA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAQA;AACA;;AATA;AAYA;;AAEA;AACA;AACA;;AAEA;AACA;;AAnBA;AAwBA;;AACA;AAEA;AAEA;AACA;;AA9BA;AAiCA;AACA;;AAlCA;AAqCA;AACA;AAGA;AACA;;AA1CA;AA6CA;AACA;AACA;;AACA;AAAA;AAAA;AACA;;AAjDA;AAoDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9EA;AAgFA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAtGA;;AADA;;;;ACdA;;AAGA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AAGA;;AC3CA;AAEA;AACA;AAQA;AAwBA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;;AAyOA;AAAA;;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7DA;AA+DA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;;AAEA;AACA;AACA;;AAEA;AAEA;;AAkBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAkBA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;;AAGA;AAIA;AAaA;AACA;AACA;AACA;AAEA;AACA;AAKA;;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AAEA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;;AACA;AACA;;AAoBA;AACA;AACA;AAKA;;AAEA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;;AAwDA;AACA;AACA;AACA;AACA;AACA;AACA;AA0CA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAGA;AACA;AACA;;AACA;AACA;AAWA;AAIA;AACA;AACA;AALA;AAUA;AACA;;AACA;AAEA;AACA;;AAEA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;;AAMA;AAMA;AACA;AACA;;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AAEA;AAFA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAUA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AAAA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;;AAEA;AACA;AACA;AAeA;AAEA;AAEA;AACA;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAIA;AAEA;AACA;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAIA;AAEA;;AACA;AACA;AACA;AACA;AAIA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AALA;;AAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAsBA;AACA;;AAEA;AACA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AAEA;AAEA;AACA;;AACA;;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;;AACA;AAAA;;AACA;AACA;AADA;AAGA;AACA;AACA;AADA;AAGA;;AACA;AACA;AAIA;AAGA;AACA;;AAKA;AAAA;;AACA;AACA;AADA;AAGA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAxBA;AA6BA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAIA;AAKA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAeA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;;AACA;AAMA;AACA;AACA;AACA;AACA;AAtCA;AA0CA;AAMA;AAqBA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAEA;AAEA;AACA;AACA;AAHA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAAA;AAAA;AAIA;;AAEA;;;;;;;;;;;;;;;;;ACvmDA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAWA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;AC/DA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAkBA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAYA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;AC5SA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAkBA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;ACxWA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAZA;AAkBA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAJA;AAUA;AAAA;AAAA;AAAA;AAEA;AAhBA;AAqBA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;ACnJA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAmBA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AASA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AALA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;;AAEA;AAAA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;AClbA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAkBA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AAQA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AATA;AAcA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;AClRA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAkBA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAWA;AACA;AACA;AAIA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AALA;AAUA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;AC5NA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAkBA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;ACrNA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAFA;AAkBA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AACA;AACA;AADA;AAGA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAFA;AAIA;AANA;AASA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AACA;AANA;AAWA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AACA;AANA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AACA;AACA;AAPA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AADA;AAGA;AACA;AACA;AACA;AAPA;AAYA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;;;;ACtZA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAkBA;AAEA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAJA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AADA;AAUA;AACA;AACA;AAhBA;AAmBA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AASA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAUA;AAEA;AACA;AACA;AACA;AACA;AANA;AAFA;AAoBA;AACA;AACA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;;ACnVA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAFA;AAYA;AACA;AAEA;AACA;AACA;AADA;AAFA;AAFA;AAWA;AAAA;AAAA;AAAA;AA+ZA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAmBA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAJA;;;;;;;;;;;;;;;;;;;;;;;ACrfA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAWA;AACA;AACA;AAFA;;AAKA;AACA;AAEA;AAGA;AAAA;AAAA;AANA;AAgBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAFA;AAFA;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1EA;AA6EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtJA;AACA;AACA;;AAoEA;AAAA;;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;;AACA;AAAA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;;AACA;AACA;AACA;AAMA;AACA;AACA;;AAEA;AAMA;;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAoBA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AAEA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AAEA;;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAmEA;;AAEA;;ACxZA;AAMA;AAGA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;ACtCA;AAEA;AACA;AACA;AACA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6CA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAFA;AASA;AAIA;AACA;AACA;AAJA;AAaA;AACA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAVA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAhBA;AAkBA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAJA;AAOA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AADA;AAGA;AACA;;AACA;AAVA;AAaA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAQA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AApDA;AA6DA;AACA;AAEA;AAEA;AACA;AADA;AAIA;AAEA;;AACA;AACA;AACA;AALA;AAUA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AAXA;AAYA;AAAA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AALA;AAtLA;;;;AC/GA;AACA;AACA;AAEA;AACA;AA+EA;AAAA;AAAA;AAAA;;AA8BA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;AAnBA;AAqBA;AACA;AACA;AAvBA;AAyBA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AALA;AAQA;;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AAAA;;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAHA;AAKA;;AACA;AACA;AADA;AAGA;AACA;;AACA;AAPA;AASA;AACA;AAFA;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;;AACA;AACA;AARA;AAUA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAHA;AAKA;;AACA;AACA;AADA;AAGA;AACA;;AACA;AAPA;AASA;AACA;AAFA;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;;AAEA;AAUA;;AACA;AAEA;AACA;AACA;AACA;AAJA;AAYA;AACA;AACA;AACA;AACA;AAjHA;AAoHA;AAEA;AACA;AAHA;AAQA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAHA;AATA;;AAgBA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AALA;AAOA;AAPA;AAQA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AALA;AAHA;AA7BA;AA2CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnEA;AAhQA;;AAyUA;;;;;;;;;;;;;;;;;AC3bA;AACA;AAEA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgCA;AAAA;AAAA;AAAA;AAaA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAEA;AAAA;AAGA;;AAXA;AAcA;AACA;AAEA;AAAA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEA;AAEA;;AAEA;AAAA;;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AASA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAHA;AAKA;;;;;ACjFA;AACA;AACA;;AAEA;AAAA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAnBA;AAqBA;;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAaA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AAMA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AAFA;AAIA;;ACpIA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AACA;AACA;;AACA;AAAA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAAA;AAAA;AAHA;AAKA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AACA;AAEA;AADA;AAJA;AASA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;;AAaA;AACA;AAEA;AAAA;AAHA;;AAQA;AACA;AAEA;AAHA;AAYA;AAAA;AAAA;AAAA;;AA2CA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AADA;AAXA;;AAyBA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAxCA;AA4CA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAOA;AACA;AAEA;AAEA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAhBA;AAFA;AA2BA;AAEA;AACA;AACA;AAFA;AAIA;AAIA;AACA;AACA;AAHA;AAPA;AAcA;AACA;AACA;AACA;AAHA;AAMA;AACA;AADA;AAIA;AACA;AAAA;AAAA;AAMA;AACA;AACA;AAPA;AA5DA;AAwEA;AACA;AACA;AADA;AADA;;;;;;;;;;;;;;;;;;;;AE5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvCA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;ACNA;AAEA;AACA;AAKA;AAIA;ACNA;;ACcA;AACA;AAMA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAJA;AAcA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;AAEA;;AD1BA;;AACA;;AAKA;AAIA;AACA;AAGA;AAHA;AAMA;AACA;;AAEA;AAKA;;AAGA;AAKA;AACA;AAEA;AACA;AAJA;AAMA;;AAEA;AACA;;AAEA;AACA;AACA;AAKA;AACA;;AAEA;AAIA;AAGA;AACA;;AA8BA;AACA;AACA;AACA;AAEA;AAGA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AAIA;AAAA;AAAA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AADA;AAGA;;AAEA;AACA;;AAEA;AAGA;AAEA;AACA;;AACA;AACA;;AAEA;AAKA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAFA;AAKA;AACA;AACA;;AAgDA;AAEA;AACA;AACA;;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE7PA;;ACDA;;AAIA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;;AAOA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAAA;;AAEA;AAAA;;AAIA;AACA;;AAEA;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAIA;AAAA;;ADtDA;AACA;AACA;AACA;AACA;AEPA;AACA;ACDA;AAKA;AAAA;AAAA;AACA;;AAYA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AApBA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAiBA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;AA/BA;ACLA;;AAKA;AALA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AA8BA;;AAwCA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAxCA;;AA4CA;AACA;AAAA;;AAIA;;AAEA;AACA;AAAA;;AC9HA;AAoDA;AAEA;AAiCA;AAUA;AAUA;AAoEA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAIA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAUA;AAEA;AAEA;AAEA;;AAqBA;AACA;AAAA;;AAeA;AACA;AACA;AAAA;;AAyBA;AACA;AAOA;AAAA;;AAGA;AACA;AAAA;;AAIA;AACA;AAUA;AAAA;;AAGA;AACA;AAAA;;AAIA;AACA;AAAA;;AAIA;AACA;;AAEA;AAQA;AAAA;;AAEA;AAAA;;AAqHA;AAGA;AAAA;;AAyCA;AAlgBA;;AAmgBA;AAAA;;AAyBA;;AAAA;AACA;AACA;AAAA;;AA0BA;AACA;AACA;AAAA;;AAEA;AAEA;AAEA;AACA;AAAA;AAGA;;AAEA;AACA;;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;;AAIA;AAAA;;AAGA;;AAGA;AACA;AAAA;;AAUA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AAEA;AAEA;AAAA;;AAGA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAAA;;AAGA;AAAA;;AAOA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAGA;AACA;;AACA;AACA;AAAA;;AAGA;AAAA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAzHA;;AAAA;;AAAA;AAIA;AAAA;;AAJA;AAQA;AAAA;;ACvlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACRA;;AAEA;AACA;AACA;AAAA;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AAEA;AAAA;AAGA;AACA;AAEA;;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAFA;AAEA;;ALZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAEA;AAAA;AAKA;AAEA;AACA;;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;;AAGA;AAAA;AAKA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AA3GA;;AA6GA;AACA;AAAA;AAKA;AAEA;;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAKA;AAEA;AAlJA;;AAmJA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAWA;;AAKA;AAAA;AAAA;AAGA;;AACA;AAEA;AAGA;AAAA;;AAGA;;AACA;AACA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAUA;AAAA;AAAA;AAMA;;AAIA;AMpOA;ACDA;ACCA;AACA;ACFA;ACCA;AASA;AAEA;;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAAA;;AAGA;AAAA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AAOA;AACA;AACA;AAAA;;AAGA;AACA;;AACA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AA5BA;AACA;AAAA;;AAgCA;AACA;AAQA;AACA;AACA;AAAA;;AAGA;AArGA;;AAsGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAVA;AAeA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;;AAGA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;AAEA;AAAA;;AAEA;AAAA;;AA9HA;AAkIA;AClKA;AACA;;AAEA;AAMA;AAEA;AAMA;AACA;AAGA;AACA;;AAGA;AAzBA;;AA0BA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAIA;AACA;AAAA;;AAGA;;AACA;AACA;AAAA;;AAQA;AAtDA;;AAuDA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAOA;;AAMA;AAhFA;;AAiFA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAMA;;AAMA;AACA;AAEA;AACA;AAEA;AAAA;AAKA;AAEA;AACA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAAA;AAKA;AAAA;;AAIA;AACA;AAMA;AACA;;AAGA;AACA;AAAA;;AAGA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAGA;AAEA;AACA;AAAA;;AASA;;AACA;AAEA;;AACA;AAEA;AAAA;;AAEA;AAEA;AAEA;AACA;AAKA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAGA;AACA;AACA;AAAA;AAGA;AAAA;;AC7MA;AAGA;;AAOA;AAIA;AAIA;AACA;AAHA;AAKA;;AAIA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;;AAGA;AACA;AAGA;;AAIA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AAOA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;;AAEA;AAEA;AAFA;AAIA;AAAA;;AAEA;AAAA;;AAGA;AAOA;AACA;;AACA;AACA;AACA;AACA;;AAGA;AAAA;;AAGA;AAUA;AAEA;;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;AAAA;;AAGA;AACA;;AAEA;AACA;AACA;AAAA;;AAGA;AACA;;AACA;AACA;AAAA;AAAA;;AAIA;AAAA;;AAGA;AAKA;;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;;AAGA;AAYA;AACA;AACA;AAEA;;AACA;AACA;AAAA;;AAGA;AAEA;;AACA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AAEA;AA5OA;;AA6OA;AACA;AACA;AACA;AACA;AAAA;;AAGA;;AAEA;AACA;AAAA;;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AAAA;;AAIA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AAEA;AAIA;AACA;AACA;AAFA;AAKA;AAAA;;AAIA;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;AAKA;AAEA;AAAA;;AAGA;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;;AACA;AACA;AACA;AAAA;;AAEA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AAMA;;AAIA;AAWA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;;AAKA;AAOA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AACA;AAGA;AAAA;;AAEA;;AACA;AACA;AAAA;AAAA;;AAIA;AAEA;;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;;AAGA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAIA;AAEA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AAAA;;AAGA;AAWA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;AAGA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AAIA;AAlDA;AAkDA;;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;AACA;AAAA;;AAGA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AACA;;AAUA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AAAA;;AAEA;AAAA;;AAEA;AACA;AAEA;;AACA;AACA;AAAA;;AAEA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;;AAUA;AAQA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAEA;AAEA;AAEA;AAAA;;AAGA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AAAA;;AAGA;;AACA;AACA;AAMA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;;AAIA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAKA;;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AAFA;AAKA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AAAA;AAAA;;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;;AACA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAoBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAMA;;AAGA;AAGA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;;AAGA;AAGA;AAKA;AAKA;;AACA;AACA;AACA;AAAA;AAEA;AAAA;;AAIA;AACA;AAGA;AACA;AAGA;AASA;AACA;AAAA;;AAEA;AAAA;;AAGA;AAiBA;AACA;AACA;AACA;AACA;AAJA;AAOA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;;AAGA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;;AACA;AAKA;AACA;AACA;AACA;AAAA;;AAGA;;AACA;AAKA;AACA;AACA;AAAA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AAAA;;AC3rCA;;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;;;AAGA;;;;;;AAMA;;AATA;AASA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAHA;AAGA;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAHA;AAGA;;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAQA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAKA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;;AAEA;AAFA;AAEA;;AAIA;AACA;AACA;AACA;;AAEA;;AAFA;AAEA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;;ACpRA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;;AAKA;AAKA;AAAA;AAJA;AAEA;AAGA;AACA;AADA;AAEA;;AAIA;AASA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAGA;;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;;AAEA;;AACA;AACA;AAAA;AAAA;AAAA;;AA7DA;ALcA;AACA;AMhBA;ACnBA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAIA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;AAMA;AACA;AAAA;;AAGA;AACA;AAAA;;AAIA;AACA;AACA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;AAIA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;;ADpBA;AACA;AACA;AAFA;;AAmBA;AAsBA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAfA;AAkBA;AACA;AA9IA;;AA+IA;;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;AAAA;AAAA;AAKA;AACA;AAAA;;AAGA;AAmBA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;;AAGA;AACA;AAAA;;AAEA;AAEA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAFA;AAEA;;AAIA;AAMA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;AAYA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAIA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAIA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAIA;;AACA;AAGA;AAAA;;AAEA;AACA;AAAA;;AAEA;AAEA;AACA;AACA;AAFA;AAEA;;AAIA;AAeA;;AAIA;AAMA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAAA;AAAA;AAGA;AAAA;;AAIA;AAmBA;;AAlYA;;AAmYA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AAEA;AAGA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAKA;AAAA;;AAKA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAEA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAKA;;AAIA;AACA;AAAA;AAAA;;AAIA;;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;;AAIA;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAAA;;AAEA;AAAA;;AAGA;AACA;AAAA;;AAGA;AA/fA;;AA6gBA;AACA;AAEA;AACA;AAjhBA;;AAkhBA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;;AACA;AACA;AACA;AAAA;;AAGA;;AACA;AACA;;AACA;AACA;AASA;AAAA;;AAEA;;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;;AASA;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AAEA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAIA;AAgBA;AACA;;AACA;AACA;;AACA;AACA;AAEA;AAFA;AAEA;;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AAEA;AAEA;;AACA;AACA;;AACA;AACA;AAAA;;AAEA;;AAEA;AACA;AAOA;;AAIA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAQA;AACA;AAAA;AAAA;;AAIA;AAnxBA;;AAwyBA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAnzBA;;AAozBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;;AAGA;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AAgBA;AAAA;;AAGA;AACA;AAYA;AAAA;;AAKA;AACA;AAAA;;AAGA;AAgBA;AAEA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAKA;AAOA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AAEA;AAQA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;AAGA;AAx+BA;;AAi/BA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAIA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAIA;AAAA;;AAgBA;AA7iCA;;AA8kCA;AACA;AACA;AACA;AACA;AACA;AACA;AAplCA;;AA2lCA;AAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AAEA;AACA;AAGA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AAEA;AAnoCA;;AA2oCA;;AAiBA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;;AAIA;AACA;AAIA;AAGA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;;AAKA;AACA;AAAA;AAEA;AAAA;;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;;AAGA;AACA;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;AAMA;AAAA;AAAA;AAAA;;AAKA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AAAA;;AAGA;;AAEA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AAoBA;;AAIA;AACA;AAAA;;AAEA;;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AAAA;AAIA;AACA;AAAA;AAGA;AAAA;;AAGA;AAoBA;AAKA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAOA;AAAA;;AAGA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;;AAKA;AA97CA;;AAy8CA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AAiBA;AACA;AACA;AAx/CA;;AAy/CA;AACA;;AAiBA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAiBA;AACA;AAiBA;AAkBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAOA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAHA;AAOA;AAAA;AAOA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AAGA;;AACA;AACA;;AACA;AAIA;AACA;AACA;AAAA;AAAA;;AAGA;;AACA;AACA;;AACA;AAIA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AACA;AAAA;;AAGA;AA9pDA;;AAgrDA;AAhrDA;;AAgrDA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAOA;;AACA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;AAIA;AAvtDA;;AAwtDA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;AAGA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;;AAGA;AAEA;AAAA;;AAGA;AAWA;AACA;AAOA;AAQA;AACA;AAAA;AAAA;AAKA;AAAA;AAGA;AAAA;;AAoDA;AACA;;AACA;AAmBA;AAAA;;AAEA;AACA;AAGA;AAAA;;AAIA;;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;;AAEA;AAEA;AAAA;;AAEA;AAAA;;AAEA;AAAA;;AAGA;AAt5DA;;AAu5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7CA;AA+CA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AACA;AASA;;AACA;AACA;AACA;AADA;AACA;;AAGA;AACA;AADA;AAGA;;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;;AAEA;AACA;AADA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;;AAGA;AAEA;AAEA;;AACA;AAjiEA;;AAkiEA;AAsBA;AAqBA;AACA;AACA;AACA;AAIA;;AAEA;AACA;AAgBA;AAAA;;AAMA;AACA;AACA;AACA;AACA;AAIA;;AAIA;AACA;AAiBA;AACA;AAEA;;AAkCA;AAhrEA;;AAorEA;AAAA;AAEA;AAgBA;AAAA;;AAKA;AACA;AAgBA;AAAA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAAA;;AAGA;AAAA;;AAGA;AAMA;AAAA;;AAGA;AACA;AACA;AAAA;AAAA;AAmBA;AAAA;AAEA;AACA;AACA;AAUA;;AAIA;AAaA;AAqBA;AAkBA;;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;AAEA;AAAA;;AAGA;AAkCA;AAqBA;AAoBA;AACA;;AAEA;AACA;AACA;AACA;AAAA;;AAGA;AAYA;AAEA;AACA;AACA;AACA;AAJA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AAAA;;AAWA;AASA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;;AAEA;AACA;AAAA;;AAGA;;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAYA;AAQA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;;AAKA;AA/hFA;;AAsiFA;AACA;;AACA;AACA;AAEA;AACA;;AACA;AACA;AAAA;;AAEA;AAKA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AASA;AAAA;AAAA;;AE5kFA;AAOA;;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AAEA;AACA;;AAIA;AACA;AAAA;;AAGA;AACA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AAMA;AAvCA;;AAwCA;AAEA;AAEA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;AACA;AAGA;AAAA;;AAGA;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;AAEA;AACA;;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;AAEA;AAAA;;AAGA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;;AAIA;AA/FA;;AAgGA;AACA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAFA;AAEA;AAGA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;;AArGA;ACdA;AAGA;AACA;AAAA;;AAGA;AAPA;;AAQA;AAAA;;AARA;;AAYA;AACA;AAAA;;AAIA;AACA;AAMA;ACxBA;;AAGA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AAAA;AAAA;;AAIA;AAAA;AAGA;AAEA;;AACA;AACA;AAAA;;AAEA;AAAA;AAEA;;AVuPA;AAhSA;;AAiSA;AACA;AACA;AAAA;;AAGA;AAtSA;;AAuSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7DA;AA+DA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AAGA;AAGA;AAEA;;AAEA;AACA;AAAA;;AAGA;AAEA;;AAkBA;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AAEA;AAAA;AAmBA;AA9cA;;AAgdA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AAAA;;AAIA;AAIA;AAaA;AACA;AACA;AACA;AAEA;AACA;AAKA;;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAUA;AAGA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAaA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAaA;AAAA;AAIA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAaA;;AAGA;AAAA;;AAqBA;AACA;AACA;AAGA;;AAIA;AAEA;AAGA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAhoBA;;AAioBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;;AAwDA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AA4CA;AACA;AACA;AACA;AAAA;AAGA;AACA;AArvBA;;AAsvBA;AACA;AACA;AACA;AAAA;;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAEA;AAEA;AAAA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAGA;AACA;AAAA;;AAEA;AACA;AAWA;AAIA;AACA;AACA;AALA;AAUA;AACA;;AACA;AAEA;AAAA;;AAGA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAKA;AAEA;;AAEA;AACA;AACA;AACA;;AAMA;AAMA;AAAA;AAAA;;AAGA;AAAA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;;AAGA;AACA;;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAIA;AAAA;AAEA;;AACA;AACA;AAAA;AAAA;;AAIA;;AACA;AAEA;AAAA;AAAA;AAKA;AACA;AAEA;AAl6BA;;AAo6BA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;;AAGA;;AAEA;AACA;AAEA;AAFA;AAEA;;AAIA;AACA;AAAA;;AAGA;AACA;AAAA;;AAGA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAGA;AAAA;;AAEA;AAAA;AAAA;AAGA;;AACA;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAIA;AAAA;AAWA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AA9gCA;;AAghCA;AACA;AAEA;;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AAAA;;AAGA;AACA;AAAA;AAgBA;AAEA;AAEA;AACA;AAEA;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAWA;AAMA;AAEA;AACA;AAEA;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAWA;AAMA;AAEA;;AACA;AACA;AAAA;AAAA;AAMA;AAEA;;AACA;AACA;AACA;AAAA;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AALA;;AAOA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAcA;AAGA;AACA;AACA;AACA;AAoBA;AAAA;;AAKA;AACA;AAEA;AAEA;AAMA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAmBA;AAEA;AAEA;AAnyCA;;AAqyCA;;AACA;AAEA;AAAA;;AAGA;AACA;AAAA;;AAGA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;;AACA;AACA;AAAA;;AAIA;AAEA;AAEA;AACA;AAEA;AAAA;AAIA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAj2CA;;AAo2CA;;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AADA;AACA;;AAGA;AAAA;AAKA;AAGA;AAt3CA;;AAu3CA;;AAKA;AACA;AACA;AADA;AACA;AAGA;AACA;AADA;AACA;AAAA;AAIA;AACA;AACA;AAAA;;AAGA;AAAA;AAEA;AAxBA;AA6BA;AAEA;AAp5CA;;AAs5CA;AACA;AACA;;AACA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;;AAIA;AAKA;AAAA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AATA;AAeA;AAAA;AAGA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAWA;AAGA;AAr/CA;;AAs/CA;AAMA;AACA;AAAA;AAEA;AACA;AAtCA;AAuCA;AAAA;AA8BA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AAHA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAAA;AAAA;AACA;;AAKA;;ADhiDA;AAtEA;;AAuEA;AAAA;;AAGA;AA1EA;;AA2EA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAkBA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAMA;AACA;AAhIA;;AAkIA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAIA;AAGA;AACA;AAAA;AAAA;AASA;AACA;AAAA;AAAA;;AAGA;AAAA;AAKA;AAEA;AACA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAhMA;;AAkMA;AACA;AAGA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;;AAIA;AAMA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;;AACA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAGA;AAAA;AAqBA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAEA;AAIA;AA1QA;;AA4QA;AACA;;AACA;AACA;AAAA;AAAA;AAGA;;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAEA;AAGA;;AACA;AACA;AAAA;AAEA;AACA;AAAA;;AAGA;AAAA;AAKA;AAEA;;AACA;AACA;AAAA;AAAA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAgEA;;AAKA;AYvZA;ACDA;;AAMA;AAGA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAEA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;ADRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6CA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAOA;AAIA;AACA;AAAA;AAAA;AAUA;AAAA;;AAGA;AA/GA;;AAgHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAGA;AA7KA;;AA8KA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAQA;AACA;;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAKA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AALA;AAKA;AAIA;AACA;AAEA;AAEA;AACA;AAAA;AAGA;AAEA;;AACA;AACA;AAAA;AAAA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAXA;AAYA;AAAA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AALA;AAiBA;;AbjTA;AA+EA;AAAA;AAAA;AAAA;;AA8BA;AAlHA;;AAmHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;AAGA;;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;;AAGA;AACA;AAAA;;AAGA;AAEA;AA1KA;;AA2KA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAKA;AACA;AACA;AACA;AACA;AAJA;AAOA;;AAEA;AAWA;AAEA;AACA;AACA;AACA;AAJA;AAYA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AAEA;AACA;AAAA;AAKA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAGA;;AAIA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAPA;AAQA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAHA;AAQA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnEA;AAmEA;;AAMA;AezbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AhBMA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAUA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AAWA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AA2BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AAEA;AACA;AAOA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AAEA;AAKA;AAEA;AAEA;AACA;AAEA;;AAEA;AAzHA;;AA0HA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AAAA;;AAGA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AAIA;AACA;;AACA;AACA;AACA;AArBA;;AAwBA;AACA;AACA;AAAA;AAAA;AAAA;;AAKA;;AAEA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AAAA;AAEA;AAAA;;AAGA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;;AAIA;AACA;AAAA;AAKA;AAtNA;;AAuNA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAIA;AApPA;;AAsPA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AAAA;AAKA;AAlQA;;AAoQA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAAA;AAAA;AAIA;AAzSA;;AA0SA;;AACA;AACA;;AAIA;AACA;AAAA;AAAA;;AAIA;AACA;AAAA;;AAGA;AACA;AACA;AADA;AAIA;AAEA;AACA;AACA;AACA;AACA;AALA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AALA;AASA;AACA;AACA;AACA;AACA;AALA;AAUA;AACA;AACA;AACA;AACA;AALA;AAYA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAoBA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AA8EA;;AAKA;AiB9dA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAMA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AAdA;AAcA;;AC9DA;AAeA;;AAEA;AAjBA;;AAuBA;AAEA;AACA;AAAA;;AAGA;AAWA;;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AAEA;AAFA;AAEA;;AAKA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAJA;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AAAA;;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;;AAGA;AACA;AAAA;;AAEA;AAAA;AAGA;AAzIA;;AA0IA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAEA;AAEA;AAFA;AAEA;AAAA;;AAKA;AAEA;AACA;;AAEA;AACA;AAEA;AAFA;AAEA;;AAIA;AACA;AAEA;AAFA;AAEA;;AAIA;AAWA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAHA;AAKA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AACA;;AC9MA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AAnBA;AAmBA;;AAIA;AACA;;ACzDA;;AASA;AASA;AAlBA;;AAyBA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAMA;;AAIA;AACA;AACA;AACA;AACA;AAKA;AAFA;AAIA;AACA;AATA;AAYA;;AACA;AACA;AAEA;AAEA;AAFA;AAFA;AAIA;;AAIA;AAAA;AAKA;AAEA;;AACA;AACA;AAAA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAGA;AAAA;AAKA;AAEA;;AACA;AACA;AAAA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAGA;;AAGA;AAAA;AAKA;AAAA;;AC1HA;;AAMA;AAMA;AAZA;;AAcA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;AAGA;AAAA;AAAA;;AAGA;AAAA;;AAGA;AAAA;;AAEA;AAAA;AAIA;AAEA;AAEA;AACA;AAEA;AAFA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAKA;AAEA;AAAA;;AC1DA;AAXA;;AAkBA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AAAA;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AAAA;;AAGA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AARA;AAUA;AACA;AAZA;AAYA;AAAA;AAGA;;AAEA;AAAA;;AAGA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;;AAAA;AACA;AACA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;;AAEA;;AACA;AACA;AACA;AAAA;;AAEA;;AACA;AACA;AACA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;;AAEA;AAAA;AAEA;AAAA;;AAEA;AAlCA;;AAqCA;AAAA;;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;;AAGA;AA/KA;;AAgLA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;;AAIA;AACA;AAAA;;AAGA;AAAA;;AAGA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AAdA;AAcA;;AAIA;AAvOA;;AA4OA;AA5OA;;AA6OA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;;AAEA;AAtBA;AAsBA;;AAIA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AAAA;;AAGA;AAAA;;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAEA;AAIA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAGA;AAAA;;ACnTA;;AAOA;AACA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AC1BA;AACA;AAAA;;AAGA;AACA;AAvBA;;AAuBA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAKA;AAEA;AAFA;AAEA;;AAGA;AAAA;AAEA;AACA;;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;;AAEA;AAIA;AAFA;AAEA;AAvCA;ACtBA;AAGA;AACA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAGA;;AACA;AAnBA;;AAoBA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AAAA;;AAEA;AACA;AAAA;AACA;;AChCA;ACDA;ACEA;AAAA;AAAA;AAAA;;ADKA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAIA;ADbA;AACA;AAPA;;AAOA;AADA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAbA;AGNA;ACAA;AAGA;AAAA;AAAA;AAAA;;AA6CA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AACA;;AAMA;ADvDA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAlBA;AENA;ACDA;ACEA;AAAA;AAAA;AAAA;ADAA;;AAcA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AA5BA;;AAmCA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAMA;AAAA;AAAA;AACA;;ADtCA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;;AAYA;AANA;AAOA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAEA;AAPA;AAOA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAKA;AACA;AAEA;AAFA;AAEA;AAhDA;AGJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;ACFA;ACDA;ACAA;AACA;ACCA;AAAA;AAAA;AAAA;ADUA;AAAA;AAAA;AACA;;AA6BA;AACA;AACA;AAAA;AAAA;;AA7BA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;AAEA;;AACA;AACA;AACA;AAAA;AAAA;;AASA;AAIA;AACA;AAAA;AAAA;AAAA;;AAxCA;AEZA;ACEA;AAAA;AAAA;AAAA;AAmCA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;;AD1CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAIA;AApCA;;AAqCA;AACA;AACA;AAAA;AAAA;AAIA;AAEA;AACA;AAAA;;AAEA;AAAA;AAKA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAPA;AAOA;;AExDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;ALaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AARA;AAUA;AAAA;AAAA;AACA;;AAKA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;;ADpDA;AACA;AAPA;;AAOA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAFA;AAKA;AACA;AAbA;AAaA;AAIA;AAAA;AAAA;AA3CA;AOHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;AAEA;AAFA;AAEA;;AAGA;AAAA;AAEA;AAvBA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;ACHA;AAKA;AAIA;AACA;AAVA;;AAUA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AA/BA;;AAgCA;AAEA;AAFA;;AANA;AAQA;AAOA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAnCA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;ACJA;AAMA;AACA;AAPA;;AAOA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAFA;AAPA;AASA;AAMA;AA3BA;ACLA;AAMA;AACA;AAPA;;AAOA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAFA;AARA;AAUA;AAMA;AAAA;AAAA;AAnCA;ACNA;ACAA;ACCA;AAAA;AAAA;AAAA;;ADYA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAKA;;AAKA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAKA;AD3CA;AACA;AAPA;;AAOA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAFA;AANA;AAQA;AAMA;AAAA;AAAA;AA9BA;AGQA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;A3D+CA;;AA+DA;AACA;AA7HA;;AAiIA;AAAA;AAAA;;AAKA;AACA;AAGA;AACA;AAIA;AACA;AAEA;AAFA;AAIA;AAEA;AAFA;AANA;AAWA;AACA;AAhBA;AAgBA;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAkcA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AAHA;;AAMA;AA3nBA;;AA4nBA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvFA;AA0FA;AACA;AACA;AAEA;AACA;AAGA;AADA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAIA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AAOA;AAEA;AACA;AACA;AAAA;AAKA;AACA;AAEA;AACA;AAKA;;AAGA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAMA;AAIA;AAAA;AAMA;AAIA;AAAA;AAMA;AAIA;AAAA;AAMA;AAh2BA;;AAo2BA;AAAA;AAAA;AAAA;AAMA;AAEA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAKA;AASA;AACA;AAAA;AAAA;AAAA;AAGA;AAEA;AAEA;AACA;AAAA;;AAEA;AAAA;AAKA;AAYA;AACA;AAAA;AAGA;AAEA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAOA;AAIA;AACA;AAEA;AAeA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAn9BA;;AAo9BA;AACA;AACA;AACA;AACA;AAEA;AANA;AADA;AAYA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;AAIA;AACA;AAEA;AAEA;AA//BA;;AAggCA;AACA;AAAA;AAEA;AAngCA;;AAogCA;AAAA;AAAA;AAAA;AAKA;AAEA;AAEA;AAKA;AAFA;AAIA;;AAEA;AACA;AAAA;;AAGA;AAAA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAHA;AAKA;AAPA;AAOA;AAGA;AAGA;AACA;AACA;AACA;;AAvjCA;;AAwjCA;AACA;;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAMA;AAIA;AAEA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;AAAA;AAIA;;AACA;AACA;AACA;AAEA;AACA;;AAMA;AACA;AACA;AACA;AAFA;AAEA;AAAA;;AAIA;;AACA;AACA;AAEA;AAFA;AAEA;;AAGA;AAAA;AAAA;AAmBA;AAvoCA;;AAyoCA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAFA;AAJA;AANA;AAYA;;AAMA;AAAA;AAKA;AAlqCA;;AAoqCA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAEA;AAMA;AAnrCA;;AAqrCA;AAEA;AACA;;AACA;AACA;;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAFA;AAIA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AAFA;AAIA;AAhBA;AAgBA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAMA;AAGA;AAEA;AACA;AAEA;AAFA;AAFA;AAQA;AAAA;AAAA;AAAA;AAAA;AAMA;AAxuCA;;AA0uCA;;AACA;AACA;AAAA;;AAGA;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAMA;AAMA;AACA;AAAA;AAAA;AAAA;;AAjwCA;;AAkwCA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;;AAEA;AACA;AACA;AAAA;;AAGA;;AAEA;AACA;AAEA;AACA;AAHA;AAGA;;AAGA;AACA;AAEA;AACA;AAHA;AAGA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;;AACA;AACA;AAAA;;AAEA;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAVA;;AAaA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAVA;;AAaA;AACA;AAAA;AAEA;AAAA;;AAGA;AACA;AAAA;AAEA;AAAA;;AAGA;AACA;AAAA;AAEA;AAAA;;AAGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAl4CA;;AAo4CA;;AACA;AACA;AAAA;;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAAA;;AAGA;;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAcA;;AACA;AAEA;AACA;AAAA;AACA;AAAA;;AAIA;AAAA;AAKA;AA37CA;;AA67CA;;AAGA;AACA;AACA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAIA;AAAA;AAKA;AACA;AAEA;AAr9CA;;AAu9CA;AACA;AACA;AACA;AACA;AAHA;AAIA;AAMA;AAl+CA;;AAo+CA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAOA;;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAAA;;AAGA;AACA;AACA;AAEA;;AACA;AAMA;;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;;AASA;AACA;AAAA;AAAA;;AAGA;AAEA;;AAGA;AAOA;AAGA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAaA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAQA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AAGA;;AACA;AAMA;;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AA6BA;AACA;AACA;AAMA;AAjtDA;;AAmtDA;AACA;;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AAEA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AAAA;AAAA;AAMA;AAMA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;;AAEA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAMA;AApyDA;;AAsyDA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAFA;AAEA;AAAA;;AAKA;AAEA;AAEA;AADA;AACA;AAOA;AACA;AAEA;;AACA;AACA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAGA;AACA;AAEA;AAFA;AAEA;AAAA;AAOA;AA31DA;;AA61DA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AAWA;AAAA;AAAA;AAAA;AAiBA;AAEA;AAn5DA;;AAq5DA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AAAA;;AAGA;AAl6DA;;AAm6DA;AACA;AAEA;AAFA;AAEA;;AAGA;AACA;AAAA;AAEA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAPA;;AASA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AADA;AACA;AAAA;;AAKA;AAKA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAGA;;AACA;AACA;AACA;;AACA;AAEA;AAAA;;AAGA;AACA;AAKA;AAEA;AAFA;AAIA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;;AAGA;AAAA;AAyBA;AAEA;AAEA;AAFA;AAIA;AACA;AA5jEA;;AA6jEA;AACA;AAEA;AAAA;AAMA;AAEA;AAEA;AAAA;AAKA;AACA;AASA;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAJA;AALA;AAPA;AAoBA;AACA;AACA;AAAA;AAaA;AAIA;;AACA;AACA;AAAA;AAAA;AAOA;AACA;AAEA;AACA;AACA;AAAA;;AAEA;AAEA;AAFA;;AAKA;AACA;AAAA;;AAEA;AAAA;AAKA;AACA;AAAA;AAGA;AAEA;AAMA;AAEA;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAGA;AAFA;AAMA;;AAIA;AAAA;AAAA;AAAA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;;AAGA;AAAA;;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;;AAGA;AAAA;;;AAEA;AACA;AAAA;AA1CA;AA0CA;;AAKA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AASA;AACA;AAAA;AAAA;;AAGA;AAEA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;;AAEA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAIA;;AACA;AACA;AACA;;AAGA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;;AAEA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAWA;AAMA;AAEA;AACA;AACA;AAEA;;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAFA;AAQA;AAGA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAMA;;AAIA;AACA;AAAA;;AAGA;AAEA;AAAA;AAcA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AA76EA;;AA86EA;AAEA;AADA;AACA;AAAA;;AAKA;AACA;AAEA;;AACA;AACA;AAEA;AAIA;;AAGA;AAAA;AAcA;AACA;AAAA;AAGA;AAEA;AAv9EA;;AAw9EA;;AACA;AACA;AAEA;AACA;AAAA;AAHA;AAGA;;AAKA;;AAEA;AACA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AARA;AAHA;AAcA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;;AAGA;AA/hFA;;AAgiFA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAMA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;;AACA;AACA;;AAQA;AACA;;AACA;AACA;AAAA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;AAAA;;AAIA;AAAA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAOA;AACA;;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAQA;AACA;AAAA;AAOA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAFA;AAEA;AAAA;;AAIA;AACA;AAEA;AADA;AAIA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;;AAEA;;AACA;AAEA;AAAA;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;;AACA;AAEA;AAAA;AAEA;AACA;AAAA;;AAEA;AAAA;AAAA;AAGA;AACA;;AACA;AAEA;AAAA;AAEA;AACA;AAAA;;AAEA;AAAA;AAAA;AAGA;;AACA;AAEA;AAAA;AAEA;AACA;AAAA;;AAEA;AAAA;AAAA;AAGA;;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAWA;AAIA;AAAA;;AAEA;AACA;AAAA;;AAGA;;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;AAgDA;AA90FA;;AAg1FA;;AACA;AAj1FA;;AAk1FA;AACA;;AACA;AACA;AAEA;AAAA;;AAEA;AACA;AACA;AAFA;AAEA;;AAGA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAFA;AAFA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAEA;AAAA;;AAIA;AAAA;;AAGA;AACA;AACA;AAIA;;AACA;AACA;AAAA;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAEA;AAAA;AAAA;AAAA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;;AAGA;AACA;AAAA;AAAA;AAGA;AAAA;;AAGA;AAEA;;AACA;AACA;AACA;AACA;;AAKA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AACA;AAAA;;AAGA;AAKA;AAAA;;AAGA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAEA;AAEA;AADA;AACA;AAAA;AAkBA;AAKA;AA3/FA;;AA6/FA;AACA;AAKA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AAAA;;AAEA;AAMA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AAAA;;AAEA;AAAA;;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;;AAQA;AACA;AAAA;;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAQA;AAEA;AAEA;AAEA;;AACA;AACA;AAAA;;AAEA;AACA;AAAA;AAQA;AACA;AACA;AACA;AAjmGA;;AAkmGA;AAMA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;;AAEA;AAAA;AAGA;AAnnGA;;AAqnGA;AAEA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAPA;AAOA;AAMA;AAEA;AAGA;AACA;AAppGA;;AAqpGA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAEA;AA1pGA;;AA2pGA;AAAA;AAEA;AA7pGA;;AA6pGA;AAXA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AACA;AACA;AACA;;AACA;AACA;AACA;AAnDA;AAmDA;AAGA;AAnEA;AAwEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;;AAEA;AAAA;;AAGA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAQA;AAAA;AAKA;AACA;AAEA;AAAA;AAIA;AACA;;AAGA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAFA;AAWA;AAAA;AAKA;AACA;AAAA;AAGA;AA5xGA;;AA6xGA;AACA;AACA;;AACA;AACA;AAAA;AAEA;AACA;;AACA;AACA;AAAA;;AAEA;AAEA;AAAA;;AAEA;AAEA;AAIA;AAAA;AAGA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlFA;AAwFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AASA;;AAaA;A4Dz6GA;;AAWA;AACA;AAEA;AAFA;AAEA;;AAUA;AAGA;AAAA;AAAA;AAAA","sources":["webpack://root/./packages/cells/src/cell.stories.tsx","webpack://root/./packages/cells/src/cells/dropdown-cell.tsx","webpack://root/./packages/cells/src/cells/links-cell.tsx","webpack://root/./packages/cells/src/cells/star-cell.tsx","webpack://root/./packages/cells/src/cells/tags-cell.tsx","webpack://root/./packages/core/src/data-editor-container/data-grid-container.tsx","webpack://root/./packages/core/src/data-editor/group-rename.tsx","webpack://root/./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx","webpack://root/./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx","webpack://root/./packages/core/src/data-editor/stories/utils.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-search/data-grid-search-style.tsx","webpack://root/./packages/core/src/docs/doc-wrapper.tsx","webpack://root/./packages/core/src/growing-entry/growing-entry-style.tsx","webpack://root/./packages/core/src/markdown-div/private/markdown-container.tsx","webpack://root/./packages/core/src/scrolling-data-grid/infinite-scroller.tsx","webpack://root/./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx","webpack://root/./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx","webpack://root/./packages/core/src/stories/story-utils.tsx","webpack://root/./packages/source/src/use-data-source.stories.tsx","webpack://root/./packages/core/dist/index.css","webpack://root/./packages/cells/src/cell.stories.tsx?5c87","webpack://root/./packages/cells/src/cells/dropdown-cell.tsx?64e5","webpack://root/./packages/cells/src/cells/links-cell.tsx?f3e9","webpack://root/./packages/cells/src/cells/star-cell.tsx?ba6f","webpack://root/./packages/cells/src/cells/tags-cell.tsx?8668","webpack://root/./packages/core/src/data-editor-container/data-grid-container.tsx?fb00","webpack://root/./packages/core/src/data-editor/group-rename.tsx?dc1e","webpack://root/./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx?3bd5","webpack://root/./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx?f57b","webpack://root/./packages/core/src/data-editor/stories/utils.tsx?1f74","webpack://root/./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx?9505","webpack://root/./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx?bcf4","webpack://root/./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx?4b8e","webpack://root/./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx?e0dd","webpack://root/./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx?4ec6","webpack://root/./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx?aeea","webpack://root/./packages/core/src/data-grid-search/data-grid-search-style.tsx?ec5c","webpack://root/./packages/core/src/docs/doc-wrapper.tsx?ffbf","webpack://root/./packages/core/src/growing-entry/growing-entry-style.tsx?4015","webpack://root/./packages/core/src/markdown-div/private/markdown-container.tsx?8374","webpack://root/./packages/core/src/scrolling-data-grid/infinite-scroller.tsx?c7c8","webpack://root/./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx?7a7e","webpack://root/./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx?e93f","webpack://root/./packages/core/src/stories/story-utils.tsx?166f","webpack://root/./packages/source/src/use-data-source.stories.tsx?1501","webpack://root/./.storybook/preview.js","webpack://root/./.storybook/preview.js-generated-config-entry.js","webpack://root/packages/cells/src/cells/star-cell.tsx","webpack://root/./packages/cells/src/cells/sparkline-cell.tsx","webpack://root/./packages/cells/src/draw-fns.ts","webpack://root/packages/cells/src/cells/tags-cell.tsx","webpack://root/./packages/cells/src/cells/user-profile-cell.tsx","webpack://root/packages/cells/src/cells/dropdown-cell.tsx","webpack://root/./packages/cells/src/cells/article-cell.tsx","webpack://root/./packages/cells/src/cells/range-cell.tsx","webpack://root/./packages/cells/src/cells/spinner-cell.tsx","webpack://root/./packages/cells/src/cells/date-picker-cell.tsx","webpack://root/packages/cells/src/cells/links-cell.tsx","webpack://root/./packages/cells/src/cells/button-cell.tsx","webpack://root/./packages/cells/src/index.ts","webpack://root/./packages/core/dist/index.css?7dc3","webpack://root/packages/cells/src/cell.stories.tsx","webpack://root/./packages/core/src/common/browser-detect.ts","webpack://root/./packages/core/src/common/styles.ts","webpack://root/./packages/core/src/common/support.ts","webpack://root/./packages/core/src/common/utils.tsx","webpack://root/./packages/core/src/click-outside-container/click-outside-container.tsx","webpack://root/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/use-stay-on-screen.ts","webpack://root/./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor.tsx","webpack://root/packages/core/src/data-grid-search/data-grid-search-style.tsx","webpack://root/./packages/core/src/data-grid-search/data-grid-search.tsx","webpack://root/packages/core/src/data-editor/group-rename.tsx","webpack://root/./packages/core/src/data-editor/use-column-sizer.ts","webpack://root/./packages/core/src/common/is-hotkey.ts","webpack://root/./packages/core/src/data-grid/use-selection-behavior.ts","webpack://root/./packages/core/src/data-editor/use-cells-for-selection.ts","webpack://root/./packages/core/src/data-editor/data-editor-fns.ts","webpack://root/packages/core/src/data-editor-container/data-grid-container.tsx","webpack://root/./packages/core/src/data-editor/use-autoscroll.ts","webpack://root/./packages/core/src/data-editor/data-editor.tsx","webpack://root/./packages/core/src/data-editor/stories/data-editor-async.stories.tsx","webpack://root/packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx","webpack://root/packages/core/src/data-editor/stories/data-editor-repros.stories.tsx","webpack://root/./packages/core/src/data-editor/stories/data-editor.stories.tsx","webpack://root/packages/core/src/data-editor/stories/utils.tsx","webpack://root/./packages/core/src/data-grid/cells/boolean-cell.tsx","webpack://root/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor.tsx","webpack://root/./packages/core/src/data-grid/cells/bubble-cell.tsx","webpack://root/packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx","webpack://root/./packages/core/src/data-grid/cells/drilldown-cell.tsx","webpack://root/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor.tsx","webpack://root/./packages/core/src/data-grid/cells/image-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/loading-cell.tsx","webpack://root/packages/core/src/markdown-div/private/markdown-container.tsx","webpack://root/./packages/core/src/markdown-div/markdown-div.tsx","webpack://root/packages/core/src/growing-entry/growing-entry-style.tsx","webpack://root/./packages/core/src/growing-entry/growing-entry.tsx","webpack://root/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor.tsx","webpack://root/./packages/core/src/data-grid/cells/markdown-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/marker-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/new-row-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/number-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/protected-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/row-id-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/text-cell.tsx","webpack://root/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx","webpack://root/./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor.tsx","webpack://root/./packages/core/src/data-grid/cells/uri-cell.tsx","webpack://root/./packages/core/src/data-grid/cells/index.ts","webpack://root/./packages/core/src/data-grid/data-grid-lib.ts","webpack://root/./packages/core/src/data-grid/data-grid-types.ts","webpack://root/./packages/core/src/data-grid/data-grid.stories.tsx","webpack://root/./packages/core/src/common/image-window-loader.ts","webpack://root/./packages/core/src/data-grid/sprites.ts","webpack://root/./packages/core/src/data-grid/data-grid-sprites.ts","webpack://root/./packages/core/src/data-grid/color-parser.ts","webpack://root/./packages/core/src/data-grid/data-grid-render.tsx","webpack://root/./packages/core/src/data-grid/animation-manager.ts","webpack://root/./packages/core/src/data-grid/use-animation-queue.ts","webpack://root/./packages/core/src/data-grid/data-grid.tsx","webpack://root/./packages/core/src/docs/00-faq.stories.tsx","webpack://root/./packages/core/src/docs/01-getting-started.stories.tsx","webpack://root/./packages/core/src/docs/02-editing-data.stories.tsx","webpack://root/./packages/core/src/docs/03-grid-column.stories.tsx","webpack://root/./packages/core/src/docs/04-streaming-data.stories.tsx","webpack://root/./packages/core/src/docs/05-copy-paste.stories.tsx.tsx","webpack://root/./packages/core/src/docs/06-search.stories.tsx","webpack://root/./packages/core/src/docs/07-column-grouping.stories.tsx","webpack://root/./packages/core/src/docs/08-theming.stories.tsx","webpack://root/./packages/core/src/docs/09-menus.stories.tsx","webpack://root/packages/core/src/docs/doc-wrapper.tsx","webpack://root/packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx","webpack://root/./packages/core/src/data-grid-dnd/data-grid-dnd.tsx","webpack://root/./packages/core/src/common/resize-detector.ts","webpack://root/packages/core/src/scrolling-data-grid/infinite-scroller.tsx","webpack://root/packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx","webpack://root/packages/core/src/stories/story-utils.tsx","webpack://root/./packages/source/src/use-movable-columns.ts","webpack://root/./packages/source/src/use-column-sort.ts","webpack://root/./packages/source/src/use-collapsing-groups.ts","webpack://root/packages/source/src/use-data-source.stories.tsx","webpack://root/./storybook-init-framework-entry.js","webpack://root/././ sync ^\\.(","webpack://root/ignored|/home/runner/work/glide-data-grid/glide-data-grid/node_modules/object-inspect|./util.inspect","webpack://root/./generated-stories-entry.cjs","webpack://root/../../../../node_modules/@emotion/memoize/dist/memoize.browser.esm.js","webpack://root/../../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js","webpack://root/../../../../node_modules/@linaria/react/src/styled.ts","webpack://root/../../../../node_modules/@linaria/core/src/cx.ts","webpack://root/../../src/data-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/data-editor.tsx","webpack://root/../../src/common/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/common/support.ts","webpack://root/../../src/data-grid-overlay-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor.tsx","webpack://root/../../src/click-outside-container/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/click-outside-container/click-outside-container.tsx","webpack://root/../../src/common/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/common/styles.ts","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/data-grid-types.ts","webpack://root/../../src/data-grid-overlay-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx","webpack://root/../../src/data-grid-overlay-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/use-stay-on-screen.ts","webpack://root/../../src/data-grid-search/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-search/data-grid-search.tsx","webpack://root/../../src/scrolling-data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx","webpack://root/../../src/data-grid-dnd/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-dnd/data-grid-dnd.tsx","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/data-grid.tsx","webpack://root/../../src/common/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/common/image-window-loader.ts","webpack://root/../../src/common/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/common/utils.tsx","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/data-grid-lib.ts","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/sprites.ts","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/data-grid-sprites.ts","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/data-grid-render.tsx","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/color-parser.ts","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/animation-manager.ts","webpack://root/../../src/common/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/common/browser-detect.ts","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/use-animation-queue.ts","webpack://root/../../src/scrolling-data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/scrolling-data-grid/infinite-scroller.tsx","webpack://root/../../src/common/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/common/resize-detector.ts","webpack://root/../../src/data-grid-search/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-search/data-grid-search-style.tsx","webpack://root/../../src/data-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/group-rename.tsx","webpack://root/../../src/data-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/use-column-sizer.ts","webpack://root/../../src/common/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/common/is-hotkey.ts","webpack://root/../../src/data-grid/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/use-selection-behavior.ts","webpack://root/../../src/data-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/use-cells-for-selection.ts","webpack://root/../../src/data-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/data-editor-fns.ts","webpack://root/../../src/data-editor-container/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor-container/data-grid-container.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/boolean-cell.tsx","webpack://root/../../src/data-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/use-autoscroll.ts","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/bubble-cell.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/drilldown-cell.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/image-cell.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/loading-cell.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/markdown-cell.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor.tsx","webpack://root/../../src/markdown-div/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/markdown-div/markdown-div.tsx","webpack://root/../../src/markdown-div/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/markdown-div/private/markdown-container.tsx","webpack://root/../../src/growing-entry/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/growing-entry/growing-entry.tsx","webpack://root/../../src/growing-entry/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/growing-entry/growing-entry-style.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/marker-cell.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/new-row-cell.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/number-cell.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/protected-cell.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/row-id-cell.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/text-cell.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/uri-cell.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor.tsx","webpack://root/../../src/data-grid-overlay-editor/private/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx","webpack://root/../../src/data-grid/cells/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-grid/cells/index.ts","webpack://root/../../src/data-editor/home/runner/work/glide-data-grid/glide-data-grid/packages/core/src/data-editor/use-custom-cells.ts"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".s1wvhs74{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1wvhs74 *,.s1wvhs74 *::before,.s1wvhs74 *::after{box-sizing:inherit;}\\n.b16aqpip{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b16aqpip > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b16aqpip .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b16aqpip .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\\n.d1npx1y{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXd2aHM3NCIsIi5iMTZhcXBpcCIsIi5kMW5weDF5Il0sIm1hcHBpbmdzIjoiQUFzQk1BO0FBaUNBQztBQW9FQUMiLCJmaWxlIjoicGFja2FnZXMvY2VsbHMvc3JjL2NlbGwuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQgfSBmcm9tIFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IERyb3Bkb3duQ2VsbCBhcyBEcm9wZG93blJlbmRlcmVyLCB1c2VFeHRyYUNlbGxzIH0gZnJvbSBcIi5cIjtcbmltcG9ydCB0eXBlIHsgU3RhckNlbGwgfSBmcm9tIFwiLi9jZWxscy9zdGFyLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgU3BhcmtsaW5lQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwYXJrbGluZS1jZWxsXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgdHlwZSB7IFRhZ3NDZWxsIH0gZnJvbSBcIi4vY2VsbHMvdGFncy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IFVzZXJQcm9maWxlQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3VzZXItcHJvZmlsZS1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IERyb3Bkb3duQ2VsbCB9IGZyb20gXCIuL2NlbGxzL2Ryb3Bkb3duLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgQXJ0aWNsZUNlbGwgfSBmcm9tIFwiLi9jZWxscy9hcnRpY2xlLWNlbGwtdHlwZXNcIjtcbmltcG9ydCB0eXBlIHsgUmFuZ2VDZWxsIH0gZnJvbSBcIi4vY2VsbHMvcmFuZ2UtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBTcGlubmVyQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwaW5uZXItY2VsbFwiO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tIFwicmVhY3QtcmVzaXplLWRldGVjdG9yXCI7XG5cbmltcG9ydCBcIkB0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci5jc3NcIjtcbmltcG9ydCBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvaW5kZXguY3NzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGVQaWNrZXJDZWxsIH0gZnJvbSBcIi4vY2VsbHMvZGF0ZS1waWNrZXItY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBMaW5rc0NlbGwgfSBmcm9tIFwiLi9jZWxscy9saW5rcy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IEJ1dHRvbkNlbGwgfSBmcm9tIFwiLi9jZWxscy9idXR0b24tY2VsbFwiO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvQ2VsbHNcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzI3OTBiOSwgIzIwNzBhOSk7XG4gICAgY29sb3I6IHdoaXRlO1xuXG4gICAgcGFkZGluZzogMzJweCA0OHB4O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwdmg7XG5cbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcblxuICAgICYgPiBoMSB7XG4gICAgICAgIGZvbnQtc2l6ZTogNTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIG1hcmdpbjogMCAwIDEycHggMDtcbiAgICB9XG5cbiAgICAuc2l6ZXIge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgYm94LXNoYWRvdzogcmdiYSg5LCAzMCwgNjYsIDAuMjUpIDBweCA0cHggOHB4IC0ycHgsIHJnYmEoOSwgMzAsIDY2LCAwLjA4KSAwcHggMHB4IDBweCAxcHg7XG5cbiAgICAgICAgLnNpemVyLWNsaXAge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG5cbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyB0aXRsZSwgY2hpbGRyZW4sIGRlc2NyaXB0aW9uIH0gPSBwO1xuXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICByb3dNYXJrZXJzOiBcIm5vbmVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5sZXQgbnVtOiBudW1iZXIgPSAxO1xuZnVuY3Rpb24gcmFuZCgpOiBudW1iZXIge1xuICAgIHJldHVybiAobnVtID0gKG51bSAqIDE2ODA3KSAlIDIxNDc0ODM2NDcpIC8gMjE0NzQ4MzY0Nztcbn1cblxuY29uc3QgcG9zc2libGVUYWdzID0gW1xuICAgIHtcbiAgICAgICAgdGFnOiBcIkJ1Z1wiLFxuICAgICAgICBjb2xvcjogXCIjZmY0ZDRkMzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZlYXR1cmVcIixcbiAgICAgICAgY29sb3I6IFwiIzM1ZjhmZjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJFbmhhbmNlbWVudFwiLFxuICAgICAgICBjb2xvcjogXCIjNDhmZjU3MzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZpcnN0IElzc3VlXCIsXG4gICAgICAgIGNvbG9yOiBcIiM0MzZmZmYzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiUFJcIixcbiAgICAgICAgY29sb3I6IFwiI2UwZmYzMjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJBc3NpZ25lZFwiLFxuICAgICAgICBjb2xvcjogXCIjZmYxZWVjMzVcIixcbiAgICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gY2VsbHNcIiBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPlNvbWUgb2Ygb3VyIGV4dGVuc2lvbiBjZWxscy48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoLi4uYXJncykgPT4gY29uc29sZS5sb2coXCJFZGl0IENlbGxcIiwgLi4uYXJncyl9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInN0YXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJUZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTdGFyQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3BhcmtsaW5lLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzOiB2YWx1ZXMubWFwKHggPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcIiM3N2M0YzRcIiA6IFwiI0Q5ODQ2NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogWy01MCwgNTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFNwYXJrbGluZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGFya2xpbmUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJhbmdlKDAsIDE1KS5tYXAoKCkgPT4gcmFuZCgpICogMTAwIC0gNTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcm93ICUgMiA9PT0gMCA/IFwiIzc3YzRjNFwiIDogXCIjRDk4NDY2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoS2luZDogXCJiYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJ0YWdzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzOiBwb3NzaWJsZVRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiByb3cgJSAyID09PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiB1bmlxKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBUYWdzQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidXNlci1wcm9maWxlLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHJvdyAlIDIgPyB1bmRlZmluZWQgOiBcImh0dHBzOi8vaS5yZWRkLml0L2FxYzFod2hhbHN6NzEuanBnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWw6IFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW50OiBcIiNGMUQ4NkVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93ICUgNSA/IHVuZGVmaW5lZCA6IFwiQmVlIGJiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVXNlclByb2ZpbGVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERyb3Bkb3duQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImRyb3Bkb3duLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1wiR29vZFwiLCBcIkJldHRlclwiLCBcIkJlc3RcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkdvb2RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBSYW5nZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJyYW5nZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxMCArIE1hdGgucm91bmQodiAqIDIwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke01hdGgucm91bmQodiAqIDEwMCl9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVMYWJlbDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBBcnRpY2xlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImFydGljbGUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bjogXCIjIyBUaGlzIGlzIGEgdGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogU3Bpbm5lckNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGlubmVyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERhdGVQaWNrZXJDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZS1waWNrZXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IExpbmtzQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImxpbmtzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lT2Zmc2V0OiA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmt5IHBob25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXCJDbGljayAxXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJDbGljayB0aGUgbGlua3kgZGlua3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBhbGVydChcIkNsaWNrIDJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IEJ1dHRvbkNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImJ1dHRvbi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1widHJhbnNwYXJlbnRcIiwgXCIjNjU3MmZmZWVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBbXCJhY2NlbnRDb2xvclwiLCBcImFjY2VudEZnXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjNjU3MmZmYTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJWaWV3IERldGFpbHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gd2luZG93LmFsZXJ0KFwiQnV0dG9uIGNsaWNrZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VGb250U3R5bGU6IFwiNzAwIDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxcIik7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlN0YXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTcGFya2xpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNwYXJrbGluZSAoYmFycylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlRhZ3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlByb2ZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJSYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQXJ0aWNsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiU3Bpbm5lclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRGF0ZSBQaWNrZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmtzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCdXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ3VzdG9tQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxFZGl0aW5nOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgY29uc3QgZGF0YSA9IFJlYWN0LnVzZVJlZjxzdHJpbmdbXT4oW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGNlbGwgZWRpdGluZ1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDZWxscyBjYW4gYmUgZWRpdGVkIGFuZCByZXNwb25kaW5nIHRvIGNvcHkvcGFzdGUgdXNpbmcgdGhlIGNvcHlEYXRhIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICB7Li4uY2VsbFByb3BzfVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoY2VsbCwgbmV3VmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwua2luZCAhPT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoRHJvcGRvd25SZW5kZXJlci5pc01hdGNoKG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFtjZWxsWzFdXSA9IG5ld1ZhbC5kYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Y2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFssIHJvd10gPSBjZWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkYXRhLmN1cnJlbnRbcm93XSA/PyBcIkFcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBEcm9wZG93bkNlbGw7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUNlbGxFZGl0aW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG4iXX0=*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/cells/src/packages/cells/src/cell.stories.tsx\",\"webpack://./packages/cells/src/cell.stories.tsx\"],\"names\":[\".s1wvhs74\",\".b16aqpip\",\".d1npx1y\"],\"mappings\":\"AAsBMA,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AAiCAC,UAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,eAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,6BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA;AAoEAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;ACxHN,muvBAAmuvB\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport { DataEditor, DataEditorProps, GridCellKind } from \\\"@glideapps/glide-data-grid\\\";\\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \\\".\\\";\\nimport type { StarCell } from \\\"./cells/star-cell\\\";\\nimport type { SparklineCell } from \\\"./cells/sparkline-cell\\\";\\nimport range from \\\"lodash/range.js\\\";\\nimport uniq from \\\"lodash/uniq.js\\\";\\nimport type { TagsCell } from \\\"./cells/tags-cell\\\";\\nimport type { UserProfileCell } from \\\"./cells/user-profile-cell\\\";\\nimport type { DropdownCell } from \\\"./cells/dropdown-cell\\\";\\nimport type { ArticleCell } from \\\"./cells/article-cell-types\\\";\\nimport type { RangeCell } from \\\"./cells/range-cell\\\";\\nimport type { SpinnerCell } from \\\"./cells/spinner-cell\\\";\\nimport { useResizeDetector } from \\\"react-resize-detector\\\";\\n\\nimport \\\"@toast-ui/editor/dist/toastui-editor.css\\\";\\nimport \\\"@glideapps/glide-data-grid/dist/index.css\\\";\\nimport type { DatePickerCell } from \\\"./cells/date-picker-cell\\\";\\nimport type { LinksCell } from \\\"./cells/links-cell\\\";\\nimport type { ButtonCell } from \\\"./cells/button-cell\\\";\\n\\nconst SimpleWrapper = styled.div`\\n    text-rendering: optimizeLegibility;\\n    -webkit-font-smoothing: antialiased;\\n\\n    box-sizing: border-box;\\n\\n    *,\\n    *::before,\\n    *::after {\\n        box-sizing: inherit;\\n    }\\n`;\\n\\nconst SimpleThemeWrapper: React.FC = p => {\\n    return (\\n        <SimpleWrapper>\\n            <div className=\\\"content\\\">{p.children}</div>\\n        </SimpleWrapper>\\n    );\\n};\\n\\nexport default {\\n    title: \\\"Extra Packages/Cells\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <Story />\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst BeautifulStyle = styled.div`\\n    background-color: #2790b9;\\n    background: linear-gradient(90deg, #2790b9, #2070a9);\\n    color: white;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    & > h1 {\\n        font-size: 50px;\\n        font-weight: 600;\\n        flex-shrink: 0;\\n        margin: 0 0 12px 0;\\n    }\\n\\n    .sizer {\\n        flex-grow: 1;\\n\\n        background-color: white;\\n\\n        border-radius: 12px;\\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\\n\\n        .sizer-clip {\\n            border-radius: 12px;\\n            overflow: hidden;\\n            transform: translateZ(0);\\n\\n            height: 100%;\\n        }\\n    }\\n`;\\n\\ninterface BeautifulProps {\\n    title: string;\\n    description?: React.ReactNode;\\n}\\n\\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\\n    const { title, children, description } = p;\\n\\n    const { ref, width, height } = useResizeDetector();\\n\\n    return (\\n        <BeautifulStyle>\\n            <h1>{title}</h1>\\n            {description}\\n            <div className=\\\"sizer\\\">\\n                <div className=\\\"sizer-clip\\\" ref={ref}>\\n                    <div\\n                        style={{\\n                            position: \\\"relative\\\",\\n                            width: width ?? 100,\\n                            height: height ?? 100,\\n                        }}>\\n                        {children}\\n                    </div>\\n                </div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n\\nconst Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nconst defaultProps: Partial<DataEditorProps> = {\\n    smoothScrollX: true,\\n    smoothScrollY: true,\\n    isDraggable: false,\\n    rowMarkers: \\\"none\\\",\\n    width: \\\"100%\\\",\\n};\\n\\nlet num: number = 1;\\nfunction rand(): number {\\n    return (num = (num * 16807) % 2147483647) / 2147483647;\\n}\\n\\nconst possibleTags = [\\n    {\\n        tag: \\\"Bug\\\",\\n        color: \\\"#ff4d4d35\\\",\\n    },\\n    {\\n        tag: \\\"Feature\\\",\\n        color: \\\"#35f8ff35\\\",\\n    },\\n    {\\n        tag: \\\"Enhancement\\\",\\n        color: \\\"#48ff5735\\\",\\n    },\\n    {\\n        tag: \\\"First Issue\\\",\\n        color: \\\"#436fff35\\\",\\n    },\\n    {\\n        tag: \\\"PR\\\",\\n        color: \\\"#e0ff3235\\\",\\n    },\\n    {\\n        tag: \\\"Assigned\\\",\\n        color: \\\"#ff1eec35\\\",\\n    },\\n];\\n\\nexport const CustomCells: React.VFC = () => {\\n    const cellProps = useExtraCells();\\n\\n    return (\\n        <BeautifulWrapper title=\\\"Custom cells\\\" description={<Description>Some of our extension cells.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                {...cellProps}\\n                onPaste={true}\\n                // eslint-disable-next-line no-console\\n                onCellEdited={(...args) => console.log(\\\"Edit Cell\\\", ...args)}\\n                getCellContent={cell => {\\n                    const [col, row] = cell;\\n                    if (col === 0) {\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"star-cell\\\",\\n                                label: \\\"Test\\\",\\n                                rating: 4,\\n                            },\\n                        } as StarCell;\\n                    } else if (col === 1) {\\n                        num = row + 1;\\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: false,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"sparkline-cell\\\",\\n                                values,\\n                                displayValues: values.map(x => Math.round(x).toString()),\\n                                color: row % 2 === 0 ? \\\"#77c4c4\\\" : \\\"#D98466\\\",\\n                                yAxis: [-50, 50],\\n                            },\\n                        } as SparklineCell;\\n                    } else if (col === 2) {\\n                        num = row + 1;\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: false,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"sparkline-cell\\\",\\n                                values: range(0, 15).map(() => rand() * 100 - 50),\\n                                color: row % 2 === 0 ? \\\"#77c4c4\\\" : \\\"#D98466\\\",\\n                                graphKind: \\\"bar\\\",\\n                                yAxis: [-50, 50],\\n                            },\\n                        } as SparklineCell;\\n                    } else if (col === 3) {\\n                        num = row + 1;\\n                        rand();\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"tags-cell\\\",\\n                                possibleTags: possibleTags,\\n                                readonly: row % 2 === 0,\\n                                tags: uniq([\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\\n                                ]),\\n                            },\\n                        } as TagsCell;\\n                    } else if (col === 4) {\\n                        num = row + 1;\\n                        rand();\\n                        return {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"user-profile-cell\\\",\\n                                image: row % 2 ? undefined : \\\"https://i.redd.it/aqc1hwhalsz71.jpg\\\",\\n                                initial: \\\"B\\\",\\n                                tint: \\\"#F1D86E\\\",\\n                                name: row % 5 ? undefined : \\\"Bee bb\\\",\\n                            },\\n                        } as UserProfileCell;\\n                    } else if (col === 5) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: DropdownCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"dropdown-cell\\\",\\n                                allowedValues: [\\\"Good\\\", \\\"Better\\\", \\\"Best\\\"],\\n                                value: \\\"Good\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 6) {\\n                        num = row + 1;\\n                        rand();\\n                        const v = rand();\\n                        const d: RangeCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"range-cell\\\",\\n                                min: 10,\\n                                max: 30,\\n                                value: 10 + Math.round(v * 20),\\n                                step: 1,\\n                                label: `${Math.round(v * 100)}%`,\\n                                measureLabel: \\\"100%\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 7) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: ArticleCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"article-cell\\\",\\n                                markdown: \\\"## This is a test\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 8) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: SpinnerCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"spinner-cell\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 9) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: DatePickerCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"date-picker-cell\\\",\\n                                date: new Date(),\\n                                displayDate: new Date().toISOString(),\\n                                format: \\\"date\\\",\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 10) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: LinksCell = {\\n                            kind: GridCellKind.Custom,\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            data: {\\n                                kind: \\\"links-cell\\\",\\n                                underlineOffset: 6,\\n                                links: [\\n                                    {\\n                                        title: \\\"Linky phone\\\",\\n                                        onClick: () => alert(\\\"Click 1\\\"),\\n                                    },\\n                                    {\\n                                        title: \\\"Click the linky dinky\\\",\\n                                        onClick: () => alert(\\\"Click 2\\\"),\\n                                    },\\n                                ],\\n                            },\\n                        };\\n                        return d;\\n                    } else if (col === 11) {\\n                        num = row + 1;\\n                        rand();\\n                        const d: ButtonCell = {\\n                            kind: GridCellKind.Custom,\\n                            cursor: \\\"pointer\\\",\\n                            allowOverlay: true,\\n                            copyData: \\\"4\\\",\\n                            readonly: true,\\n                            data: {\\n                                kind: \\\"button-cell\\\",\\n                                backgroundColor: [\\\"transparent\\\", \\\"#6572ffee\\\"],\\n                                color: [\\\"accentColor\\\", \\\"accentFg\\\"],\\n                                borderColor: \\\"#6572ffa0\\\",\\n                                borderRadius: 9,\\n                                title: \\\"View Details\\\",\\n                                onClick: () => window.alert(\\\"Button clicked\\\"),\\n                            },\\n                            themeOverride: {\\n                                baseFontStyle: \\\"700 12px\\\",\\n                            },\\n                        };\\n                        return d;\\n                    }\\n                    throw new Error(\\\"Fail\\\");\\n                }}\\n                columns={[\\n                    {\\n                        title: \\\"Stars\\\",\\n                        width: 200,\\n                    },\\n                    {\\n                        title: \\\"Sparkline\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Sparkline (bars)\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Tags\\\",\\n                        width: 250,\\n                    },\\n                    {\\n                        title: \\\"Profile\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Dropdown\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Range\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Article\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Spinner\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Date Picker\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Links\\\",\\n                        width: 150,\\n                    },\\n                    {\\n                        title: \\\"Button\\\",\\n                        width: 120,\\n                    },\\n                ]}\\n                rows={500}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomCells as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const CustomCellEditing: React.VFC = () => {\\n    const cellProps = useExtraCells();\\n\\n    const data = React.useRef<string[]>([]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Custom cell editing\\\"\\n            description={\\n                <Description>\\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                {...cellProps}\\n                onPaste={true}\\n                onCellEdited={(cell, newVal) => {\\n                    if (newVal.kind !== GridCellKind.Custom) return;\\n                    if (DropdownRenderer.isMatch(newVal)) {\\n                        data.current[cell[1]] = newVal.data.value;\\n                    }\\n                }}\\n                getCellsForSelection={true}\\n                getCellContent={cell => {\\n                    const [, row] = cell;\\n                    const val = data.current[row] ?? \\\"A\\\";\\n                    return {\\n                        kind: GridCellKind.Custom,\\n                        allowOverlay: true,\\n                        copyData: val,\\n                        data: {\\n                            kind: \\\"dropdown-cell\\\",\\n                            allowedValues: [\\\"A\\\", \\\"B\\\", \\\"C\\\"],\\n                            value: val,\\n                        },\\n                    } as DropdownCell;\\n                }}\\n                columns={[\\n                    {\\n                        title: \\\"Dropdown\\\",\\n                        width: 200,\\n                    },\\n                ]}\\n                rows={500}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomCellEditing as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\",\".s1wvhs74{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1wvhs74 *,.s1wvhs74 *::before,.s1wvhs74 *::after{box-sizing:inherit;}\\n.b16aqpip{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b16aqpip > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b16aqpip .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b16aqpip .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\\n.d1npx1y{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXd2aHM3NCIsIi5iMTZhcXBpcCIsIi5kMW5weDF5Il0sIm1hcHBpbmdzIjoiQUFzQk1BO0FBaUNBQztBQW9FQUMiLCJmaWxlIjoicGFja2FnZXMvY2VsbHMvc3JjL2NlbGwuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQgfSBmcm9tIFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IERyb3Bkb3duQ2VsbCBhcyBEcm9wZG93blJlbmRlcmVyLCB1c2VFeHRyYUNlbGxzIH0gZnJvbSBcIi5cIjtcbmltcG9ydCB0eXBlIHsgU3RhckNlbGwgfSBmcm9tIFwiLi9jZWxscy9zdGFyLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgU3BhcmtsaW5lQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwYXJrbGluZS1jZWxsXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgdHlwZSB7IFRhZ3NDZWxsIH0gZnJvbSBcIi4vY2VsbHMvdGFncy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IFVzZXJQcm9maWxlQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3VzZXItcHJvZmlsZS1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IERyb3Bkb3duQ2VsbCB9IGZyb20gXCIuL2NlbGxzL2Ryb3Bkb3duLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgQXJ0aWNsZUNlbGwgfSBmcm9tIFwiLi9jZWxscy9hcnRpY2xlLWNlbGwtdHlwZXNcIjtcbmltcG9ydCB0eXBlIHsgUmFuZ2VDZWxsIH0gZnJvbSBcIi4vY2VsbHMvcmFuZ2UtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBTcGlubmVyQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwaW5uZXItY2VsbFwiO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tIFwicmVhY3QtcmVzaXplLWRldGVjdG9yXCI7XG5cbmltcG9ydCBcIkB0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci5jc3NcIjtcbmltcG9ydCBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvaW5kZXguY3NzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGVQaWNrZXJDZWxsIH0gZnJvbSBcIi4vY2VsbHMvZGF0ZS1waWNrZXItY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBMaW5rc0NlbGwgfSBmcm9tIFwiLi9jZWxscy9saW5rcy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IEJ1dHRvbkNlbGwgfSBmcm9tIFwiLi9jZWxscy9idXR0b24tY2VsbFwiO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvQ2VsbHNcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzI3OTBiOSwgIzIwNzBhOSk7XG4gICAgY29sb3I6IHdoaXRlO1xuXG4gICAgcGFkZGluZzogMzJweCA0OHB4O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwdmg7XG5cbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcblxuICAgICYgPiBoMSB7XG4gICAgICAgIGZvbnQtc2l6ZTogNTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIG1hcmdpbjogMCAwIDEycHggMDtcbiAgICB9XG5cbiAgICAuc2l6ZXIge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgYm94LXNoYWRvdzogcmdiYSg5LCAzMCwgNjYsIDAuMjUpIDBweCA0cHggOHB4IC0ycHgsIHJnYmEoOSwgMzAsIDY2LCAwLjA4KSAwcHggMHB4IDBweCAxcHg7XG5cbiAgICAgICAgLnNpemVyLWNsaXAge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG5cbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyB0aXRsZSwgY2hpbGRyZW4sIGRlc2NyaXB0aW9uIH0gPSBwO1xuXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICByb3dNYXJrZXJzOiBcIm5vbmVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5sZXQgbnVtOiBudW1iZXIgPSAxO1xuZnVuY3Rpb24gcmFuZCgpOiBudW1iZXIge1xuICAgIHJldHVybiAobnVtID0gKG51bSAqIDE2ODA3KSAlIDIxNDc0ODM2NDcpIC8gMjE0NzQ4MzY0Nztcbn1cblxuY29uc3QgcG9zc2libGVUYWdzID0gW1xuICAgIHtcbiAgICAgICAgdGFnOiBcIkJ1Z1wiLFxuICAgICAgICBjb2xvcjogXCIjZmY0ZDRkMzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZlYXR1cmVcIixcbiAgICAgICAgY29sb3I6IFwiIzM1ZjhmZjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJFbmhhbmNlbWVudFwiLFxuICAgICAgICBjb2xvcjogXCIjNDhmZjU3MzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZpcnN0IElzc3VlXCIsXG4gICAgICAgIGNvbG9yOiBcIiM0MzZmZmYzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiUFJcIixcbiAgICAgICAgY29sb3I6IFwiI2UwZmYzMjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJBc3NpZ25lZFwiLFxuICAgICAgICBjb2xvcjogXCIjZmYxZWVjMzVcIixcbiAgICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gY2VsbHNcIiBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPlNvbWUgb2Ygb3VyIGV4dGVuc2lvbiBjZWxscy48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoLi4uYXJncykgPT4gY29uc29sZS5sb2coXCJFZGl0IENlbGxcIiwgLi4uYXJncyl9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInN0YXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJUZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTdGFyQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3BhcmtsaW5lLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzOiB2YWx1ZXMubWFwKHggPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcIiM3N2M0YzRcIiA6IFwiI0Q5ODQ2NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogWy01MCwgNTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFNwYXJrbGluZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGFya2xpbmUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJhbmdlKDAsIDE1KS5tYXAoKCkgPT4gcmFuZCgpICogMTAwIC0gNTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcm93ICUgMiA9PT0gMCA/IFwiIzc3YzRjNFwiIDogXCIjRDk4NDY2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoS2luZDogXCJiYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJ0YWdzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzOiBwb3NzaWJsZVRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiByb3cgJSAyID09PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiB1bmlxKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBUYWdzQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidXNlci1wcm9maWxlLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHJvdyAlIDIgPyB1bmRlZmluZWQgOiBcImh0dHBzOi8vaS5yZWRkLml0L2FxYzFod2hhbHN6NzEuanBnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWw6IFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW50OiBcIiNGMUQ4NkVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93ICUgNSA/IHVuZGVmaW5lZCA6IFwiQmVlIGJiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVXNlclByb2ZpbGVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERyb3Bkb3duQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImRyb3Bkb3duLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1wiR29vZFwiLCBcIkJldHRlclwiLCBcIkJlc3RcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkdvb2RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBSYW5nZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJyYW5nZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxMCArIE1hdGgucm91bmQodiAqIDIwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke01hdGgucm91bmQodiAqIDEwMCl9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVMYWJlbDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBBcnRpY2xlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImFydGljbGUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bjogXCIjIyBUaGlzIGlzIGEgdGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogU3Bpbm5lckNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGlubmVyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERhdGVQaWNrZXJDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZS1waWNrZXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IExpbmtzQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImxpbmtzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lT2Zmc2V0OiA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmt5IHBob25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXCJDbGljayAxXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJDbGljayB0aGUgbGlua3kgZGlua3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBhbGVydChcIkNsaWNrIDJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IEJ1dHRvbkNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImJ1dHRvbi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1widHJhbnNwYXJlbnRcIiwgXCIjNjU3MmZmZWVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBbXCJhY2NlbnRDb2xvclwiLCBcImFjY2VudEZnXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjNjU3MmZmYTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJWaWV3IERldGFpbHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gd2luZG93LmFsZXJ0KFwiQnV0dG9uIGNsaWNrZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VGb250U3R5bGU6IFwiNzAwIDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxcIik7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlN0YXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTcGFya2xpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNwYXJrbGluZSAoYmFycylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlRhZ3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlByb2ZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJSYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQXJ0aWNsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiU3Bpbm5lclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRGF0ZSBQaWNrZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmtzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCdXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ3VzdG9tQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxFZGl0aW5nOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgY29uc3QgZGF0YSA9IFJlYWN0LnVzZVJlZjxzdHJpbmdbXT4oW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGNlbGwgZWRpdGluZ1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDZWxscyBjYW4gYmUgZWRpdGVkIGFuZCByZXNwb25kaW5nIHRvIGNvcHkvcGFzdGUgdXNpbmcgdGhlIGNvcHlEYXRhIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICB7Li4uY2VsbFByb3BzfVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoY2VsbCwgbmV3VmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwua2luZCAhPT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoRHJvcGRvd25SZW5kZXJlci5pc01hdGNoKG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFtjZWxsWzFdXSA9IG5ld1ZhbC5kYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Y2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFssIHJvd10gPSBjZWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkYXRhLmN1cnJlbnRbcm93XSA/PyBcIkFcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBEcm9wZG93bkNlbGw7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUNlbGxFZGl0aW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG4iXX0=*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".wg6ppx4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}.wg6ppx4 .glide-select{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);}\\n.p7jnwoo{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);color:var(--gdg-text-dark);}.p7jnwoo > div{border-radius:4px;border:1px solid var(--gdg-border-color);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCJdLCJuYW1lcyI6WyIud2c2cHB4NCIsIi5wN2pud29vIl0sIm1hcHBpbmdzIjoiQUE2Qk1BO0FBV0FDIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBQcm92aWRlRWRpdG9yQ2FsbGJhY2ssXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICB1c2VUaGVtZSxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTZWxlY3QsIHsgTWVudVByb3BzLCBjb21wb25lbnRzIH0gZnJvbSBcInJlYWN0LXNlbGVjdFwiO1xuXG5pbnRlcmZhY2UgQ3VzdG9tTWVudVByb3BzIGV4dGVuZHMgTWVudVByb3BzPGFueT4ge31cblxuY29uc3QgQ3VzdG9tTWVudTogUmVhY3QuRkM8Q3VzdG9tTWVudVByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgTWVudSB9ID0gY29tcG9uZW50cztcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiA8TWVudSB7Li4ucmVzdH0+e2NoaWxkcmVufTwvTWVudT47XG59O1xuXG5pbnRlcmZhY2UgRHJvcGRvd25DZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiO1xuICAgIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgYWxsb3dlZFZhbHVlczogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgcmVhZG9ubHkgcmVhZG9ubHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBEcm9wZG93bkNlbGwgPSBDdXN0b21DZWxsPERyb3Bkb3duQ2VsbFByb3BzPjtcblxuY29uc3QgV3JhcCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuXG4gICAgLmdsaWRlLXNlbGVjdCB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgICAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICB9XG5gO1xuXG5jb25zdCBQb3J0YWxXcmFwID0gc3R5bGVkLmRpdmBcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICA+IGRpdiB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuYDtcblxuY29uc3QgRWRpdG9yOiBSZXR1cm5UeXBlPFByb3ZpZGVFZGl0b3JDYWxsYmFjazxEcm9wZG93bkNlbGw+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNlbGwsIG9uRmluaXNoZWRFZGl0aW5nLCBpbml0aWFsVmFsdWUgfSA9IHA7XG4gICAgY29uc3QgeyBhbGxvd2VkVmFsdWVzLCB2YWx1ZTogdmFsdWVJbiB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSh2YWx1ZUluKTtcbiAgICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsVmFsdWUgPz8gXCJcIik7XG5cbiAgICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBSZWFjdC51c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYWxsb3dlZFZhbHVlcy5tYXAoeCA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB4LFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBbYWxsb3dlZFZhbHVlc11cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFdyYXA+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2xpZGUtc2VsZWN0XCJcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlPXtpbnB1dFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uSW5wdXRDaGFuZ2U9e3NldElucHV0VmFsdWV9XG4gICAgICAgICAgICAgICAgbWVudVBsYWNlbWVudD17XCJhdXRvXCJ9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlcy5maW5kKHggPT4geC52YWx1ZSA9PT0gdmFsdWUpfVxuICAgICAgICAgICAgICAgIHN0eWxlcz17e1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBiYXNlID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICB0aGVtZT17dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udC5jb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDA6IHRoZW1lLmJnQ2VsbCwgLy8gdGhpcyBpcyBib3RoIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIEFORCB0aGUgZmcgY29sb3Igb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgaXRlbSBiZWNhdXNlIG9mIGNvdXJzZSBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNTogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwyMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwzMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw0MDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw1MDogdGhlbWUudGV4dExpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw2MDogdGhlbWUudGV4dE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNzA6IHRoZW1lLnRleHRNZWRpdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDgwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsOTA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk6IHRoZW1lLmFjY2VudENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk3NTogdGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTUwOiB0aGVtZS5hY2NlbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5MjU6IHRoZW1lLmFjY2VudExpZ2h0LCAvLyBwcmVsaWdodCBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG1lbnVQb3J0YWxUYXJnZXQ9e2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicG9ydGFsXCIpfVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvcGVuTWVudU9uRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cz17e1xuICAgICAgICAgICAgICAgICAgICBEcm9wZG93bkluZGljYXRvcjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgSW5kaWNhdG9yU2VwYXJhdG9yOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBNZW51OiBwcm9wcyA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8UG9ydGFsV3JhcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q3VzdG9tTWVudSBjbGFzc05hbWU9e1wiY2xpY2stb3V0c2lkZS1pZ25vcmVcIn0gey4uLnByb3BzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Qb3J0YWxXcmFwPlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17dmFsdWVzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXthc3luYyBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyKSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRmluaXNoZWRFZGl0aW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvV3JhcD5cbiAgICApO1xufTtcblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPERyb3Bkb3duQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgRHJvcGRvd25DZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcImRyb3Bkb3duLWNlbGxcIixcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGNlbGwuZGF0YTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLnRleHREYXJrO1xuICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHJlY3QueCArIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCB0aGVtZSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+ICh7XG4gICAgICAgIGVkaXRvcjogRWRpdG9yLFxuICAgICAgICBkaXNhYmxlUGFkZGluZzogdHJ1ZSxcbiAgICAgICAgZGVsZXRlZFZhbHVlOiB2ID0+ICh7XG4gICAgICAgICAgICAuLi52LFxuICAgICAgICAgICAgY29weURhdGE6IFwiXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4udi5kYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgfSksXG4gICAgb25QYXN0ZTogKHYsIGQpID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHZhbHVlOiBkLmFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModikgPyB2IDogZC52YWx1ZSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/cells/src/cells/packages/cells/src/cells/dropdown-cell.tsx\",\"webpack://./packages/cells/src/cells/dropdown-cell.tsx\"],\"names\":[\".wg6ppx4\",\".p7jnwoo\"],\"mappings\":\"AA6BMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,uBAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA;AAWAC,SAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,eAAAA,iBAAAA,CAAAA,wCAAAA,CAAAA;ACtCN,2wPAA2wP\",\"sourcesContent\":[\"import {\\n    CustomCell,\\n    ProvideEditorCallback,\\n    CustomRenderer,\\n    getMiddleCenterBias,\\n    useTheme,\\n    GridCellKind,\\n} from \\\"@glideapps/glide-data-grid\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport Select, { MenuProps, components } from \\\"react-select\\\";\\n\\ninterface CustomMenuProps extends MenuProps<any> {}\\n\\nconst CustomMenu: React.FC<CustomMenuProps> = p => {\\n    const { Menu } = components;\\n    const { children, ...rest } = p;\\n    return <Menu {...rest}>{children}</Menu>;\\n};\\n\\ninterface DropdownCellProps {\\n    readonly kind: \\\"dropdown-cell\\\";\\n    readonly value: string;\\n    readonly allowedValues: readonly string[];\\n    readonly readonly?: boolean;\\n}\\n\\nexport type DropdownCell = CustomCell<DropdownCellProps>;\\n\\nconst Wrap = styled.div`\\n    display: flex;\\n    flex-direction: column;\\n    align-items: stretch;\\n\\n    .glide-select {\\n        font-family: var(--gdg-font-family);\\n        font-size: var(--gdg-editor-font-size);\\n    }\\n`;\\n\\nconst PortalWrap = styled.div`\\n    font-family: var(--gdg-font-family);\\n    font-size: var(--gdg-editor-font-size);\\n    color: var(--gdg-text-dark);\\n\\n    > div {\\n        border-radius: 4px;\\n        border: 1px solid var(--gdg-border-color);\\n    }\\n`;\\n\\nconst Editor: ReturnType<ProvideEditorCallback<DropdownCell>> = p => {\\n    const { value: cell, onFinishedEditing, initialValue } = p;\\n    const { allowedValues, value: valueIn } = cell.data;\\n\\n    const [value, setValue] = React.useState(valueIn);\\n    const [inputValue, setInputValue] = React.useState(initialValue ?? \\\"\\\");\\n\\n    const theme = useTheme();\\n\\n    const values = React.useMemo(\\n        () =>\\n            allowedValues.map(x => ({\\n                value: x,\\n                label: x,\\n            })),\\n        [allowedValues]\\n    );\\n\\n    return (\\n        <Wrap>\\n            <Select\\n                className=\\\"glide-select\\\"\\n                inputValue={inputValue}\\n                onInputChange={setInputValue}\\n                menuPlacement={\\\"auto\\\"}\\n                value={values.find(x => x.value === value)}\\n                styles={{\\n                    control: base => ({\\n                        ...base,\\n                        border: 0,\\n                        boxShadow: \\\"none\\\",\\n                    }),\\n                }}\\n                theme={t => {\\n                    return {\\n                        ...t,\\n                        colors: {\\n                            ...t.colors,\\n                            neutral0: theme.bgCell, // this is both the background color AND the fg color of\\n                            // the selected item because of course it is.\\n                            neutral5: theme.bgCell,\\n                            neutral10: theme.bgCell,\\n                            neutral20: theme.bgCellMedium,\\n                            neutral30: theme.bgCellMedium,\\n                            neutral40: theme.bgCellMedium,\\n                            neutral50: theme.textLight,\\n                            neutral60: theme.textMedium,\\n                            neutral70: theme.textMedium,\\n                            neutral80: theme.textDark,\\n                            neutral90: theme.textDark,\\n                            neutral100: theme.textDark,\\n                            primary: theme.accentColor,\\n                            primary75: theme.accentColor,\\n                            primary50: theme.accentColor,\\n                            primary25: theme.accentLight, // prelight color\\n                        },\\n                    };\\n                }}\\n                menuPortalTarget={document.getElementById(\\\"portal\\\")}\\n                autoFocus={true}\\n                openMenuOnFocus={true}\\n                components={{\\n                    DropdownIndicator: () => null,\\n                    IndicatorSeparator: () => null,\\n                    Menu: props => (\\n                        <PortalWrap>\\n                            <CustomMenu className={\\\"click-outside-ignore\\\"} {...props} />\\n                        </PortalWrap>\\n                    ),\\n                }}\\n                options={values}\\n                onChange={async e => {\\n                    if (e === null) return;\\n                    setValue(e.value);\\n                    await new Promise(r => window.requestAnimationFrame(r));\\n                    onFinishedEditing({\\n                        ...cell,\\n                        data: {\\n                            ...cell.data,\\n                            value: e.value,\\n                        },\\n                    });\\n                }}\\n            />\\n        </Wrap>\\n    );\\n};\\n\\nconst renderer: CustomRenderer<DropdownCell> = {\\n    kind: GridCellKind.Custom,\\n    isMatch: (c): c is DropdownCell => (c.data as any).kind === \\\"dropdown-cell\\\",\\n    draw: (args, cell) => {\\n        const { ctx, theme, rect } = args;\\n        const { value } = cell.data;\\n        ctx.fillStyle = theme.textDark;\\n        ctx.fillText(\\n            value,\\n            rect.x + theme.cellHorizontalPadding,\\n            rect.y + rect.height / 2 + getMiddleCenterBias(ctx, theme)\\n        );\\n\\n        return true;\\n    },\\n    provideEditor: () => ({\\n        editor: Editor,\\n        disablePadding: true,\\n        deletedValue: v => ({\\n            ...v,\\n            copyData: \\\"\\\",\\n            data: {\\n                ...v.data,\\n                value: \\\"\\\",\\n            },\\n        }),\\n    }),\\n    onPaste: (v, d) => ({\\n        ...d,\\n        value: d.allowedValues.includes(v) ? v : d.value,\\n    }),\\n};\\n\\nexport default renderer;\\n\",\".wg6ppx4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}.wg6ppx4 .glide-select{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);}\\n.p7jnwoo{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);color:var(--gdg-text-dark);}.p7jnwoo > div{border-radius:4px;border:1px solid var(--gdg-border-color);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCJdLCJuYW1lcyI6WyIud2c2cHB4NCIsIi5wN2pud29vIl0sIm1hcHBpbmdzIjoiQUE2Qk1BO0FBV0FDIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBQcm92aWRlRWRpdG9yQ2FsbGJhY2ssXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICB1c2VUaGVtZSxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTZWxlY3QsIHsgTWVudVByb3BzLCBjb21wb25lbnRzIH0gZnJvbSBcInJlYWN0LXNlbGVjdFwiO1xuXG5pbnRlcmZhY2UgQ3VzdG9tTWVudVByb3BzIGV4dGVuZHMgTWVudVByb3BzPGFueT4ge31cblxuY29uc3QgQ3VzdG9tTWVudTogUmVhY3QuRkM8Q3VzdG9tTWVudVByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgTWVudSB9ID0gY29tcG9uZW50cztcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiA8TWVudSB7Li4ucmVzdH0+e2NoaWxkcmVufTwvTWVudT47XG59O1xuXG5pbnRlcmZhY2UgRHJvcGRvd25DZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiO1xuICAgIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgYWxsb3dlZFZhbHVlczogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgcmVhZG9ubHkgcmVhZG9ubHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBEcm9wZG93bkNlbGwgPSBDdXN0b21DZWxsPERyb3Bkb3duQ2VsbFByb3BzPjtcblxuY29uc3QgV3JhcCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuXG4gICAgLmdsaWRlLXNlbGVjdCB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgICAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICB9XG5gO1xuXG5jb25zdCBQb3J0YWxXcmFwID0gc3R5bGVkLmRpdmBcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICA+IGRpdiB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuYDtcblxuY29uc3QgRWRpdG9yOiBSZXR1cm5UeXBlPFByb3ZpZGVFZGl0b3JDYWxsYmFjazxEcm9wZG93bkNlbGw+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNlbGwsIG9uRmluaXNoZWRFZGl0aW5nLCBpbml0aWFsVmFsdWUgfSA9IHA7XG4gICAgY29uc3QgeyBhbGxvd2VkVmFsdWVzLCB2YWx1ZTogdmFsdWVJbiB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSh2YWx1ZUluKTtcbiAgICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsVmFsdWUgPz8gXCJcIik7XG5cbiAgICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBSZWFjdC51c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYWxsb3dlZFZhbHVlcy5tYXAoeCA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB4LFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBbYWxsb3dlZFZhbHVlc11cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFdyYXA+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2xpZGUtc2VsZWN0XCJcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlPXtpbnB1dFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uSW5wdXRDaGFuZ2U9e3NldElucHV0VmFsdWV9XG4gICAgICAgICAgICAgICAgbWVudVBsYWNlbWVudD17XCJhdXRvXCJ9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlcy5maW5kKHggPT4geC52YWx1ZSA9PT0gdmFsdWUpfVxuICAgICAgICAgICAgICAgIHN0eWxlcz17e1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBiYXNlID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICB0aGVtZT17dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udC5jb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDA6IHRoZW1lLmJnQ2VsbCwgLy8gdGhpcyBpcyBib3RoIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIEFORCB0aGUgZmcgY29sb3Igb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgaXRlbSBiZWNhdXNlIG9mIGNvdXJzZSBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNTogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwyMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwzMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw0MDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw1MDogdGhlbWUudGV4dExpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw2MDogdGhlbWUudGV4dE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNzA6IHRoZW1lLnRleHRNZWRpdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDgwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsOTA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk6IHRoZW1lLmFjY2VudENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk3NTogdGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTUwOiB0aGVtZS5hY2NlbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5MjU6IHRoZW1lLmFjY2VudExpZ2h0LCAvLyBwcmVsaWdodCBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG1lbnVQb3J0YWxUYXJnZXQ9e2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicG9ydGFsXCIpfVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvcGVuTWVudU9uRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cz17e1xuICAgICAgICAgICAgICAgICAgICBEcm9wZG93bkluZGljYXRvcjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgSW5kaWNhdG9yU2VwYXJhdG9yOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBNZW51OiBwcm9wcyA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8UG9ydGFsV3JhcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q3VzdG9tTWVudSBjbGFzc05hbWU9e1wiY2xpY2stb3V0c2lkZS1pZ25vcmVcIn0gey4uLnByb3BzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Qb3J0YWxXcmFwPlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17dmFsdWVzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXthc3luYyBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyKSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRmluaXNoZWRFZGl0aW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvV3JhcD5cbiAgICApO1xufTtcblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPERyb3Bkb3duQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgRHJvcGRvd25DZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcImRyb3Bkb3duLWNlbGxcIixcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGNlbGwuZGF0YTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLnRleHREYXJrO1xuICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHJlY3QueCArIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCB0aGVtZSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+ICh7XG4gICAgICAgIGVkaXRvcjogRWRpdG9yLFxuICAgICAgICBkaXNhYmxlUGFkZGluZzogdHJ1ZSxcbiAgICAgICAgZGVsZXRlZFZhbHVlOiB2ID0+ICh7XG4gICAgICAgICAgICAuLi52LFxuICAgICAgICAgICAgY29weURhdGE6IFwiXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4udi5kYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgfSksXG4gICAgb25QYXN0ZTogKHYsIGQpID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHZhbHVlOiBkLmFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModikgPyB2IDogZC52YWx1ZSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".lld219p{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;margin:4px 0;}.lld219p > button{color:var(--gdg-accent-color);font-weight:600;-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border:none;outline:none;background-color:transparent;-webkit-transition:background-color 200ms;transition:background-color 200ms;border-radius:4px;padding:6px 8px;cursor:pointer;}.lld219p > button:hover,.lld219p > button:focus-visible{background-color:var(--gdg-accent-light);}.lld219p > button:disabled{opacity:0.4;pointer-events:none;}.lld219p .gdg-link-title-editor{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-width:250px;}.lld219p .gdg-link-title-editor > input{outline:none;border:1px solid var(--gdg-border-color);border-radius:4px;box-shadow:none;padding:6px 8px;min-width:0;width:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-transition:border 200ms;transition:border 200ms;}.lld219p .gdg-link-title-editor > input:not(:last-child){margin-right:4px;}.lld219p .gdg-link-title-editor > input:focus{border:1px solid var(--gdg-accent-color);}.lld219p .gdg-link-title-editor:not(:last-child){margin-bottom:4px;}.lld219p .gdg-link-title-editor > button{border:none;outline:none;border-radius:4px;background-color:transparent;cursor:pointer;-webkit-transition:background-color 200ms,color 200ms;transition:background-color 200ms,color 200ms;color:var(--gdg-text-medium);}.lld219p .gdg-link-title-editor > button:hover,.lld219p .gdg-link-title-editor > button:focus-visible{background-color:var(--gdg-accent-light);color:var(--gdg-text-dark);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9saW5rcy1jZWxsLnRzeCJdLCJuYW1lcyI6WyIubGxkMjE5cCJdLCJtYXBwaW5ncyI6IkFBdU1NQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvbGlua3MtY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEN1c3RvbUNlbGwsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG4gICAgYmxlbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIExpbmtzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcImxpbmtzLWNlbGxcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGhhbmQgdHVuZSB0aGUgcG9zaXRpb24gb2YgdGhlIHVuZGVybGluZSBhcyB0aGlzIGlzIG5vdCBhIG5hdGl2ZSBjYW52YXMgY2FwYWJpbGl0eSwgaXQgY2FuIG5lZWQgdHdlYWtpbmdcbiAgICAgKiBmb3IgZGlmZmVyZW50IGZvbnRzLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHVuZGVybGluZU9mZnNldD86IG51bWJlcjtcbiAgICByZWFkb25seSBtYXhMaW5rcz86IG51bWJlcjtcbiAgICByZWFkb25seSBuYXZpZ2F0ZU9uPzogXCJjbGlja1wiIHwgXCJjb250cm9sLWNsaWNrXCI7XG4gICAgcmVhZG9ubHkgbGlua3M6IHJlYWRvbmx5IHtcbiAgICAgICAgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgaHJlZj86IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgb25DbGljaz86ICgpID0+IHZvaWQ7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBMaW5rc0NlbGwgPSBDdXN0b21DZWxsPExpbmtzQ2VsbFByb3BzPjtcblxuZnVuY3Rpb24gb25DbGlja1NlbGVjdChlOiBQYXJhbWV0ZXJzPE5vbk51bGxhYmxlPEN1c3RvbVJlbmRlcmVyPExpbmtzQ2VsbD5bXCJvblNlbGVjdFwiXT4+WzBdKSB7XG4gICAgY29uc3QgdXNlQ3RybCA9IGUuY2VsbC5kYXRhLm5hdmlnYXRlT24gIT09IFwiY2xpY2tcIjtcbiAgICBpZiAodXNlQ3RybCAhPT0gZS5jdHJsS2V5KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICBpZiAoY3R4ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHBvc1g6IGhvdmVyWCwgYm91bmRzOiByZWN0LCBjZWxsLCB0aGVtZSB9ID0gZTtcbiAgICBjb25zdCBmb250ID0gYCR7dGhlbWUuYmFzZUZvbnRTdHlsZX0gJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuXG4gICAgY29uc3QgeyBsaW5rcyB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgeFBhZCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcblxuICAgIGxldCBkcmF3WCA9IHJlY3QueCArIHhQYWQ7XG5cbiAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBuZWVkc0NvbW1hID0gaW5kZXggPCBsaW5rcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSwgY3R4KTtcbiAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gcmVjdEhvdmVyWCA+IGRyYXdYICYmIHJlY3RIb3ZlclggPCBkcmF3WCArIG1ldHJpY3Mud2lkdGg7XG5cbiAgICAgICAgaWYgKGlzSG92ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cblxuICAgICAgICBkcmF3WCArPSBjb21tYU1ldHJpY3Mud2lkdGggKyA0O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxMaW5rc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBuZWVkc0hvdmVyUG9zaXRpb246IHRydWUsXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIExpbmtzQ2VsbCA9PiAoYy5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJsaW5rcy1jZWxsXCIsXG4gICAgb25TZWxlY3Q6IGUgPT4ge1xuICAgICAgICBpZiAob25DbGlja1NlbGVjdChlKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2xpY2s6IGUgPT4ge1xuICAgICAgICBjb25zdCBob3ZlcmVkID0gb25DbGlja1NlbGVjdChlKTtcbiAgICAgICAgaWYgKGhvdmVyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaG92ZXJlZC5vbkNsaWNrPy4oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QsIHRoZW1lLCBob3ZlclggPSAtMTAwLCBoaWdobGlnaHRlZCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBsaW5rcywgdW5kZXJsaW5lT2Zmc2V0ID0gNSB9ID0gY2VsbC5kYXRhO1xuXG4gICAgICAgIGNvbnN0IHhQYWQgPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgICAgbGV0IGRyYXdYID0gcmVjdC54ICsgeFBhZDtcblxuICAgICAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgICAgIGNvbnN0IGZvbnQgPSBgJHt0aGVtZS5iYXNlRm9udFN0eWxlfSAke3RoZW1lLmZvbnRGYW1pbHl9YDtcblxuICAgICAgICBjb25zdCBtaWRkbGVDZW50ZXJCaWFzID0gZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIGZvbnQpO1xuICAgICAgICBjb25zdCBkcmF3WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIG1pZGRsZUNlbnRlckJpYXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgbmVlZHNDb21tYSA9IGluZGV4IDwgbGlua3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZChsLnRpdGxlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IHJlY3RIb3ZlclggPiBkcmF3WCAmJiByZWN0SG92ZXJYIDwgZHJhd1ggKyBtZXRyaWNzLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAoaXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhkcmF3WCwgTWF0aC5mbG9vcihkcmF3WSArIHVuZGVybGluZU9mZnNldCkgKyAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZHJhd1ggKyBtZXRyaWNzLndpZHRoLCBNYXRoLmZsb29yKGRyYXdZICsgdW5kZXJsaW5lT2Zmc2V0KSArIDAuNSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGlnaGxpZ2h0ZWQgPyBibGVuZCh0aGVtZS5hY2NlbnRMaWdodCwgdGhlbWUuYmdDZWxsKSA6IHRoZW1lLmJnQ2VsbDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMSwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAxLCBkcmF3WSk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMiwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAyLCBkcmF3WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYLCBkcmF3WSk7XG5cbiAgICAgICAgICAgIGRyYXdYICs9IGNvbW1hTWV0cmljcy53aWR0aCArIDQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiBwID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgb25DaGFuZ2UgfSA9IHA7XG4gICAgICAgIGNvbnN0IHsgbGlua3MsIG1heExpbmtzID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TGlua3NDZWxsRWRpdG9yU3R5bGUgb25LZXlEb3duPXtpZ25vcmVUYWJ9PlxuICAgICAgICAgICAgICAgIHtsaW5rcy5tYXAoKGwsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPExpbmtUaXRsZUVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluaz17bC5ocmVmID8/IFwiXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17bC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzPXtpID09PSAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGU9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsobGluaywgdGl0bGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5rcyA9IFsuLi5saW5rc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3NbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17bGlua3MubGVuZ3RoID49IG1heExpbmtzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhZGQtbGlua1wiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzLCB7IHRpdGxlOiBcIlwiIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgIEFkZCBsaW5rXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L0xpbmtzQ2VsbEVkaXRvclN0eWxlPlxuICAgICAgICApO1xuICAgIH0sXG4gICAgb25QYXN0ZTogKHYsIGQpID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgaWYgKGQubGlua3Muc29tZSgobCwgaSkgPT4gc3BsaXRbaV0gIT09IGwudGl0bGUpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIGxpbmtzOiBzcGxpdC5tYXAobCA9PiAoeyB0aXRsZTogbCB9KSksXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmNvbnN0IExpbmtzQ2VsbEVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICBtYXJnaW46IDRweCAwO1xuXG4gICAgPiBidXR0b24ge1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcblxuICAgICAgICBwYWRkaW5nOiA2cHggOHB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgOmhvdmVyLFxuICAgICAgICA6Zm9jdXMtdmlzaWJsZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIDpkaXNhYmxlZCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5nZGctbGluay10aXRsZS1lZGl0b3Ige1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgICAgIG1pbi13aWR0aDogMjUwcHg7XG5cbiAgICAgICAgPiBpbnB1dCB7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgICAgICAgIHdpZHRoOiAwO1xuICAgICAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgICAgICAmOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMjAwbXM7XG5cbiAgICAgICAgICAgICY6Zm9jdXMge1xuICAgICAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDRweDtcbiAgICAgICAgfVxuXG4gICAgICAgID4gYnV0dG9uIHtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG5cbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXMsIGNvbG9yIDIwMG1zO1xuXG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICAgICAgOmhvdmVyLFxuICAgICAgICAgICAgOmZvY3VzLXZpc2libGUge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBMaW5rVGl0bGVFZGl0b3JQcm9wcyB7XG4gICAgcmVhZG9ubHkgbGluazogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHRpdGxlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgb25DaGFuZ2U6IChsaW5rOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25EZWxldGU/OiAoKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IGZvY3VzOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBpZ25vcmVUYWIoZTogUmVhY3QuS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChlLmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbn1cblxuY29uc3QgTGlua1RpdGxlRWRpdG9yOiBSZWFjdC5WRkM8TGlua1RpdGxlRWRpdG9yUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBsaW5rLCBvbkNoYW5nZSwgdGl0bGUsIG9uRGVsZXRlLCBmb2N1cyB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdkZy1saW5rLXRpdGxlLWVkaXRvclwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLXRpdGxlLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGl0bGV9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJUaXRsZVwiXG4gICAgICAgICAgICAgICAgYXV0b0ZvY3VzPXtmb2N1c31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGxpbmssIGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdkZy1saW5rLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17bGlua31cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlVSTFwiXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShlLnRhcmdldC52YWx1ZSwgdGl0bGUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge29uRGVsZXRlICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17b25EZWxldGV9PlxuICAgICAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17MTZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9ezE2fVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cImljb24taW1wb3J0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0zIDZMNSA2TDIxIDZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTE3LjkwMTkgNkMxOC40OTEgNiAxOC45NTI1IDYuNTA2NzYgMTguODk3NSA3LjA5MzM0TDE3LjY3IDIwLjE4NjdDMTcuNTczNiAyMS4yMTQ0IDE2LjcxMSAyMiAxNS42Nzg3IDIySDguMzIxMjdDNy4yODkwMiAyMiA2LjQyNjM1IDIxLjIxNDQgNi4zMyAyMC4xODY3TDUuMTAyNSA3LjA5MzM0QzUuMDQ3NTEgNi41MDY3NiA1LjUwODk4IDYgNi4wOTgxMyA2SDE3LjkwMTlaXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0xNC40NDk5IDEwLjIxMUwxMy45OTQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk05LjU1NDk5IDEwLjIxMUwxMC4wMDQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk03LjUgMi4yNUgxNi41XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyZXI7XG4iXX0=*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/cells/src/cells/packages/cells/src/cells/links-cell.tsx\",\"webpack://./packages/cells/src/cells/links-cell.tsx\"],\"names\":[\".lld219p\"],\"mappings\":\"AAuMMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,CAAAA,kBAAAA,6BAAAA,CAAAA,eAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,4BAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,wDAAAA,wCAAAA,CAAAA,CAAAA,2BAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,gCAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,eAAAA,CAAAA,CAAAA,wCAAAA,YAAAA,CAAAA,wCAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,OAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,+BAAAA,CAAAA,uBAAAA,CAAAA,CAAAA,yDAAAA,gBAAAA,CAAAA,CAAAA,8CAAAA,wCAAAA,CAAAA,CAAAA,iDAAAA,iBAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,YAAAA,CAAAA,iBAAAA,CAAAA,4BAAAA,CAAAA,cAAAA,CAAAA,qDAAAA,CAAAA,6CAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,sGAAAA,wCAAAA,CAAAA,0BAAAA,CAAAA;ACtMN,mghBAAmghB\",\"sourcesContent\":[\"import {\\n    CustomCell,\\n    measureTextCached,\\n    CustomRenderer,\\n    getMiddleCenterBias,\\n    GridCellKind,\\n    blend,\\n} from \\\"@glideapps/glide-data-grid\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\n\\ninterface LinksCellProps {\\n    readonly kind: \\\"links-cell\\\";\\n    /**\\n     * Used to hand tune the position of the underline as this is not a native canvas capability, it can need tweaking\\n     * for different fonts.\\n     */\\n    readonly underlineOffset?: number;\\n    readonly maxLinks?: number;\\n    readonly navigateOn?: \\\"click\\\" | \\\"control-click\\\";\\n    readonly links: readonly {\\n        readonly title: string;\\n        readonly href?: string;\\n        readonly onClick?: () => void;\\n    }[];\\n}\\n\\nexport type LinksCell = CustomCell<LinksCellProps>;\\n\\nfunction onClickSelect(e: Parameters<NonNullable<CustomRenderer<LinksCell>[\\\"onSelect\\\"]>>[0]) {\\n    const useCtrl = e.cell.data.navigateOn !== \\\"click\\\";\\n    if (useCtrl !== e.ctrlKey) return undefined;\\n    const canvas = document.createElement(\\\"canvas\\\");\\n    const ctx = canvas.getContext(\\\"2d\\\", { alpha: false });\\n    if (ctx === null) return;\\n\\n    const { posX: hoverX, bounds: rect, cell, theme } = e;\\n    const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\\n    ctx.font = font;\\n\\n    const { links } = cell.data;\\n\\n    const xPad = theme.cellHorizontalPadding;\\n\\n    let drawX = rect.x + xPad;\\n\\n    const rectHoverX = rect.x + hoverX;\\n\\n    for (const [index, l] of links.entries()) {\\n        const needsComma = index < links.length - 1;\\n        const metrics = measureTextCached(l.title, ctx);\\n        const commaMetrics = needsComma ? measureTextCached(l.title + \\\",\\\", ctx, font) : metrics;\\n\\n        const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\\n\\n        if (isHovered) {\\n            return l;\\n        }\\n\\n        drawX += commaMetrics.width + 4;\\n    }\\n\\n    return undefined;\\n}\\n\\nconst renderer: CustomRenderer<LinksCell> = {\\n    kind: GridCellKind.Custom,\\n    needsHover: true,\\n    needsHoverPosition: true,\\n    isMatch: (c): c is LinksCell => (c.data as any).kind === \\\"links-cell\\\",\\n    onSelect: e => {\\n        if (onClickSelect(e) !== undefined) {\\n            e.preventDefault();\\n        }\\n    },\\n    onClick: e => {\\n        const hovered = onClickSelect(e);\\n        if (hovered !== undefined) {\\n            hovered.onClick?.();\\n            e.preventDefault();\\n        }\\n        return undefined;\\n    },\\n    draw: (args, cell) => {\\n        const { ctx, rect, theme, hoverX = -100, highlighted } = args;\\n        const { links, underlineOffset = 5 } = cell.data;\\n\\n        const xPad = theme.cellHorizontalPadding;\\n\\n        let drawX = rect.x + xPad;\\n\\n        const rectHoverX = rect.x + hoverX;\\n\\n        const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\\n\\n        const middleCenterBias = getMiddleCenterBias(ctx, font);\\n        const drawY = rect.y + rect.height / 2 + middleCenterBias;\\n\\n        for (const [index, l] of links.entries()) {\\n            const needsComma = index < links.length - 1;\\n            const metrics = measureTextCached(l.title, ctx);\\n            const commaMetrics = needsComma ? measureTextCached(l.title + \\\",\\\", ctx, font) : metrics;\\n\\n            const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\\n\\n            if (isHovered) {\\n                ctx.moveTo(drawX, Math.floor(drawY + underlineOffset) + 0.5);\\n                ctx.lineTo(drawX + metrics.width, Math.floor(drawY + underlineOffset) + 0.5);\\n\\n                // ctx.lineWidth = 1;\\n                ctx.strokeStyle = theme.textDark;\\n                ctx.stroke();\\n\\n                ctx.fillStyle = highlighted ? blend(theme.accentLight, theme.bgCell) : theme.bgCell;\\n                ctx.fillText(needsComma ? l.title + \\\",\\\" : l.title, drawX - 1, drawY);\\n                ctx.fillText(needsComma ? l.title + \\\",\\\" : l.title, drawX + 1, drawY);\\n\\n                ctx.fillText(needsComma ? l.title + \\\",\\\" : l.title, drawX - 2, drawY);\\n                ctx.fillText(needsComma ? l.title + \\\",\\\" : l.title, drawX + 2, drawY);\\n            }\\n            ctx.fillStyle = theme.textDark;\\n            ctx.fillText(needsComma ? l.title + \\\",\\\" : l.title, drawX, drawY);\\n\\n            drawX += commaMetrics.width + 4;\\n        }\\n\\n        return true;\\n    },\\n    // eslint-disable-next-line react/display-name\\n    provideEditor: () => p => {\\n        const { value, onChange } = p;\\n        const { links, maxLinks = Number.MAX_SAFE_INTEGER } = value.data;\\n        return (\\n            <LinksCellEditorStyle onKeyDown={ignoreTab}>\\n                {links.map((l, i) => (\\n                    <LinkTitleEditor\\n                        key={i}\\n                        link={l.href ?? \\\"\\\"}\\n                        title={l.title}\\n                        focus={i === 0}\\n                        onDelete={\\n                            links.length > 1\\n                                ? () => {\\n                                      const newLinks = [...links];\\n                                      newLinks.splice(i, 1);\\n                                      onChange({\\n                                          ...value,\\n                                          data: {\\n                                              ...value.data,\\n                                              links: newLinks,\\n                                          },\\n                                      });\\n                                  }\\n                                : undefined\\n                        }\\n                        onChange={(link, title) => {\\n                            const newLinks = [...links];\\n                            newLinks[i] = {\\n                                href: link,\\n                                title,\\n                            };\\n                            onChange({\\n                                ...value,\\n                                data: {\\n                                    ...value.data,\\n                                    links: newLinks,\\n                                },\\n                            });\\n                        }}\\n                    />\\n                ))}\\n                <button\\n                    disabled={links.length >= maxLinks}\\n                    className=\\\"add-link\\\"\\n                    onClick={() => {\\n                        const newLinks = [...links, { title: \\\"\\\" }];\\n                        onChange({\\n                            ...value,\\n                            data: {\\n                                ...value.data,\\n                                links: newLinks,\\n                            },\\n                        });\\n                    }}>\\n                    Add link\\n                </button>\\n            </LinksCellEditorStyle>\\n        );\\n    },\\n    onPaste: (v, d) => {\\n        const split = v.split(\\\",\\\");\\n        if (d.links.some((l, i) => split[i] !== l.title)) return undefined;\\n        return {\\n            ...d,\\n            links: split.map(l => ({ title: l })),\\n        };\\n    },\\n};\\n\\nconst LinksCellEditorStyle = styled.div`\\n    display: flex;\\n    flex-direction: column;\\n\\n    margin: 4px 0;\\n\\n    > button {\\n        color: var(--gdg-accent-color);\\n        font-weight: 600;\\n        align-self: flex-end;\\n        border: none;\\n        outline: none;\\n        background-color: transparent;\\n\\n        transition: background-color 200ms;\\n        border-radius: 4px;\\n\\n        padding: 6px 8px;\\n        cursor: pointer;\\n\\n        :hover,\\n        :focus-visible {\\n            background-color: var(--gdg-accent-light);\\n        }\\n\\n        :disabled {\\n            opacity: 0.4;\\n            pointer-events: none;\\n        }\\n    }\\n\\n    .gdg-link-title-editor {\\n        display: flex;\\n\\n        min-width: 250px;\\n\\n        > input {\\n            outline: none;\\n            border: 1px solid var(--gdg-border-color);\\n            border-radius: 4px;\\n            box-shadow: none;\\n            padding: 6px 8px;\\n            min-width: 0;\\n            width: 0;\\n            flex-grow: 1;\\n\\n            &:not(:last-child) {\\n                margin-right: 4px;\\n            }\\n\\n            transition: border 200ms;\\n\\n            &:focus {\\n                border: 1px solid var(--gdg-accent-color);\\n            }\\n        }\\n\\n        &:not(:last-child) {\\n            margin-bottom: 4px;\\n        }\\n\\n        > button {\\n            border: none;\\n            outline: none;\\n            border-radius: 4px;\\n\\n            background-color: transparent;\\n\\n            cursor: pointer;\\n\\n            transition: background-color 200ms, color 200ms;\\n\\n            color: var(--gdg-text-medium);\\n\\n            :hover,\\n            :focus-visible {\\n                background-color: var(--gdg-accent-light);\\n                color: var(--gdg-text-dark);\\n            }\\n        }\\n    }\\n`;\\n\\ninterface LinkTitleEditorProps {\\n    readonly link: string;\\n    readonly title: string;\\n    readonly onChange: (link: string, title: string) => void;\\n    readonly onDelete?: () => void;\\n    readonly focus: boolean;\\n}\\n\\nfunction ignoreTab(e: React.KeyboardEvent) {\\n    if (e.key === \\\"Tab\\\") {\\n        e.stopPropagation();\\n    }\\n}\\n\\nconst LinkTitleEditor: React.VFC<LinkTitleEditorProps> = p => {\\n    const { link, onChange, title, onDelete, focus } = p;\\n    return (\\n        <div className=\\\"gdg-link-title-editor\\\">\\n            <input\\n                className=\\\"gdg-title-input\\\"\\n                value={title}\\n                placeholder=\\\"Title\\\"\\n                autoFocus={focus}\\n                onChange={e => {\\n                    onChange(link, e.target.value);\\n                }}\\n            />\\n            <input\\n                className=\\\"gdg-link-input\\\"\\n                value={link}\\n                placeholder=\\\"URL\\\"\\n                onChange={e => {\\n                    onChange(e.target.value, title);\\n                }}\\n            />\\n            {onDelete !== undefined && (\\n                <button onClick={onDelete}>\\n                    <svg\\n                        width={16}\\n                        height={16}\\n                        viewBox=\\\"0 0 24 24\\\"\\n                        fill=\\\"none\\\"\\n                        id=\\\"icon-import\\\"\\n                        xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n                        <path\\n                            d=\\\"M3 6L5 6L21 6\\\"\\n                            stroke=\\\"currentColor\\\"\\n                            strokeWidth=\\\"1px\\\"\\n                            strokeLinecap=\\\"round\\\"\\n                            strokeLinejoin=\\\"round\\\"\\n                        />\\n                        <path\\n                            d=\\\"M17.9019 6C18.491 6 18.9525 6.50676 18.8975 7.09334L17.67 20.1867C17.5736 21.2144 16.711 22 15.6787 22H8.32127C7.28902 22 6.42635 21.2144 6.33 20.1867L5.1025 7.09334C5.04751 6.50676 5.50898 6 6.09813 6H17.9019Z\\\"\\n                            stroke=\\\"currentColor\\\"\\n                            strokeWidth=\\\"1px\\\"\\n                            strokeLinecap=\\\"round\\\"\\n                            strokeLinejoin=\\\"round\\\"\\n                        />\\n                        <path\\n                            d=\\\"M14.4499 10.211L13.9949 17\\\"\\n                            stroke=\\\"currentColor\\\"\\n                            strokeWidth=\\\"1px\\\"\\n                            strokeLinecap=\\\"round\\\"\\n                            strokeLinejoin=\\\"round\\\"\\n                        />\\n                        <path\\n                            d=\\\"M9.55499 10.211L10.0049 17\\\"\\n                            stroke=\\\"currentColor\\\"\\n                            strokeWidth=\\\"1px\\\"\\n                            strokeLinecap=\\\"round\\\"\\n                            strokeLinejoin=\\\"round\\\"\\n                        />\\n                        <path\\n                            d=\\\"M7.5 2.25H16.5\\\"\\n                            stroke=\\\"currentColor\\\"\\n                            strokeWidth=\\\"1px\\\"\\n                            strokeLinecap=\\\"round\\\"\\n                            strokeLinejoin=\\\"round\\\"\\n                        />\\n                    </svg>\\n                </button>\\n            )}\\n        </div>\\n    );\\n};\\n\\nexport default renderer;\\n\",\".lld219p{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;margin:4px 0;}.lld219p > button{color:var(--gdg-accent-color);font-weight:600;-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border:none;outline:none;background-color:transparent;-webkit-transition:background-color 200ms;transition:background-color 200ms;border-radius:4px;padding:6px 8px;cursor:pointer;}.lld219p > button:hover,.lld219p > button:focus-visible{background-color:var(--gdg-accent-light);}.lld219p > button:disabled{opacity:0.4;pointer-events:none;}.lld219p .gdg-link-title-editor{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-width:250px;}.lld219p .gdg-link-title-editor > input{outline:none;border:1px solid var(--gdg-border-color);border-radius:4px;box-shadow:none;padding:6px 8px;min-width:0;width:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-transition:border 200ms;transition:border 200ms;}.lld219p .gdg-link-title-editor > input:not(:last-child){margin-right:4px;}.lld219p .gdg-link-title-editor > input:focus{border:1px solid var(--gdg-accent-color);}.lld219p .gdg-link-title-editor:not(:last-child){margin-bottom:4px;}.lld219p .gdg-link-title-editor > button{border:none;outline:none;border-radius:4px;background-color:transparent;cursor:pointer;-webkit-transition:background-color 200ms,color 200ms;transition:background-color 200ms,color 200ms;color:var(--gdg-text-medium);}.lld219p .gdg-link-title-editor > button:hover,.lld219p .gdg-link-title-editor > button:focus-visible{background-color:var(--gdg-accent-light);color:var(--gdg-text-dark);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9saW5rcy1jZWxsLnRzeCJdLCJuYW1lcyI6WyIubGxkMjE5cCJdLCJtYXBwaW5ncyI6IkFBdU1NQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvbGlua3MtY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEN1c3RvbUNlbGwsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG4gICAgYmxlbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIExpbmtzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcImxpbmtzLWNlbGxcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGhhbmQgdHVuZSB0aGUgcG9zaXRpb24gb2YgdGhlIHVuZGVybGluZSBhcyB0aGlzIGlzIG5vdCBhIG5hdGl2ZSBjYW52YXMgY2FwYWJpbGl0eSwgaXQgY2FuIG5lZWQgdHdlYWtpbmdcbiAgICAgKiBmb3IgZGlmZmVyZW50IGZvbnRzLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHVuZGVybGluZU9mZnNldD86IG51bWJlcjtcbiAgICByZWFkb25seSBtYXhMaW5rcz86IG51bWJlcjtcbiAgICByZWFkb25seSBuYXZpZ2F0ZU9uPzogXCJjbGlja1wiIHwgXCJjb250cm9sLWNsaWNrXCI7XG4gICAgcmVhZG9ubHkgbGlua3M6IHJlYWRvbmx5IHtcbiAgICAgICAgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgaHJlZj86IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgb25DbGljaz86ICgpID0+IHZvaWQ7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBMaW5rc0NlbGwgPSBDdXN0b21DZWxsPExpbmtzQ2VsbFByb3BzPjtcblxuZnVuY3Rpb24gb25DbGlja1NlbGVjdChlOiBQYXJhbWV0ZXJzPE5vbk51bGxhYmxlPEN1c3RvbVJlbmRlcmVyPExpbmtzQ2VsbD5bXCJvblNlbGVjdFwiXT4+WzBdKSB7XG4gICAgY29uc3QgdXNlQ3RybCA9IGUuY2VsbC5kYXRhLm5hdmlnYXRlT24gIT09IFwiY2xpY2tcIjtcbiAgICBpZiAodXNlQ3RybCAhPT0gZS5jdHJsS2V5KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICBpZiAoY3R4ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHBvc1g6IGhvdmVyWCwgYm91bmRzOiByZWN0LCBjZWxsLCB0aGVtZSB9ID0gZTtcbiAgICBjb25zdCBmb250ID0gYCR7dGhlbWUuYmFzZUZvbnRTdHlsZX0gJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuXG4gICAgY29uc3QgeyBsaW5rcyB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgeFBhZCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcblxuICAgIGxldCBkcmF3WCA9IHJlY3QueCArIHhQYWQ7XG5cbiAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBuZWVkc0NvbW1hID0gaW5kZXggPCBsaW5rcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSwgY3R4KTtcbiAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gcmVjdEhvdmVyWCA+IGRyYXdYICYmIHJlY3RIb3ZlclggPCBkcmF3WCArIG1ldHJpY3Mud2lkdGg7XG5cbiAgICAgICAgaWYgKGlzSG92ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cblxuICAgICAgICBkcmF3WCArPSBjb21tYU1ldHJpY3Mud2lkdGggKyA0O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxMaW5rc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBuZWVkc0hvdmVyUG9zaXRpb246IHRydWUsXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIExpbmtzQ2VsbCA9PiAoYy5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJsaW5rcy1jZWxsXCIsXG4gICAgb25TZWxlY3Q6IGUgPT4ge1xuICAgICAgICBpZiAob25DbGlja1NlbGVjdChlKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2xpY2s6IGUgPT4ge1xuICAgICAgICBjb25zdCBob3ZlcmVkID0gb25DbGlja1NlbGVjdChlKTtcbiAgICAgICAgaWYgKGhvdmVyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaG92ZXJlZC5vbkNsaWNrPy4oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QsIHRoZW1lLCBob3ZlclggPSAtMTAwLCBoaWdobGlnaHRlZCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBsaW5rcywgdW5kZXJsaW5lT2Zmc2V0ID0gNSB9ID0gY2VsbC5kYXRhO1xuXG4gICAgICAgIGNvbnN0IHhQYWQgPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgICAgbGV0IGRyYXdYID0gcmVjdC54ICsgeFBhZDtcblxuICAgICAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgICAgIGNvbnN0IGZvbnQgPSBgJHt0aGVtZS5iYXNlRm9udFN0eWxlfSAke3RoZW1lLmZvbnRGYW1pbHl9YDtcblxuICAgICAgICBjb25zdCBtaWRkbGVDZW50ZXJCaWFzID0gZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIGZvbnQpO1xuICAgICAgICBjb25zdCBkcmF3WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIG1pZGRsZUNlbnRlckJpYXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgbmVlZHNDb21tYSA9IGluZGV4IDwgbGlua3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZChsLnRpdGxlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IHJlY3RIb3ZlclggPiBkcmF3WCAmJiByZWN0SG92ZXJYIDwgZHJhd1ggKyBtZXRyaWNzLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAoaXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhkcmF3WCwgTWF0aC5mbG9vcihkcmF3WSArIHVuZGVybGluZU9mZnNldCkgKyAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZHJhd1ggKyBtZXRyaWNzLndpZHRoLCBNYXRoLmZsb29yKGRyYXdZICsgdW5kZXJsaW5lT2Zmc2V0KSArIDAuNSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGlnaGxpZ2h0ZWQgPyBibGVuZCh0aGVtZS5hY2NlbnRMaWdodCwgdGhlbWUuYmdDZWxsKSA6IHRoZW1lLmJnQ2VsbDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMSwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAxLCBkcmF3WSk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMiwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAyLCBkcmF3WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYLCBkcmF3WSk7XG5cbiAgICAgICAgICAgIGRyYXdYICs9IGNvbW1hTWV0cmljcy53aWR0aCArIDQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiBwID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgb25DaGFuZ2UgfSA9IHA7XG4gICAgICAgIGNvbnN0IHsgbGlua3MsIG1heExpbmtzID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TGlua3NDZWxsRWRpdG9yU3R5bGUgb25LZXlEb3duPXtpZ25vcmVUYWJ9PlxuICAgICAgICAgICAgICAgIHtsaW5rcy5tYXAoKGwsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPExpbmtUaXRsZUVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluaz17bC5ocmVmID8/IFwiXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17bC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzPXtpID09PSAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGU9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsobGluaywgdGl0bGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5rcyA9IFsuLi5saW5rc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3NbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17bGlua3MubGVuZ3RoID49IG1heExpbmtzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhZGQtbGlua1wiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzLCB7IHRpdGxlOiBcIlwiIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgIEFkZCBsaW5rXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L0xpbmtzQ2VsbEVkaXRvclN0eWxlPlxuICAgICAgICApO1xuICAgIH0sXG4gICAgb25QYXN0ZTogKHYsIGQpID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgaWYgKGQubGlua3Muc29tZSgobCwgaSkgPT4gc3BsaXRbaV0gIT09IGwudGl0bGUpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIGxpbmtzOiBzcGxpdC5tYXAobCA9PiAoeyB0aXRsZTogbCB9KSksXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmNvbnN0IExpbmtzQ2VsbEVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICBtYXJnaW46IDRweCAwO1xuXG4gICAgPiBidXR0b24ge1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcblxuICAgICAgICBwYWRkaW5nOiA2cHggOHB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgOmhvdmVyLFxuICAgICAgICA6Zm9jdXMtdmlzaWJsZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIDpkaXNhYmxlZCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5nZGctbGluay10aXRsZS1lZGl0b3Ige1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgICAgIG1pbi13aWR0aDogMjUwcHg7XG5cbiAgICAgICAgPiBpbnB1dCB7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgICAgICAgIHdpZHRoOiAwO1xuICAgICAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgICAgICAmOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMjAwbXM7XG5cbiAgICAgICAgICAgICY6Zm9jdXMge1xuICAgICAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDRweDtcbiAgICAgICAgfVxuXG4gICAgICAgID4gYnV0dG9uIHtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG5cbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXMsIGNvbG9yIDIwMG1zO1xuXG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICAgICAgOmhvdmVyLFxuICAgICAgICAgICAgOmZvY3VzLXZpc2libGUge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBMaW5rVGl0bGVFZGl0b3JQcm9wcyB7XG4gICAgcmVhZG9ubHkgbGluazogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHRpdGxlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgb25DaGFuZ2U6IChsaW5rOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25EZWxldGU/OiAoKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IGZvY3VzOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBpZ25vcmVUYWIoZTogUmVhY3QuS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChlLmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbn1cblxuY29uc3QgTGlua1RpdGxlRWRpdG9yOiBSZWFjdC5WRkM8TGlua1RpdGxlRWRpdG9yUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBsaW5rLCBvbkNoYW5nZSwgdGl0bGUsIG9uRGVsZXRlLCBmb2N1cyB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdkZy1saW5rLXRpdGxlLWVkaXRvclwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLXRpdGxlLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGl0bGV9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJUaXRsZVwiXG4gICAgICAgICAgICAgICAgYXV0b0ZvY3VzPXtmb2N1c31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGxpbmssIGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdkZy1saW5rLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17bGlua31cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlVSTFwiXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShlLnRhcmdldC52YWx1ZSwgdGl0bGUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge29uRGVsZXRlICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17b25EZWxldGV9PlxuICAgICAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17MTZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9ezE2fVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cImljb24taW1wb3J0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0zIDZMNSA2TDIxIDZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTE3LjkwMTkgNkMxOC40OTEgNiAxOC45NTI1IDYuNTA2NzYgMTguODk3NSA3LjA5MzM0TDE3LjY3IDIwLjE4NjdDMTcuNTczNiAyMS4yMTQ0IDE2LjcxMSAyMiAxNS42Nzg3IDIySDguMzIxMjdDNy4yODkwMiAyMiA2LjQyNjM1IDIxLjIxNDQgNi4zMyAyMC4xODY3TDUuMTAyNSA3LjA5MzM0QzUuMDQ3NTEgNi41MDY3NiA1LjUwODk4IDYgNi4wOTgxMyA2SDE3LjkwMTlaXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0xNC40NDk5IDEwLjIxMUwxMy45OTQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk05LjU1NDk5IDEwLjIxMUwxMC4wMDQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk03LjUgMi4yNUgxNi41XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyZXI7XG4iXX0=*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".e8nv6xj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:6px 0;color:var(--gdg-text-light);}.e8nv6xj .active{color:var(--gdg-text-dark);}.e8nv6xj > *{position:relative;width:16px;height:16px;cursor:pointer;margin-right:2px;}.e8nv6xj > * svg{width:100%;height:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lOG52NnhqIl0sIm1hcHBpbmdzIjoiQUFrRE1BIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VzdG9tQ2VsbCwgSXRlbSwgQ3VzdG9tUmVuZGVyZXIsIEdyaWRDZWxsS2luZCB9IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFN0YXJDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwic3Rhci1jZWxsXCI7XG4gICAgcmVhZG9ubHkgcmF0aW5nOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFN0YXJDZWxsID0gQ3VzdG9tQ2VsbDxTdGFyQ2VsbFByb3BzPjtcblxuY29uc3Qgc3RhclBvaW50cyA9IFtcbiAgICBbNTAsIDVdLFxuICAgIFs2MS4yMywgMzkuNTVdLFxuICAgIFs5Ny41NSwgMzkuNTVdLFxuICAgIFs2OC4xNiwgNjAuOV0sXG4gICAgWzc5LjM5LCA5NS40NV0sXG4gICAgWzUwLCA3NC4xXSxcbiAgICBbMjAuNjEsIDk1LjQ1XSxcbiAgICBbMzEuODQsIDYwLjldLFxuICAgIFsyLjQ1LCAzOS41NV0sXG4gICAgWzM4Ljc3LCAzOS41NV0sXG5dO1xuXG5mdW5jdGlvbiBwYXRoU3RhcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2VudGVyOiBJdGVtLCBzaXplOiBudW1iZXIpIHtcbiAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHAgb2Ygc3RhclBvaW50cykge1xuICAgICAgICBjb25zdCB4ID0gKHBbMF0gLSA1MCkgKiAoc2l6ZSAvIDEwMCkgKyBjZW50ZXJbMF07XG4gICAgICAgIGNvbnN0IHkgPSAocFsxXSAtIDUwKSAqIChzaXplIC8gMTAwKSArIGNlbnRlclsxXTtcblxuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5jb25zdCBTdGFyU1ZHID0gKCkgPT4gKFxuICAgIDxzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGQ9XCJNNDcuMTQ2OCAxMy43ODExQzQ4LjA0NDkgMTEuMDE3MiA1MS45NTUxIDExLjAxNzIgNTIuODUzMiAxMy43ODEyTDYwLjU1MjIgMzcuNDc2MkM2MC45NTM4IDM4LjcxMjMgNjIuMTA1NiAzOS41NDkxIDYzLjQwNTMgMzkuNTQ5MUg4OC4zMTk4QzkxLjIyNiAzOS41NDkxIDkyLjQzNDMgNDMuMjY4IDkwLjA4MzEgNDQuOTc2Mkw2OS45MjY5IDU5LjYyMDVDNjguODc1NSA2MC4zODQ1IDY4LjQzNTUgNjEuNzM4NiA2OC44MzcxIDYyLjk3NDZMNzYuNTM2MSA4Ni42Njk3Qzc3LjQzNDIgODkuNDMzNiA3NC4yNzA3IDkxLjczMiA3MS45MTk2IDkwLjAyMzhMNTEuNzYzNCA3NS4zNzk0QzUwLjcxMTkgNzQuNjE1NSA0OS4yODgxIDc0LjYxNTUgNDguMjM2NiA3NS4zNzk1TDI4LjA4MDQgOTAuMDIzOEMyNS43MjkzIDkxLjczMiAyMi41NjU5IDg5LjQzMzYgMjMuNDYzOSA4Ni42Njk3TDMxLjE2MjkgNjIuOTc0NkMzMS41NjQ1IDYxLjczODYgMzEuMTI0NSA2MC4zODQ1IDMwLjA3MzEgNTkuNjIwNUw5LjkxNjg2IDQ0Ljk3NjJDNy41NjU3MiA0My4yNjggOC43NzQwNSAzOS41NDkxIDExLjY4MDIgMzkuNTQ5MUgzNi41OTQ3QzM3Ljg5NDQgMzkuNTQ5MSAzOS4wNDYyIDM4LjcxMjMgMzkuNDQ3OCAzNy40NzYyTDQ3LjE0NjggMTMuNzgxMVpcIlxuICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIC8+XG4gICAgPC9zdmc+XG4pO1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdmBcbiAgICAuYWN0aXZlIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIH1cblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiA2cHggMDtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuXG4gICAgPiAqIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTZweDtcbiAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMnB4O1xuXG4gICAgICAgIHN2ZyB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxTdGFyQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoY2VsbDogQ3VzdG9tQ2VsbCk6IGNlbGwgaXMgU3RhckNlbGwgPT4gKGNlbGwuZGF0YSBhcyBhbnkpLmtpbmQgPT09IFwic3Rhci1jZWxsXCIsXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QsIGhvdmVyQW1vdW50IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHJhdGluZyB9ID0gY2VsbC5kYXRhO1xuICAgICAgICBjb25zdCBwYWRYID0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuICAgICAgICBsZXQgZHJhd1ggPSByZWN0LnggKyBwYWRYO1xuICAgICAgICBjb25zdCBzdGFycyA9IE1hdGgubWluKDUsIE1hdGguY2VpbChyYXRpbmcpKTtcbiAgICAgICAgZHJhd1ggKz0gODtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJzOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGhTdGFyKGN0eCwgW2RyYXdYLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdLCAxNik7XG4gICAgICAgICAgICBkcmF3WCArPSAxODtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNiArIDAuNCAqIGhvdmVyQW1vdW50O1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgICAgICByZXR1cm4gcCA9PiAoXG4gICAgICAgICAgICA8RWRpdG9yV3JhcD5cbiAgICAgICAgICAgICAgICB7WzAsIDEsIDIsIDMsIDRdLm1hcChpbmRleCA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3AudmFsdWUuZGF0YS5yYXRpbmcgPCBpbmRleCArIDEgPyBcImluYWN0aXZlXCIgOiBcImFjdGl2ZVwifVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPFN0YXJTVkcgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L0VkaXRvcldyYXA+XG4gICAgICAgICk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAodmFsLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUludCh2YWwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIHJhdGluZzogTnVtYmVyLmlzTmFOKG51bSkgPyAwIDogbnVtLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/cells/src/cells/packages/cells/src/cells/star-cell.tsx\",\"webpack://./packages/cells/src/cells/star-cell.tsx\"],\"names\":[\".e8nv6xj\"],\"mappings\":\"AAkDMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,aAAAA,CAAAA,2BAAAA,CAAAA,CAAAA,iBAAAA,0BAAAA,CAAAA,CAAAA,aAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,iBAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACjDN,mvLAAmvL\",\"sourcesContent\":[\"import { CustomCell, Item, CustomRenderer, GridCellKind } from \\\"@glideapps/glide-data-grid\\\";\\nimport * as React from \\\"react\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\n\\ninterface StarCellProps {\\n    readonly kind: \\\"star-cell\\\";\\n    readonly rating: number;\\n}\\n\\nexport type StarCell = CustomCell<StarCellProps>;\\n\\nconst starPoints = [\\n    [50, 5],\\n    [61.23, 39.55],\\n    [97.55, 39.55],\\n    [68.16, 60.9],\\n    [79.39, 95.45],\\n    [50, 74.1],\\n    [20.61, 95.45],\\n    [31.84, 60.9],\\n    [2.45, 39.55],\\n    [38.77, 39.55],\\n];\\n\\nfunction pathStar(ctx: CanvasRenderingContext2D, center: Item, size: number) {\\n    let moved = false;\\n    for (const p of starPoints) {\\n        const x = (p[0] - 50) * (size / 100) + center[0];\\n        const y = (p[1] - 50) * (size / 100) + center[1];\\n\\n        if (moved) {\\n            ctx.lineTo(x, y);\\n        } else {\\n            ctx.moveTo(x, y);\\n            moved = true;\\n        }\\n    }\\n\\n    ctx.closePath();\\n}\\n\\nconst StarSVG = () => (\\n    <svg width=\\\"100\\\" height=\\\"100\\\" viewBox=\\\"0 0 100 100\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n        <path\\n            d=\\\"M47.1468 13.7811C48.0449 11.0172 51.9551 11.0172 52.8532 13.7812L60.5522 37.4762C60.9538 38.7123 62.1056 39.5491 63.4053 39.5491H88.3198C91.226 39.5491 92.4343 43.268 90.0831 44.9762L69.9269 59.6205C68.8755 60.3845 68.4355 61.7386 68.8371 62.9746L76.5361 86.6697C77.4342 89.4336 74.2707 91.732 71.9196 90.0238L51.7634 75.3794C50.7119 74.6155 49.2881 74.6155 48.2366 75.3795L28.0804 90.0238C25.7293 91.732 22.5659 89.4336 23.4639 86.6697L31.1629 62.9746C31.5645 61.7386 31.1245 60.3845 30.0731 59.6205L9.91686 44.9762C7.56572 43.268 8.77405 39.5491 11.6802 39.5491H36.5947C37.8944 39.5491 39.0462 38.7123 39.4478 37.4762L47.1468 13.7811Z\\\"\\n            fill=\\\"currentColor\\\"\\n        />\\n    </svg>\\n);\\n\\nconst EditorWrap = styled.div`\\n    .active {\\n        color: var(--gdg-text-dark);\\n    }\\n\\n    display: flex;\\n    align-items: center;\\n    padding: 6px 0;\\n    color: var(--gdg-text-light);\\n\\n    > * {\\n        position: relative;\\n        width: 16px;\\n        height: 16px;\\n        cursor: pointer;\\n        margin-right: 2px;\\n\\n        svg {\\n            width: 100%;\\n            height: 100%;\\n        }\\n    }\\n`;\\n\\nconst renderer: CustomRenderer<StarCell> = {\\n    kind: GridCellKind.Custom,\\n    isMatch: (cell: CustomCell): cell is StarCell => (cell.data as any).kind === \\\"star-cell\\\",\\n    needsHover: true,\\n    draw: (args, cell) => {\\n        const { ctx, theme, rect, hoverAmount } = args;\\n        const { rating } = cell.data;\\n        const padX = theme.cellHorizontalPadding;\\n        let drawX = rect.x + padX;\\n        const stars = Math.min(5, Math.ceil(rating));\\n        drawX += 8;\\n        ctx.beginPath();\\n        for (let i = 0; i < stars; i++) {\\n            pathStar(ctx, [drawX, rect.y + rect.height / 2], 16);\\n            drawX += 18;\\n        }\\n        ctx.fillStyle = theme.textDark;\\n        ctx.globalAlpha = 0.6 + 0.4 * hoverAmount;\\n        ctx.fill();\\n        ctx.globalAlpha = 1;\\n        return true;\\n    },\\n    provideEditor: () => {\\n        // eslint-disable-next-line react/display-name\\n        return p => (\\n            <EditorWrap>\\n                {[0, 1, 2, 3, 4].map(index => (\\n                    <div\\n                        key={index}\\n                        className={p.value.data.rating < index + 1 ? \\\"inactive\\\" : \\\"active\\\"}\\n                        onClick={() => {\\n                            p.onChange({\\n                                ...p.value,\\n                                data: {\\n                                    ...p.value.data,\\n                                    rating: index + 1,\\n                                },\\n                            });\\n                        }}>\\n                        <StarSVG />\\n                    </div>\\n                ))}\\n            </EditorWrap>\\n        );\\n    },\\n    onPaste: (val, d) => {\\n        const num = Number.parseInt(val);\\n        return {\\n            ...d,\\n            rating: Number.isNaN(num) ? 0 : num,\\n        };\\n    },\\n};\\n\\nexport default renderer;\\n\",\".e8nv6xj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:6px 0;color:var(--gdg-text-light);}.e8nv6xj .active{color:var(--gdg-text-dark);}.e8nv6xj > *{position:relative;width:16px;height:16px;cursor:pointer;margin-right:2px;}.e8nv6xj > * svg{width:100%;height:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lOG52NnhqIl0sIm1hcHBpbmdzIjoiQUFrRE1BIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VzdG9tQ2VsbCwgSXRlbSwgQ3VzdG9tUmVuZGVyZXIsIEdyaWRDZWxsS2luZCB9IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFN0YXJDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwic3Rhci1jZWxsXCI7XG4gICAgcmVhZG9ubHkgcmF0aW5nOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFN0YXJDZWxsID0gQ3VzdG9tQ2VsbDxTdGFyQ2VsbFByb3BzPjtcblxuY29uc3Qgc3RhclBvaW50cyA9IFtcbiAgICBbNTAsIDVdLFxuICAgIFs2MS4yMywgMzkuNTVdLFxuICAgIFs5Ny41NSwgMzkuNTVdLFxuICAgIFs2OC4xNiwgNjAuOV0sXG4gICAgWzc5LjM5LCA5NS40NV0sXG4gICAgWzUwLCA3NC4xXSxcbiAgICBbMjAuNjEsIDk1LjQ1XSxcbiAgICBbMzEuODQsIDYwLjldLFxuICAgIFsyLjQ1LCAzOS41NV0sXG4gICAgWzM4Ljc3LCAzOS41NV0sXG5dO1xuXG5mdW5jdGlvbiBwYXRoU3RhcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2VudGVyOiBJdGVtLCBzaXplOiBudW1iZXIpIHtcbiAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHAgb2Ygc3RhclBvaW50cykge1xuICAgICAgICBjb25zdCB4ID0gKHBbMF0gLSA1MCkgKiAoc2l6ZSAvIDEwMCkgKyBjZW50ZXJbMF07XG4gICAgICAgIGNvbnN0IHkgPSAocFsxXSAtIDUwKSAqIChzaXplIC8gMTAwKSArIGNlbnRlclsxXTtcblxuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5jb25zdCBTdGFyU1ZHID0gKCkgPT4gKFxuICAgIDxzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGQ9XCJNNDcuMTQ2OCAxMy43ODExQzQ4LjA0NDkgMTEuMDE3MiA1MS45NTUxIDExLjAxNzIgNTIuODUzMiAxMy43ODEyTDYwLjU1MjIgMzcuNDc2MkM2MC45NTM4IDM4LjcxMjMgNjIuMTA1NiAzOS41NDkxIDYzLjQwNTMgMzkuNTQ5MUg4OC4zMTk4QzkxLjIyNiAzOS41NDkxIDkyLjQzNDMgNDMuMjY4IDkwLjA4MzEgNDQuOTc2Mkw2OS45MjY5IDU5LjYyMDVDNjguODc1NSA2MC4zODQ1IDY4LjQzNTUgNjEuNzM4NiA2OC44MzcxIDYyLjk3NDZMNzYuNTM2MSA4Ni42Njk3Qzc3LjQzNDIgODkuNDMzNiA3NC4yNzA3IDkxLjczMiA3MS45MTk2IDkwLjAyMzhMNTEuNzYzNCA3NS4zNzk0QzUwLjcxMTkgNzQuNjE1NSA0OS4yODgxIDc0LjYxNTUgNDguMjM2NiA3NS4zNzk1TDI4LjA4MDQgOTAuMDIzOEMyNS43MjkzIDkxLjczMiAyMi41NjU5IDg5LjQzMzYgMjMuNDYzOSA4Ni42Njk3TDMxLjE2MjkgNjIuOTc0NkMzMS41NjQ1IDYxLjczODYgMzEuMTI0NSA2MC4zODQ1IDMwLjA3MzEgNTkuNjIwNUw5LjkxNjg2IDQ0Ljk3NjJDNy41NjU3MiA0My4yNjggOC43NzQwNSAzOS41NDkxIDExLjY4MDIgMzkuNTQ5MUgzNi41OTQ3QzM3Ljg5NDQgMzkuNTQ5MSAzOS4wNDYyIDM4LjcxMjMgMzkuNDQ3OCAzNy40NzYyTDQ3LjE0NjggMTMuNzgxMVpcIlxuICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIC8+XG4gICAgPC9zdmc+XG4pO1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdmBcbiAgICAuYWN0aXZlIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIH1cblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiA2cHggMDtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuXG4gICAgPiAqIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTZweDtcbiAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMnB4O1xuXG4gICAgICAgIHN2ZyB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxTdGFyQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoY2VsbDogQ3VzdG9tQ2VsbCk6IGNlbGwgaXMgU3RhckNlbGwgPT4gKGNlbGwuZGF0YSBhcyBhbnkpLmtpbmQgPT09IFwic3Rhci1jZWxsXCIsXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QsIGhvdmVyQW1vdW50IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHJhdGluZyB9ID0gY2VsbC5kYXRhO1xuICAgICAgICBjb25zdCBwYWRYID0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuICAgICAgICBsZXQgZHJhd1ggPSByZWN0LnggKyBwYWRYO1xuICAgICAgICBjb25zdCBzdGFycyA9IE1hdGgubWluKDUsIE1hdGguY2VpbChyYXRpbmcpKTtcbiAgICAgICAgZHJhd1ggKz0gODtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJzOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGhTdGFyKGN0eCwgW2RyYXdYLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdLCAxNik7XG4gICAgICAgICAgICBkcmF3WCArPSAxODtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNiArIDAuNCAqIGhvdmVyQW1vdW50O1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgICAgICByZXR1cm4gcCA9PiAoXG4gICAgICAgICAgICA8RWRpdG9yV3JhcD5cbiAgICAgICAgICAgICAgICB7WzAsIDEsIDIsIDMsIDRdLm1hcChpbmRleCA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3AudmFsdWUuZGF0YS5yYXRpbmcgPCBpbmRleCArIDEgPyBcImluYWN0aXZlXCIgOiBcImFjdGl2ZVwifVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPFN0YXJTVkcgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L0VkaXRvcldyYXA+XG4gICAgICAgICk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAodmFsLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUludCh2YWwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIHJhdGluZzogTnVtYmVyLmlzTmFOKG51bSkgPyAwIDogbnVtLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".e14vzbfa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;padding-top:6px;color:var(--gdg-text-dark);box-sizing:border-box;}.e14vzbfa *{box-sizing:border-box;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;cursor:pointer;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label input{cursor:pointer;width:auto;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill{margin-left:8px;margin-right:6px;margin-bottom:6px;border-radius:var(--e14vzbfa-0);min-height:var(--e14vzbfa-1);padding:2px var(--e14vzbfa-2);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font:12px var(--gdg-font-family);background-color:var(--gdg-bg-bubble);-webkit-transition:box-shadow 150ms;transition:box-shadow 150ms;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill.unselected{opacity:0.8;}.e14vzbfa label:hover .pill{box-shadow:0 1px 4px rgba(0,0,0,0.15);}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label{cursor:default;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label .pill{box-shadow:none !important;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy90YWdzLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lMTR2emJmYSJdLCJtYXBwaW5ncyI6IkFBMkJNQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvdGFncy1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBSZWN0YW5nbGUsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHJvdW5kZWRSZWN0IH0gZnJvbSBcIi4uL2RyYXctZm5zXCI7XG5cbmludGVyZmFjZSBUYWdzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcInRhZ3MtY2VsbFwiO1xuICAgIHJlYWRvbmx5IHRhZ3M6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICAgIHJlYWRvbmx5IHJlYWRvbmx5PzogYm9vbGVhbjtcbiAgICByZWFkb25seSBwb3NzaWJsZVRhZ3M6IHJlYWRvbmx5IHtcbiAgICAgICAgdGFnOiBzdHJpbmc7XG4gICAgICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBUYWdzQ2VsbCA9IEN1c3RvbUNlbGw8VGFnc0NlbGxQcm9wcz47XG5cbmNvbnN0IHRhZ0hlaWdodCA9IDIwO1xuY29uc3QgaW5uZXJQYWQgPSA2O1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdjx7IHRhZ0hlaWdodDogbnVtYmVyOyBpbm5lclBhZDogbnVtYmVyIH0+YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBwYWRkaW5nLXRvcDogNnB4O1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG5cbiAgICAmJiYmIGxhYmVsIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGlucHV0IHtcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLnBpbGwge1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNnB4O1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAke3AgPT4gcC50YWdIZWlnaHQgLyAyfXB4O1xuICAgICAgICAgICAgbWluLWhlaWdodDogJHtwID0+IHAudGFnSGVpZ2h0fXB4O1xuICAgICAgICAgICAgcGFkZGluZzogMnB4ICR7cCA9PiBwLmlubmVyUGFkfXB4O1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgICAgIGZvbnQ6IDEycHggdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcblxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWJ1YmJsZSk7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMTUwbXM7XG5cbiAgICAgICAgICAgICYudW5zZWxlY3RlZCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC44O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxhYmVsOmhvdmVyIC5waWxsIHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xNSk7XG4gICAgfVxuXG4gICAgJiYmJi5yZWFkb25seSBsYWJlbCB7XG4gICAgICAgIGN1cnNvcjogZGVmYXVsdDtcblxuICAgICAgICAucGlsbCB7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5jb25zdCByZW5kZXJlcjogQ3VzdG9tUmVuZGVyZXI8VGFnc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIFRhZ3NDZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcInRhZ3MtY2VsbFwiLFxuICAgIGRyYXc6IChhcmdzLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCB0aGVtZSwgcmVjdCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MgfSA9IGNlbGwuZGF0YTtcblxuICAgICAgICBjb25zdCBkcmF3QXJlYTogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogcmVjdC54ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nLFxuICAgICAgICAgICAgeTogcmVjdC55ICsgdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC0gMiAqIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLSAyICogdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZHJhd0FyZWEuaGVpZ2h0IC8gKHRhZ0hlaWdodCArIGlubmVyUGFkKSkpO1xuXG4gICAgICAgIGxldCB4ID0gZHJhd0FyZWEueDtcbiAgICAgICAgbGV0IHJvdyA9IDE7XG4gICAgICAgIGxldCB5ID0gZHJhd0FyZWEueSArIChkcmF3QXJlYS5oZWlnaHQgLSByb3dzICogdGFnSGVpZ2h0IC0gKHJvd3MgLSAxKSAqIGlubmVyUGFkKSAvIDI7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gcG9zc2libGVUYWdzLmZpbmQodCA9PiB0LnRhZyA9PT0gdGFnKT8uY29sb3IgPz8gdGhlbWUuYmdCdWJibGU7XG5cbiAgICAgICAgICAgIGN0eC5mb250ID0gYDEycHggJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQodGFnLCBjdHgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtZXRyaWNzLndpZHRoICsgaW5uZXJQYWQgKiAyO1xuICAgICAgICAgICAgY29uc3QgdGV4dFkgPSB0YWdIZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAhPT0gZHJhd0FyZWEueCAmJiB4ICsgd2lkdGggPiBkcmF3QXJlYS54ICsgZHJhd0FyZWEud2lkdGggJiYgcm93IDwgcm93cykge1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICAgIHkgKz0gdGFnSGVpZ2h0ICsgaW5uZXJQYWQ7XG4gICAgICAgICAgICAgICAgeCA9IGRyYXdBcmVhLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHJvdW5kZWRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIHRhZ0hlaWdodCwgdGFnSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGFnLCB4ICsgaW5uZXJQYWQsIHkgKyB0ZXh0WSArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCBgMTJweCAke3RoZW1lLmZvbnRGYW1pbHl9YCkpO1xuXG4gICAgICAgICAgICB4ICs9IHdpZHRoICsgODtcbiAgICAgICAgICAgIGlmICh4ID4gZHJhd0FyZWEueCArIGRyYXdBcmVhLndpZHRoICYmIHJvdyA+PSByb3dzKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgICAgIHJldHVybiBwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25DaGFuZ2UsIHZhbHVlIH0gPSBwO1xuICAgICAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MsIHJlYWRvbmx5ID0gZmFsc2UgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxFZGl0b3JXcmFwIHRhZ0hlaWdodD17dGFnSGVpZ2h0fSBpbm5lclBhZD17aW5uZXJQYWR9IGNsYXNzTmFtZT17cmVhZG9ubHkgPyBcInJlYWRvbmx5XCIgOiBcIlwifT5cbiAgICAgICAgICAgICAgICAgICAge3Bvc3NpYmxlVGFncy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRhZ3MuaW5kZXhPZih0LnRhZykgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwga2V5PXt0LnRhZ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmVhZG9ubHkgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3NlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBzZWxlY3RlZCA/IHRhZ3MuZmlsdGVyKHggPT4geCAhPT0gdC50YWcpIDogWy4uLnRhZ3MsIHQudGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IG5ld1RhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcInBpbGwgXCIgKyAoc2VsZWN0ZWQgPyBcInNlbGVjdGVkXCIgOiBcInVuc2VsZWN0ZWRcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IHNlbGVjdGVkID8gdC5jb2xvciA6IHVuZGVmaW5lZCB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0LnRhZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvRWRpdG9yV3JhcD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvblBhc3RlOiAodiwgZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgdGFnczogZC5wb3NzaWJsZVRhZ3NcbiAgICAgICAgICAgIC5tYXAoeCA9PiB4LnRhZylcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PlxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcyh4KVxuICAgICAgICAgICAgKSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/cells/src/cells/packages/cells/src/cells/tags-cell.tsx\",\"webpack://./packages/cells/src/cells/tags-cell.tsx\"],\"names\":[\".e14vzbfa\"],\"mappings\":\"AA2BMA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,mBAAAA,CAAAA,eAAAA,CAAAA,0BAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,YAAAA,qBAAAA,CAAAA,CAAAA,2CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,cAAAA,CAAAA,CAAAA,iDAAAA,cAAAA,CAAAA,UAAAA,CAAAA,CAAAA,iDAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,+BAAAA,CAAAA,4BAAAA,CAAAA,6BAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,gCAAAA,CAAAA,qCAAAA,CAAAA,mCAAAA,CAAAA,2BAAAA,CAAAA,CAAAA,4DAAAA,WAAAA,CAAAA,CAAAA,4BAAAA,qCAAAA,CAAAA,CAAAA,oDAAAA,cAAAA,CAAAA,CAAAA,0DAAAA,0BAAAA,CAAAA;AC1BN,+pQAA+pQ\",\"sourcesContent\":[\"import {\\n    CustomCell,\\n    Rectangle,\\n    measureTextCached,\\n    CustomRenderer,\\n    getMiddleCenterBias,\\n    GridCellKind,\\n} from \\\"@glideapps/glide-data-grid\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport { roundedRect } from \\\"../draw-fns\\\";\\n\\ninterface TagsCellProps {\\n    readonly kind: \\\"tags-cell\\\";\\n    readonly tags: readonly string[];\\n    readonly readonly?: boolean;\\n    readonly possibleTags: readonly {\\n        tag: string;\\n        color: string;\\n    }[];\\n}\\n\\nexport type TagsCell = CustomCell<TagsCellProps>;\\n\\nconst tagHeight = 20;\\nconst innerPad = 6;\\n\\nconst EditorWrap = styled.div<{ tagHeight: number; innerPad: number }>`\\n    display: flex;\\n    flex-direction: column;\\n    align-items: stretch;\\n    padding-top: 6px;\\n    color: var(--gdg-text-dark);\\n\\n    box-sizing: border-box;\\n\\n    * {\\n        box-sizing: border-box;\\n    }\\n\\n    &&&& label {\\n        display: flex;\\n        cursor: pointer;\\n\\n        input {\\n            cursor: pointer;\\n            width: auto;\\n        }\\n\\n        .pill {\\n            margin-left: 8px;\\n            margin-right: 6px;\\n            margin-bottom: 6px;\\n\\n            border-radius: ${p => p.tagHeight / 2}px;\\n            min-height: ${p => p.tagHeight}px;\\n            padding: 2px ${p => p.innerPad}px;\\n            display: flex;\\n            align-items: center;\\n\\n            font: 12px var(--gdg-font-family);\\n\\n            background-color: var(--gdg-bg-bubble);\\n\\n            transition: box-shadow 150ms;\\n\\n            &.unselected {\\n                opacity: 0.8;\\n            }\\n        }\\n    }\\n    label:hover .pill {\\n        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);\\n    }\\n\\n    &&&&.readonly label {\\n        cursor: default;\\n\\n        .pill {\\n            box-shadow: none !important;\\n        }\\n    }\\n`;\\n\\nconst renderer: CustomRenderer<TagsCell> = {\\n    kind: GridCellKind.Custom,\\n    isMatch: (c): c is TagsCell => (c.data as any).kind === \\\"tags-cell\\\",\\n    draw: (args, cell) => {\\n        const { ctx, theme, rect } = args;\\n        const { possibleTags, tags } = cell.data;\\n\\n        const drawArea: Rectangle = {\\n            x: rect.x + theme.cellHorizontalPadding,\\n            y: rect.y + theme.cellVerticalPadding,\\n            width: rect.width - 2 * theme.cellHorizontalPadding,\\n            height: rect.height - 2 * theme.cellVerticalPadding,\\n        };\\n        const rows = Math.max(1, Math.floor(drawArea.height / (tagHeight + innerPad)));\\n\\n        let x = drawArea.x;\\n        let row = 1;\\n        let y = drawArea.y + (drawArea.height - rows * tagHeight - (rows - 1) * innerPad) / 2;\\n        for (const tag of tags) {\\n            const color = possibleTags.find(t => t.tag === tag)?.color ?? theme.bgBubble;\\n\\n            ctx.font = `12px ${theme.fontFamily}`;\\n            const metrics = measureTextCached(tag, ctx);\\n            const width = metrics.width + innerPad * 2;\\n            const textY = tagHeight / 2;\\n\\n            if (x !== drawArea.x && x + width > drawArea.x + drawArea.width && row < rows) {\\n                row++;\\n                y += tagHeight + innerPad;\\n                x = drawArea.x;\\n            }\\n\\n            ctx.fillStyle = color;\\n            ctx.beginPath();\\n            roundedRect(ctx, x, y, width, tagHeight, tagHeight / 2);\\n            ctx.fill();\\n\\n            ctx.fillStyle = theme.textDark;\\n            ctx.fillText(tag, x + innerPad, y + textY + getMiddleCenterBias(ctx, `12px ${theme.fontFamily}`));\\n\\n            x += width + 8;\\n            if (x > drawArea.x + drawArea.width && row >= rows) break;\\n        }\\n\\n        return true;\\n    },\\n    provideEditor: () => {\\n        // eslint-disable-next-line react/display-name\\n        return p => {\\n            const { onChange, value } = p;\\n            const { possibleTags, tags, readonly = false } = value.data;\\n            return (\\n                <EditorWrap tagHeight={tagHeight} innerPad={innerPad} className={readonly ? \\\"readonly\\\" : \\\"\\\"}>\\n                    {possibleTags.map(t => {\\n                        const selected = tags.indexOf(t.tag) !== -1;\\n                        return (\\n                            <label key={t.tag}>\\n                                {!readonly && (\\n                                    <input\\n                                        className=\\\"gdg-input\\\"\\n                                        type=\\\"checkbox\\\"\\n                                        checked={selected}\\n                                        onChange={() => {\\n                                            const newTags = selected ? tags.filter(x => x !== t.tag) : [...tags, t.tag];\\n                                            onChange({\\n                                                ...p.value,\\n                                                data: {\\n                                                    ...value.data,\\n                                                    tags: newTags,\\n                                                },\\n                                            });\\n                                        }}\\n                                    />\\n                                )}\\n                                <div\\n                                    className={\\\"pill \\\" + (selected ? \\\"selected\\\" : \\\"unselected\\\")}\\n                                    style={{ backgroundColor: selected ? t.color : undefined }}>\\n                                    {t.tag}\\n                                </div>\\n                            </label>\\n                        );\\n                    })}\\n                </EditorWrap>\\n            );\\n        };\\n    },\\n    onPaste: (v, d) => ({\\n        ...d,\\n        tags: d.possibleTags\\n            .map(x => x.tag)\\n            .filter(x =>\\n                v\\n                    .split(\\\",\\\")\\n                    .map(s => s.trim())\\n                    .includes(x)\\n            ),\\n    }),\\n};\\n\\nexport default renderer;\\n\",\".e14vzbfa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;padding-top:6px;color:var(--gdg-text-dark);box-sizing:border-box;}.e14vzbfa *{box-sizing:border-box;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;cursor:pointer;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label input{cursor:pointer;width:auto;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill{margin-left:8px;margin-right:6px;margin-bottom:6px;border-radius:var(--e14vzbfa-0);min-height:var(--e14vzbfa-1);padding:2px var(--e14vzbfa-2);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font:12px var(--gdg-font-family);background-color:var(--gdg-bg-bubble);-webkit-transition:box-shadow 150ms;transition:box-shadow 150ms;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill.unselected{opacity:0.8;}.e14vzbfa label:hover .pill{box-shadow:0 1px 4px rgba(0,0,0,0.15);}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label{cursor:default;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label .pill{box-shadow:none !important;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy90YWdzLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lMTR2emJmYSJdLCJtYXBwaW5ncyI6IkFBMkJNQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvdGFncy1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBSZWN0YW5nbGUsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHJvdW5kZWRSZWN0IH0gZnJvbSBcIi4uL2RyYXctZm5zXCI7XG5cbmludGVyZmFjZSBUYWdzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcInRhZ3MtY2VsbFwiO1xuICAgIHJlYWRvbmx5IHRhZ3M6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICAgIHJlYWRvbmx5IHJlYWRvbmx5PzogYm9vbGVhbjtcbiAgICByZWFkb25seSBwb3NzaWJsZVRhZ3M6IHJlYWRvbmx5IHtcbiAgICAgICAgdGFnOiBzdHJpbmc7XG4gICAgICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBUYWdzQ2VsbCA9IEN1c3RvbUNlbGw8VGFnc0NlbGxQcm9wcz47XG5cbmNvbnN0IHRhZ0hlaWdodCA9IDIwO1xuY29uc3QgaW5uZXJQYWQgPSA2O1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdjx7IHRhZ0hlaWdodDogbnVtYmVyOyBpbm5lclBhZDogbnVtYmVyIH0+YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBwYWRkaW5nLXRvcDogNnB4O1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG5cbiAgICAmJiYmIGxhYmVsIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGlucHV0IHtcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLnBpbGwge1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNnB4O1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAke3AgPT4gcC50YWdIZWlnaHQgLyAyfXB4O1xuICAgICAgICAgICAgbWluLWhlaWdodDogJHtwID0+IHAudGFnSGVpZ2h0fXB4O1xuICAgICAgICAgICAgcGFkZGluZzogMnB4ICR7cCA9PiBwLmlubmVyUGFkfXB4O1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgICAgIGZvbnQ6IDEycHggdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcblxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWJ1YmJsZSk7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMTUwbXM7XG5cbiAgICAgICAgICAgICYudW5zZWxlY3RlZCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC44O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxhYmVsOmhvdmVyIC5waWxsIHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xNSk7XG4gICAgfVxuXG4gICAgJiYmJi5yZWFkb25seSBsYWJlbCB7XG4gICAgICAgIGN1cnNvcjogZGVmYXVsdDtcblxuICAgICAgICAucGlsbCB7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5jb25zdCByZW5kZXJlcjogQ3VzdG9tUmVuZGVyZXI8VGFnc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIFRhZ3NDZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcInRhZ3MtY2VsbFwiLFxuICAgIGRyYXc6IChhcmdzLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCB0aGVtZSwgcmVjdCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MgfSA9IGNlbGwuZGF0YTtcblxuICAgICAgICBjb25zdCBkcmF3QXJlYTogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogcmVjdC54ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nLFxuICAgICAgICAgICAgeTogcmVjdC55ICsgdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC0gMiAqIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLSAyICogdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZHJhd0FyZWEuaGVpZ2h0IC8gKHRhZ0hlaWdodCArIGlubmVyUGFkKSkpO1xuXG4gICAgICAgIGxldCB4ID0gZHJhd0FyZWEueDtcbiAgICAgICAgbGV0IHJvdyA9IDE7XG4gICAgICAgIGxldCB5ID0gZHJhd0FyZWEueSArIChkcmF3QXJlYS5oZWlnaHQgLSByb3dzICogdGFnSGVpZ2h0IC0gKHJvd3MgLSAxKSAqIGlubmVyUGFkKSAvIDI7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gcG9zc2libGVUYWdzLmZpbmQodCA9PiB0LnRhZyA9PT0gdGFnKT8uY29sb3IgPz8gdGhlbWUuYmdCdWJibGU7XG5cbiAgICAgICAgICAgIGN0eC5mb250ID0gYDEycHggJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQodGFnLCBjdHgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtZXRyaWNzLndpZHRoICsgaW5uZXJQYWQgKiAyO1xuICAgICAgICAgICAgY29uc3QgdGV4dFkgPSB0YWdIZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAhPT0gZHJhd0FyZWEueCAmJiB4ICsgd2lkdGggPiBkcmF3QXJlYS54ICsgZHJhd0FyZWEud2lkdGggJiYgcm93IDwgcm93cykge1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICAgIHkgKz0gdGFnSGVpZ2h0ICsgaW5uZXJQYWQ7XG4gICAgICAgICAgICAgICAgeCA9IGRyYXdBcmVhLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHJvdW5kZWRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIHRhZ0hlaWdodCwgdGFnSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGFnLCB4ICsgaW5uZXJQYWQsIHkgKyB0ZXh0WSArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCBgMTJweCAke3RoZW1lLmZvbnRGYW1pbHl9YCkpO1xuXG4gICAgICAgICAgICB4ICs9IHdpZHRoICsgODtcbiAgICAgICAgICAgIGlmICh4ID4gZHJhd0FyZWEueCArIGRyYXdBcmVhLndpZHRoICYmIHJvdyA+PSByb3dzKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgICAgIHJldHVybiBwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25DaGFuZ2UsIHZhbHVlIH0gPSBwO1xuICAgICAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MsIHJlYWRvbmx5ID0gZmFsc2UgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxFZGl0b3JXcmFwIHRhZ0hlaWdodD17dGFnSGVpZ2h0fSBpbm5lclBhZD17aW5uZXJQYWR9IGNsYXNzTmFtZT17cmVhZG9ubHkgPyBcInJlYWRvbmx5XCIgOiBcIlwifT5cbiAgICAgICAgICAgICAgICAgICAge3Bvc3NpYmxlVGFncy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRhZ3MuaW5kZXhPZih0LnRhZykgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwga2V5PXt0LnRhZ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmVhZG9ubHkgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3NlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBzZWxlY3RlZCA/IHRhZ3MuZmlsdGVyKHggPT4geCAhPT0gdC50YWcpIDogWy4uLnRhZ3MsIHQudGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IG5ld1RhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcInBpbGwgXCIgKyAoc2VsZWN0ZWQgPyBcInNlbGVjdGVkXCIgOiBcInVuc2VsZWN0ZWRcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IHNlbGVjdGVkID8gdC5jb2xvciA6IHVuZGVmaW5lZCB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0LnRhZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvRWRpdG9yV3JhcD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvblBhc3RlOiAodiwgZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgdGFnczogZC5wb3NzaWJsZVRhZ3NcbiAgICAgICAgICAgIC5tYXAoeCA9PiB4LnRhZylcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PlxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcyh4KVxuICAgICAgICAgICAgKSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".wo9gtxb{position:relative;min-width:10px;min-height:10px;max-width:100%;max-height:100%;width:var(--wo9gtxb-0);height:var(--wo9gtxb-1);overflow:hidden;overflow:clip;contain:strict;}.wo9gtxb > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyIud285Z3R4YiJdLCJtYXBwaW5ncyI6IkFBYU1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGluV2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgICBpbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b0Nzcyh4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHJldHVybiB4O1xuICAgIHJldHVybiBgJHt4fXB4YDtcbn1cblxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBpbm5lcldpZHRoOiBzdHJpbmc7IGlubmVySGVpZ2h0OiBzdHJpbmcgfT5gXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgbWluLXdpZHRoOiAxMHB4O1xuICAgIG1pbi1oZWlnaHQ6IDEwcHg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG5cbiAgICB3aWR0aDogJHtwID0+IHAuaW5uZXJXaWR0aH07XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5pbm5lckhlaWdodH07XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG92ZXJmbG93OiBjbGlwO1xuXG4gICAgY29udGFpbjogc3RyaWN0O1xuXG4gICAgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMgZXh0ZW5kcyBXcmFwcGVyUHJvcHMsIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiB7fVxuXG5leHBvcnQgY29uc3QgRGF0YUVkaXRvckNvbnRhaW5lcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48UHJvcHM+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwcGVyIGlubmVySGVpZ2h0PXt0b0NzcyhpbkhlaWdodCl9IGlubmVyV2lkdGg9e3RvQ3NzKGluV2lkdGgpfSB7Li4ucmVzdH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-editor-container/packages/core/src/data-editor-container/data-grid-container.tsx\",\"webpack://./packages/core/src/data-editor-container/data-grid-container.tsx\"],\"names\":[\".wo9gtxb\"],\"mappings\":\"AAaMA,SAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,sBAAAA,CAAAA,uBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAAA,CAAAA,wBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACZN,22DAA22D\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\n\\ninterface WrapperProps {\\n    inWidth: number | string;\\n    inHeight: number | string;\\n}\\n\\nfunction toCss(x: number | string) {\\n    if (typeof x === \\\"string\\\") return x;\\n    return `${x}px`;\\n}\\n\\nconst Wrapper = styled.div<{ innerWidth: string; innerHeight: string }>`\\n    position: relative;\\n\\n    min-width: 10px;\\n    min-height: 10px;\\n    max-width: 100%;\\n    max-height: 100%;\\n\\n    width: ${p => p.innerWidth};\\n    height: ${p => p.innerHeight};\\n\\n    overflow: hidden;\\n    overflow: clip;\\n\\n    contain: strict;\\n\\n    > :first-child {\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        width: 100%;\\n        height: 100%;\\n    }\\n`;\\n\\ninterface Props extends WrapperProps, React.HTMLAttributes<HTMLDivElement> {}\\n\\nexport const DataEditorContainer: React.FunctionComponent<React.PropsWithChildren<Props>> = p => {\\n    const { inWidth, inHeight, children, ...rest } = p;\\n    return (\\n        <Wrapper innerHeight={toCss(inHeight)} innerWidth={toCss(inWidth)} {...rest}>\\n            {children}\\n        </Wrapper>\\n    );\\n};\\n\",\".wo9gtxb{position:relative;min-width:10px;min-height:10px;max-width:100%;max-height:100%;width:var(--wo9gtxb-0);height:var(--wo9gtxb-1);overflow:hidden;overflow:clip;contain:strict;}.wo9gtxb > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyIud285Z3R4YiJdLCJtYXBwaW5ncyI6IkFBYU1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGluV2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgICBpbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b0Nzcyh4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHJldHVybiB4O1xuICAgIHJldHVybiBgJHt4fXB4YDtcbn1cblxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBpbm5lcldpZHRoOiBzdHJpbmc7IGlubmVySGVpZ2h0OiBzdHJpbmcgfT5gXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgbWluLXdpZHRoOiAxMHB4O1xuICAgIG1pbi1oZWlnaHQ6IDEwcHg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG5cbiAgICB3aWR0aDogJHtwID0+IHAuaW5uZXJXaWR0aH07XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5pbm5lckhlaWdodH07XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG92ZXJmbG93OiBjbGlwO1xuXG4gICAgY29udGFpbjogc3RyaWN0O1xuXG4gICAgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMgZXh0ZW5kcyBXcmFwcGVyUHJvcHMsIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiB7fVxuXG5leHBvcnQgY29uc3QgRGF0YUVkaXRvckNvbnRhaW5lcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48UHJvcHM+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwcGVyIGlubmVySGVpZ2h0PXt0b0NzcyhpbkhlaWdodCl9IGlubmVyV2lkdGg9e3RvQ3NzKGluV2lkdGgpfSB7Li4ucmVzdH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".r1fzhvm4{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;border:none;outline:none;background-color:var(--gdg-bg-header-has-focus);border-radius:9px;padding:0 8px;box-shadow:0 0 0 1px var(--gdg-border-color);color:var(--gdg-text-group-header);min-height:var(--r1fzhvm4-0);font:var(--gdg-header-font-style) var(--gdg-font-family);}\\n.c181oggi{padding:0 8px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:var(--gdg-bg-header);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL2dyb3VwLXJlbmFtZS50c3giXSwibmFtZXMiOlsiLnIxZnpodm00IiwiLmMxODFvZ2dpIl0sIm1hcHBpbmdzIjoiQUFjTUE7QUEyQmdCQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9ncm91cC1yZW5hbWUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgeyBjc3MgfSBmcm9tIFwiQGxpbmFyaWEvY29yZVwiO1xuaW1wb3J0IENsaWNrT3V0c2lkZUNvbnRhaW5lciBmcm9tIFwiLi4vY2xpY2stb3V0c2lkZS1jb250YWluZXIvY2xpY2stb3V0c2lkZS1jb250YWluZXJcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICByZWFkb25seSBib3VuZHM6IFJlY3RhbmdsZTtcbiAgICByZWFkb25seSBncm91cDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG9uQ2xvc2U6ICgpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25GaW5pc2g6IChuZXdWYWw6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZWFkb25seSBjYW52YXNCb3VuZHM6IERPTVJlY3Q7XG59XG5cbmNvbnN0IFJlbmFtZUlucHV0ID0gc3R5bGVkLmlucHV0PHsgdGFyZ2V0SGVpZ2h0OiBudW1iZXIgfT5gXG4gICAgZmxleC1ncm93OiAxO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXItaGFzLWZvY3VzKTtcbiAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgcGFkZGluZzogMCA4cHg7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1ncm91cC1oZWFkZXIpO1xuICAgIG1pbi1oZWlnaHQ6ICR7cCA9PiBNYXRoLm1heCgxNiwgcC50YXJnZXRIZWlnaHQgLSAxMCl9cHg7XG4gICAgZm9udDogdmFyKC0tZ2RnLWhlYWRlci1mb250LXN0eWxlKSB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3VwUmVuYW1lOiBSZWFjdC5WRkM8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBib3VuZHMsIGdyb3VwLCBvbkNsb3NlLCBjYW52YXNCb3VuZHMsIG9uRmluaXNoIH0gPSBwO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShncm91cCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8Q2xpY2tPdXRzaWRlQ29udGFpbmVyXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLnggLSBjYW52YXNCb3VuZHMubGVmdCArIDEsXG4gICAgICAgICAgICAgICAgdG9wOiBib3VuZHMueSAtIGNhbnZhc0JvdW5kcy50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCAtIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyKTtcbiAgICAgICAgICAgIGB9XG4gICAgICAgICAgICBvbkNsaWNrT3V0c2lkZT17b25DbG9zZX0+XG4gICAgICAgICAgICA8UmVuYW1lSW5wdXRcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQ9e2JvdW5kcy5oZWlnaHR9XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJncm91cC1yZW5hbWUtaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICBvbkJsdXI9e29uQ2xvc2V9XG4gICAgICAgICAgICAgICAgb25Gb2N1cz17ZSA9PiBlLnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSgwLCB2YWx1ZS5sZW5ndGgpfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICBvbktleURvd249e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5pc2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xpY2tPdXRzaWRlQ29udGFpbmVyPlxuICAgICk7XG59O1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-editor/packages/core/src/data-editor/group-rename.tsx\",\"webpack://./packages/core/src/data-editor/group-rename.tsx\"],\"names\":[\".r1fzhvm4\",\".c181oggi\"],\"mappings\":\"AAcMA,UAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,+CAAAA,CAAAA,iBAAAA,CAAAA,aAAAA,CAAAA,4CAAAA,CAAAA,kCAAAA,CAAAA,4BAAAA,CAAAA,wDAAAA,CAAAA;AA2BgBC,UAAAA,aAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,qCAAAA,CAAAA;ACvCtB,m4GAAm4G\",\"sourcesContent\":[\"import React from \\\"react\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport { css } from \\\"@linaria/core\\\";\\nimport ClickOutsideContainer from \\\"../click-outside-container/click-outside-container\\\";\\nimport type { Rectangle } from \\\"../data-grid/data-grid-types\\\";\\n\\ninterface Props {\\n    readonly bounds: Rectangle;\\n    readonly group: string;\\n    readonly onClose: () => void;\\n    readonly onFinish: (newVal: string) => void;\\n    readonly canvasBounds: DOMRect;\\n}\\n\\nconst RenameInput = styled.input<{ targetHeight: number }>`\\n    flex-grow: 1;\\n    border: none;\\n    outline: none;\\n    background-color: var(--gdg-bg-header-has-focus);\\n    border-radius: 9px;\\n    padding: 0 8px;\\n    box-shadow: 0 0 0 1px var(--gdg-border-color);\\n    color: var(--gdg-text-group-header);\\n    min-height: ${p => Math.max(16, p.targetHeight - 10)}px;\\n    font: var(--gdg-header-font-style) var(--gdg-font-family);\\n`;\\n\\nexport const GroupRename: React.VFC<Props> = p => {\\n    const { bounds, group, onClose, canvasBounds, onFinish } = p;\\n\\n    const [value, setValue] = React.useState(group);\\n\\n    return (\\n        <ClickOutsideContainer\\n            style={{\\n                position: \\\"absolute\\\",\\n                left: bounds.x - canvasBounds.left + 1,\\n                top: bounds.y - canvasBounds.top,\\n                width: bounds.width - 2,\\n                height: bounds.height,\\n            }}\\n            className={css`\\n                padding: 0 8px;\\n                display: flex;\\n                align-items: center;\\n                background-color: var(--gdg-bg-header);\\n            `}\\n            onClickOutside={onClose}>\\n            <RenameInput\\n                targetHeight={bounds.height}\\n                data-testid=\\\"group-rename-input\\\"\\n                value={value}\\n                onBlur={onClose}\\n                onFocus={e => e.target.setSelectionRange(0, value.length)}\\n                onChange={e => setValue(e.target.value)}\\n                onKeyDown={e => {\\n                    if (e.key === \\\"Enter\\\") {\\n                        onFinish(value);\\n                    } else if (e.key === \\\"Escape\\\") {\\n                        onClose();\\n                    }\\n                }}\\n                autoFocus={true}\\n            />\\n        </ClickOutsideContainer>\\n    );\\n};\\n\",\".r1fzhvm4{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;border:none;outline:none;background-color:var(--gdg-bg-header-has-focus);border-radius:9px;padding:0 8px;box-shadow:0 0 0 1px var(--gdg-border-color);color:var(--gdg-text-group-header);min-height:var(--r1fzhvm4-0);font:var(--gdg-header-font-style) var(--gdg-font-family);}\\n.c181oggi{padding:0 8px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:var(--gdg-bg-header);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL2dyb3VwLXJlbmFtZS50c3giXSwibmFtZXMiOlsiLnIxZnpodm00IiwiLmMxODFvZ2dpIl0sIm1hcHBpbmdzIjoiQUFjTUE7QUEyQmdCQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9ncm91cC1yZW5hbWUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgeyBjc3MgfSBmcm9tIFwiQGxpbmFyaWEvY29yZVwiO1xuaW1wb3J0IENsaWNrT3V0c2lkZUNvbnRhaW5lciBmcm9tIFwiLi4vY2xpY2stb3V0c2lkZS1jb250YWluZXIvY2xpY2stb3V0c2lkZS1jb250YWluZXJcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICByZWFkb25seSBib3VuZHM6IFJlY3RhbmdsZTtcbiAgICByZWFkb25seSBncm91cDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG9uQ2xvc2U6ICgpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25GaW5pc2g6IChuZXdWYWw6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZWFkb25seSBjYW52YXNCb3VuZHM6IERPTVJlY3Q7XG59XG5cbmNvbnN0IFJlbmFtZUlucHV0ID0gc3R5bGVkLmlucHV0PHsgdGFyZ2V0SGVpZ2h0OiBudW1iZXIgfT5gXG4gICAgZmxleC1ncm93OiAxO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXItaGFzLWZvY3VzKTtcbiAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgcGFkZGluZzogMCA4cHg7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1ncm91cC1oZWFkZXIpO1xuICAgIG1pbi1oZWlnaHQ6ICR7cCA9PiBNYXRoLm1heCgxNiwgcC50YXJnZXRIZWlnaHQgLSAxMCl9cHg7XG4gICAgZm9udDogdmFyKC0tZ2RnLWhlYWRlci1mb250LXN0eWxlKSB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3VwUmVuYW1lOiBSZWFjdC5WRkM8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBib3VuZHMsIGdyb3VwLCBvbkNsb3NlLCBjYW52YXNCb3VuZHMsIG9uRmluaXNoIH0gPSBwO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShncm91cCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8Q2xpY2tPdXRzaWRlQ29udGFpbmVyXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLnggLSBjYW52YXNCb3VuZHMubGVmdCArIDEsXG4gICAgICAgICAgICAgICAgdG9wOiBib3VuZHMueSAtIGNhbnZhc0JvdW5kcy50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCAtIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyKTtcbiAgICAgICAgICAgIGB9XG4gICAgICAgICAgICBvbkNsaWNrT3V0c2lkZT17b25DbG9zZX0+XG4gICAgICAgICAgICA8UmVuYW1lSW5wdXRcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQ9e2JvdW5kcy5oZWlnaHR9XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJncm91cC1yZW5hbWUtaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICBvbkJsdXI9e29uQ2xvc2V9XG4gICAgICAgICAgICAgICAgb25Gb2N1cz17ZSA9PiBlLnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSgwLCB2YWx1ZS5sZW5ndGgpfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICBvbktleURvd249e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5pc2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xpY2tPdXRzaWRlQ29udGFpbmVyPlxuICAgICk7XG59O1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".k1txkgwh{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;}\\n.s11gjm00{width:175px;padding:8px 0;border-radius:6px;box-shadow:0px 0px 1px rgba(62,65,86,0.7),0px 6px 12px rgba(62,65,86,0.35);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:white;font-size:13px;font-weight:600;font-family:-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,Oxygen,Ubuntu,Cantarell,\\\"Open Sans\\\", \\\"Helvetica Neue\\\",sans-serif;}.s11gjm00 .danger{color:rgba(255,40,40,0.8);}.s11gjm00 .danger:hover{color:rgba(255,40,40,1);}.s11gjm00 > div{padding:6px 8px;color:rgba(0,0,0,0.7);-webkit-transition:background-color 100ms;transition:background-color 100ms;cursor:pointer;}.s11gjm00 > div:hover{background-color:rgba(0,0,0,0.05);color:rgba(0,0,0,0.9);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItYmVhdXRpZnVsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5rMXR4a2d3aCIsIi5zMTFnam0wMCJdLCJtYXBwaW5ncyI6IkFBazNDTUE7QUFrdUJBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLWJlYXV0aWZ1bC5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHNvbmFyanMvbm8taWRlbnRpY2FsLWZ1bmN0aW9ucyAqL1xuLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgICBDZWxsQXJyYXksXG4gICAgQ29tcGFjdFNlbGVjdGlvbixcbiAgICBEcmF3SGVhZGVyQ2FsbGJhY2ssXG4gICAgR3JpZENlbGwsXG4gICAgR3JpZENlbGxLaW5kLFxuICAgIEdyaWRDb2x1bW4sXG4gICAgR3JpZENvbHVtbkljb24sXG4gICAgR3JpZE1vdXNlRXZlbnRBcmdzLFxuICAgIEdyaWRTZWxlY3Rpb24sXG4gICAgR3JvdXBIZWFkZXJDbGlja2VkRXZlbnRBcmdzLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBJdGVtLFxuICAgIFJlY3RhbmdsZSxcbn0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IFNpbXBsZVRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsc1wiO1xuaW1wb3J0IHsgSUJvdW5kcywgdXNlTGF5ZXIgfSBmcm9tIFwicmVhY3QtbGFhZ1wiO1xuaW1wb3J0IHR5cGUgeyBTcHJpdGVNYXAgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC1zcHJpdGVzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGFFZGl0b3JSZWYsIFRoZW1lIH0gZnJvbSBcIi4uLy4uXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHtcbiAgICB1c2VNb2NrRGF0YUdlbmVyYXRvcixcbiAgICBCZWF1dGlmdWxXcmFwcGVyLFxuICAgIERlc2NyaXB0aW9uLFxuICAgIE1vcmVJbmZvLFxuICAgIFByb3BOYW1lLFxuICAgIGxvc3N5Q29weURhdGEsXG4gICAgZ2V0R3JpZENvbHVtbixcbiAgICBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvLFxuICAgIENvbnRlbnRDYWNoZSxcbiAgICBCZWF1dGlmdWxTdHlsZSxcbiAgICBDb2x1bW5BZGRCdXR0b24sXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwibG9kYXNoL25vb3AuanNcIjtcbmltcG9ydCB0eXBlIHsgR2V0Um93VGhlbWVDYWxsYmFjayB9IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXJlbmRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiR2xpZGUtRGF0YS1HcmlkL0RhdGFFZGl0b3IgRGVtb3NcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb246IHRydWUsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuZXhwb3J0IGNvbnN0IFJlc2l6YWJsZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlc2l6YWJsZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIHJlc2l6ZSBjb2x1bW5zIGJ5IGRyYWdnaW5nIHRoZWlyIGVkZ2VzLCBhcyBsb25nIGFzIHlvdSByZXNwb25kIHRvIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5vbkNvbHVtblJlc2l6ZTwvUHJvcE5hbWU+IHByb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IHNldHRpbmcgdGhlIDxQcm9wTmFtZT5vdmVyc2Nyb2xsWDwvUHJvcE5hbWU+IHByb3BlcnR5IGV4dHJhIHNwYWNlIGNhbiBiZSBhbGxvY2F0ZWQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGdyaWQgdG8gYWxsb3cgZm9yIGVhc2llciByZXNpemluZyBvZiB0aGUgZmluYWwgY29sdW1uLiBZb3UgY2FuIGhpZ2hsaWdodCBtdWx0aXBsZSBjb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB0byByZXNpemUgdGhlbSBhbGwgYXQgb25jZS5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9ezIwMH1cbiAgICAgICAgICAgICAgICBvdmVyc2Nyb2xsWT17MjAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbkF1dG9XaWR0aD17NTAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXsyMDAwfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVzaXphYmxlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgT3ZlcnNjcm9sbFByb3BzIHtcbiAgICBvdmVyc2Nyb2xsWDogbnVtYmVyO1xuICAgIG92ZXJzY3JvbGxZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBPdmVyc2Nyb2xsOiBSZWFjdC5WRkM8T3ZlcnNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgb3ZlcnNjcm9sbFgsIG92ZXJzY3JvbGxZIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk92ZXJzY3JvbGxcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWxsb2NhdGUgZXh0cmEgc3BhY2UgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b3ZlcnNjcm9sbFg8L1Byb3BOYW1lPiBhbmQgPFByb3BOYW1lPm92ZXJzY3JvbGxZPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e292ZXJzY3JvbGxYfVxuICAgICAgICAgICAgICAgIG92ZXJzY3JvbGxZPXtvdmVyc2Nyb2xsWX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgb3ZlcnNjcm9sbFg6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvdmVyc2Nyb2xsWToge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDYwMCxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBvdmVyc2Nyb2xsWDogMjAwLFxuICAgIG92ZXJzY3JvbGxZOiAyMDAsXG59O1xuKE92ZXJzY3JvbGwgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBjbGVhckNlbGwoY2VsbDogR3JpZENlbGwpOiBHcmlkQ2VsbCB7XG4gICAgc3dpdGNoIChjZWxsLmtpbmQpIHtcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuRHJpbGxkb3duOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5CdWJibGU6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVXJpOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5NYXJrZG93bjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlRleHQ6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5OdW1iZXI6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiAwLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbn1cblxuZXhwb3J0IGNvbnN0IEFkZERhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA2MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3Qgb25Sb3dBcHBlbmRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gbnVtUm93cztcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsQ29udGVudChbYywgbmV3Um93XSk7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWVSYXcoW2MsIG5ld1Jvd10sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgIH0sIFtnZXRDZWxsQ29udGVudCwgbnVtUm93cywgc2V0Q2VsbFZhbHVlUmF3XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPkRhdGEgY2FuIGJlIGFkZGVkIGJ5IGNsaWNraW5nIG9uIHRoZSB0cmFpbGluZyByb3cuPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgS2V5Ym9hcmQgaXMgYWxzbyBzdXBwb3J0ZWQsIGp1c3QgbmF2aWdhdGUgcGFzdCB0aGUgbGFzdCByb3cgYW5kIHByZXNzIDxLZXlOYW1lPkVudGVyPC9LZXlOYW1lPlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGREYXRhIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodFRvTGVmdDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2wsIF9yb3ddID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChjb2wgIT09IDApIHJldHVybiBnZXRDZWxsQ29udGVudChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwi15DXoNeZINeS15PXoteV158sINee15XXnteX15Qg15zXkNek15zXmden16bXmdeV16og15LXnNeZ15nXky5cIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCLXkNeg15kg15LXk9ei15XXnywg157Xldee15fXlCDXnNeQ16TXnNeZ16fXpteZ15XXqiDXktec15nXmdeTLlwiLFxuICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJpZ2h0IFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRoZSBkYXRhIGVkaXRvciBhdXRvbWF0aWNhbGx5IGRldGVjdHMgUlRMIGluIHRleHQgY2VsbHMgYW5kIHJlc3BlY3RzIGl0LjwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJpZ2h0VG9MZWZ0IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZURhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVmFsaWRhdGUgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YSBjYW4gYmUgdmFsaWRhdGVkIHVzaW5nIHRoZSA8UHJvcE5hbWU+dmFsaWRhdGVDZWxsPC9Qcm9wTmFtZT4gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlRoaXMgZXhhbXBsZSBvbmx5IGFsbG93cyB0aGUgd29yZCAmcXVvdDtWYWxpZCZxdW90OyBpbnNpZGUgdGV4dCBjZWxscy48L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDZWxsPXsoX2NlbGwsIG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5raW5kICE9PSBHcmlkQ2VsbEtpbmQuVGV4dCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5kYXRhID09PSBcIlZhbGlkXCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJWYWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBbMCwgM10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFZhbGlkYXRlRGF0YSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRmlsbEhhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoXG4gICAgICAgIDYwLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgICAgIGlmIChpWzBdID09PSAxICYmIHZhbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRmlsbCBoYW5kbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5GaWxsIGhhbmRsZXMgY2FuIGJlIHVzZWQgdG8gZG93bmZpbGwgZGF0YSB3aXRoIHRoZSBtb3VzZS48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBKdXN0IGNsaWNrIGFuZCBkcmFnLCB0aGUgdG9wIHJvdyB3aWxsIGJlIGNvcGllZCBkb3duLiBFbmFibGUgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmZpbGxIYW5kbGU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnRNYW5nbGVkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgZmlsbEhhbmRsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihGaWxsSGFuZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNIaW50OiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAgIDI6IFwiU21vbCB0ZXh0XCIsXG4gICAgMzogXCJBZGRcIixcbiAgICA1OiBcIk5ld1wiLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0ljb246IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7XG4gICAgMjogR3JpZENvbHVtbkljb24uSGVhZGVyQXJyYXksXG4gICAgMzogR3JpZENvbHVtbkljb24uSGVhZGVyRW1vamksXG4gICAgNTogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldDogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHtcbiAgICAyOiAwLFxuICAgIDM6IDAsXG4gICAgNTogMCxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNEaXNhYmxlZDogUmVjb3JkPG51bWJlciwgYm9vbGVhbj4gPSB7XG4gICAgMzogdHJ1ZSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNUaGVtZTogUmVjb3JkPG51bWJlciwgUGFydGlhbDxUaGVtZT4+ID0ge1xuICAgIDI6IHtcbiAgICAgICAgYmFzZUZvbnRTdHlsZTogXCIxMHB4XCIsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBUcmFpbGluZ1Jvd09wdGlvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgY29uc3QgY29sdW1uc1dpdGhSb3dPcHRpb25zOiBHcmlkQ29sdW1uW10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKChjLCBpZHgpID0+ICh7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgaGludDogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0hpbnRbaWR4XSxcbiAgICAgICAgICAgICAgICBhZGRJY29uOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzSWNvbltpZHhdLFxuICAgICAgICAgICAgICAgIHRhcmdldENvbHVtbjogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldFtpZHhdLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzRGlzYWJsZWRbaWR4XSxcbiAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzVGhlbWVbaWR4XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9LCBbY29sc10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVHJhaWxpbmcgcm93IG9wdGlvbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBjdXN0b21pemUgdGhlIHRyYWlsaW5nIHJvdyBpbiBlYWNoIGNvbHVtbiBieSBzZXR0aW5nIGF7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT50cmFpbGluZ1Jvd09wdGlvbnM8L1Byb3BOYW1lPiBpbiB5b3VyIGNvbHVtbnMuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnNXaXRoUm93T3B0aW9uc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRyYWlsaW5nUm93T3B0aW9ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQWRkRGF0YVRvVG9wOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlUmF3LCBzZXRDZWxsVmFsdWUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCBhbGwgb2YgdGhlIGV4aXN0aW5nIGNlbGxzIGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiAwOyB5LS0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFt4LCB5XSwgZ2V0Q2VsbENvbnRlbnQoW3gsIHkgLSAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIDBdKTtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbYywgMF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gXCJ0b3BcIiBhcyBjb25zdDtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQWRkIGRhdGFcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFkZERhdGFUb1RvcCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgQWRkRGF0YVRvTWlkZGxlUHJvcHMge1xuICAgIGluc2VydEluZGV4OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgQWRkRGF0YVRvTWlkZGxlOiBSZWFjdC5GQzxBZGREYXRhVG9NaWRkbGVQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IGluZGV4ID0gcC5pbnNlcnRJbmRleDtcbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCByb3dzIGJlbG93IGluZGV4IGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiBpbmRleDsgeS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDY7IHgrKykge1xuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbeCwgeV0sIGdldENlbGxDb250ZW50KFt4LCB5IC0gMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDY7IGMrKykge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGdldENlbGxDb250ZW50KFtjLCBpbmRleF0pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBpbmRleF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSwgW2dldENlbGxDb250ZW50LCBudW1Sb3dzLCBzZXRDZWxsVmFsdWVSYXcsIGluZGV4XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YSB0byBtaWRkbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCA8S2V5TmFtZT5pbnNlcnRJbmRleDwvS2V5TmFtZT4gaXMgemVyby1iYXNlZCB3aGlsZSB0aGUgbnVtYmVyIGNvbHVtbiBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZ3JpZCBpcyBvbmUtYmFzZWQsIHNvIGluc2VydGluZyBhdCBpbmRleCAmcXVvdDs0JnF1b3Q7IGNyZWF0ZXMgYSBuZXcgcm93IGF0ICZxdW90OzUmcXVvdDtcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIGhpbnQ6IFwiTmV3IHJvdy4uLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpbnNlcnRJbmRleDogMTAsXG59O1xuKEFkZERhdGFUb01pZGRsZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGluc2VydEluZGV4OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICAgIG1heDogNDgsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEFwcGVuZFJvd0hhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3Qgb25DbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdm9pZCByZWYuY3VycmVudD8uYXBwZW5kUm93KDMpO1xuICAgIH0sIFtyZWZdKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiYXBwZW5kUm93IFJlZlwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgQWRkaW5nIGRhdGEgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGZyb20gb3V0c2lkZSBvZiA8UHJvcE5hbWU+RGF0YUVkaXRvcjwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IGNhbGxpbmcgPFByb3BOYW1lPmFwcGVuZFJvdzwvUHJvcE5hbWU+IG9uIGEgPFByb3BOYW1lPnJlZjwvUHJvcE5hbWU+IHRvIHlvdXIgZ3JpZCwgeW91IGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciB0aGUgYXBwZW5kIGVsc2V3aGVyZSwgbGlrZSB0aGlzIDxLZXlOYW1lIG9uQ2xpY2s9e29uQ2xpY2t9PkFwcGVuZDwvS2V5TmFtZT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFwcGVuZFJvd0hhbmRsZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU21hbGxFZGl0YWJsZUdyaWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJFZGl0YWJsZSBHcmlkXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBzdXBwb3J0cyBvdmVybGF5IGVkaXRvcnMgZm9yIGNoYW5naW5nIHZhbHVlcy4gVGhlcmUgYXJlIGJlc3Bva2UgZWRpdG9ycyBmb3IgbnVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncywgaW1hZ2VzLCBib29sZWFucywgbWFya2Rvd24sIGFuZCB1cmkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezIwfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNtYWxsRWRpdGFibGVHcmlkIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVNaWxsaW9uUm93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk9uZSBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5EYXRhIGdyaWQgc3VwcG9ydHMgb3ZlciAxIG1pbGxpb24gcm93cy4gWW91ciBsaW1pdCBpcyBtb3N0bHkgUkFNLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxXzAwMF8wMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oT25lTWlsbGlvblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFNpbGx5TnVtYmVyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIjEwMCBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgMTAwIG1pbGxpb24gcm93cyBpcyBzaWxseS4gT25jZSB3ZSBjcm9zcyBhYm91dCAzMyBtaWxsaW9uIHBpeGVscyBpbiBoZWlnaHQgd2UgY2FuIG5vIGxvbmdlciB0cnVzdFxuICAgICAgICAgICAgICAgICAgICB0aGUgYnJvd3NlciB0byBzY3JvbGwgYWNjdXJhdGVseS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDBfMDAwXzAwMH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibnVtYmVyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTaWxseU51bWJlcnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IE9ic2VydmVWaXNpYmxlUmVnaW9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIGNvbnN0IFt2aXNpYmxlUmVnaW9uLCBzZXRWaXNpYmxlUmVnaW9uXSA9IFJlYWN0LnVzZVN0YXRlPFJlY3RhbmdsZT4oeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT2JzZXJ2ZSBWaXNpYmxlIFJlZ2lvblwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHZpc2libGUgcmVnaW9uIGNhbiBiZSBvYnNlcnZlZCB1c2luZyA8UHJvcE5hbWU+b25WaXNpYmxlUmVnaW9uQ2hhbmdlZDwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZW4gY3VycmVudCB2aXNpYmxlIHJlZ2lvbiBpcyB4OjxLZXlOYW1lPnt2aXNpYmxlUmVnaW9uLnh9PC9LZXlOYW1lPiB5OlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ueX08L0tleU5hbWU+IHdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ud2lkdGh9PC9LZXlOYW1lPiBoZWlnaHQ6PEtleU5hbWU+e3Zpc2libGVSZWdpb24uaGVpZ2h0fTwvS2V5TmFtZT5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPXtzZXRWaXNpYmxlUmVnaW9ufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZU1pbGxpb25Sb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVIdW5kcmVkVGhvdXNhbmRDb2xzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMF8wMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT25lIEh1bmRyZWQgVGhvdXNhbmQgQ29sdW1uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgd2F5IG1vcmUgY29sdW1ucyB0aGFuIHlvdSB3aWxsIGV2ZXIgbmVlZC4gQWxzbyB0aGlzIGlzIHJlbmRlcmluZyAxMCBtaWxsaW9uIGNlbGxzXG4gICAgICAgICAgICAgICAgICAgIGJ1dCB0aGF0JmFwb3M7cyBub3QgaW1wb3J0YW50LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZUh1bmRyZWRUaG91c2FuZENvbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRlbk1pbGxpb25DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJUZW4gTWlsbGlvbiBDZWxsc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPkRhdGEgZ3JpZCBzdXBwb3J0cyBvdmVyIDEwIG1pbGxpb24gY2VsbHMuIEdvIG51dHMgd2l0aCBpdC48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihUZW5NaWxsaW9uQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIFNtb290aFNjcm9sbGluZ0dyaWRQcm9wcyB7XG4gICAgc21vb3RoU2Nyb2xsWDogYm9vbGVhbjtcbiAgICBzbW9vdGhTY3JvbGxZOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgU21vb3RoU2Nyb2xsaW5nR3JpZDogUmVhY3QuRkM8U21vb3RoU2Nyb2xsaW5nR3JpZFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDMwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNtb290aCBzY3JvbGxpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBlbmFibGUgc21vb3RoIHNjcm9sbGluZyB3aXRoIHRoZSA8UHJvcE5hbWU+c21vb3RoU2Nyb2xsWDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPnNtb290aFNjcm9sbFk8L1Byb3BOYW1lPiBwcm9wcy4gRGlzYWJsaW5nIHNtb290aCBzY3JvbGxpbmcgY2FuIGRyYW1hdGljYWxseSBpbmNyZWFzZVxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZSBhbmQgaW1wcm92ZSB2aXN1YWwgc3RhYmlsaXR5IGR1cmluZyByYXBpZCBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17cC5zbW9vdGhTY3JvbGxYfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3Auc21vb3RoU2Nyb2xsWX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU21vb3RoU2Nyb2xsaW5nR3JpZCBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogZmFsc2UsXG4gICAgc21vb3RoU2Nyb2xsWTogZmFsc2UsXG59O1xuKFNtb290aFNjcm9sbGluZ0dyaWQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW5wdXRCbGVuZGluZ0dyaWRQcm9wcyB7XG4gICAgcmFuZ2VCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICBjb2x1bW5CbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByYW5nZU11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwiY2VsbFwiIHwgXCJyZWN0XCIgfCBcIm11bHRpLWNlbGxcIiB8IFwibXVsdGktcmVjdFwiO1xuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwic2luZ2xlXCIgfCBcIm11bHRpXCI7XG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibm9uZVwiIHwgXCJzaW5nbGVcIiB8IFwibXVsdGlcIjtcbn1cblxuZXhwb3J0IGNvbnN0IElucHV0QmxlbmRpbmc6IFJlYWN0LkZDPElucHV0QmxlbmRpbmdHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMzApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiSW5wdXQgYmxlbmRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgSW5wdXQgYmxlbmRpbmcgY2FuIGJlIGVuYWJsZWQgb3IgZGlzYWJsZSBiZXR3ZWVuIHJvdywgY29sdW1uLCBhbmQgcmFuZ2Ugc2VsZWN0aW9ucy4gTXVsdGktc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjYW4gYWxzbyBiZSBlbmFibGVkIG9yIGRpc2FibGVkIHdpdGggdGhlIHNhbWUgbGV2ZWwgb2YgZ3JhbnVsYXJpdHkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17cC5yb3dNdWx0aVNlbGVjdCA9PT0gXCJub25lXCIgPyBcIm51bWJlclwiIDogXCJib3RoXCJ9XG4gICAgICAgICAgICAgICAga2V5YmluZGluZ3M9e3tcbiAgICAgICAgICAgICAgICAgICAgY2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvcHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRvd25GaWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByaWdodEZpbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEb3duOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYWdlVXA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEFsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0Q29sdW1uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RSb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICByYW5nZVNlbGVjdD17cC5yYW5nZU11bHRpU2VsZWN0fVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdD17cC5jb2x1bW5NdWx0aVNlbGVjdH1cbiAgICAgICAgICAgICAgICByb3dTZWxlY3Q9e3Aucm93TXVsdGlTZWxlY3R9XG4gICAgICAgICAgICAgICAgcmFuZ2VTZWxlY3Rpb25CbGVuZGluZz17cC5yYW5nZUJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdGlvbkJsZW5kaW5nPXtwLmNvbHVtbkJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbkJsZW5kaW5nPXtwLnJvd0JsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkuYXJncyA9IHtcbiAgICByYW5nZUJsZW5kaW5nOiBcIm1peGVkXCIsXG4gICAgY29sdW1uQmxlbmRpbmc6IFwibWl4ZWRcIixcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiLFxuICAgIHJhbmdlTXVsdGlTZWxlY3Q6IFwicmVjdFwiLFxuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm11bHRpXCIsXG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibXVsdGlcIixcbn07XG4oSW5wdXRCbGVuZGluZyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJhbmdlQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgY29sdW1uQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcm93QmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcmFuZ2VNdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJjZWxsXCIsIFwicmVjdFwiLCBcIm11bHRpLWNlbGxcIiwgXCJtdWx0aS1yZWN0XCJdIH0sXG4gICAgfSxcbiAgICBjb2x1bW5NdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJzaW5nbGVcIiwgXCJtdWx0aVwiXSB9LFxuICAgIH0sXG4gICAgcm93TXVsdGlTZWxlY3Q6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJub25lXCIsIFwic2luZ2xlXCIsIFwibXVsdGlcIl0gfSxcbiAgICB9LFxufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIEFkZENvbHVtbnNQcm9wcyB7XG4gICAgY29sdW1uc0NvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBBZGRDb2x1bW5zOiBSZWFjdC5GQzxBZGRDb2x1bW5zUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKHAuY29sdW1uc0NvdW50KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkFkZCBhbmQgcmVtb3ZlIGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGFkZCBhbmQgcmVtb3ZlIGNvbHVtbnMgYXQgeW91ciBkaXNwb3NhbDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5Vc2UgdGhlIHN0b3J5JmFwb3M7cyBjb250cm9scyB0byBjaGFuZ2UgdGhlIG51bWJlciBvZiBjb2x1bW5zPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJncyA9IHtcbiAgICBjb2x1bW5zQ291bnQ6IDEwLFxufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgY29sdW1uc0NvdW50OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKEFkZENvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU2Nyb2xsU2hhZG93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IFJlYWN0LnVzZVN0YXRlPEdyaWRTZWxlY3Rpb24+KHtcbiAgICAgICAgcm93czogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBvblNlbGVjdGlvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdTZWw6IEdyaWRTZWxlY3Rpb24pID0+IHtcbiAgICAgICAgbGV0IG5ld1Jvd3MgPSBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIGlmIChuZXdTZWwuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdSb3dzID0gbmV3Um93cy5hZGQoW25ld1NlbC5jdXJyZW50LnJhbmdlLnksIG5ld1NlbC5jdXJyZW50LnJhbmdlLnkgKyBuZXdTZWwuY3VycmVudC5yYW5nZS5oZWlnaHRdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbmV3U2VsLmN1cnJlbnQ/LnJhbmdlU3RhY2sgPz8gW10pIHtcbiAgICAgICAgICAgIG5ld1Jvd3MgPSBuZXdSb3dzLmFkZChbYi55LCBiLnkgKyBiLmhlaWdodF0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAuLi5uZXdTZWwsXG4gICAgICAgICAgICByb3dzOiBuZXdSb3dzLFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB0aGVtZSA9IFJlYWN0LnVzZU1lbW88UGFydGlhbDxUaGVtZT4+KFxuICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgICAgYWNjZW50TGlnaHQ6IFwiI2IxZjZmZlwiLFxuICAgICAgICAgICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBoZWFkZXJCb3R0b21Cb3JkZXJDb2xvcjogXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXCIsXG4gICAgICAgIH0pLFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2socm93ID0+IChyb3cgJSAyID09PSAwID8gdW5kZWZpbmVkIDogeyBiZ0NlbGw6IFwiI2Y1ZjVmNlwiIH0pLCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBdXRvbWF0aWMgUm93IE1hcmtlcnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGVuYWJsZSBhbmQgZGlzYWJsZSB0aGUgaG9yaXpvbnRhbC92ZXJ0aWNhbCBzY3JvbGwgc2hhZG93cy48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcIm51bWJlclwifVxuICAgICAgICAgICAgICAgIGdyaWRTZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBvbkdyaWRTZWxlY3Rpb25DaGFuZ2U9e29uU2VsZWN0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0PXsyNn1cbiAgICAgICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezIyfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICB0aGVtZT17dGhlbWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU2Nyb2xsU2hhZG93cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQXV0b21hdGljUm93TWFya2VyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQXV0b21hdGljIFJvdyBNYXJrZXJzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGVuYWJsZSByb3cgbWFya2VycyB3aXRoIHJpY2ggc2VsZWN0aW9uIGJlaGF2aW9yIHVzaW5nIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5yb3dNYXJrZXJzPC9Qcm9wTmFtZT4gcHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIDxLZXlOYW1lPuKHpzwvS2V5TmFtZT4gKyBjbGljayB0byBtYWtlIHJhbmdlIHNlbGVjdGlvbnMsIGFuZCA8S2V5TmFtZT5DdHJsPC9LZXlOYW1lPiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyBjbGljayB0byBhZGQvcmVtb3ZlIGluZGl2aWR1YWwgcm93cy5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBdXRvbWF0aWNSb3dNYXJrZXJzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBXcmFwcGluZ1RleHQ6IFJlYWN0LlZGQzx7XG4gICAgYWxpZ25tZW50OiBcImxlZnRcIiB8IFwiY2VudGVyXCIgfCBcInJpZ2h0XCI7XG4gICAgbGVuZ3RoOiBudW1iZXI7XG4gICAgaHlwZXJXcmFwcGluZzogYm9vbGVhbjtcbn0+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3Qgc3VmZml4ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCAxMDApLm1hcCgoKSA9PiBmYWtlci5sb3JlbS5zZW50ZW5jZShwLmxlbmd0aCkpO1xuICAgIH0sIFtwLmxlbmd0aF0pO1xuXG4gICAgY29uc3QgbWFuZ2xlZEdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2s8dHlwZW9mIGdldENlbGxDb250ZW50PihcbiAgICAgICAgaSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gaTtcblxuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtyb3d9LFxcbiR7c3VmZml4W3JvdyAlIHN1ZmZpeC5sZW5ndGhdfWAsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd30sICR7c3VmZml4fWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBbGlnbjogcC5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50LCBwLmFsaWdubWVudCwgc3VmZml4XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJXcmFwcGluZyBUZXh0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRleHQgY2VsbHMgY2FuIGhhdmUgd3JhcHBpbmcgdGV4dCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+YWxsb3dXcmFwcGluZzwvUHJvcE5hbWU+IHByb3AgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezgwfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWw9e3tcbiAgICAgICAgICAgICAgICAgICAgaHlwZXJXcmFwcGluZzogcC5oeXBlcldyYXBwaW5nLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oV3JhcHBpbmdUZXh0IGFzIGFueSkuYXJncyA9IHtcbiAgICBhbGlnbm1lbnQ6IFwibGVmdFwiLFxuICAgIGxlbmd0aDogMjAsXG4gICAgaHlwZXJXcmFwcGluZzogZmFsc2UsXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGFsaWdubWVudDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXSB9LFxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBVbmV2ZW5Sb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJVbmV2ZW4gUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBSb3dzIGNhbiBiZSBtYWRlIHVuZXZlbiBieSBwYXNzaW5nIGEgY2FsbGJhY2sgdG8gdGhlIDxQcm9wTmFtZT5yb3dIZWlnaHQ8L1Byb3BOYW1lPiBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXtyID0+IChyICUgMyA9PT0gMCA/IDMwIDogciAlIDIgPyA1MCA6IDYwKX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVuZXZlblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IERyYXdDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhdyBjdXN0b20gY2VsbHNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmF3IGN1c3RvbSBjZWxsIGNvbnRlbnRzIGhvd2V2ZXIgeW91IHdhbnQgdXNpbmcgdGhlIDxQcm9wTmFtZT5kcmF3Q3VzdG9tQ2VsbDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZHJhd0NlbGw9e2FyZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNlbGwsIHJlY3QsIGN0eCB9ID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwua2luZCAhPT0gR3JpZENlbGxLaW5kLlRleHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNYID0gY2VsbC5kaXNwbGF5RGF0YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwieFwiKTsgLy8gYWxsIG15IHgncyBsaXZlIGluIHRleGFzXG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gY2VsbC5kaXNwbGF5RGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGFzWCA/IFwiI2JmZmZjZFwiIDogXCIjZmZlNmU2XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICsgMSwgeSArIDEsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGhhc1ggPyBcIiMwZmMwMzVcIiA6IFwiI2UwMWUxZVwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IFwiYm9sZCAxNHB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRhdGEsIHggKyA4ICsgMC41LCB5ICsgaGVpZ2h0IC8gMiArIDQuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKERyYXdDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUmVhcnJhbmdlQ29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZGlydHkgaGFjayBiZWNhdXNlIHRoZSBtb2NrIGdlbmVyYXRvciBkb2Vzbid0IHJlYWxseSBzdXBwb3J0IGNoYW5naW5nIHRoaXMuIEluIGEgcmVhbCBkYXRhIHNvdXJjZVxuICAgIC8vIHlvdSBzaG91bGQgdHJhY2sgaW5kZXhlcyBwcm9wZXJseVxuICAgIGNvbnN0IFtzb3J0YWJsZUNvbHMsIHNldFNvcnRhYmxlQ29sc10gPSBSZWFjdC51c2VTdGF0ZShjb2xzKTtcblxuICAgIGNvbnN0IG9uQ29sTW92ZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoc3RhcnRJbmRleDogbnVtYmVyLCBlbmRJbmRleDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIHNldFNvcnRhYmxlQ29scyhvbGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29scyA9IFsuLi5vbGRdO1xuICAgICAgICAgICAgY29uc3QgW3RvTW92ZV0gPSBuZXdDb2xzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgICAgICAgIG5ld0NvbHMuc3BsaWNlKGVuZEluZGV4LCAwLCB0b01vdmUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbHM7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldENlbGxDb250ZW50TWFuZ2xlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkQ29sID0gY29scy5maW5kSW5kZXgoYyA9PiBjLnRpdGxlID09PSBzb3J0YWJsZUNvbHNbY29sXS50aXRsZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2VsbENvbnRlbnQoW3JlbWFwcGVkQ29sLCByb3ddKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHMsIGdldENlbGxDb250ZW50LCBzb3J0YWJsZUNvbHNdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlYXJyYW5nZSBDb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgY2FuIGJlIHJlYXJyYW5nZWQgYnkgZHJhZyBhbmQgZHJvcHBpbmcsIGFzIGxvbmcgYXMgeW91IHJlc3BvbmQgdG8gdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25Db2x1bW5Nb3ZlZDwvUHJvcE5hbWU+IGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3NvcnRhYmxlQ29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtvbkNvbE1vdmVkfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVhcnJhbmdlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUm93QW5kSGVhZGVyU2l6ZXNQcm9wcyB7XG4gICAgcm93SGVpZ2h0OiBudW1iZXI7XG4gICAgaGVhZGVySGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgUm93QW5kSGVhZGVyU2l6ZXM6IFJlYWN0LlZGQzxSb3dBbmRIZWFkZXJTaXplc1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJvdyBhbmQgSGVhZGVyIHNpemVzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGUgcm93IHNpemUgY2FuIGJlIGNvbnRyb2xsZWQgd2l0aCA8UHJvcE5hbWU+cm93SGVpZ2h0PC9Qcm9wTmFtZT4gYW5kIHRoZSBoZWFkZXIgc2l6ZSB3aXRoe1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmhlYWRlckhlaWdodDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VXNlIHRoZSBzdG9yeSZhcG9zO3MgY29udHJvbHMgdG8gcmVzaXplIHRoZW08L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9e3Aucm93SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhlYWRlckhlaWdodD17cC5oZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wibnVtYmVyXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgcm93SGVpZ2h0OiAzNCxcbiAgICBoZWFkZXJIZWlnaHQ6IDM0LFxufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJvd0hlaWdodDoge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDIwLFxuICAgICAgICAgICAgbWF4OiAyMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBoZWFkZXJIZWlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAyMCxcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFJvd0FuZEhlYWRlclNpemVzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgS2V5TmFtZSA9IHN0eWxlZC5rYmRgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICBjb2xvcjogIzJiMmIyYjtcbiAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgbWFyZ2luOiAwIDAuMWVtO1xuYDtcblxuZXhwb3J0IGNvbnN0IE11bHRpU2VsZWN0Q29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTXVsdGkgc2VsZWN0IGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gc2VsZWN0IG11bHRpcGxlIGNvbHVtbnMgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5zZWxlY3RlZENvbHVtbnM8L1Byb3BOYW1lPiBhbmR7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25TZWxlY3RlZENvbHVtbnNDaGFuZ2U8L1Byb3BOYW1lPiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBIZXJlIHlvdSBjYW4gbXVsdGkgc2VsZWN0IGNvbHVtbnMgYnkgdXNpbmcgPEtleU5hbWU+Q3RybDwvS2V5TmFtZT4gKG9uIFdpbmRvd3MpIG9ye1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+4oyYPC9LZXlOYW1lPiAob24gTWFjKVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oTXVsdGlTZWxlY3RDb2x1bW5zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGdldENvbHVtbnNGb3JDZWxsVHlwZXMoKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJSb3cgSURcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJSb3dJRCxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Sb3dJRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFrZXIuZGF0YXR5cGUudXVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIlByb3RlY3RlZFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmYWtlci5maW5hbmNlLmJpdGNvaW5BZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkxvYWRpbmdcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJTdHJpbmcsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVGV4dFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTnVtYmVyXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gZmFrZXIuZGF0YXR5cGUubnVtYmVyKDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYWdlLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7YWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckJvb2xlYW4sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb2xsID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcm9sbCA8IDAuMSA/IHVuZGVmaW5lZCA6IHJvbGwgPCAwLjIgPyBudWxsIDogcm9sbCA8IDAuNjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIGVkaXRhYmxlLiBVWCBsb29rcyBiYWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJJbWFnZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYCR7ZmFrZXIuaW1hZ2UuYW5pbWFscyg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVXJpXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyVXJpLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZmFrZXIuaW50ZXJuZXQudXJsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlVyaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1hcmtkb3duXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTWFya2Rvd24sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZG93biA9IGAjIFRpdGxlXG5IZWxsbyBteSBuYW1lIGlzICoke2Zha2VyLm5hbWUuZmlyc3ROYW1lKCl9KlxuXG4jIyBUT0RPOlxuVHJ5IG91dCBbR2xpZGVdKGh0dHBzOi8vd3d3LmdsaWRlYXBwcy5jb20vKVxuYDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1hcmtkb3duLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkJ1YmJsZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2Zha2VyLmxvcmVtLndvcmQoKSwgZmFrZXIubG9yZW0ud29yZCgpLCBmYWtlci5sb3JlbS53b3JkKCldLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRyaWxsZG93blwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkRyaWxsZG93bixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZha2VyLmFkZHJlc3MuY2l0eU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IGAke2Zha2VyLmltYWdlLm5hdHVyZSg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmFrZXIuYWRkcmVzcy5jaXR5TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogYCR7ZmFrZXIuaW1hZ2UubmF0dXJlKDQwLCA0MCl9P3JhbmRvbT0ke2Zha2VyLmRhdGF0eXBlLm51bWJlcigxMDBfMDAwKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZUFsbE1vY2tlZEtpbmRzKCkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKGdldENvbHVtbnNGb3JDZWxsVHlwZXMpO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgW3VwZGF0ZVZlcnNpb24sIHNldFVwZGF0ZVZlcnNpb25dID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiB7XG4gICAgICAgICAgICAvLyBUZXJyaWJsZSBoYWNrIHRvIGZvcmNlIHVwZGF0ZSB3aGVuIHNldENlbGxWYWx1ZSByZXF1ZXN0cyBpdFxuICAgICAgICAgICAgbm9vcCh1cGRhdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBjYWNoZS5jdXJyZW50LmdldChjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbY29sc01hcCwgdXBkYXRlVmVyc2lvbl1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsLCBub0Rpc3BsYXk/OiBib29sZWFuLCBmb3JjZVVwZGF0ZT86IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY2FjaGUuY3VycmVudC5nZXQoY29sLCByb3cpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGVHcmlkQ2VsbCh2YWwpICYmIGlzRWRpdGFibGVHcmlkQ2VsbChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcGllZCA9IGxvc3N5Q29weURhdGEodmFsLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jdXJyZW50LnNldChjb2wsIHJvdywge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb3BpZWQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBub0Rpc3BsYXkgPT09IHRydWUgPyB1bmRlZmluZWQgOiBjb3BpZWQuZGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVVwZGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcGRhdGVWZXJzaW9uKHYgPT4gdiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNNYXBdXG4gICAgKTtcblxuICAgIHJldHVybiB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH07XG59XG5cbmV4cG9ydCBjb25zdCBBbGxDZWxsS2luZHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTG90c2EgY2VsbCBraW5kc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgcGxlbnR5IGNlbGwga2luZHMuIEFueXRoaW5nIHVuZGVyIDxQcm9wTmFtZT5HcmlkQ2VsbEtpbmQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjZmYwMGZmMzNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFsbENlbGxLaW5kcyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5jb25zdCBkYXJrVGhlbWUgPSB7XG4gICAgYWNjZW50Q29sb3I6IFwiIzhjOTZmZlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoMjAyLCAyMDYsIDI1NSwgMC4yNTMpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjZmZmZmZmXCIsXG4gICAgdGV4dE1lZGl1bTogXCIjYjhiOGI4XCIsXG4gICAgdGV4dExpZ2h0OiBcIiNhMGEwYTBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiNmZmZmZmZcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjYjhiOGI4XCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiMwMDAwMDBcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiNhMWExYTFcIixcbiAgICB0ZXh0SGVhZGVyU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdDZWxsOiBcIiMxNjE2MWJcIixcbiAgICBiZ0NlbGxNZWRpdW06IFwiIzIwMjAyN1wiLFxuICAgIGJnSGVhZGVyOiBcIiMyMTIxMjFcIixcbiAgICBiZ0hlYWRlckhhc0ZvY3VzOiBcIiM0NzQ3NDdcIixcbiAgICBiZ0hlYWRlckhvdmVyZWQ6IFwiIzQwNDA0MFwiLFxuXG4gICAgYmdCdWJibGU6IFwiIzIxMjEyMVwiLFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFwiIzQyM2MyNFwiLFxuXG4gICAgYm9yZGVyQ29sb3I6IFwicmdiYSgyMjUsMjI1LDIyNSwwLjIpXCIsXG4gICAgZHJpbGxkb3duQm9yZGVyOiBcInJnYmEoMjI1LDIyNSwyMjUsMC40KVwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmNvbnN0IGhvdGRvZ1N0YW5kID0ge1xuICAgIGFjY2VudENvbG9yOiBcIiM4Yzk2ZmZcIixcbiAgICBhY2NlbnRMaWdodDogXCJyZ2JhKDIwMiwgMjA2LCAyNTUsIDAuMjUzKVwiLFxuXG4gICAgdGV4dERhcms6IFwiI2ZmZmZmZlwiLFxuICAgIHRleHRNZWRpdW06IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpXCIsXG4gICAgdGV4dExpZ2h0OiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KVwiLFxuICAgIHRleHRCdWJibGU6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdJY29uSGVhZGVyOiBcIiM4ODAwMDBcIixcbiAgICBmZ0ljb25IZWFkZXI6IFwiI2ZmNTU1NVwiLFxuICAgIHRleHRIZWFkZXI6IFwicmdiYSgwLCAwLCAwLCAwLjkpXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiMwMDAwMDBcIixcblxuICAgIGJnQ2VsbDogXCIjZmYwMDAwXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNmZjRkNGRcIixcbiAgICBiZ0hlYWRlcjogXCIjZjNmMzAwXCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjZWVlZTAwXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNlMGUwMDBcIixcblxuICAgIGJnQnViYmxlOiBcIiNmZmZmMDBcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNmZmZmMDBcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiM0MjNjMjRcIixcblxuICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmMDBcIixcbiAgICBkcmlsbGRvd25Cb3JkZXI6IFwiI2ZmZmYwMFwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUaGVtZVN1cHBvcnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW3RoZW1lLCBzZXRUaGVtZV0gPSBSZWFjdC51c2VTdGF0ZTxQYXJ0aWFsPFRoZW1lPj4oe30pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMTAwMCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdSb3cgPSBudW1Sb3dzO1xuICAgICAgICBzZXROdW1Sb3dzKGN2ID0+IGN2ICsgMSk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoW2MsIG5ld1Jvd10sIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICB9XG4gICAgfSwgW251bVJvd3MsIHNldENlbGxWYWx1ZV0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YUdyaWQgcmVzcGVjdHMgdGhlIHRoZW1lIHByb3ZpZGVkIGJ5IHRoZSA8UHJvcE5hbWU+dGhlbWU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKHt9KX0+TGlnaHQ8L2J1dHRvbj4gb3J7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKGRhcmtUaGVtZSl9PkRhcms8L2J1dHRvbj4gZXZlbntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0VGhlbWUoaG90ZG9nU3RhbmQpfT5Ib3Rkb2cgU3RhbmQ8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgdGhlbWU9e3RoZW1lfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lU3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgVGhlbWVQZXJDb2x1bW46IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s0XSA9IHtcbiAgICAgICAgICAgIC4uLmNbNF0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s5XSA9IHtcbiAgICAgICAgICAgIC4uLmNbOV0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjWzEwXSA9IHtcbiAgICAgICAgICAgIC4uLmNbMTBdLFxuICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xuICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBiZ0ljb25IZWFkZXI6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudENvbG9yOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBhY2NlbnRMaWdodDogXCIjMDA5Q0E2MjBcIixcbiAgICAgICAgICAgICAgICBmZ0ljb25IZWFkZXI6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlRoZW1lIHBlciBjb2x1bW5cIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5FYWNoIGNvbHVtbiBjYW4gcHJvdmlkZSB0aGVtZSBvdmVycmlkZXMgZm9yIHJlbmRlcmluZyB0aGF0IGNvbHVtbi48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oVGhlbWVQZXJDb2x1bW4gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRoZW1lUGVyUm93OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgcGVyIHJvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRWFjaCByb3cgY2FuIHByb3ZpZGUgdGhlbWUgb3ZlcnJpZGVzIGZvciByZW5kZXJpbmcgdGhhdCByb3cgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmdldFJvd1RoZW1lT3ZlcnJpZGU8L1Byb3BOYW1lPiBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17aSA9PlxuICAgICAgICAgICAgICAgICAgICBpICUgMiA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmMGY4ZmZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzZjkwZTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgcm93cz17MV8wMDBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lUGVyUm93IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDZWxsQWN0aXZhdGVkRXZlbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW2xhc3RBY3RpdmF0ZWQsIHNldExhc3RBY3RpdmF0ZWRdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IG9uQ2VsbEFjdGl2YXRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChjZWxsOiBJdGVtKSA9PiB7XG4gICAgICAgIHNldExhc3RBY3RpdmF0ZWQoY2VsbCk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ2VsbCBBY3RpdmF0ZWQgZXZlbnRcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4geW91IHRhcCA8S2V5TmFtZT5FbnRlcjwvS2V5TmFtZT4sIDxLZXlOYW1lPlNwYWNlPC9LZXlOYW1lPiBvciBkb3VibGUgY2xpY2sgYSBjZWxsLCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsIGlzIGFjdGl2YXRlZC4gWW91IGNhbiB0cmFjayB0aGlzIHdpdGggPFByb3BOYW1lPm9uQ2VsbEFjdGl2YXRlZDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXN0IGFjdGl2YXRlZCBjZWxsOntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtsYXN0QWN0aXZhdGVkID09PSB1bmRlZmluZWQgPyBcIm5vbmVcIiA6IGAoJHtsYXN0QWN0aXZhdGVkWzBdfSwgJHtsYXN0QWN0aXZhdGVkWzFdfSlgfVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25DZWxsQWN0aXZhdGVkPXtvbkNlbGxBY3RpdmF0ZWR9XG4gICAgICAgICAgICAgICAgcm93cz17MTBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKENlbGxBY3RpdmF0ZWRFdmVudCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQnVpbHRJblNlYXJjaDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbc2hvd1NlYXJjaCwgc2V0U2hvd1NlYXJjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwia2V5ZG93blwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgZXZlbnQuY29kZSA9PT0gXCJLZXlGXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRTaG93U2VhcmNoKGN2ID0+ICFjdik7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pLFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNlYXJjaCBpcyBlYXN5XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZWFyY2ggZm9yIGFueSBkYXRhIGluIHlvdXIgZ3JpZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5zaG93U2VhcmNoPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEluIHRoaXMgc3RvcnksIDxLZXlOYW1lPkN0cmw8L0tleU5hbWU+ICg8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyA8S2V5TmFtZT5mPC9LZXlOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZXMgdGhlIHNlYXJjaCBiYXIuIE1ha2Ugc3VyZSB5b3UmYXBvcztyZSBmb2N1c2VkIG9uIHRoZSBEYXRhIEdyaWQhXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgc2hvd1NlYXJjaD17c2hvd1NlYXJjaH1cbiAgICAgICAgICAgICAgICBvblNlYXJjaENsb3NlPXsoKSA9PiBzZXRTaG93U2VhcmNoKGZhbHNlKX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQnVpbHRJblNlYXJjaCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW1wZXJhdGl2ZVNjcm9sbFByb3BzIHtcbiAgICBwYWRkaW5nWTogbnVtYmVyO1xuICAgIHBhZGRpbmdYOiBudW1iZXI7XG4gICAgdkFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG4gICAgaEFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG59XG5cbmV4cG9ydCBjb25zdCBJbXBlcmF0aXZlU2Nyb2xsOiBSZWFjdC5WRkM8SW1wZXJhdGl2ZVNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudD8uc2Nyb2xsVG8oNCwgOTksIFwiYm90aFwiLCBwLnBhZGRpbmdYLCBwLnBhZGRpbmdZLCB7XG4gICAgICAgICAgICB2QWxpZ246IHAudkFsaWduLFxuICAgICAgICAgICAgaEFsaWduOiBwLmhBbGlnbixcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkltcGVyYXRpdmUgc2Nyb2xsaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGltcGVyYXRpdmVseSBzY3JvbGwgdG8gYSBjZWxsIGJ5IGNhbGxpbmcgPFByb3BOYW1lPnNjcm9sbFRvPC9Qcm9wTmFtZT4gb24gYSBEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWNrIDxidXR0b24gb25DbGljaz17b25DbGlja30+SGVyZTwvYnV0dG9uPiB0byBzY3JvbGwgdG8gY29sdW1uIDQgcm93IDEwMFxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiY2xpY2thYmxlLW51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBwYWRkaW5nWTogMCxcbiAgICBwYWRkaW5nWDogMCxcbiAgICB2QWxpZ246IFwic3RhcnRcIixcbiAgICBoQWxpZ246IFwic3RhcnRcIixcbn07XG4oSW1wZXJhdGl2ZVNjcm9sbCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHBhZGRpbmdZOiAwLFxuICAgIHBhZGRpbmdYOiAwLFxuICAgIHZBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxuICAgIGhBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgU2ltcGxlTWVudSA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDE3NXB4O1xuICAgIHBhZGRpbmc6IDhweCAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNyksIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMzUpO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgZm9udC1zaXplOiAxM3B4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIFwiT3BlbiBTYW5zXCIsXG4gICAgICAgIFwiSGVsdmV0aWNhIE5ldWVcIiwgc2Fucy1zZXJpZjtcblxuICAgIC5kYW5nZXIge1xuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMC44KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgNDAsIDQwLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgID4gZGl2IHtcbiAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XG4gICAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTAwbXM7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgSGVhZGVyTWVudXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKGMgPT4gKHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIGNvbnN0IFttZW51LCBzZXRNZW51XSA9XG4gICAgICAgIFJlYWN0LnVzZVN0YXRlPHtcbiAgICAgICAgICAgIGNvbDogbnVtYmVyO1xuICAgICAgICAgICAgYm91bmRzOiBSZWN0YW5nbGU7XG4gICAgICAgIH0+KCk7XG5cbiAgICBjb25zdCBpc09wZW4gPSBtZW51ICE9PSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCB7IGxheWVyUHJvcHMsIHJlbmRlckxheWVyIH0gPSB1c2VMYXllcih7XG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgYXV0bzogdHJ1ZSxcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICAgICAgdHJpZ2dlck9mZnNldDogMixcbiAgICAgICAgb25PdXRzaWRlQ2xpY2s6ICgpID0+IHNldE1lbnUodW5kZWZpbmVkKSxcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG1lbnU/LmJvdW5kcy54ID8/IDAsXG4gICAgICAgICAgICAgICAgdG9wOiBtZW51Py5ib3VuZHMueSA/PyAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBtZW51Py5ib3VuZHMud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICByaWdodDogKG1lbnU/LmJvdW5kcy54ID8/IDApICsgKG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwKSxcbiAgICAgICAgICAgICAgICBib3R0b206IChtZW51Py5ib3VuZHMueSA/PyAwKSArIChtZW51Py5ib3VuZHMuaGVpZ2h0ID8/IDApLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkhlYWRlck1lbnVDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2w6IG51bWJlciwgYm91bmRzOiBSZWN0YW5nbGUpID0+IHtcbiAgICAgICAgc2V0TWVudSh7IGNvbCwgYm91bmRzIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2tlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coXCJIZWFkZXIgY2xpY2tlZFwiKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJIZWFkZXIgbWVudXNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIEhlYWRlcnMgb24gdGhlIGRhdGEgZ3JpZCBjYW4gYmUgY29uZmlndXJlZCB0byBzdXBwb3J0IG1lbnVzLiBXZSBwcm92aWRlIHRoZSBldmVudHMgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUsIHlvdSBwcm92aWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja2VkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtpc09wZW4gJiZcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcbiAgICAgICAgICAgICAgICAgICAgPFNpbXBsZU1lbnUgey4uLmxheWVyUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiBsZWZ0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRhbmdlclwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIZWFkZXJNZW51cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVySWNvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aXRsZTogXCJDVVNUT00gSUNPTlwiLFxuICAgICAgICAgICAgaWNvbjogXCJjdXN0b21cIixcbiAgICAgICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICBjb25zdCBoZWFkZXJJY29ucyA9IFJlYWN0LnVzZU1lbW88U3ByaXRlTWFwPigoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXN0b206IHAgPT4gYDxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgICAgICAgICAgPHJlY3QgeD1cIjIuMDAwMTVcIiB5PVwiMlwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiNFwiIGZpbGw9XCIke3AuYmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTQuNjk3NTkgNi4wMDk3N0M0LjIzNzM1IDYuMDA5NzcgMy44NjQyNiA2LjM4Mjg2IDMuODY0MjYgNi44NDMxQzMuODY0MjYgNy4zMDMzNCA0LjIzNzM1IDcuNjc2NDMgNC42OTc1OSA3LjY3NjQzSDguODY0MjZDOS4zMjQ1IDcuNjc2NDMgOS42OTc1OSA3LjMwMzM0IDkuNjk3NTkgNi44NDMxQzkuNjk3NTkgNi4zODI4NiA5LjMyNDQ5IDYuMDA5NzcgOC44NjQyNiA2LjAwOTc3SDQuNjk3NTlaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNy42MTQyNiA0Ljc2MDA5QzcuNjE0MjYgNC4yOTk4NSA3LjI0MTE2IDMuOTI2NzYgNi43ODA5MiAzLjkyNjc2QzYuMzIwNjkgMy45MjY3NiA1Ljk0NzU5IDQuMjk5ODUgNS45NDc1OSA0Ljc2MDA5TDUuOTQ3NTkgOC45MjY3NkM1Ljk0NzU5IDkuMzg3IDYuMzIwNjkgOS43NjAwOSA2Ljc4MDkyIDkuNzYwMDlDNy4yNDExNiA5Ljc2MDA5IDcuNjE0MjYgOS4zODY5OSA3LjYxNDI2IDguOTI2NzZMNy42MTQyNiA0Ljc2MDA5WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTExLjAzMzYgNi4wMDk3N0MxMC41NzM0IDYuMDA5NzcgMTAuMjAwMyA2LjM4Mjg2IDEwLjIwMDMgNi44NDMxQzEwLjIwMDMgNy4zMDMzNCAxMC41NzM0IDcuNjc2NDMgMTEuMDMzNiA3LjY3NjQzSDE1LjIwMDNDMTUuNjYwNSA3LjY3NjQzIDE2LjAzMzYgNy4zMDMzNCAxNi4wMzM2IDYuODQzMUMxNi4wMzM2IDYuMzgyODYgMTUuNjYwNSA2LjAwOTc3IDE1LjIwMDMgNi4wMDk3N0gxMS4wMzM2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTUuODk3MDQgMTAuOTkxNkM1LjU3MTYgMTAuNjY2MiA1LjA0Mzk3IDEwLjY2NjIgNC43MTg1MyAxMC45OTE2QzQuMzkzMDkgMTEuMzE3IDQuMzkzMDkgMTEuODQ0NyA0LjcxODUzIDEyLjE3MDFMNy42NjQ4MSAxNS4xMTY0QzcuOTkwMjQgMTUuNDQxOCA4LjUxNzg4IDE1LjQ0MTggOC44NDMzMiAxNS4xMTY0QzkuMTY4NzYgMTQuNzkxIDkuMTY4NzYgMTQuMjYzMyA4Ljg0MzMyIDEzLjkzNzlMNS44OTcwNCAxMC45OTE2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTguODQzMzIgMTIuMTcwM0M5LjE2ODc1IDExLjg0NDkgOS4xNjg3NSAxMS4zMTcyIDguODQzMzIgMTAuOTkxOEM4LjUxNzg4IDEwLjY2NjQgNy45OTAyNCAxMC42NjY0IDcuNjY0OCAxMC45OTE4TDQuNzE4NTMgMTMuOTM4MUM0LjM5MzA5IDE0LjI2MzUgNC4zOTMwOSAxNC43OTEyIDQuNzE4NTMgMTUuMTE2NkM1LjA0Mzk2IDE1LjQ0MiA1LjU3MTYgMTUuNDQyIDUuODk3MDQgMTUuMTE2Nkw4Ljg0MzMyIDEyLjE3MDNaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTEuODA0QzEwLjIwMDMgMTEuMzQzOCAxMC41NzM0IDEwLjk3MDcgMTEuMDMzNiAxMC45NzA3SDE1LjIwMDNDMTUuNjYwNSAxMC45NzA3IDE2LjAzMzYgMTEuMzQzOCAxNi4wMzM2IDExLjgwNEMxNi4wMzM2IDEyLjI2NDMgMTUuNjYwNSAxMi42Mzc0IDE1LjIwMDMgMTIuNjM3NEgxMS4wMzM2QzEwLjU3MzQgMTIuNjM3NCAxMC4yMDAzIDEyLjI2NDMgMTAuMjAwMyAxMS44MDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTQuMzA0QzEwLjIwMDMgMTMuODQzOCAxMC41NzM0IDEzLjQ3MDcgMTEuMDMzNiAxMy40NzA3SDE1LjIwMDNDMTUuNjYwNSAxMy40NzA3IDE2LjAzMzYgMTMuODQzOCAxNi4wMzM2IDE0LjMwNEMxNi4wMzM2IDE0Ljc2NDMgMTUuNjYwNSAxNS4xMzc0IDE1LjIwMDMgMTUuMTM3NEgxMS4wMzM2QzEwLjU3MzQgMTUuMTM3NCAxMC4yMDAzIDE0Ljc2NDMgMTAuMjAwMyAxNC4zMDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgIDwvc3ZnPmAsXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGhlYWRlciBpY29uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIG92ZXJyaWRlcyBmb3IgdGhlIGRlZmF1bHQgaWNvbnMgYnkgcGFzc2luZyB0aGUgPFByb3BOYW1lPmhlYWRlckljb25zPC9Qcm9wTmFtZT57XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIGhlYWRlckljb25zPXtoZWFkZXJJY29uc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlckljb25zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodEVsZW1lbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig4LCBmYWxzZSk7XG5cbiAgICBjb25zdCBjb2x1bW5zID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb2xzLm1hcChjID0+ICh7IC4uLmMsIGdyb3c6IDEgfSkpLCBbY29sc10pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMzAwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZShbYywgbmV3Um93XSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgIH1cbiAgICB9LCBbbnVtUm93cywgc2V0Q2VsbFZhbHVlXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSaWdodCBFbGVtZW50XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgRE9NIGVsZW1lbnQgbWF5IGJlIGFkZGVkIGFzIGEgdHJhaWxlciB0byB0aGUgZ3JpZCBieSB1c2luZyB0aGUgPFByb3BOYW1lPnJpZ2h0RWxlbWVudDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgaGludDogXCJOZXcgcm93Li4uXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17eyBzdGlja3k6IHRydWUgfX1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIyMHB4IDIwcHggNDBweCAyMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjUwLCAwLjIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwiMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjE1KVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wRmlsdGVyOiBcImJsdXIoMTJweClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBpcyBhIHJlYWwgRE9NIGVsZW1lbnQuIFlvdSBjYW4gcHV0IHdoYXRldmVyIHlvdSB3YW50IGhlcmUuIFlvdSBjYW4gYWxzbyBzaXplIGl0IGFzIGJpZyBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgeW91IHdhbnQuIHtcIlxcblxcblwifUl0IGFsc28gZG9lcyBub3QgaGF2ZSB0byBiZSBzdGlja3kuXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSaWdodEVsZW1lbnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxubGV0IG51bTogbnVtYmVyID0gMTtcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNl84MDcpICUgMl8xNDdfNDgzXzY0Nyk7XG59XG5cbmV4cG9ydCBjb25zdCBSYXBpZFVwZGF0ZXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3QgY291bnRSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgZGlzcGxheUNvdW50UmVmID0gUmVhY3QudXNlUmVmPEhUTUxFbGVtZW50PihudWxsKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCByYWZJRCA9IDA7XG5cbiAgICAgICAgY29uc3Qgc2VuZFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzOiB7XG4gICAgICAgICAgICAgICAgY2VsbDogSXRlbTtcbiAgICAgICAgICAgIH1bXSA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDUwMDA7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IE1hdGgubWF4KDEwLCByYW5kKCkgJSAxMDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHJhbmQoKSAlIDEwXzAwMDtcblxuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbY29sLCByb3ddLCB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB4LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHt4fWtgLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCAlIDUgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2YyZmZmNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMGQ0MWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2ZmZjZmNlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiNkNDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5vdyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHsgY2VsbDogW2NvbCwgcm93XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50UmVmLmN1cnJlbnQgKz0gNTAwMDtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5Q291bnRSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlDb3VudFJlZi5jdXJyZW50LnRleHRDb250ZW50ID0gYCR7Y291bnRSZWYuY3VycmVudH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWYuY3VycmVudD8udXBkYXRlQ2VsbHMoY2VsbHMpO1xuXG4gICAgICAgICAgICByYWZJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2VuZFVwZGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VuZFVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJRCk7XG4gICAgICAgIH07XG4gICAgfSwgW3NldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUmFwaWQgdXBkYXRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBjYW4gc3VwcG9ydCBtYW55IHRob3VzYW5kcyBvZiB1cGRhdGVzIHBlciBzZWNvbmRzLiBUaGUgZGF0YSBncmlkIGNhbiBlYXNpbHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGZhc3RlciB0aGFuIGEgaHVtYW4gY2FuIHJlYWQgaXQsIG1vcmUgaW1wb3J0YW50bHkgdGhlIGZhc3RlciB0aGUgZGF0YSBncmlkIGNhbiB1cGRhdGUsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZSB0aW1lIHlvdXIgY29kZSBjYW4gc3BlbmQgZG9pbmcgbW9yZSB2YWx1YWJsZSB3b3JrLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGVzIHByb2Nlc3NlZDogPEtleU5hbWUgcmVmPXtkaXNwbGF5Q291bnRSZWZ9IC8+IFdlIGNvdWxkIGRvIHRoaXMgZmFzdGVyIGJ1dCB3ZSB3cm90ZSBhXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsbHkgY3JhcHB5IGRhdGEgc3RvcmUgZm9yIHRoaXMgZGVtbyB3aGljaCBpcyBhY3R1YWxseSBzbG93aW5nIGRvd24gdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSYXBpZFVwZGF0ZXMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvcHlTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICAxMCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29weSBzdXBwb3J0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXJnZSBhbW91bnRzIG9mIGRhdGEgY2FuIGJlIGNvcGllZCBhbmQgY3VzdG9taXplZCB1c2luZ3tcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5nZXRDZWxsc0ZvclNlbGVjdGlvbjwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VGhlIGRhdGEgaXMgY29waWVkIGludG8gYSBmb3JtYXQgcmVhZHkgdG8gYmUgcGFzdGVkIGludG8gRXhjZWwgb3IgR29vZ2xlIFNoZWV0czwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJDb3B5IHNvbWV0aGluZyBiZWxvdyBhbmQgcGFzdGUgaXQgaGVyZS4uLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG1hcmdpbkJvdHRvbTogMjAsIGJvcmRlclJhZGl1czogOSwgbWluSGVpZ2h0OiAyMDAsIHBhZGRpbmc6IDEwIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb3B5U3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUGFzdGVTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA1MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUGFzdGUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZ3JpZCBjYW4gaGFuZGxlIHBhc3RlIGF1dG9tYXRpY2FsbHkgYnkgcmV0dXJuaW5nIHRydWUgZnJvbSA8UHJvcE5hbWU+b25QYXN0ZTwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgICAgICAuIFlvdSBjYW4gYWxzbyByZXR1cm4gZmFsc2UgYW5kIGhhbmRsZSBwYXN0ZSB5b3Vyc2VsZi4gSWYgcGFzdGUgaXMgdW5kZWZpbmVkIHRoZSBEYXRhRWRpdG9yIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIGl0cyBiZXN0IHRvIHBhc3RlIHRvIHRoZSBjdXJyZW50IGNlbGwuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFBhc3RlIHN1cHBvcnRzIHRoZSBjb3B5IGZvcm1hdCBvZiBHb29nbGUgU2hlZXRzIGFuZCBFeGNlbC4gQmVsb3cgaXMgYW4gZXhhbXBsZSBvZiBkYXRhIGNvcGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBleGNlbCB3aXRoIHNvbWUgZXNjYXBlZCB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtgU3VuZGF5XHREb2dzXHRodHRwczovL2dvb2dsZS5jb21cbk1vbmRheVx0Q2F0c1x0aHR0cHM6Ly9nb29nbGUuY29tXG5UdWVzZGF5XHRUdXJ0bGVzXHRodHRwczovL2dvb2dsZS5jb21cbldlZG5lc2RheVx0QmVhcnNcdGh0dHBzOi8vZ29vZ2xlLmNvbVxuVGh1cnNkYXlcdFwiTCAgaW9uc1wiXHRodHRwczovL2dvb2dsZS5jb21cbkZyaWRheVx0UGlnc1x0aHR0cHM6Ly9nb29nbGUuY29tXG5TYXR1cmRheVx0XCJUdXJrZXlzIGFuZCBzb21lIFwiXCJxdW90ZXNcIlwiIGFuZFxuYSBuZXcgbGluZSBjaGFyIFwiXCJtb3JlIHF1b3Rlc1wiXCIgcGx1cyBhIHRhYiAgLlwiXHRodHRwczovL2dvb2dsZS5jb21gfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBtYXJnaW5Cb3R0b206IDIwLCBib3JkZXJSYWRpdXM6IDksIG1pbkhlaWdodDogMjAwLCBwYWRkaW5nOiAxMCB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihQYXN0ZVN1cHBvcnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEZyZWV6ZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkZyZWV6ZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgZ3JpZCBjYW4gYmUgZnJvemVuIGluIHBsYWNlIGJ5IHNldHRpbmdze1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+ZnJlZXplQ29sdW1uczwvUHJvcE5hbWU+IHRvIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXsxfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17YyA9PiBjID4gMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEZyZWV6ZUNvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFJlb3JkZXJSb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29scyA9IFJlYWN0LnVzZU1lbW88R3JpZENvbHVtbltdPihcbiAgICAgICAgKCkgPT4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkNvbCBBXCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQ29sIEJcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgW3Jvd0RhdGEsIHNldFJvd0RhdGFdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgNTApLm1hcCh4ID0+IFtgQTogJHt4fWAsIGBCOiAke3h9YF0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjazxEYXRhRWRpdG9yUHJvcHNbXCJnZXRDZWxsQ29udGVudFwiXT4oXG4gICAgICAgIChbY29sLCByb3ddKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogcm93RGF0YVtyb3ddW2NvbF0sXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IHJvd0RhdGFbcm93XVtjb2xdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW3Jvd0RhdGFdXG4gICAgKTtcblxuICAgIGNvbnN0IHJlb3JkZXJSb3dzID0gUmVhY3QudXNlQ2FsbGJhY2soKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRSb3dEYXRhKGN2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBbLi4uY3ZdO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGQuc3BsaWNlKGZyb20sIDEpO1xuICAgICAgICAgICAgZC5zcGxpY2UodG8sIDAsIC4uLnJlbW92ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlb3JkZXIgUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgUm93cyBjYW4gYmUgcmUtYXJyYW5nZWQgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5vblJvd01vdmVkPC9Qcm9wTmFtZT4gY2FsbGJhY2suIFdoZW4gc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3Qgcm93IGNhbiBiZSB1c2VkIHRvIGRyYWcgYW5kIGRyb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUm93TW92ZWQ9e3Jlb3JkZXJSb3dzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJlb3JkZXJSb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb2x1bW5Hcm91cHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAsIHRydWUsIHRydWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29sdW1uIEdyb3VwaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgaW4gdGhlIGRhdGEgZ3JpZCBtYXkgYmUgZ3JvdXBlZCBieSBzZXR0aW5nIHRoZWlyIDxQcm9wTmFtZT5ncm91cDwvUHJvcE5hbWU+IHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBvbkdyb3VwSGVhZGVyUmVuYW1lZD17KHgsIHkpID0+IHdpbmRvdy5hbGVydChgUGxlYXNlIHJlbmFtZSBncm91cCAke3h9IHRvICR7eX1gKX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17ZyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBnLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBnID09PSBcIlwiID8gdW5kZWZpbmVkIDogR3JpZENvbHVtbkljb24uSGVhZGVyQ29kZSxcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ29sdW1uR3JvdXBzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBTdHJldGNoQ29sdW1uU2l6ZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uLCBvbkNvbHVtblJlc2l6ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBoYXNSZXNpemVkID0gUmVhY3QudXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKCh4LCBpKSA9PiAoeyAuLi54LCBncm93OiBoYXNSZXNpemVkLmN1cnJlbnQuaGFzKGkpID8gdW5kZWZpbmVkIDogKDUgKyBpKSAvIDUgfSkpO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb2x1bW4gR3Jvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDb2x1bW5zIGluIHRoZSBkYXRhIGdyaWQgbWF5IGJlIHNldCB0byBncm93IHRvIGZpbGwgc3BhY2UgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPmdyb3c8L1Byb3BOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgcHJvcC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17KGNvbCwgX25ld1NpemUsIGNvbEluZGV4LCBuZXdTaXplV2l0aEdyb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVzaXplZC5jdXJyZW50LmFkZChjb2xJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplKGNvbCwgbmV3U2l6ZVdpdGhHcm93KTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTdHJldGNoQ29sdW1uU2l6ZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiB1c2VDb2xsYXBzYWJsZUNvbHVtbkdyb3Vwcyhjb2xzOiByZWFkb25seSBHcmlkQ29sdW1uW10pIHtcbiAgICBjb25zdCBbY29sbGFwc2VkLCBzZXRDb2xsYXBzZWRdID0gUmVhY3QudXNlU3RhdGU8cmVhZG9ubHkgc3RyaW5nW10+KFtdKTtcblxuICAgIGNvbnN0IG9uR3JvdXBIZWFkZXJDbGlja2VkID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjb2xJbmRleDogbnVtYmVyLCBhcmdzOiBHcm91cEhlYWRlckNsaWNrZWRFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gY29sc1tjb2xJbmRleF0uZ3JvdXAgPz8gXCJcIjtcbiAgICAgICAgICAgIHNldENvbGxhcHNlZChjdiA9PiAoY3YuaW5jbHVkZXMoZ3JvdXApID8gY3YuZmlsdGVyKGcgPT4gZyAhPT0gZ3JvdXApIDogWy4uLmN2LCBncm91cF0pKTtcbiAgICAgICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNdXG4gICAgKTtcblxuICAgIGNvbnN0IFtzZWxlY3RlZENvbHVtbnMsIHNldFNlbGVjdGVkQ29sdW1uc10gPSBSZWFjdC51c2VTdGF0ZTxDb21wYWN0U2VsZWN0aW9uPihDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCkpO1xuXG4gICAgY29uc3Qgc2V0Q29scyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdWYWw6IENvbXBhY3RTZWxlY3Rpb24sIHRyaWdnZXI6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodHJpZ2dlciA9PT0gXCJncm91cFwiKSByZXR1cm47XG5cbiAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKG5ld1ZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY29scy5tYXAoYyA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbGxhcHNlZC5pbmNsdWRlcyhjLmdyb3VwID8/IFwiXCIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICAgIGhhc01lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgICAgICB3aWR0aDogOCxcbiAgICAgICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvbGxhcHNlZCwgY29sc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgb25Hcm91cEhlYWRlckNsaWNrZWQsXG4gICAgICAgIHNlbGVjdGVkQ29sdW1ucyxcbiAgICAgICAgb25TZWxlY3RlZENvbHVtbnNDaGFuZ2U6IHNldENvbHMsXG4gICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkdyb3VwQ29sbGFwc2U6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAsIHRydWUsIHRydWUpO1xuXG4gICAgY29uc3QgZ3JvdXBIZWFkZXJBcmdzID0gdXNlQ29sbGFwc2FibGVDb2x1bW5Hcm91cHMoY29scyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJHcm91cCBjb2xsYXBzZVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3VnaCBjbGV2ZXIgdXNhZ2Ugb2YgPFByb3BOYW1lPm9uR3JvdXBIZWFkZXJDbGlja2VkPC9Qcm9wTmFtZT4geW91IGNhbiBpbXBsZW1lbnQgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNpbmcuIFRoaXMgaXMgYSB2ZXJ5IGJhc2ljIHZlcnNpb24gaG93ZXZlciBpdCBpcyBwb3NzaWJsZSB0byBnbyBtdWNoIGZ1cnRoZXIuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5DZWxscyB1bmRlciBhIGNlcnRhaW4gc2l6ZSB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbmRlciB0byBzYXZlIHNvbWUgZnJhbWVzLjwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5ncm91cEhlYWRlckFyZ3N9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXsyNH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb2x1bW5Hcm91cENvbGxhcHNlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBNaW5pbWFwOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJNaW5pbWFwXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbWluaW1hcCBjYW4gYmUgZW5hYmxlZCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+c2hvd01pbmltYXA8L1Byb3BOYW1lPiBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBzaG93TWluaW1hcD17dHJ1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXszMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihNaW5pbWFwIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb250ZW50QWxpZ25tZW50OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgX3Jvd10gPSBjZWxsO1xuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdldENlbGxDb250ZW50KGNlbGwpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5nZXRDZWxsQ29udGVudChjZWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb250ZW50IEFsaWdubWVudFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgY29udGVudCBhbGlnbm1lbnQgYnkgc2V0dGluZyA8UHJvcE5hbWU+Y29udGVudEFsaWduPC9Qcm9wTmFtZT4gb2YgYSBjZWxsIHRve1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+bGVmdDwvUHJvcE5hbWU+LCA8UHJvcE5hbWU+cmlnaHQ8L1Byb3BOYW1lPiBvciA8UHJvcE5hbWU+Y2VudGVyPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvciB7Li4uZGVmYXVsdFByb3BzfSBnZXRDZWxsQ29udGVudD17bWFuZ2xlZEdldENlbGxDb250ZW50fSBjb2x1bW5zPXtjb2xzfSByb3dzPXszMDB9IC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFJvd0hvdmVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IFtob3ZlclJvdywgc2V0SG92ZXJSb3ddID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgW18sIHJvd10gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICBzZXRIb3ZlclJvdyhhcmdzLmtpbmQgIT09IFwiY2VsbFwiID8gdW5kZWZpbmVkIDogcm93KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2s8R2V0Um93VGhlbWVDYWxsYmFjaz4oXG4gICAgICAgIHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAocm93ICE9PSBob3ZlclJvdykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmN2Y3ZjdcIixcbiAgICAgICAgICAgICAgICBiZ0NlbGxNZWRpdW06IFwiI2YwZjBmMFwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW2hvdmVyUm93XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSb3cgSG92ZXIgRWZmZWN0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRocm91Z2ggY2FyZWZ1bCB1c2FnZSBvZiB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBjYWxsYmFjayBpdCBpcyBwb3NzaWJsZSB0byBlYXNpbHlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlIGEgcm93IGhvdmVyIGVmZmVjdC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17b25JdGVtSG92ZXJlZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNwYW5DZWxsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwLCB0cnVlLCB0cnVlKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAocm93ID09PSA2ICYmIGNvbCA+PSAzICYmIGNvbCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IFszLCA0XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPT09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJTcGFuIENlbGwgdGhhdCBpcyB2ZXJ5IGxvbmcgYW5kIHdpbGwgZ28gcGFzdCB0aGUgY2VsbCBsaW1pdHNcIixcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogWzAsIDk5XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRDZWxsc0ZvclNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoc2VsZWN0aW9uOiBSZWN0YW5nbGUpOiBDZWxsQXJyYXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBHcmlkQ2VsbFtdW10gPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHNlbGVjdGlvbi55OyB5IDwgc2VsZWN0aW9uLnkgKyBzZWxlY3Rpb24uaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3c6IEdyaWRDZWxsW10gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gc2VsZWN0aW9uLng7IHggPCBzZWxlY3Rpb24ueCArIHNlbGVjdGlvbi53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKG1hbmdsZWRHZXRDZWxsQ29udGVudChbeCwgeV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgW21hbmdsZWRHZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiU3BhbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgQnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnNwYW48L1Byb3BOYW1lPiBvZiBhIGNlbGwgeW91IGNhbiBjcmVhdGUgc3BhbnMgaW4geW91ciBncmlkLiBBbGwgY2VsbHNcbiAgICAgICAgICAgICAgICAgICAgd2l0aGluIGEgc3BhbiBtdXN0IHJldHVybiBjb25zaXN0ZW50IGRhdGEgZm9yIGRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNwYW5zIHdpbGwgYWx3YXlzIGJlIHNwbGl0IGlmIHRoZXkgc3BhbiBmcm96ZW4gYW5kIG5vbi1mcm96ZW4gY29sdW1ucy4gQnkgZGVmYXVsdCBzZWxlY3Rpb25zIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzIGV4cGFuZGVkIHRvIGluY2x1ZGUgYSBzcGFuLiBUaGlzIGNhbiBiZSBkaXNhYmxlZCB1c2luZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+c3BhblJhbmdlQmVoYXZpb3I8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17Mn1cbiAgICAgICAgICAgICAgICByb3dzPXszMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNwYW5DZWxsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHplcm9Cb3VuZHMgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICByaWdodDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBUb29sdGlwczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3Rvb2x0aXAsIHNldFRvb2x0aXBdID0gUmVhY3QudXNlU3RhdGU8eyB2YWw6IHN0cmluZzsgYm91bmRzOiBJQm91bmRzIH0gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gXCJjZWxsXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHNldFRvb2x0aXAodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBgVG9vbHRpcCBmb3IgJHthcmdzLmxvY2F0aW9uWzBdfSwgJHthcmdzLmxvY2F0aW9uWzFdfWAsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIHJlYWN0LWxhYWcgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFyZ3MuYm91bmRzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGFyZ3MuYm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGFyZ3MuYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBhcmdzLmJvdW5kcy54ICsgYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGFyZ3MuYm91bmRzLnkgKyBhcmdzLmJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IDA7XG4gICAgICAgICAgICBzZXRUb29sdGlwKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpLCBbXSk7XG5cbiAgICBjb25zdCBpc09wZW4gPSB0b29sdGlwICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyByZW5kZXJMYXllciwgbGF5ZXJQcm9wcyB9ID0gdXNlTGF5ZXIoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDQsXG4gICAgICAgIGF1dG86IHRydWUsXG4gICAgICAgIGNvbnRhaW5lcjogXCJwb3J0YWxcIixcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiB0b29sdGlwPy5ib3VuZHMgPz8gemVyb0JvdW5kcyxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiVG9vbHRpcHNcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvdWJsZVwiXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBVc2luZyB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBldmVudCBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSB0b29sdGlwcy4gVGhpcyBzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgaXMgaW50ZW50aW9uYWxseSBmb3JjZWQgdG8gc2Nyb2xsIHZlcnRpY2FsbHkgc28gbGF5b3V0IGluIHNjcm9sbGluZyBkb2N1bWVudHMgY2FuIGJlIGNvbmZpcm1lZC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICB9PlxuICAgICAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9e29uSXRlbUhvdmVyZWR9XG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICAgICAgICAge2lzT3BlbiAmJlxuICAgICAgICAgICAgICAgIHJlbmRlckxheWVyKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ubGF5ZXJQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGF5ZXJQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjhweCAxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250OiBcIjUwMCAxM3B4IEludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC44NSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0b29sdGlwLnZhbH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgPC8+XG4gICAgKTtcbn07XG4oVG9vbHRpcHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvbnRyb2xsZWRTZWxlY3Rpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigzMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkNvbnRyb2xsZWQgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBzZWxlY3Rpb24gb2YgdGhlIGdyaWQgY2FuIGJlIGNvbnRyb2xsZWQgdmlhIDxQcm9wTmFtZT5HcmlkU2VsZWN0aW9uPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25HcmlkU2VsZWN0aW9uQ2hhbmdlPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbj17MH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heD17Mjl9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2VsZWN0aW9uLmN1cnJlbnQ/LmNlbGxbMF0gPz8gMH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2wgPSBlLnRhcmdldC52YWx1ZUFzTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvbihjdiA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbDogW25ld0NvbCwgY3YuY3VycmVudD8uY2VsbFsxXSA/PyAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbmV3Q29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN2LmN1cnJlbnQ/LmNlbGxbMV0gPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFjazogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4PXs5OX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxlY3Rpb24uY3VycmVudD8uY2VsbFsxXSA/PyAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGUudGFyZ2V0LnZhbHVlQXNOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKGN2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsOiBbY3YuY3VycmVudD8uY2VsbFswXSA/PyAwLCBuZXdSb3ddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjdi5jdXJyZW50Py5jZWxsWzBdID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogbmV3Um93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTmV3Q29sdW1uQnV0dG9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAsIHRydWUpO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29scy5tYXAoYyA9PiAoeyAuLi5jLCBncm93OiAxIH0pKSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk5ldyBjb2x1bW4gYnV0dG9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbmV3IGNvbHVtbiBidXR0b24gY2FuIGJlIGNyZWF0ZWQgdXNpbmcgdGhlIDxQcm9wTmFtZT5yaWdodEVsZW1lbnQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8Q29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB3aW5kb3cuYWxlcnQoXCJBZGQgYSBjb2x1bW4hXCIpfT4rPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvQ29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17e1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkcmF3SGVhZGVyOiBEcmF3SGVhZGVyQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhhcmdzID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxnID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHJlY3QueSwgMCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICBsZy5hZGRDb2xvclN0b3AoMCwgXCIjZmYwMGQ5MzRcIik7XG4gICAgICAgIGxnLmFkZENvbG9yU3RvcCgxLCBcIiMwMGEyZmYzNFwiKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxnO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gSGVhZGVyXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5NYWtlIGl0IGFzIGZhbmN5IGFzIHlvdSBsaWtlLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtkcmF3SGVhZGVyfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlciBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUGFkZGluZ1Byb3BzIHtcbiAgICBwYWRkaW5nUmlnaHQ6IG51bWJlcjtcbiAgICBwYWRkaW5nQm90dG9tOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBQYWRkaW5nOiBSZWFjdC5WRkM8UGFkZGluZ1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlBhZGRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWRkIHBhZGRpbmcgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnBhZGRpbmdSaWdodDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5wYWRkaW5nQm90dG9tPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt7IHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdUeXBlcyA9IHtcbiAgICBwYWRkaW5nUmlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwYWRkaW5nQm90dG9tOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogNjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdzID0ge1xuICAgIHBhZGRpbmdSaWdodDogMjAwLFxuICAgIHBhZGRpbmdCb3R0b206IDIwMCxcbn07XG4oUGFkZGluZyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHRDZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgW2dyaWRTZWxlY3Rpb24sIHNldEdyaWRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGhpZ2hsaWdodHMgPSBSZWFjdC51c2VNZW1vPERhdGFFZGl0b3JQcm9wc1tcImhpZ2hsaWdodFJlZ2lvbnNcIl0+KCgpID0+IHtcbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGw7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFwiIzQ0QkIwMDIyXCIsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29sICsgMixcbiAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjYjAwMGIwMjFcIixcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJvdyArIDIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSwgW2dyaWRTZWxlY3Rpb25dKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkhpZ2hsaWdodENlbGxzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSA8UHJvcE5hbWU+aGlnaGxpZ2h0UmVnaW9uczwvUHJvcE5hbWU+IHByb3AgY2FuIGJlIHNldCB0byBwcm92aWRlIGFkZGl0aW9uYWwgaGludGluZyBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtncmlkU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17c2V0R3JpZFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdmVydGljYWxCb3JkZXI9e2MgPT4gYyA+IDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIaWdobGlnaHRDZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgTGF5b3V0SW50ZWdyYXRpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAwLCB0cnVlLCB0cnVlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxTdHlsZT5cbiAgICAgICAgICAgIDxoMT5MYXlvdXQgSW50ZWdyYXRpb248L2gxPlxuICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRyeWluZyB0aGUgZ3JpZCBpbiBkaWZmZXJlbnQgc2l0dWF0aW9uczwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBoZWlnaHQ6IFwiMzAwcHhcIiB9fT5cbiAgICAgICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTB9XG4gICAgICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleFNocmluazogMCB9fT5UaGlzIGlzIHNvbWUgdGV4dCB3aGF0IGhhcHBlbnMgaGVyZT88L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuKExheW91dEludGVncmF0aW9uIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBEcmFnU291cmNlOiBSZWFjdC5WRkM8eyBpc0RyYWdnYWJsZTogYm9vbGVhbiB8IFwiaGVhZGVyXCIgfCBcImNlbGxcIiB9PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigyMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhZyBzb3VyY2VcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmcgdGhlIDxQcm9wTmFtZT5pc0RyYWdnYWJsZTwvUHJvcE5hbWU+IHByb3AgY2FuIGFsbG93IGZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wgb3ZlciB3aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyBkcmFnZ2FibGUgaW4gdGhlIGdyaWQgdmlhIEhUTUwgZHJhZyBhbmQgZHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17KHMsIGUpID0+IHdpbmRvdy5hbGVydChgTW92ZWQgcm93ICR7c30gdG8gJHtlfWApfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9eyhzLCBlKSA9PiB3aW5kb3cuYWxlcnQoYE1vdmVkIGNvbCAke3N9IHRvICR7ZX1gKX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIFwiRHJhZyBkYXRhIGhlcmUhXCIpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJhZ1NvdXJjZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGlzRHJhZ2dhYmxlOiB7XG4gICAgICAgIGNvbnRyb2w6IHsgdHlwZTogXCJzZWxlY3RcIiwgb3B0aW9uczogW3RydWUsIGZhbHNlLCBcImNlbGxcIiwgXCJoZWFkZXJcIl0gfSxcbiAgICB9LFxufTtcbihEcmFnU291cmNlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG59O1xuKERyYWdTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUHJldmVudERpYWdvbmFsU2Nyb2xsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlByZXZlbnQgRGlhZ29uYWwgU2Nyb2xsXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBEaWFnb25hbCBzY3JvbGxpbmcgY2FuIGJlIHByZXZlbnRlZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5wcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUHJldmVudERpYWdvbmFsU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbi8vIEEgZmV3IHN1cHBvcnRlZCBtaW1lIHR5cGVzIGZvciBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMuXG5jb25zdCBTVVBQT1JURURfSU1BR0VfVFlQRVMgPSBuZXcgU2V0KFtcImltYWdlL3BuZ1wiLCBcImltYWdlL2dpZlwiLCBcImltYWdlL2JtcFwiLCBcImltYWdlL2pwZWdcIl0pO1xuXG5leHBvcnQgY29uc3QgRHJvcEV2ZW50czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbaGlnaGxpZ2h0cywgc2V0SGlnaGxpZ2h0c10gPSBSZWFjdC51c2VTdGF0ZTxEYXRhRWRpdG9yUHJvcHNbXCJoaWdobGlnaHRSZWdpb25zXCJdPihbXSk7XG5cbiAgICBjb25zdCBbbGFzdERyb3BDZWxsLCBzZXRMYXN0RHJvcENlbGxdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IG9uRHJvcCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoY2VsbDogSXRlbSwgZGF0YVRyYW5zZmVyOiBEYXRhVHJhbnNmZXIgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBmaWxlcyB9ID0gZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IHN1cHBvcnRzIG9uZSBpbWFnZSwgZm9yIHNpbXBsaWNpdHkuXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBbZmlsZV0gPSBmaWxlcztcbiAgICAgICAgICAgIGlmICghU1VQUE9SVEVEX0lNQUdFX1RZUEVTLmhhcyhmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbWdVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuXG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoXG4gICAgICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5JbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2ltZ1VybF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzZXRMYXN0RHJvcENlbGwoY2VsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtzZXRDZWxsVmFsdWVdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ092ZXJDZWxsID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjZWxsOiBJdGVtLCBkYXRhVHJhbnNmZXI6IERhdGFUcmFuc2ZlciB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IGRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIC8vIFRoaXMgb25seSBzdXBwb3J0cyBvbmUgaW1hZ2UsIGZvciBzaW1wbGljaXR5LlxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2l0ZW1dID0gaXRlbXM7XG4gICAgICAgICAgICBpZiAoIVNVUFBPUlRFRF9JTUFHRV9UWVBFUy5oYXMoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAoZ2V0Q2VsbENvbnRlbnQoY2VsbCkua2luZCA9PT0gR3JpZENlbGxLaW5kLkltYWdlKSB7XG4gICAgICAgICAgICAgICAgc2V0SGlnaGxpZ2h0cyhbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiM0NEJCMDAyMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEhpZ2hsaWdodHMoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ0xlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJEcm9wIGV2ZW50c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMgYnkgdXNpbmcgPFByb3BOYW1lPm9uRHJhZ092ZXJDZWxsPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPm9uRHJvcDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7bGFzdERyb3BDZWxsID09PSB1bmRlZmluZWQgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPk5vdGhpbmcgZHJvcHBlZCwgeWV0PC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWW91IGxhc3QgZHJvcHBlZCBpbiBjZWxsIDxQcm9wTmFtZT57SlNPTi5zdHJpbmdpZnkobGFzdERyb3BDZWxsKX08L1Byb3BOYW1lPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uRHJvcD17b25Ecm9wfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtvbkRyYWdPdmVyQ2VsbH1cbiAgICAgICAgICAgICAgICBvbkRyYWdMZWF2ZT17b25EcmFnTGVhdmV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibm9uZVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJvcEV2ZW50cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-editor/stories/packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx\",\"webpack://./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx\"],\"names\":[\".k1txkgwh\",\".s11gjm00\"],\"mappings\":\"AAk3CMA,UAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA;AAkuBAC,UAAAA,WAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,0EAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,sBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,+HAAAA,CAAAA,CAAAA,kBAAAA,yBAAAA,CAAAA,CAAAA,wBAAAA,uBAAAA,CAAAA,CAAAA,gBAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,iCAAAA,CAAAA,qBAAAA,CAAAA;ACllEN,m26JAAm26J\",\"sourcesContent\":[\"/* eslint-disable sonarjs/no-identical-functions */\\n/* eslint-disable sonarjs/no-duplicate-string */\\nimport * as React from \\\"react\\\";\\n\\nimport {\\n    CellArray,\\n    CompactSelection,\\n    DrawHeaderCallback,\\n    GridCell,\\n    GridCellKind,\\n    GridColumn,\\n    GridColumnIcon,\\n    GridMouseEventArgs,\\n    GridSelection,\\n    GroupHeaderClickedEventArgs,\\n    isEditableGridCell,\\n    Item,\\n    Rectangle,\\n} from \\\"../../data-grid/data-grid-types\\\";\\nimport { DataEditor, DataEditorProps } from \\\"../data-editor\\\";\\n\\nimport faker from \\\"faker\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport { SimpleThemeWrapper } from \\\"../../stories/story-utils\\\";\\nimport { useEventListener } from \\\"../../common/utils\\\";\\nimport { IBounds, useLayer } from \\\"react-laag\\\";\\nimport type { SpriteMap } from \\\"../../data-grid/data-grid-sprites\\\";\\nimport type { DataEditorRef, Theme } from \\\"../..\\\";\\nimport range from \\\"lodash/range.js\\\";\\nimport {\\n    useMockDataGenerator,\\n    BeautifulWrapper,\\n    Description,\\n    MoreInfo,\\n    PropName,\\n    lossyCopyData,\\n    getGridColumn,\\n    GridColumnWithMockingInfo,\\n    ContentCache,\\n    BeautifulStyle,\\n    ColumnAddButton,\\n} from \\\"./utils\\\";\\nimport noop from \\\"lodash/noop.js\\\";\\nimport type { GetRowThemeCallback } from \\\"../../data-grid/data-grid-render\\\";\\n\\nexport default {\\n    title: \\\"Glide-Data-Grid/DataEditor Demos\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <Story />\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst defaultProps: Partial<DataEditorProps> = {\\n    smoothScrollX: true,\\n    smoothScrollY: true,\\n    isDraggable: false,\\n    getCellsForSelection: true,\\n    rowMarkers: \\\"none\\\",\\n    width: \\\"100%\\\",\\n};\\n\\nexport const ResizableColumns: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, getCellsForSelection } = useMockDataGenerator(60);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Resizable columns\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can resize columns by dragging their edges, as long as you respond to the{\\\" \\\"}\\n                        <PropName>onColumnResize</PropName> prop.\\n                    </Description>\\n                    <MoreInfo>\\n                        By setting the <PropName>overscrollX</PropName> property extra space can be allocated at the end\\n                        of the grid to allow for easier resizing of the final column. You can highlight multiple columns\\n                        to resize them all at once.\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                overscrollX={200}\\n                overscrollY={200}\\n                maxColumnAutoWidth={500}\\n                maxColumnWidth={2000}\\n                rows={50}\\n                onColumnResize={onColumnResize}\\n                getCellsForSelection={getCellsForSelection}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ResizableColumns as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\ninterface OverscrollProps {\\n    overscrollX: number;\\n    overscrollY: number;\\n}\\n\\nexport const Overscroll: React.VFC<OverscrollProps> = p => {\\n    const { overscrollX, overscrollY } = p;\\n    const { cols, getCellContent } = useMockDataGenerator(20);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Overscroll\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can allocate extra space at the ends of the grid by setting the{\\\" \\\"}\\n                        <PropName>overscrollX</PropName> and <PropName>overscrollY</PropName> props\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                overscrollX={overscrollX}\\n                overscrollY={overscrollY}\\n                rows={50}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(Overscroll as any).argTypes = {\\n    overscrollX: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 0,\\n            max: 600,\\n        },\\n    },\\n    overscrollY: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 0,\\n            max: 600,\\n        },\\n    },\\n};\\n(Overscroll as any).args = {\\n    overscrollX: 200,\\n    overscrollY: 200,\\n};\\n(Overscroll as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nfunction clearCell(cell: GridCell): GridCell {\\n    switch (cell.kind) {\\n        case GridCellKind.Boolean: {\\n            return {\\n                ...cell,\\n                data: false,\\n            };\\n        }\\n        case GridCellKind.Image: {\\n            return {\\n                ...cell,\\n                data: [],\\n                displayData: [],\\n            };\\n        }\\n        case GridCellKind.Drilldown:\\n        case GridCellKind.Bubble: {\\n            return {\\n                ...cell,\\n                data: [],\\n            };\\n        }\\n        case GridCellKind.Uri:\\n        case GridCellKind.Markdown: {\\n            return {\\n                ...cell,\\n                data: \\\"\\\",\\n            };\\n        }\\n        case GridCellKind.Text: {\\n            return {\\n                ...cell,\\n                data: \\\"\\\",\\n                displayData: \\\"\\\",\\n            };\\n        }\\n        case GridCellKind.Number: {\\n            return {\\n                ...cell,\\n                data: 0,\\n                displayData: \\\"\\\",\\n            };\\n        }\\n    }\\n    return cell;\\n}\\n\\nexport const AddData: React.VFC = () => {\\n    const { cols, getCellContent, setCellValueRaw, setCellValue, getCellsForSelection } = useMockDataGenerator(\\n        60,\\n        false\\n    );\\n\\n    const [numRows, setNumRows] = React.useState(50);\\n\\n    const onRowAppended = React.useCallback(() => {\\n        const newRow = numRows;\\n        for (let c = 0; c < 6; c++) {\\n            const cell = getCellContent([c, newRow]);\\n            setCellValueRaw([c, newRow], clearCell(cell));\\n        }\\n        setNumRows(cv => cv + 1);\\n    }, [getCellContent, numRows, setCellValueRaw]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Add data\\\"\\n            description={\\n                <>\\n                    <Description>Data can be added by clicking on the trailing row.</Description>\\n                    <MoreInfo>\\n                        Keyboard is also supported, just navigate past the last row and press <KeyName>Enter</KeyName>\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                getCellsForSelection={getCellsForSelection}\\n                rowMarkers={\\\"both\\\"}\\n                onPaste={true}\\n                onCellEdited={setCellValue}\\n                trailingRowOptions={{\\n                    sticky: true,\\n                    tint: true,\\n                    hint: \\\"New row...\\\",\\n                }}\\n                rows={numRows}\\n                onRowAppended={onRowAppended}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(AddData as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const RightToLeft: React.VFC = () => {\\n    const { cols, getCellContent, setCellValue, onColumnResize } = useMockDataGenerator(60, false);\\n\\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\\n        item => {\\n            const [col, _row] = item;\\n            if (col !== 0) return getCellContent(item);\\n            return {\\n                kind: GridCellKind.Text,\\n                allowOverlay: true,\\n                data: \\\" ,   .\\\",\\n                displayData: \\\" ,   .\\\",\\n                allowWrapping: true,\\n            };\\n        },\\n        [getCellContent]\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Right \\\"\\n            description={\\n                <>\\n                    <Description>The data editor automatically detects RTL in text cells and respects it.</Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContentMangled}\\n                columns={cols}\\n                onColumnResize={onColumnResize}\\n                getCellsForSelection={true}\\n                rowMarkers={\\\"both\\\"}\\n                onPaste={true}\\n                onCellEdited={setCellValue}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(RightToLeft as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ValidateData: React.VFC = () => {\\n    const { cols, getCellContent, setCellValue, getCellsForSelection } = useMockDataGenerator(60, false);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Validate data\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Data can be validated using the <PropName>validateCell</PropName> callback\\n                    </Description>\\n                    <MoreInfo>This example only allows the word &quot;Valid&quot; inside text cells.</MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                getCellsForSelection={getCellsForSelection}\\n                rowMarkers={\\\"both\\\"}\\n                onPaste={true}\\n                onCellEdited={setCellValue}\\n                rows={100}\\n                validateCell={(_cell, newValue) => {\\n                    if (newValue.kind !== GridCellKind.Text) return true;\\n                    if (newValue.data === \\\"Valid\\\") return true;\\n                    if (newValue.data.toLowerCase() === \\\"valid\\\") {\\n                        return {\\n                            ...newValue,\\n                            data: \\\"Valid\\\",\\n                            selectionRange: [0, 3],\\n                        };\\n                    }\\n                    return false;\\n                }}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ValidateData as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const FillHandle: React.VFC = () => {\\n    const { cols, getCellContent, setCellValueRaw, setCellValue, getCellsForSelection } = useMockDataGenerator(\\n        60,\\n        false\\n    );\\n\\n    const [numRows, setNumRows] = React.useState(50);\\n\\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\\n        i => {\\n            let val = getCellContent(i);\\n            if (i[0] === 1 && val.kind === GridCellKind.Text) {\\n                val = {\\n                    ...val,\\n                    readonly: true,\\n                };\\n            }\\n\\n            return val;\\n        },\\n        [getCellContent]\\n    );\\n\\n    const onRowAppended = React.useCallback(() => {\\n        const newRow = numRows;\\n        for (let c = 0; c < 6; c++) {\\n            const cell = getCellContent([c, newRow]);\\n            setCellValueRaw([c, newRow], clearCell(cell));\\n        }\\n        setNumRows(cv => cv + 1);\\n    }, [getCellContent, numRows, setCellValueRaw]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Fill handle\\\"\\n            description={\\n                <>\\n                    <Description>Fill handles can be used to downfill data with the mouse.</Description>\\n                    <MoreInfo>\\n                        Just click and drag, the top row will be copied down. Enable using the{\\\" \\\"}\\n                        <PropName>fillHandle</PropName> prop.\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContentMangled}\\n                columns={cols}\\n                getCellsForSelection={getCellsForSelection}\\n                rowMarkers={\\\"both\\\"}\\n                onPaste={true}\\n                fillHandle={true}\\n                onCellEdited={setCellValue}\\n                trailingRowOptions={{\\n                    sticky: true,\\n                    tint: true,\\n                    hint: \\\"New row...\\\",\\n                }}\\n                rows={numRows}\\n                onRowAppended={onRowAppended}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(FillHandle as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nconst trailingRowOptionsColumnIndexesHint: Record<number, string> = {\\n    2: \\\"Smol text\\\",\\n    3: \\\"Add\\\",\\n    5: \\\"New\\\",\\n};\\n\\nconst trailingRowOptionsColumnIndexesIcon: Record<number, string> = {\\n    2: GridColumnIcon.HeaderArray,\\n    3: GridColumnIcon.HeaderEmoji,\\n    5: GridColumnIcon.HeaderNumber,\\n};\\n\\nconst trailingRowOptionsColumnIndexesTarget: Record<number, number> = {\\n    2: 0,\\n    3: 0,\\n    5: 0,\\n};\\n\\nconst trailingRowOptionsColumnIndexesDisabled: Record<number, boolean> = {\\n    3: true,\\n};\\n\\nconst trailingRowOptionsColumnIndexesTheme: Record<number, Partial<Theme>> = {\\n    2: {\\n        baseFontStyle: \\\"10px\\\",\\n    },\\n};\\n\\nexport const TrailingRowOptions: React.VFC = () => {\\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\\n\\n    const [numRows, setNumRows] = React.useState(50);\\n\\n    const onRowAppended = React.useCallback(() => {\\n        const newRow = numRows;\\n        for (let c = 0; c < 6; c++) {\\n            const cell = getCellContent([c, newRow]);\\n            setCellValueRaw([c, newRow], clearCell(cell));\\n        }\\n        setNumRows(cv => cv + 1);\\n    }, [getCellContent, numRows, setCellValueRaw]);\\n\\n    const columnsWithRowOptions: GridColumn[] = React.useMemo(() => {\\n        return cols.map((c, idx) => ({\\n            ...c,\\n            trailingRowOptions: {\\n                hint: trailingRowOptionsColumnIndexesHint[idx],\\n                addIcon: trailingRowOptionsColumnIndexesIcon[idx],\\n                targetColumn: trailingRowOptionsColumnIndexesTarget[idx],\\n                disabled: trailingRowOptionsColumnIndexesDisabled[idx],\\n                themeOverride: trailingRowOptionsColumnIndexesTheme[idx],\\n            },\\n        }));\\n    }, [cols]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Trailing row options\\\"\\n            description={\\n                <Description>\\n                    You can customize the trailing row in each column by setting a{\\\" \\\"}\\n                    <PropName>trailingRowOptions</PropName> in your columns.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={columnsWithRowOptions}\\n                rowMarkers={\\\"both\\\"}\\n                onCellEdited={setCellValue}\\n                trailingRowOptions={{\\n                    tint: true,\\n                    sticky: true,\\n                }}\\n                rows={numRows}\\n                onRowAppended={onRowAppended}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(TrailingRowOptions as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const AddDataToTop: React.VFC = () => {\\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\\n\\n    const [numRows, setNumRows] = React.useState(50);\\n\\n    const onRowAppended = React.useCallback(async () => {\\n        // shift all of the existing cells down\\n        for (let y = numRows; y > 0; y--) {\\n            for (let x = 0; x < 6; x++) {\\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\\n            }\\n        }\\n        for (let c = 0; c < 6; c++) {\\n            const cell = getCellContent([c, 0]);\\n            setCellValueRaw([c, 0], clearCell(cell));\\n        }\\n        setNumRows(cv => cv + 1);\\n        return \\\"top\\\" as const;\\n    }, [getCellContent, numRows, setCellValueRaw]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Add data\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can return a different location to have the new row append take place.\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rowMarkers={\\\"both\\\"}\\n                onCellEdited={setCellValue}\\n                trailingRowOptions={{\\n                    hint: \\\"New row...\\\",\\n                    sticky: true,\\n                    tint: true,\\n                }}\\n                rows={numRows}\\n                onRowAppended={onRowAppended}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(AddDataToTop as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\ninterface AddDataToMiddleProps {\\n    insertIndex: number;\\n}\\nexport const AddDataToMiddle: React.FC<AddDataToMiddleProps> = p => {\\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\\n\\n    const [numRows, setNumRows] = React.useState(50);\\n\\n    const index = p.insertIndex;\\n    const onRowAppended = React.useCallback(async () => {\\n        // shift rows below index down\\n        for (let y = numRows; y > index; y--) {\\n            for (let x = 0; x < 6; x++) {\\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\\n            }\\n        }\\n        for (let c = 0; c < 6; c++) {\\n            const cell = getCellContent([c, index]);\\n            setCellValueRaw([c, index], clearCell(cell));\\n        }\\n        setNumRows(cv => cv + 1);\\n        return index;\\n    }, [getCellContent, numRows, setCellValueRaw, index]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Add data to middle\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can return a different location to have the new row append take place.\\n                    </Description>\\n                    <MoreInfo>\\n                        Note that <KeyName>insertIndex</KeyName> is zero-based while the number column on the left side\\n                        of the grid is one-based, so inserting at index &quot;4&quot; creates a new row at &quot;5&quot;\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rowMarkers={\\\"both\\\"}\\n                onCellEdited={setCellValue}\\n                trailingRowOptions={{\\n                    hint: \\\"New row...\\\",\\n                    sticky: true,\\n                    tint: true,\\n                }}\\n                rows={numRows}\\n                onRowAppended={onRowAppended}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(AddDataToMiddle as any).args = {\\n    insertIndex: 10,\\n};\\n(AddDataToMiddle as any).argTypes = {\\n    insertIndex: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 1,\\n            max: 48,\\n        },\\n    },\\n};\\n(AddDataToMiddle as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nexport const AppendRowHandle: React.VFC = () => {\\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\\n\\n    const [numRows, setNumRows] = React.useState(50);\\n\\n    const ref = React.useRef<DataEditorRef>(null);\\n\\n    const onClick = React.useCallback(() => {\\n        void ref.current?.appendRow(3);\\n    }, [ref]);\\n\\n    const onRowAppended = React.useCallback(() => {\\n        const newRow = numRows;\\n        for (let c = 0; c < 6; c++) {\\n            const cell = getCellContent([c, newRow]);\\n            setCellValueRaw([c, newRow], clearCell(cell));\\n        }\\n        setNumRows(cv => cv + 1);\\n    }, [getCellContent, numRows, setCellValueRaw]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"appendRow Ref\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Adding data can also be triggered from outside of <PropName>DataEditor</PropName>\\n                    </Description>\\n                    <MoreInfo>\\n                        By calling <PropName>appendRow</PropName> on a <PropName>ref</PropName> to your grid, you can\\n                        trigger the append elsewhere, like this <KeyName onClick={onClick}>Append</KeyName> button\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                ref={ref}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rowMarkers={\\\"both\\\"}\\n                onCellEdited={setCellValue}\\n                trailingRowOptions={{\\n                    hint: \\\"New row...\\\",\\n                    sticky: true,\\n                    tint: true,\\n                }}\\n                rows={numRows}\\n                onRowAppended={onRowAppended}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(AppendRowHandle as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const SmallEditableGrid = () => {\\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(6, false);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Editable Grid\\\"\\n            description={\\n                <Description>\\n                    Data grid supports overlay editors for changing values. There are bespoke editors for numbers,\\n                    strings, images, booleans, markdown, and uri.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                rowMarkers=\\\"both\\\"\\n                columns={cols}\\n                rows={20}\\n                onCellEdited={setCellValue}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(SmallEditableGrid as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const OneMillionRows: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"One Million Rows\\\"\\n            description={<Description>Data grid supports over 1 million rows. Your limit is mostly RAM.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                rowHeight={31}\\n                rows={1_000_000}\\n                rowMarkers=\\\"number\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(OneMillionRows as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const SillyNumbers: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"100 Million Rows\\\"\\n            description={\\n                <Description>\\n                    100 million rows is silly. Once we cross about 33 million pixels in height we can no longer trust\\n                    the browser to scroll accurately.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                rowHeight={31}\\n                rows={100_000_000}\\n                rowMarkers=\\\"number\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(SillyNumbers as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ObserveVisibleRegion: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(100);\\n\\n    const [visibleRegion, setVisibleRegion] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Observe Visible Region\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        The visible region can be observed using <PropName>onVisibleRegionChanged</PropName>\\n                    </Description>\\n                    <MoreInfo>\\n                        Then current visible region is x:<KeyName>{visibleRegion.x}</KeyName> y:\\n                        <KeyName>{visibleRegion.y}</KeyName> width:\\n                        <KeyName>{visibleRegion.width}</KeyName> height:<KeyName>{visibleRegion.height}</KeyName>\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={1000}\\n                onVisibleRegionChanged={setVisibleRegion}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(OneMillionRows as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const OneHundredThousandCols: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100_000);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"One Hundred Thousand Columns\\\"\\n            description={\\n                <Description>\\n                    Data grid supports way more columns than you will ever need. Also this is rendering 10 million cells\\n                    but that&apos;s not important.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellsForSelection={getCellsForSelection}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(OneHundredThousandCols as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const TenMillionCells: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(100);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Ten Million Cells\\\"\\n            description={<Description>Data grid supports over 10 million cells. Go nuts with it.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers=\\\"number\\\"\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={100_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(TenMillionCells as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\ninterface SmoothScrollingGridProps {\\n    smoothScrollX: boolean;\\n    smoothScrollY: boolean;\\n}\\n\\nexport const SmoothScrollingGrid: React.FC<SmoothScrollingGridProps> = p => {\\n    const { cols, getCellContent } = useMockDataGenerator(30);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Smooth scrolling\\\"\\n            description={\\n                <Description>\\n                    You can enable smooth scrolling with the <PropName>smoothScrollX</PropName> and{\\\" \\\"}\\n                    <PropName>smoothScrollY</PropName> props. Disabling smooth scrolling can dramatically increase\\n                    performance and improve visual stability during rapid scrolling.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                smoothScrollX={p.smoothScrollX}\\n                smoothScrollY={p.smoothScrollY}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={10_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(SmoothScrollingGrid as any).args = {\\n    smoothScrollX: false,\\n    smoothScrollY: false,\\n};\\n(SmoothScrollingGrid as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\ninterface InputBlendingGridProps {\\n    rangeBlending: \\\"mixed\\\" | \\\"exclusive\\\";\\n    columnBlending: \\\"mixed\\\" | \\\"exclusive\\\";\\n    rowBlending: \\\"mixed\\\" | \\\"exclusive\\\";\\n    rangeMultiSelect: \\\"none\\\" | \\\"cell\\\" | \\\"rect\\\" | \\\"multi-cell\\\" | \\\"multi-rect\\\";\\n    columnMultiSelect: \\\"none\\\" | \\\"single\\\" | \\\"multi\\\";\\n    rowMultiSelect: \\\"none\\\" | \\\"single\\\" | \\\"multi\\\";\\n}\\n\\nexport const InputBlending: React.FC<InputBlendingGridProps> = p => {\\n    const { cols, getCellContent } = useMockDataGenerator(30);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Input blending\\\"\\n            description={\\n                <Description>\\n                    Input blending can be enabled or disable between row, column, and range selections. Multi-selections\\n                    can also be enabled or disabled with the same level of granularity.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers={p.rowMultiSelect === \\\"none\\\" ? \\\"number\\\" : \\\"both\\\"}\\n                keybindings={{\\n                    clear: true,\\n                    copy: true,\\n                    downFill: true,\\n                    rightFill: true,\\n                    pageDown: true,\\n                    pageUp: true,\\n                    paste: true,\\n                    search: true,\\n                    selectAll: true,\\n                    selectColumn: true,\\n                    selectRow: true,\\n                }}\\n                getCellsForSelection={true}\\n                rangeSelect={p.rangeMultiSelect}\\n                columnSelect={p.columnMultiSelect}\\n                rowSelect={p.rowMultiSelect}\\n                rangeSelectionBlending={p.rangeBlending}\\n                columnSelectionBlending={p.columnBlending}\\n                rowSelectionBlending={p.rowBlending}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={10_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(InputBlending as any).args = {\\n    rangeBlending: \\\"mixed\\\",\\n    columnBlending: \\\"mixed\\\",\\n    rowBlending: \\\"mixed\\\",\\n    rangeMultiSelect: \\\"rect\\\",\\n    columnMultiSelect: \\\"multi\\\",\\n    rowMultiSelect: \\\"multi\\\",\\n};\\n(InputBlending as any).argTypes = {\\n    rangeBlending: {\\n        control: { type: \\\"select\\\", options: [\\\"mixed\\\", \\\"exclusive\\\"] },\\n    },\\n    columnBlending: {\\n        control: { type: \\\"select\\\", options: [\\\"mixed\\\", \\\"exclusive\\\"] },\\n    },\\n    rowBlending: {\\n        control: { type: \\\"select\\\", options: [\\\"mixed\\\", \\\"exclusive\\\"] },\\n    },\\n    rangeMultiSelect: {\\n        control: { type: \\\"select\\\", options: [\\\"none\\\", \\\"cell\\\", \\\"rect\\\", \\\"multi-cell\\\", \\\"multi-rect\\\"] },\\n    },\\n    columnMultiSelect: {\\n        control: { type: \\\"select\\\", options: [\\\"none\\\", \\\"single\\\", \\\"multi\\\"] },\\n    },\\n    rowMultiSelect: {\\n        control: { type: \\\"select\\\", options: [\\\"none\\\", \\\"single\\\", \\\"multi\\\"] },\\n    },\\n};\\n(InputBlending as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\ninterface AddColumnsProps {\\n    columnsCount: number;\\n}\\n\\nexport const AddColumns: React.FC<AddColumnsProps> = p => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(p.columnsCount);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Add and remove columns\\\"\\n            description={\\n                <>\\n                    <Description>You can add and remove columns at your disposal</Description>\\n                    <MoreInfo>Use the story&apos;s controls to change the number of columns</MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers=\\\"number\\\"\\n                getCellsForSelection={getCellsForSelection}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={10_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(AddColumns as any).args = {\\n    columnsCount: 10,\\n};\\n(AddColumns as any).argTypes = {\\n    columnsCount: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 2,\\n            max: 200,\\n        },\\n    },\\n};\\n(AddColumns as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nexport const ScrollShadows: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(6);\\n\\n    const [selection, setSelection] = React.useState<GridSelection>({\\n        rows: CompactSelection.empty(),\\n        columns: CompactSelection.empty(),\\n    });\\n\\n    const onSelectionChange = React.useCallback((newSel: GridSelection) => {\\n        let newRows = CompactSelection.empty();\\n        if (newSel.current !== undefined) {\\n            newRows = newRows.add([newSel.current.range.y, newSel.current.range.y + newSel.current.range.height]);\\n        }\\n        for (const b of newSel.current?.rangeStack ?? []) {\\n            newRows = newRows.add([b.y, b.y + b.height]);\\n        }\\n        setSelection({\\n            ...newSel,\\n            rows: newRows,\\n        });\\n    }, []);\\n\\n    const theme = React.useMemo<Partial<Theme>>(\\n        () => ({\\n            accentLight: \\\"#b1f6ff\\\",\\n            horizontalBorderColor: \\\"transparent\\\",\\n            headerBottomBorderColor: \\\"rgba(115, 116, 131, 0.16)\\\",\\n        }),\\n        []\\n    );\\n\\n    const getRowThemeOverride = React.useCallback(row => (row % 2 === 0 ? undefined : { bgCell: \\\"#f5f5f6\\\" }), []);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Automatic Row Markers\\\"\\n            description={\\n                <>\\n                    <Description>You can enable and disable the horizontal/vertical scroll shadows.</Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers={\\\"number\\\"}\\n                gridSelection={selection}\\n                onGridSelectionChange={onSelectionChange}\\n                fixedShadowX={false}\\n                headerHeight={26}\\n                drawFocusRing={false}\\n                rowHeight={22}\\n                fixedShadowY={false}\\n                getRowThemeOverride={getRowThemeOverride}\\n                verticalBorder={false}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={1000}\\n                theme={theme}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ScrollShadows as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const AutomaticRowMarkers: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(6);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Automatic Row Markers\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can enable row markers with rich selection behavior using the{\\\" \\\"}\\n                        <PropName>rowMarkers</PropName> prop.\\n                    </Description>\\n                    <MoreInfo>\\n                        Use <KeyName></KeyName> + click to make range selections, and <KeyName>Ctrl</KeyName> (\\n                        <KeyName></KeyName> on Mac) + click to add/remove individual rows.\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers={\\\"both\\\"}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(AutomaticRowMarkers as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const WrappingText: React.VFC<{\\n    alignment: \\\"left\\\" | \\\"center\\\" | \\\"right\\\";\\n    length: number;\\n    hyperWrapping: boolean;\\n}> = p => {\\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(6);\\n\\n    const suffix = React.useMemo(() => {\\n        return range(0, 100).map(() => faker.lorem.sentence(p.length));\\n    }, [p.length]);\\n\\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\\n        i => {\\n            const [col, row] = i;\\n\\n            if (col === 0) {\\n                return {\\n                    kind: GridCellKind.Text,\\n                    allowOverlay: true,\\n                    displayData: `${row},\\\\n${suffix[row % suffix.length]}`,\\n                    data: `${row}, ${suffix}`,\\n                    allowWrapping: true,\\n                    contentAlign: p.alignment,\\n                };\\n            }\\n            return getCellContent(i);\\n        },\\n        [getCellContent, p.alignment, suffix]\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Wrapping Text\\\"\\n            description={\\n                <Description>\\n                    Text cells can have wrapping text by setting the <PropName>allowWrapping</PropName> prop to true.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowHeight={80}\\n                getCellContent={mangledGetCellContent}\\n                columns={cols}\\n                rows={1000}\\n                onColumnResize={onColumnResize}\\n                experimental={{\\n                    hyperWrapping: p.hyperWrapping,\\n                }}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(WrappingText as any).args = {\\n    alignment: \\\"left\\\",\\n    length: 20,\\n    hyperWrapping: false,\\n};\\n(WrappingText as any).argTypes = {\\n    alignment: {\\n        control: { type: \\\"select\\\", options: [\\\"left\\\", \\\"center\\\", \\\"right\\\"] },\\n    },\\n    length: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 2,\\n            max: 200,\\n        },\\n    },\\n};\\n(WrappingText as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nexport const UnevenRows: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(6);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Uneven Rows\\\"\\n            description={\\n                <Description>\\n                    Rows can be made uneven by passing a callback to the <PropName>rowHeight</PropName> prop\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowHeight={r => (r % 3 === 0 ? 30 : r % 2 ? 50 : 60)}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(UnevenRows as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const DrawCustomCells: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(6);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Draw custom cells\\\"\\n            description={\\n                <Description>\\n                    You can draw custom cell contents however you want using the <PropName>drawCustomCell</PropName>{\\\" \\\"}\\n                    prop\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                drawCell={args => {\\n                    const { cell, rect, ctx } = args;\\n                    if (cell.kind !== GridCellKind.Text) return false;\\n\\n                    const hasX = cell.displayData.toLowerCase().includes(\\\"x\\\"); // all my x's live in texas\\n\\n                    ctx.save();\\n                    const { x, y, width, height } = rect;\\n                    const data = cell.displayData;\\n\\n                    ctx.fillStyle = hasX ? \\\"#bfffcd\\\" : \\\"#ffe6e6\\\";\\n                    ctx.fillRect(x + 1, y + 1, width - 1, height - 1);\\n\\n                    ctx.fillStyle = hasX ? \\\"#0fc035\\\" : \\\"#e01e1e\\\";\\n                    ctx.font = \\\"bold 14px sans-serif\\\";\\n                    ctx.fillText(data, x + 8 + 0.5, y + height / 2 + 4.5);\\n                    ctx.restore();\\n\\n                    return true;\\n                }}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(DrawCustomCells as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const RearrangeColumns: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(60);\\n\\n    // This is a dirty hack because the mock generator doesn't really support changing this. In a real data source\\n    // you should track indexes properly\\n    const [sortableCols, setSortableCols] = React.useState(cols);\\n\\n    const onColMoved = React.useCallback((startIndex: number, endIndex: number): void => {\\n        setSortableCols(old => {\\n            const newCols = [...old];\\n            const [toMove] = newCols.splice(startIndex, 1);\\n            newCols.splice(endIndex, 0, toMove);\\n            return newCols;\\n        });\\n    }, []);\\n\\n    const getCellContentMangled = React.useCallback(\\n        ([col, row]: Item): GridCell => {\\n            const remappedCol = cols.findIndex(c => c.title === sortableCols[col].title);\\n            return getCellContent([remappedCol, row]);\\n        },\\n        [cols, getCellContent, sortableCols]\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Rearrange Columns\\\"\\n            description={\\n                <Description>\\n                    Columns can be rearranged by drag and dropping, as long as you respond to the{\\\" \\\"}\\n                    <PropName>onColumnMoved</PropName> callback.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                freezeColumns={1}\\n                rowMarkers=\\\"both\\\"\\n                getCellContent={getCellContentMangled}\\n                getCellsForSelection={getCellsForSelection}\\n                columns={sortableCols}\\n                onColumnMoved={onColMoved}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(RearrangeColumns as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\ninterface RowAndHeaderSizesProps {\\n    rowHeight: number;\\n    headerHeight: number;\\n}\\nexport const RowAndHeaderSizes: React.VFC<RowAndHeaderSizesProps> = p => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Row and Header sizes\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        The row size can be controlled with <PropName>rowHeight</PropName> and the header size with{\\\" \\\"}\\n                        <PropName>headerHeight</PropName>.\\n                    </Description>\\n                    <MoreInfo>Use the story&apos;s controls to resize them</MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowHeight={p.rowHeight}\\n                headerHeight={p.headerHeight}\\n                getCellsForSelection={getCellsForSelection}\\n                rowMarkers={\\\"number\\\"}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(RowAndHeaderSizes as any).args = {\\n    rowHeight: 34,\\n    headerHeight: 34,\\n};\\n(RowAndHeaderSizes as any).argTypes = {\\n    rowHeight: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 20,\\n            max: 200,\\n        },\\n    },\\n    headerHeight: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 20,\\n            max: 200,\\n        },\\n    },\\n};\\n(RowAndHeaderSizes as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nconst KeyName = styled.kbd`\\n    background-color: #f4f4f4;\\n    color: #2b2b2b;\\n    padding: 2px 6px;\\n    font-family: monospace;\\n    font-size: 14px;\\n    border-radius: 4px;\\n    box-shadow: 0px 1px 2px #00000040;\\n    margin: 0 0.1em;\\n`;\\n\\nexport const MultiSelectColumns: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Multi select columns\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can select multiple columns by using the <PropName>selectedColumns</PropName> and{\\\" \\\"}\\n                        <PropName>onSelectedColumnsChange</PropName> props\\n                    </Description>\\n                    <MoreInfo>\\n                        Here you can multi select columns by using <KeyName>Ctrl</KeyName> (on Windows) or{\\\" \\\"}\\n                        <KeyName></KeyName> (on Mac)\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={getCellsForSelection}\\n                rowMarkers=\\\"both\\\"\\n                columns={cols}\\n                rows={100_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(MultiSelectColumns as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nfunction getColumnsForCellTypes(): GridColumnWithMockingInfo[] {\\n    return [\\n        {\\n            title: \\\"Row ID\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderRowID,\\n            hasMenu: false,\\n            getContent: () => {\\n                return {\\n                    kind: GridCellKind.RowID,\\n                    data: faker.datatype.uuid(),\\n                    allowOverlay: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Protected\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderCode,\\n            hasMenu: false,\\n            getContent: () => {\\n                return {\\n                    kind: GridCellKind.Protected,\\n                    data: faker.finance.bitcoinAddress(),\\n                    allowOverlay: false,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Loading\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderString,\\n            hasMenu: false,\\n            getContent: () => {\\n                return {\\n                    kind: GridCellKind.Loading,\\n                    allowOverlay: false,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Text\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderCode,\\n            hasMenu: false,\\n            getContent: () => {\\n                const name = faker.name.firstName();\\n                return {\\n                    kind: GridCellKind.Text,\\n                    data: name,\\n                    displayData: name,\\n                    allowOverlay: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Number\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderNumber,\\n            hasMenu: false,\\n            getContent: () => {\\n                const age = faker.datatype.number(100);\\n                return {\\n                    kind: GridCellKind.Number,\\n                    data: age,\\n                    displayData: `${age}`,\\n                    allowOverlay: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Boolean\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderBoolean,\\n            hasMenu: false,\\n            getContent: () => {\\n                const roll = Math.random();\\n                const checked = roll < 0.1 ? undefined : roll < 0.2 ? null : roll < 0.6;\\n                // TODO: Make editable. UX looks bad by default.\\n                return {\\n                    kind: GridCellKind.Boolean,\\n                    data: checked,\\n                    allowOverlay: false,\\n                    readonly: false,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Image\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderImage,\\n            hasMenu: false,\\n            getContent: () => {\\n                return {\\n                    kind: GridCellKind.Image,\\n                    data: [`${faker.image.animals(40, 40)}?random=${faker.datatype.number(100_000)}`],\\n                    allowOverlay: true,\\n                    allowAdd: false,\\n                    readonly: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Uri\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderUri,\\n            hasMenu: false,\\n            getContent: () => {\\n                const url = faker.internet.url();\\n                return {\\n                    kind: GridCellKind.Uri,\\n                    data: url,\\n                    allowOverlay: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Markdown\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderMarkdown,\\n            hasMenu: false,\\n            getContent: () => {\\n                const markdown = `# Title\\nHello my name is *${faker.name.firstName()}*\\n\\n## TODO:\\nTry out [Glide](https://www.glideapps.com/)\\n`;\\n                return {\\n                    kind: GridCellKind.Markdown,\\n                    data: markdown,\\n                    allowOverlay: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Bubble\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderArray,\\n            hasMenu: false,\\n            getContent: () => {\\n                return {\\n                    kind: GridCellKind.Bubble,\\n                    data: [faker.lorem.word(), faker.lorem.word(), faker.lorem.word()],\\n                    allowOverlay: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Drilldown\\\",\\n            width: 120,\\n            icon: GridColumnIcon.HeaderArray,\\n            hasMenu: false,\\n            getContent: () => {\\n                return {\\n                    kind: GridCellKind.Drilldown,\\n                    data: [\\n                        {\\n                            text: faker.address.cityName(),\\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\\n                        },\\n                        {\\n                            text: faker.address.cityName(),\\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\\n                        },\\n                    ],\\n                    allowOverlay: true,\\n                };\\n            },\\n        },\\n    ];\\n}\\n\\nfunction useAllMockedKinds() {\\n    const cache = React.useRef<ContentCache>(new ContentCache());\\n\\n    const [colsMap, setColsMap] = React.useState(getColumnsForCellTypes);\\n\\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\\n        setColsMap(prevColsMap => {\\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\\n            const newArray = [...prevColsMap];\\n            newArray.splice(index, 1, {\\n                ...prevColsMap[index],\\n                width: newSize,\\n            });\\n            return newArray;\\n        });\\n    }, []);\\n\\n    const cols = React.useMemo(() => {\\n        return colsMap.map(getGridColumn);\\n    }, [colsMap]);\\n\\n    const [updateVersion, setUpdateVersion] = React.useState(0);\\n    const getCellContent = React.useCallback(\\n        ([col, row]: Item): GridCell => {\\n            // Terrible hack to force update when setCellValue requests it\\n            noop(updateVersion);\\n            let val = cache.current.get(col, row);\\n            if (val === undefined) {\\n                val = colsMap[col].getContent();\\n                cache.current.set(col, row, val);\\n            }\\n\\n            return val;\\n        },\\n        [colsMap, updateVersion]\\n    );\\n\\n    const setCellValue = React.useCallback(\\n        ([col, row]: Item, val: GridCell, noDisplay?: boolean, forceUpdate?: boolean): void => {\\n            let current = cache.current.get(col, row);\\n            if (current === undefined) {\\n                current = colsMap[col].getContent();\\n            }\\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\\n                const copied = lossyCopyData(val, current);\\n                cache.current.set(col, row, {\\n                    ...copied,\\n                    displayData: noDisplay === true ? undefined : copied.data?.toString() ?? \\\"\\\",\\n                } as any);\\n\\n                if (forceUpdate === true) {\\n                    setUpdateVersion(v => v + 1);\\n                }\\n            }\\n        },\\n        [colsMap]\\n    );\\n\\n    return { cols, getCellContent, onColumnResize, setCellValue };\\n}\\n\\nexport const AllCellKinds: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Lotsa cell kinds\\\"\\n            description={\\n                <Description>\\n                    Data grid supports plenty cell kinds. Anything under <PropName>GridCellKind</PropName>.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                highlightRegions={[\\n                    {\\n                        color: \\\"#ff00ff33\\\",\\n                        range: {\\n                            x: 1,\\n                            y: 1,\\n                            width: 3,\\n                            height: 3,\\n                        },\\n                    },\\n                ]}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(AllCellKinds as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nconst darkTheme = {\\n    accentColor: \\\"#8c96ff\\\",\\n    accentLight: \\\"rgba(202, 206, 255, 0.253)\\\",\\n\\n    textDark: \\\"#ffffff\\\",\\n    textMedium: \\\"#b8b8b8\\\",\\n    textLight: \\\"#a0a0a0\\\",\\n    textBubble: \\\"#ffffff\\\",\\n\\n    bgIconHeader: \\\"#b8b8b8\\\",\\n    fgIconHeader: \\\"#000000\\\",\\n    textHeader: \\\"#a1a1a1\\\",\\n    textHeaderSelected: \\\"#000000\\\",\\n\\n    bgCell: \\\"#16161b\\\",\\n    bgCellMedium: \\\"#202027\\\",\\n    bgHeader: \\\"#212121\\\",\\n    bgHeaderHasFocus: \\\"#474747\\\",\\n    bgHeaderHovered: \\\"#404040\\\",\\n\\n    bgBubble: \\\"#212121\\\",\\n    bgBubbleSelected: \\\"#000000\\\",\\n\\n    bgSearchResult: \\\"#423c24\\\",\\n\\n    borderColor: \\\"rgba(225,225,225,0.2)\\\",\\n    drilldownBorder: \\\"rgba(225,225,225,0.4)\\\",\\n\\n    linkColor: \\\"#4F5DFF\\\",\\n\\n    headerFontStyle: \\\"bold 14px\\\",\\n    baseFontStyle: \\\"13px\\\",\\n    fontFamily:\\n        \\\"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\\\",\\n};\\n\\nconst hotdogStand = {\\n    accentColor: \\\"#8c96ff\\\",\\n    accentLight: \\\"rgba(202, 206, 255, 0.253)\\\",\\n\\n    textDark: \\\"#ffffff\\\",\\n    textMedium: \\\"rgba(255, 255, 255, 0.9)\\\",\\n    textLight: \\\"rgba(255, 255, 255, 0.7)\\\",\\n    textBubble: \\\"#000000\\\",\\n\\n    bgIconHeader: \\\"#880000\\\",\\n    fgIconHeader: \\\"#ff5555\\\",\\n    textHeader: \\\"rgba(0, 0, 0, 0.9)\\\",\\n    textHeaderSelected: \\\"#000000\\\",\\n\\n    bgCell: \\\"#ff0000\\\",\\n    bgCellMedium: \\\"#ff4d4d\\\",\\n    bgHeader: \\\"#f3f300\\\",\\n    bgHeaderHasFocus: \\\"#eeee00\\\",\\n    bgHeaderHovered: \\\"#e0e000\\\",\\n\\n    bgBubble: \\\"#ffff00\\\",\\n    bgBubbleSelected: \\\"#ffff00\\\",\\n\\n    bgSearchResult: \\\"#423c24\\\",\\n\\n    borderColor: \\\"#ffff00\\\",\\n    drilldownBorder: \\\"#ffff00\\\",\\n\\n    linkColor: \\\"#4F5DFF\\\",\\n\\n    headerFontStyle: \\\"bold 14px\\\",\\n    baseFontStyle: \\\"13px\\\",\\n    fontFamily:\\n        \\\"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\\\",\\n};\\n\\nexport const ThemeSupport: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const [theme, setTheme] = React.useState<Partial<Theme>>({});\\n\\n    const [numRows, setNumRows] = React.useState(1000);\\n\\n    const onRowAppended = React.useCallback(() => {\\n        const newRow = numRows;\\n        setNumRows(cv => cv + 1);\\n        for (let c = 0; c < 6; c++) {\\n            setCellValue([c, newRow], {\\n                displayData: \\\"\\\",\\n                data: \\\"\\\",\\n            } as any);\\n        }\\n    }, [numRows, setCellValue]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Theme support\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        DataGrid respects the theme provided by the <PropName>theme</PropName> prop.\\n                    </Description>\\n                    <MoreInfo>\\n                        <button onClick={() => setTheme({})}>Light</button> or{\\\" \\\"}\\n                        <button onClick={() => setTheme(darkTheme)}>Dark</button> even{\\\" \\\"}\\n                        <button onClick={() => setTheme(hotdogStand)}>Hotdog Stand</button>\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                theme={theme}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                onRowAppended={onRowAppended}\\n                trailingRowOptions={{\\n                    tint: true,\\n                    sticky: true,\\n                }}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={numRows}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ThemeSupport as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ThemePerColumn: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const realCols = React.useMemo(() => {\\n        const c = [...cols];\\n        c[3] = {\\n            ...c[3],\\n            themeOverride: {\\n                textDark: \\\"#009CA6\\\",\\n                bgIconHeader: \\\"#009CA6\\\",\\n                accentColor: \\\"#009CA6\\\",\\n                accentLight: \\\"#009CA620\\\",\\n                fgIconHeader: \\\"#FFFFFF\\\",\\n                baseFontStyle: \\\"600 13px\\\",\\n            },\\n        };\\n        c[4] = {\\n            ...c[4],\\n            themeOverride: {\\n                textDark: \\\"#009CA6\\\",\\n                bgIconHeader: \\\"#009CA6\\\",\\n                accentColor: \\\"#009CA6\\\",\\n                accentLight: \\\"#009CA620\\\",\\n                fgIconHeader: \\\"#FFFFFF\\\",\\n                baseFontStyle: \\\"600 13px\\\",\\n            },\\n        };\\n        c[9] = {\\n            ...c[9],\\n            themeOverride: {\\n                textDark: \\\"#009CA6\\\",\\n                bgIconHeader: \\\"#009CA6\\\",\\n                accentColor: \\\"#009CA6\\\",\\n                accentLight: \\\"#009CA620\\\",\\n                fgIconHeader: \\\"#FFFFFF\\\",\\n            },\\n        };\\n        c[10] = {\\n            ...c[10],\\n            themeOverride: {\\n                textDark: \\\"#009CA6\\\",\\n                bgIconHeader: \\\"#009CA6\\\",\\n                accentColor: \\\"#009CA6\\\",\\n                accentLight: \\\"#009CA620\\\",\\n                fgIconHeader: \\\"#FFFFFF\\\",\\n            },\\n        };\\n        return c;\\n    }, [cols]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Theme per column\\\"\\n            description={\\n                <>\\n                    <Description>Each column can provide theme overrides for rendering that column.</Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={realCols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ThemePerColumn as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ThemePerRow: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(5);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Theme per row\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Each row can provide theme overrides for rendering that row using the{\\\" \\\"}\\n                        <PropName>getRowThemeOverride</PropName> callback.\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                trailingRowOptions={{\\n                    sticky: true,\\n                    tint: true,\\n                }}\\n                onRowAppended={() => undefined}\\n                getCellsForSelection={getCellsForSelection}\\n                getRowThemeOverride={i =>\\n                    i % 2 === 0\\n                        ? undefined\\n                        : {\\n                              bgCell: \\\"#f0f8ff\\\",\\n                              borderColor: \\\"#3f90e0\\\",\\n                          }\\n                }\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={1_000_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ThemePerRow as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const CellActivatedEvent: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const [lastActivated, setLastActivated] = React.useState<Item | undefined>(undefined);\\n\\n    const onCellActivated = React.useCallback((cell: Item) => {\\n        setLastActivated(cell);\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Cell Activated event\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        When you tap <KeyName>Enter</KeyName>, <KeyName>Space</KeyName> or double click a cell, that\\n                        cell is activated. You can track this with <PropName>onCellActivated</PropName>.\\n                    </Description>\\n                    <MoreInfo>\\n                        Last activated cell:{\\\" \\\"}\\n                        {lastActivated === undefined ? \\\"none\\\" : `(${lastActivated[0]}, ${lastActivated[1]})`}\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={true}\\n                columns={cols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                onCellActivated={onCellActivated}\\n                rows={10_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CellActivatedEvent as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const BuiltInSearch: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const [showSearch, setShowSearch] = React.useState(false);\\n\\n    const [selection, setSelection] = React.useState<GridSelection>({\\n        rows: CompactSelection.empty(),\\n        columns: CompactSelection.empty(),\\n    });\\n\\n    useEventListener(\\n        \\\"keydown\\\",\\n        React.useCallback(event => {\\n            if ((event.ctrlKey || event.metaKey) && event.code === \\\"KeyF\\\") {\\n                setShowSearch(cv => !cv);\\n                event.stopPropagation();\\n                event.preventDefault();\\n            }\\n        }, []),\\n        window,\\n        false,\\n        true\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Search is easy\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Search for any data in your grid by setting <PropName>showSearch</PropName>.\\n                    </Description>\\n                    <MoreInfo>\\n                        In this story, <KeyName>Ctrl</KeyName> (<KeyName></KeyName> on Mac) + <KeyName>f</KeyName>{\\\" \\\"}\\n                        toggles the search bar. Make sure you&apos;re focused on the Data Grid!\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={true}\\n                gridSelection={selection}\\n                onGridSelectionChange={setSelection}\\n                columns={cols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                showSearch={showSearch}\\n                onSearchClose={() => setShowSearch(false)}\\n                rows={10_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(BuiltInSearch as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\ninterface ImperativeScrollProps {\\n    paddingY: number;\\n    paddingX: number;\\n    vAlign?: \\\"start\\\" | \\\"center\\\" | \\\"end\\\";\\n    hAlign?: \\\"start\\\" | \\\"center\\\" | \\\"end\\\";\\n}\\n\\nexport const ImperativeScroll: React.VFC<ImperativeScrollProps> = p => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const ref = React.useRef<DataEditorRef>(null);\\n\\n    const onClick = () => {\\n        ref.current?.scrollTo(4, 99, \\\"both\\\", p.paddingX, p.paddingY, {\\n            vAlign: p.vAlign,\\n            hAlign: p.hAlign,\\n        });\\n    };\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Imperative scrolling\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can imperatively scroll to a cell by calling <PropName>scrollTo</PropName> on a DataEditor\\n                        ref.\\n                    </Description>\\n                    <MoreInfo>\\n                        Click <button onClick={onClick}>Here</button> to scroll to column 4 row 100\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                ref={ref}\\n                rowMarkers=\\\"clickable-number\\\"\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={10_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ImperativeScroll as any).args = {\\n    paddingY: 0,\\n    paddingX: 0,\\n    vAlign: \\\"start\\\",\\n    hAlign: \\\"start\\\",\\n};\\n(ImperativeScroll as any).argTypes = {\\n    paddingY: 0,\\n    paddingX: 0,\\n    vAlign: {\\n        control: { type: \\\"select\\\", options: [\\\"start\\\", \\\"center\\\", \\\"end\\\", undefined] },\\n    },\\n    hAlign: {\\n        control: { type: \\\"select\\\", options: [\\\"start\\\", \\\"center\\\", \\\"end\\\", undefined] },\\n    },\\n};\\n(ImperativeScroll as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nconst SimpleMenu = styled.div`\\n    width: 175px;\\n    padding: 8px 0;\\n    border-radius: 6px;\\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\\n\\n    display: flex;\\n    flex-direction: column;\\n\\n    background-color: white;\\n    font-size: 13px;\\n    font-weight: 600;\\n    font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Oxygen, Ubuntu, Cantarell, \\\"Open Sans\\\",\\n        \\\"Helvetica Neue\\\", sans-serif;\\n\\n    .danger {\\n        color: rgba(255, 40, 40, 0.8);\\n        :hover {\\n            color: rgba(255, 40, 40, 1);\\n        }\\n    }\\n\\n    > div {\\n        padding: 6px 8px;\\n        color: rgba(0, 0, 0, 0.7);\\n        :hover {\\n            background-color: rgba(0, 0, 0, 0.05);\\n            color: rgba(0, 0, 0, 0.9);\\n        }\\n        transition: background-color 100ms;\\n        cursor: pointer;\\n    }\\n`;\\n\\nexport const HeaderMenus: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const realCols = React.useMemo(() => {\\n        return cols.map(c => ({\\n            ...c,\\n            hasMenu: true,\\n        }));\\n    }, [cols]);\\n\\n    const [menu, setMenu] =\\n        React.useState<{\\n            col: number;\\n            bounds: Rectangle;\\n        }>();\\n\\n    const isOpen = menu !== undefined;\\n\\n    const { layerProps, renderLayer } = useLayer({\\n        isOpen,\\n        auto: true,\\n        placement: \\\"bottom-end\\\",\\n        triggerOffset: 2,\\n        onOutsideClick: () => setMenu(undefined),\\n        trigger: {\\n            getBounds: () => ({\\n                left: menu?.bounds.x ?? 0,\\n                top: menu?.bounds.y ?? 0,\\n                width: menu?.bounds.width ?? 0,\\n                height: menu?.bounds.height ?? 0,\\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\\n            }),\\n        },\\n    });\\n\\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\\n        setMenu({ col, bounds });\\n    }, []);\\n\\n    const onHeaderClicked = React.useCallback(() => {\\n        // eslint-disable-next-line no-console\\n        console.log(\\\"Header clicked\\\");\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Header menus\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Headers on the data grid can be configured to support menus. We provide the events and the\\n                        triangle, you provide the menu.\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                onHeaderMenuClick={onHeaderMenuClick}\\n                onHeaderClicked={onHeaderClicked}\\n                columns={realCols}\\n                onCellContextMenu={(_, e) => e.preventDefault()}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={1000}\\n            />\\n            {isOpen &&\\n                renderLayer(\\n                    <SimpleMenu {...layerProps}>\\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\\n                        <div className=\\\"danger\\\" onClick={() => setMenu(undefined)}>\\n                            Delete\\n                        </div>\\n                    </SimpleMenu>\\n                )}\\n        </BeautifulWrapper>\\n    );\\n};\\n(HeaderMenus as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const CustomHeaderIcons: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const realCols = React.useMemo(() => {\\n        const c = [...cols];\\n        c[3] = {\\n            ...c[3],\\n            title: \\\"CUSTOM ICON\\\",\\n            icon: \\\"custom\\\",\\n            width: 200,\\n        };\\n        return c;\\n    }, [cols]);\\n\\n    const headerIcons = React.useMemo<SpriteMap>(() => {\\n        return {\\n            custom: p => `<svg width=\\\"20\\\" height=\\\"20\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n                <rect x=\\\"2.00015\\\" y=\\\"2\\\" width=\\\"16\\\" height=\\\"16\\\" rx=\\\"4\\\" fill=\\\"${p.bgColor}\\\"/>\\n                <path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M4.69759 6.00977C4.23735 6.00977 3.86426 6.38286 3.86426 6.8431C3.86426 7.30334 4.23735 7.67643 4.69759 7.67643H8.86426C9.3245 7.67643 9.69759 7.30334 9.69759 6.8431C9.69759 6.38286 9.32449 6.00977 8.86426 6.00977H4.69759Z\\\" fill=\\\"${p.fgColor}\\\"/>\\n                <path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M7.61426 4.76009C7.61426 4.29985 7.24116 3.92676 6.78092 3.92676C6.32069 3.92676 5.94759 4.29985 5.94759 4.76009L5.94759 8.92676C5.94759 9.387 6.32069 9.76009 6.78092 9.76009C7.24116 9.76009 7.61426 9.38699 7.61426 8.92676L7.61426 4.76009Z\\\" fill=\\\"${p.fgColor}\\\"/>\\n                <path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M11.0336 6.00977C10.5734 6.00977 10.2003 6.38286 10.2003 6.8431C10.2003 7.30334 10.5734 7.67643 11.0336 7.67643H15.2003C15.6605 7.67643 16.0336 7.30334 16.0336 6.8431C16.0336 6.38286 15.6605 6.00977 15.2003 6.00977H11.0336Z\\\" fill=\\\"${p.fgColor}\\\"/>\\n                <path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M5.89704 10.9916C5.5716 10.6662 5.04397 10.6662 4.71853 10.9916C4.39309 11.317 4.39309 11.8447 4.71853 12.1701L7.66481 15.1164C7.99024 15.4418 8.51788 15.4418 8.84332 15.1164C9.16876 14.791 9.16876 14.2633 8.84332 13.9379L5.89704 10.9916Z\\\" fill=\\\"${p.fgColor}\\\"/>\\n                <path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M8.84332 12.1703C9.16875 11.8449 9.16875 11.3172 8.84332 10.9918C8.51788 10.6664 7.99024 10.6664 7.6648 10.9918L4.71853 13.9381C4.39309 14.2635 4.39309 14.7912 4.71853 15.1166C5.04396 15.442 5.5716 15.442 5.89704 15.1166L8.84332 12.1703Z\\\" fill=\\\"${p.fgColor}\\\"/>\\n                <path d=\\\"M10.2003 11.804C10.2003 11.3438 10.5734 10.9707 11.0336 10.9707H15.2003C15.6605 10.9707 16.0336 11.3438 16.0336 11.804C16.0336 12.2643 15.6605 12.6374 15.2003 12.6374H11.0336C10.5734 12.6374 10.2003 12.2643 10.2003 11.804Z\\\" fill=\\\"${p.fgColor}\\\"/>\\n                <path d=\\\"M10.2003 14.304C10.2003 13.8438 10.5734 13.4707 11.0336 13.4707H15.2003C15.6605 13.4707 16.0336 13.8438 16.0336 14.304C16.0336 14.7643 15.6605 15.1374 15.2003 15.1374H11.0336C10.5734 15.1374 10.2003 14.7643 10.2003 14.304Z\\\" fill=\\\"${p.fgColor}\\\"/>\\n            </svg>`,\\n        };\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Custom header icons\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can provide overrides for the default icons by passing the <PropName>headerIcons</PropName>{\\\" \\\"}\\n                        prop.\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={realCols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                headerIcons={headerIcons}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomHeaderIcons as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const RightElement: React.VFC = () => {\\n    const { cols, getCellContent, setCellValue, getCellsForSelection } = useMockDataGenerator(8, false);\\n\\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\\n\\n    const [numRows, setNumRows] = React.useState(300);\\n\\n    const onRowAppended = React.useCallback(() => {\\n        const newRow = numRows;\\n        setNumRows(cv => cv + 1);\\n        for (let c = 0; c < 6; c++) {\\n            setCellValue([c, newRow], {\\n                displayData: \\\"\\\",\\n                data: \\\"\\\",\\n            } as any);\\n        }\\n    }, [numRows, setCellValue]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Right Element\\\"\\n            description={\\n                <Description>\\n                    A DOM element may be added as a trailer to the grid by using the <PropName>rightElement</PropName>{\\\" \\\"}\\n                    prop.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={columns}\\n                getCellsForSelection={getCellsForSelection}\\n                rowMarkers={\\\"both\\\"}\\n                onCellEdited={setCellValue}\\n                trailingRowOptions={{\\n                    hint: \\\"New row...\\\",\\n                    sticky: true,\\n                    tint: true,\\n                }}\\n                rows={numRows}\\n                onRowAppended={onRowAppended}\\n                rightElementProps={{ sticky: true }}\\n                rightElement={\\n                    <div\\n                        style={{\\n                            height: \\\"100%\\\",\\n                            padding: \\\"20px 20px 40px 20px\\\",\\n                            width: 200,\\n                            color: \\\"black\\\",\\n                            whiteSpace: \\\"pre-wrap\\\",\\n                            backgroundColor: \\\"rgba(240, 240, 250, 0.2)\\\",\\n                            display: \\\"flex\\\",\\n                            justifyContent: \\\"center\\\",\\n                            alignItems: \\\"center\\\",\\n                            boxShadow: \\\"0 0 10px rgba(0, 0, 0, 0.15)\\\",\\n                            backdropFilter: \\\"blur(12px)\\\",\\n                        }}>\\n                        This is a real DOM element. You can put whatever you want here. You can also size it as big as\\n                        you want. {\\\"\\\\n\\\\n\\\"}It also does not have to be sticky.\\n                    </div>\\n                }\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(RightElement as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nlet num: number = 1;\\nfunction rand(): number {\\n    return (num = (num * 16_807) % 2_147_483_647);\\n}\\n\\nexport const RapidUpdates: React.VFC = () => {\\n    const { cols, getCellContent, setCellValueRaw, getCellsForSelection } = useMockDataGenerator(100);\\n\\n    const ref = React.useRef<DataEditorRef>(null);\\n\\n    const countRef = React.useRef(0);\\n    const displayCountRef = React.useRef<HTMLElement>(null);\\n\\n    React.useEffect(() => {\\n        let rafID = 0;\\n\\n        const sendUpdate = () => {\\n            const cells: {\\n                cell: Item;\\n            }[] = [];\\n            const now = performance.now();\\n            for (let x = 0; x < 5000; x++) {\\n                const col = Math.max(10, rand() % 100);\\n                const row = rand() % 10_000;\\n\\n                setCellValueRaw([col, row], {\\n                    kind: GridCellKind.Text,\\n                    data: x.toString(),\\n                    displayData: `${x}k`,\\n                    themeOverride:\\n                        x % 5 !== 0\\n                            ? {\\n                                  bgCell: \\\"#f2fff4\\\",\\n                                  textDark: \\\"#00d41c\\\",\\n                              }\\n                            : {\\n                                  bgCell: \\\"#fff6f6\\\",\\n                                  textDark: \\\"#d40000\\\",\\n                              },\\n                    allowOverlay: true,\\n                    lastUpdated: now,\\n                });\\n                cells.push({ cell: [col, row] });\\n            }\\n            countRef.current += 5000;\\n            if (displayCountRef.current !== null) {\\n                displayCountRef.current.textContent = `${countRef.current}`;\\n            }\\n\\n            ref.current?.updateCells(cells);\\n\\n            rafID = window.requestAnimationFrame(sendUpdate);\\n        };\\n\\n        sendUpdate();\\n\\n        return () => {\\n            cancelAnimationFrame(rafID);\\n        };\\n    }, [setCellValueRaw]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Rapid updating\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Data grid can support many thousands of updates per seconds. The data grid can easily update\\n                        data faster than a human can read it, more importantly the faster the data grid can update, the\\n                        more time your code can spend doing more valuable work.\\n                    </Description>\\n                    <MoreInfo>\\n                        Updates processed: <KeyName ref={displayCountRef} /> We could do this faster but we wrote a\\n                        really crappy data store for this demo which is actually slowing down the data grid.\\n                    </MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                ref={ref}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                rows={10_000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(RapidUpdates as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const CopySupport: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(\\n        10,\\n        false\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Copy support\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Large amounts of data can be copied and customized using{\\\" \\\"}\\n                        <PropName>getCellsForSelection</PropName>.\\n                    </Description>\\n                    <MoreInfo>The data is copied into a format ready to be pasted into Excel or Google Sheets</MoreInfo>\\n                    <textarea\\n                        placeholder=\\\"Copy something below and paste it here...\\\"\\n                        style={{ width: \\\"100%\\\", marginBottom: 20, borderRadius: 9, minHeight: 200, padding: 10 }}\\n                    />\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                rowMarkers=\\\"both\\\"\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={400}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CopySupport as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const PasteSupport: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(\\n        50,\\n        false\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Paste support\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        The data grid can handle paste automatically by returning true from <PropName>onPaste</PropName>\\n                        . You can also return false and handle paste yourself. If paste is undefined the DataEditor will\\n                        do its best to paste to the current cell.\\n                    </Description>\\n                    <MoreInfo>\\n                        Paste supports the copy format of Google Sheets and Excel. Below is an example of data copied\\n                        from excel with some escaped text.\\n                    </MoreInfo>\\n                    <textarea\\n                        value={`Sunday\\tDogs\\thttps://google.com\\nMonday\\tCats\\thttps://google.com\\nTuesday\\tTurtles\\thttps://google.com\\nWednesday\\tBears\\thttps://google.com\\nThursday\\t\\\"L  ions\\\"\\thttps://google.com\\nFriday\\tPigs\\thttps://google.com\\nSaturday\\t\\\"Turkeys and some \\\"\\\"quotes\\\"\\\" and\\na new line char \\\"\\\"more quotes\\\"\\\" plus a tab  .\\\"\\thttps://google.com`}\\n                        style={{ width: \\\"100%\\\", marginBottom: 20, borderRadius: 9, minHeight: 200, padding: 10 }}\\n                    />\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                rowMarkers=\\\"both\\\"\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                onPaste={true}\\n                rows={400}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(PasteSupport as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const FreezeColumns: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Freeze columns\\\"\\n            description={\\n                <Description>\\n                    Columns at the start of your grid can be frozen in place by settings{\\\" \\\"}\\n                    <PropName>freezeColumns</PropName> to a number greater than 0.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers=\\\"both\\\"\\n                freezeColumns={1}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                verticalBorder={c => c > 0}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(FreezeColumns as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ReorderRows: React.VFC = () => {\\n    const cols = React.useMemo<GridColumn[]>(\\n        () => [\\n            {\\n                title: \\\"Col A\\\",\\n                width: 150,\\n            },\\n            {\\n                title: \\\"Col B\\\",\\n                width: 150,\\n            },\\n        ],\\n        []\\n    );\\n\\n    const [rowData, setRowData] = React.useState(() => {\\n        return range(0, 50).map(x => [`A: ${x}`, `B: ${x}`]);\\n    });\\n\\n    const getCellContent = React.useCallback<DataEditorProps[\\\"getCellContent\\\"]>(\\n        ([col, row]) => {\\n            return {\\n                kind: GridCellKind.Text,\\n                allowOverlay: false,\\n                data: rowData[row][col],\\n                displayData: rowData[row][col],\\n            };\\n        },\\n        [rowData]\\n    );\\n\\n    const reorderRows = React.useCallback((from: number, to: number) => {\\n        setRowData(cv => {\\n            const d = [...cv];\\n            const removed = d.splice(from, 1);\\n            d.splice(to, 0, ...removed);\\n            return d;\\n        });\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Reorder Rows\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Rows can be re-arranged by using the <PropName>onRowMoved</PropName> callback. When set the\\n                        first row can be used to drag and drop.\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers={\\\"both\\\"}\\n                onRowMoved={reorderRows}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={50}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ReorderRows as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ColumnGroups: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(20, true, true);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Column Grouping\\\"\\n            description={\\n                <Description>\\n                    Columns in the data grid may be grouped by setting their <PropName>group</PropName> property.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                onGroupHeaderRenamed={(x, y) => window.alert(`Please rename group ${x} to ${y}`)}\\n                columns={cols}\\n                getCellsForSelection={getCellsForSelection}\\n                rows={1000}\\n                getGroupDetails={g => ({\\n                    name: g,\\n                    icon: g === \\\"\\\" ? undefined : GridColumnIcon.HeaderCode,\\n                })}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ColumnGroups as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const StretchColumnSize: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection, onColumnResize } = useMockDataGenerator(5, true, true);\\n\\n    const hasResized = React.useRef(new Set<number>());\\n\\n    const columns = React.useMemo(() => {\\n        return cols.map((x, i) => ({ ...x, grow: hasResized.current.has(i) ? undefined : (5 + i) / 5 }));\\n    }, [cols]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Column Grow\\\"\\n            description={\\n                <Description>\\n                    Columns in the data grid may be set to grow to fill space by setting the <PropName>grow</PropName>{\\\" \\\"}\\n                    prop.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={columns}\\n                getCellsForSelection={getCellsForSelection}\\n                rows={1000}\\n                onColumnResize={(col, _newSize, colIndex, newSizeWithGrow) => {\\n                    hasResized.current.add(colIndex);\\n                    onColumnResize(col, newSizeWithGrow);\\n                }}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(StretchColumnSize as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nfunction useCollapsableColumnGroups(cols: readonly GridColumn[]) {\\n    const [collapsed, setCollapsed] = React.useState<readonly string[]>([]);\\n\\n    const onGroupHeaderClicked = React.useCallback(\\n        (colIndex: number, args: GroupHeaderClickedEventArgs) => {\\n            const group = cols[colIndex].group ?? \\\"\\\";\\n            setCollapsed(cv => (cv.includes(group) ? cv.filter(g => g !== group) : [...cv, group]));\\n            args.preventDefault();\\n        },\\n        [cols]\\n    );\\n\\n    const [selectedColumns, setSelectedColumns] = React.useState<CompactSelection>(CompactSelection.empty());\\n\\n    const setCols = React.useCallback((newVal: CompactSelection, trigger: string) => {\\n        if (trigger === \\\"group\\\") return;\\n\\n        setSelectedColumns(newVal);\\n    }, []);\\n\\n    const columns = React.useMemo(() => {\\n        return cols.map(c => {\\n            if (!collapsed.includes(c.group ?? \\\"\\\"))\\n                return {\\n                    ...c,\\n                    hasMenu: true,\\n                };\\n            return {\\n                ...c,\\n                width: 8,\\n                hasMenu: true,\\n            };\\n        });\\n    }, [collapsed, cols]);\\n\\n    return {\\n        columns,\\n        onGroupHeaderClicked,\\n        selectedColumns,\\n        onSelectedColumnsChange: setCols,\\n    };\\n}\\n\\nexport const ColumnGroupCollapse: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\\n\\n    const groupHeaderArgs = useCollapsableColumnGroups(cols);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Group collapse\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Through clever usage of <PropName>onGroupHeaderClicked</PropName> you can implement group\\n                        collapsing. This is a very basic version however it is possible to go much further.\\n                    </Description>\\n                    <MoreInfo>Cells under a certain size will not attempt to render to save some frames.</MoreInfo>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                {...groupHeaderArgs}\\n                getCellContent={getCellContent}\\n                groupHeaderHeight={24}\\n                rows={1000}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(ColumnGroupCollapse as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const Minimap: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Minimap\\\"\\n            description={\\n                <Description>\\n                    A minimap can be enabled by setting the <PropName>showMinimap</PropName> property.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                showMinimap={true}\\n                rows={3000}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(Minimap as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ContentAlignment: React.VFC = () => {\\n    const { cols, getCellContent } = useAllMockedKinds();\\n\\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\\n        cell => {\\n            const [col, _row] = cell;\\n            if (col === 3) {\\n                return {\\n                    ...getCellContent(cell),\\n                    contentAlign: \\\"center\\\",\\n                };\\n            }\\n            if (col === 4) {\\n                return {\\n                    ...getCellContent(cell),\\n                    contentAlign: \\\"right\\\",\\n                };\\n            }\\n            return getCellContent(cell);\\n        },\\n        [getCellContent]\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Content Alignment\\\"\\n            description={\\n                <Description>\\n                    You can customize the content alignment by setting <PropName>contentAlign</PropName> of a cell to{\\\" \\\"}\\n                    <PropName>left</PropName>, <PropName>right</PropName> or <PropName>center</PropName>.\\n                </Description>\\n            }>\\n            <DataEditor {...defaultProps} getCellContent={mangledGetCellContent} columns={cols} rows={300} />\\n        </BeautifulWrapper>\\n    );\\n};\\n\\nexport const RowHover: React.VFC = () => {\\n    const { cols, getCellContent } = useAllMockedKinds();\\n\\n    const [hoverRow, setHoverRow] = React.useState<number | undefined>(undefined);\\n\\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\\n        const [_, row] = args.location;\\n        setHoverRow(args.kind !== \\\"cell\\\" ? undefined : row);\\n    }, []);\\n\\n    const getRowThemeOverride = React.useCallback<GetRowThemeCallback>(\\n        row => {\\n            if (row !== hoverRow) return undefined;\\n            return {\\n                bgCell: \\\"#f7f7f7\\\",\\n                bgCellMedium: \\\"#f0f0f0\\\",\\n            };\\n        },\\n        [hoverRow]\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Row Hover Effect\\\"\\n            description={\\n                <Description>\\n                    Through careful usage of the <PropName>onItemHovered</PropName> callback it is possible to easily\\n                    create a row hover effect.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers=\\\"both\\\"\\n                onItemHovered={onItemHovered}\\n                getCellContent={getCellContent}\\n                getRowThemeOverride={getRowThemeOverride}\\n                columns={cols}\\n                rows={300}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n\\nexport const SpanCell: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\\n\\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\\n        cell => {\\n            const [col, row] = cell;\\n            if (row === 6 && col >= 3 && col <= 4) {\\n                return {\\n                    kind: GridCellKind.Text,\\n                    allowOverlay: false,\\n                    data: \\\"Span Cell that is very long and will go past the cell limits\\\",\\n                    span: [3, 4],\\n                    displayData: \\\"Span Cell that is very long and will go past the cell limits\\\",\\n                };\\n            }\\n            if (row === 5) {\\n                return {\\n                    kind: GridCellKind.Text,\\n                    allowOverlay: false,\\n                    data: \\\"Span Cell that is very long and will go past the cell limits\\\",\\n                    span: [0, 99],\\n                    displayData: \\\"Span Cell that is very long and will go past the cell limits\\\",\\n                };\\n            }\\n            return getCellContent(cell);\\n        },\\n        [getCellContent]\\n    );\\n\\n    const getCellsForSelection = React.useCallback(\\n        (selection: Rectangle): CellArray => {\\n            const result: GridCell[][] = [];\\n\\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\\n                const row: GridCell[] = [];\\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\\n                    row.push(mangledGetCellContent([x, y]));\\n                }\\n                result.push(row);\\n            }\\n\\n            return result;\\n        },\\n        [mangledGetCellContent]\\n    );\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Spans\\\"\\n            description={\\n                <Description>\\n                    By setting the <PropName>span</PropName> of a cell you can create spans in your grid. All cells\\n                    within a span must return consistent data for defined behavior.\\n                    <MoreInfo>\\n                        Spans will always be split if they span frozen and non-frozen columns. By default selections are\\n                        always expanded to include a span. This can be disabled using the{\\\" \\\"}\\n                        <PropName>spanRangeBehavior</PropName> prop.\\n                    </MoreInfo>\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={mangledGetCellContent}\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                freezeColumns={2}\\n                rows={300}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(SpanCell as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nconst zeroBounds = {\\n    left: 0,\\n    top: 0,\\n    width: 0,\\n    height: 0,\\n    bottom: 0,\\n    right: 0,\\n};\\n\\nexport const Tooltips: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(6);\\n\\n    const [tooltip, setTooltip] = React.useState<{ val: string; bounds: IBounds } | undefined>();\\n\\n    const timeoutRef = React.useRef(0);\\n\\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\\n        if (args.kind === \\\"cell\\\") {\\n            window.clearTimeout(timeoutRef.current);\\n            setTooltip(undefined);\\n            timeoutRef.current = window.setTimeout(() => {\\n                setTooltip({\\n                    val: `Tooltip for ${args.location[0]}, ${args.location[1]}`,\\n                    bounds: {\\n                        // translate to react-laag types\\n                        left: args.bounds.x,\\n                        top: args.bounds.y,\\n                        width: args.bounds.width,\\n                        height: args.bounds.height,\\n                        right: args.bounds.x + args.bounds.width,\\n                        bottom: args.bounds.y + args.bounds.height,\\n                    },\\n                });\\n            }, 1000);\\n        } else {\\n            window.clearTimeout(timeoutRef.current);\\n            timeoutRef.current = 0;\\n            setTooltip(undefined);\\n        }\\n    }, []);\\n\\n    React.useEffect(() => () => window.clearTimeout(timeoutRef.current), []);\\n\\n    const isOpen = tooltip !== undefined;\\n    const { renderLayer, layerProps } = useLayer({\\n        isOpen,\\n        triggerOffset: 4,\\n        auto: true,\\n        container: \\\"portal\\\",\\n        trigger: {\\n            getBounds: () => tooltip?.bounds ?? zeroBounds,\\n        },\\n    });\\n\\n    return (\\n        <>\\n            <BeautifulWrapper\\n                title=\\\"Tooltips\\\"\\n                className=\\\"double\\\"\\n                description={\\n                    <Description>\\n                        Using the <PropName>onItemHovered</PropName> event makes it easy to create tooltips. This story\\n                        is intentionally forced to scroll vertically so layout in scrolling documents can be confirmed.\\n                    </Description>\\n                }>\\n                <DataEditor\\n                    {...defaultProps}\\n                    onItemHovered={onItemHovered}\\n                    getCellContent={getCellContent}\\n                    columns={cols}\\n                    rows={1000}\\n                />\\n            </BeautifulWrapper>\\n            {isOpen &&\\n                renderLayer(\\n                    <div\\n                        {...layerProps}\\n                        style={{\\n                            ...layerProps.style,\\n                            padding: \\\"8px 12px\\\",\\n                            color: \\\"white\\\",\\n                            font: \\\"500 13px Inter\\\",\\n                            backgroundColor: \\\"rgba(0, 0, 0, 0.85)\\\",\\n                            borderRadius: 9,\\n                        }}>\\n                        {tooltip.val}\\n                    </div>\\n                )}\\n        </>\\n    );\\n};\\n(Tooltips as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const ControlledSelection: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(30, true, true);\\n\\n    const [selection, setSelection] = React.useState<GridSelection>({\\n        columns: CompactSelection.empty(),\\n        rows: CompactSelection.empty(),\\n    });\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Controlled Selection\\\"\\n            description={\\n                <Description>\\n                    The selection of the grid can be controlled via <PropName>GridSelection</PropName> and{\\\" \\\"}\\n                    <PropName>onGridSelectionChange</PropName>.\\n                    <input\\n                        type=\\\"range\\\"\\n                        min={0}\\n                        max={29}\\n                        value={selection.current?.cell[0] ?? 0}\\n                        onChange={e => {\\n                            const newCol = e.target.valueAsNumber;\\n                            setSelection(cv => ({\\n                                ...cv,\\n                                current: {\\n                                    cell: [newCol, cv.current?.cell[1] ?? 0],\\n                                    range: {\\n                                        x: newCol,\\n                                        y: cv.current?.cell[1] ?? 0,\\n                                        width: 1,\\n                                        height: 1,\\n                                    },\\n                                    rangeStack: [],\\n                                },\\n                            }));\\n                        }}\\n                    />\\n                    <input\\n                        type=\\\"range\\\"\\n                        min={0}\\n                        max={99}\\n                        value={selection.current?.cell[1] ?? 0}\\n                        onChange={e => {\\n                            const newRow = e.target.valueAsNumber;\\n                            setSelection(cv => ({\\n                                ...cv,\\n                                current: {\\n                                    cell: [cv.current?.cell[0] ?? 0, newRow],\\n                                    range: {\\n                                        x: cv.current?.cell[0] ?? 0,\\n                                        y: newRow,\\n                                        width: 1,\\n                                        height: 1,\\n                                    },\\n                                    rangeStack: [],\\n                                },\\n                            }));\\n                        }}\\n                    />\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                gridSelection={selection}\\n                onGridSelectionChange={setSelection}\\n                columns={cols}\\n                rows={100}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n\\nexport const NewColumnButton: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(10, true);\\n\\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"New column button\\\"\\n            description={\\n                <Description>\\n                    A new column button can be created using the <PropName>rightElement</PropName>.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={columns}\\n                rightElement={\\n                    <ColumnAddButton>\\n                        <button onClick={() => window.alert(\\\"Add a column!\\\")}>+</button>\\n                    </ColumnAddButton>\\n                }\\n                rightElementProps={{\\n                    fill: false,\\n                    sticky: false,\\n                }}\\n                rows={3000}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n\\nexport const CustomHeader: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\\n\\n    const drawHeader: DrawHeaderCallback = React.useCallback(args => {\\n        const { ctx, rect } = args;\\n        ctx.rect(rect.x, rect.y, rect.width, rect.height);\\n        const lg = ctx.createLinearGradient(0, rect.y, 0, rect.y + rect.height);\\n        lg.addColorStop(0, \\\"#ff00d934\\\");\\n        lg.addColorStop(1, \\\"#00a2ff34\\\");\\n        ctx.fillStyle = lg;\\n        ctx.fill();\\n        return false;\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper title=\\\"Custom Header\\\" description={<Description>Make it as fancy as you like.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                drawHeader={drawHeader}\\n                rows={3000}\\n                rowMarkers=\\\"both\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(CustomHeader as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\ninterface PaddingProps {\\n    paddingRight: number;\\n    paddingBottom: number;\\n}\\n\\nexport const Padding: React.VFC<PaddingProps> = p => {\\n    const { paddingRight, paddingBottom } = p;\\n    const { cols, getCellContent } = useMockDataGenerator(20);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Padding\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can add padding at the ends of the grid by setting the <PropName>paddingRight</PropName> and{\\\" \\\"}\\n                        <PropName>paddingBottom</PropName> props\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rowMarkers={\\\"both\\\"}\\n                experimental={{ paddingRight, paddingBottom }}\\n                rows={50}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(Padding as any).argTypes = {\\n    paddingRight: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 0,\\n            max: 600,\\n        },\\n    },\\n    paddingBottom: {\\n        control: {\\n            type: \\\"range\\\",\\n            min: 0,\\n            max: 600,\\n        },\\n    },\\n};\\n(Padding as any).args = {\\n    paddingRight: 200,\\n    paddingBottom: 200,\\n};\\n(Padding as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nexport const HighlightCells: React.VFC = () => {\\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\\n\\n    const [gridSelection, setGridSelection] = React.useState<GridSelection>({\\n        columns: CompactSelection.empty(),\\n        rows: CompactSelection.empty(),\\n    });\\n\\n    const highlights = React.useMemo<DataEditorProps[\\\"highlightRegions\\\"]>(() => {\\n        if (gridSelection.current === undefined) return undefined;\\n        const [col, row] = gridSelection.current.cell;\\n        return [\\n            {\\n                color: \\\"#44BB0022\\\",\\n                range: {\\n                    x: col + 2,\\n                    y: row,\\n                    width: 10,\\n                    height: 10,\\n                },\\n                style: \\\"solid\\\",\\n            },\\n            {\\n                color: \\\"#b000b021\\\",\\n                range: {\\n                    x: col,\\n                    y: row + 2,\\n                    width: 1,\\n                    height: 1,\\n                },\\n            },\\n        ];\\n    }, [gridSelection]);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"HighlightCells\\\"\\n            description={\\n                <Description>\\n                    The <PropName>highlightRegions</PropName> prop can be set to provide additional hinting or context\\n                    for the current selection.\\n                </Description>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                rowMarkers=\\\"both\\\"\\n                freezeColumns={1}\\n                highlightRegions={highlights}\\n                gridSelection={gridSelection}\\n                onGridSelectionChange={setGridSelection}\\n                getCellContent={getCellContent}\\n                getCellsForSelection={getCellsForSelection}\\n                columns={cols}\\n                verticalBorder={c => c > 0}\\n                rows={1000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(HighlightCells as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const LayoutIntegration: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\\n\\n    return (\\n        <BeautifulStyle>\\n            <h1>Layout Integration</h1>\\n            <Description>Trying the grid in different situations</Description>\\n            <DataEditor\\n                {...defaultProps}\\n                className=\\\"white\\\"\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={10}\\n                rowMarkers=\\\"both\\\"\\n                height={200}\\n            />\\n            <DataEditor\\n                {...defaultProps}\\n                className=\\\"white\\\"\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rows={10}\\n                rowMarkers=\\\"both\\\"\\n            />\\n            <div style={{ display: \\\"flex\\\", height: \\\"300px\\\" }}>\\n                <DataEditor\\n                    {...defaultProps}\\n                    className=\\\"white\\\"\\n                    getCellContent={getCellContent}\\n                    columns={cols}\\n                    rows={10}\\n                    rowMarkers=\\\"both\\\"\\n                />\\n                <div style={{ flexShrink: 0 }}>This is some text what happens here?</div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n(LayoutIntegration as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\nexport const DragSource: React.VFC<{ isDraggable: boolean | \\\"header\\\" | \\\"cell\\\" }> = p => {\\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(200);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Drag source\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Setting the <PropName>isDraggable</PropName> prop can allow for more granular control over what\\n                        is draggable in the grid via HTML drag and drop.\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                rowMarkers=\\\"both\\\"\\n                rows={5000}\\n                onRowMoved={(s, e) => window.alert(`Moved row ${s} to ${e}`)}\\n                onColumnMoved={(s, e) => window.alert(`Moved col ${s} to ${e}`)}\\n                onColumnResize={onColumnResize}\\n                isDraggable={p.isDraggable}\\n                onDragStart={e => {\\n                    e.setData(\\\"text/plain\\\", \\\"Drag data here!\\\");\\n                }}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(DragSource as any).argTypes = {\\n    isDraggable: {\\n        control: { type: \\\"select\\\", options: [true, false, \\\"cell\\\", \\\"header\\\"] },\\n    },\\n};\\n(DragSource as any).args = {\\n    isDraggable: false,\\n};\\n(DragSource as any).parameters = {\\n    options: {\\n        showPanel: true,\\n    },\\n};\\n\\nexport const PreventDiagonalScroll: React.VFC = () => {\\n    const { cols, getCellContent } = useMockDataGenerator(200);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Prevent Diagonal Scroll\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        Diagonal scrolling can be prevented by setting <PropName>preventDiagonalScrolling</PropName>.\\n                    </Description>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                preventDiagonalScrolling={true}\\n                rows={5000}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(PreventDiagonalScroll as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\\n// A few supported mime types for drag and drop into cells.\\nconst SUPPORTED_IMAGE_TYPES = new Set([\\\"image/png\\\", \\\"image/gif\\\", \\\"image/bmp\\\", \\\"image/jpeg\\\"]);\\n\\nexport const DropEvents: React.VFC = () => {\\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\\n\\n    const [highlights, setHighlights] = React.useState<DataEditorProps[\\\"highlightRegions\\\"]>([]);\\n\\n    const [lastDropCell, setLastDropCell] = React.useState<Item | undefined>();\\n\\n    const onDrop = React.useCallback(\\n        (cell: Item, dataTransfer: DataTransfer | null) => {\\n            setHighlights([]);\\n\\n            if (dataTransfer === null) {\\n                return;\\n            }\\n\\n            const { files } = dataTransfer;\\n            // This only supports one image, for simplicity.\\n            if (files.length !== 1) {\\n                return;\\n            }\\n\\n            const [file] = files;\\n            if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {\\n                return;\\n            }\\n\\n            const imgUrl = URL.createObjectURL(file);\\n\\n            setCellValue(\\n                cell,\\n                {\\n                    kind: GridCellKind.Image,\\n                    data: [imgUrl],\\n                    allowOverlay: true,\\n                    allowAdd: false,\\n                },\\n                true,\\n                true\\n            );\\n\\n            setLastDropCell(cell);\\n        },\\n        [setCellValue]\\n    );\\n\\n    const onDragOverCell = React.useCallback(\\n        (cell: Item, dataTransfer: DataTransfer | null) => {\\n            if (dataTransfer === null) {\\n                return;\\n            }\\n\\n            const { items } = dataTransfer;\\n            // This only supports one image, for simplicity.\\n            if (items.length !== 1) {\\n                return;\\n            }\\n\\n            const [item] = items;\\n            if (!SUPPORTED_IMAGE_TYPES.has(item.type)) {\\n                return;\\n            }\\n\\n            const [col, row] = cell;\\n            if (getCellContent(cell).kind === GridCellKind.Image) {\\n                setHighlights([\\n                    {\\n                        color: \\\"#44BB0022\\\",\\n                        range: {\\n                            x: col,\\n                            y: row,\\n                            width: 1,\\n                            height: 1,\\n                        },\\n                    },\\n                ]);\\n            } else {\\n                setHighlights([]);\\n            }\\n        },\\n        [getCellContent]\\n    );\\n\\n    const onDragLeave = React.useCallback(() => {\\n        setHighlights([]);\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper\\n            title=\\\"Drop events\\\"\\n            description={\\n                <>\\n                    <Description>\\n                        You can drag and drop into cells by using <PropName>onDragOverCell</PropName> and{\\\" \\\"}\\n                        <PropName>onDrop</PropName>.\\n                    </Description>\\n\\n                    <div>\\n                        {lastDropCell === undefined ? (\\n                            <MoreInfo>Nothing dropped, yet</MoreInfo>\\n                        ) : (\\n                            <>\\n                                <MoreInfo>\\n                                    You last dropped in cell <PropName>{JSON.stringify(lastDropCell)}</PropName>\\n                                </MoreInfo>\\n                            </>\\n                        )}\\n                    </div>\\n                </>\\n            }>\\n            <DataEditor\\n                {...defaultProps}\\n                getCellContent={getCellContent}\\n                columns={cols}\\n                onCellEdited={setCellValue}\\n                onColumnResize={onColumnResize}\\n                rows={1000}\\n                onDrop={onDrop}\\n                onDragOverCell={onDragOverCell}\\n                onDragLeave={onDragLeave}\\n                highlightRegions={highlights}\\n                rowMarkers=\\\"none\\\"\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(DropEvents as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\",\".k1txkgwh{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;}\\n.s11gjm00{width:175px;padding:8px 0;border-radius:6px;box-shadow:0px 0px 1px rgba(62,65,86,0.7),0px 6px 12px rgba(62,65,86,0.35);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:white;font-size:13px;font-weight:600;font-family:-apple-system,BlinkMacSystemFont,\\\"Segoe UI\\\",Roboto,Oxygen,Ubuntu,Cantarell,\\\"Open Sans\\\", \\\"Helvetica Neue\\\",sans-serif;}.s11gjm00 .danger{color:rgba(255,40,40,0.8);}.s11gjm00 .danger:hover{color:rgba(255,40,40,1);}.s11gjm00 > div{padding:6px 8px;color:rgba(0,0,0,0.7);-webkit-transition:background-color 100ms;transition:background-color 100ms;cursor:pointer;}.s11gjm00 > div:hover{background-color:rgba(0,0,0,0.05);color:rgba(0,0,0,0.9);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItYmVhdXRpZnVsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5rMXR4a2d3aCIsIi5zMTFnam0wMCJdLCJtYXBwaW5ncyI6IkFBazNDTUE7QUFrdUJBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLWJlYXV0aWZ1bC5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHNvbmFyanMvbm8taWRlbnRpY2FsLWZ1bmN0aW9ucyAqL1xuLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgICBDZWxsQXJyYXksXG4gICAgQ29tcGFjdFNlbGVjdGlvbixcbiAgICBEcmF3SGVhZGVyQ2FsbGJhY2ssXG4gICAgR3JpZENlbGwsXG4gICAgR3JpZENlbGxLaW5kLFxuICAgIEdyaWRDb2x1bW4sXG4gICAgR3JpZENvbHVtbkljb24sXG4gICAgR3JpZE1vdXNlRXZlbnRBcmdzLFxuICAgIEdyaWRTZWxlY3Rpb24sXG4gICAgR3JvdXBIZWFkZXJDbGlja2VkRXZlbnRBcmdzLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBJdGVtLFxuICAgIFJlY3RhbmdsZSxcbn0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IFNpbXBsZVRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsc1wiO1xuaW1wb3J0IHsgSUJvdW5kcywgdXNlTGF5ZXIgfSBmcm9tIFwicmVhY3QtbGFhZ1wiO1xuaW1wb3J0IHR5cGUgeyBTcHJpdGVNYXAgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC1zcHJpdGVzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGFFZGl0b3JSZWYsIFRoZW1lIH0gZnJvbSBcIi4uLy4uXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHtcbiAgICB1c2VNb2NrRGF0YUdlbmVyYXRvcixcbiAgICBCZWF1dGlmdWxXcmFwcGVyLFxuICAgIERlc2NyaXB0aW9uLFxuICAgIE1vcmVJbmZvLFxuICAgIFByb3BOYW1lLFxuICAgIGxvc3N5Q29weURhdGEsXG4gICAgZ2V0R3JpZENvbHVtbixcbiAgICBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvLFxuICAgIENvbnRlbnRDYWNoZSxcbiAgICBCZWF1dGlmdWxTdHlsZSxcbiAgICBDb2x1bW5BZGRCdXR0b24sXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwibG9kYXNoL25vb3AuanNcIjtcbmltcG9ydCB0eXBlIHsgR2V0Um93VGhlbWVDYWxsYmFjayB9IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXJlbmRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiR2xpZGUtRGF0YS1HcmlkL0RhdGFFZGl0b3IgRGVtb3NcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb246IHRydWUsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuZXhwb3J0IGNvbnN0IFJlc2l6YWJsZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlc2l6YWJsZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIHJlc2l6ZSBjb2x1bW5zIGJ5IGRyYWdnaW5nIHRoZWlyIGVkZ2VzLCBhcyBsb25nIGFzIHlvdSByZXNwb25kIHRvIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5vbkNvbHVtblJlc2l6ZTwvUHJvcE5hbWU+IHByb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IHNldHRpbmcgdGhlIDxQcm9wTmFtZT5vdmVyc2Nyb2xsWDwvUHJvcE5hbWU+IHByb3BlcnR5IGV4dHJhIHNwYWNlIGNhbiBiZSBhbGxvY2F0ZWQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGdyaWQgdG8gYWxsb3cgZm9yIGVhc2llciByZXNpemluZyBvZiB0aGUgZmluYWwgY29sdW1uLiBZb3UgY2FuIGhpZ2hsaWdodCBtdWx0aXBsZSBjb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB0byByZXNpemUgdGhlbSBhbGwgYXQgb25jZS5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9ezIwMH1cbiAgICAgICAgICAgICAgICBvdmVyc2Nyb2xsWT17MjAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbkF1dG9XaWR0aD17NTAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXsyMDAwfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVzaXphYmxlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgT3ZlcnNjcm9sbFByb3BzIHtcbiAgICBvdmVyc2Nyb2xsWDogbnVtYmVyO1xuICAgIG92ZXJzY3JvbGxZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBPdmVyc2Nyb2xsOiBSZWFjdC5WRkM8T3ZlcnNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgb3ZlcnNjcm9sbFgsIG92ZXJzY3JvbGxZIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk92ZXJzY3JvbGxcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWxsb2NhdGUgZXh0cmEgc3BhY2UgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b3ZlcnNjcm9sbFg8L1Byb3BOYW1lPiBhbmQgPFByb3BOYW1lPm92ZXJzY3JvbGxZPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e292ZXJzY3JvbGxYfVxuICAgICAgICAgICAgICAgIG92ZXJzY3JvbGxZPXtvdmVyc2Nyb2xsWX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgb3ZlcnNjcm9sbFg6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvdmVyc2Nyb2xsWToge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDYwMCxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBvdmVyc2Nyb2xsWDogMjAwLFxuICAgIG92ZXJzY3JvbGxZOiAyMDAsXG59O1xuKE92ZXJzY3JvbGwgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBjbGVhckNlbGwoY2VsbDogR3JpZENlbGwpOiBHcmlkQ2VsbCB7XG4gICAgc3dpdGNoIChjZWxsLmtpbmQpIHtcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuRHJpbGxkb3duOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5CdWJibGU6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVXJpOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5NYXJrZG93bjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlRleHQ6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5OdW1iZXI6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiAwLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbn1cblxuZXhwb3J0IGNvbnN0IEFkZERhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA2MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3Qgb25Sb3dBcHBlbmRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gbnVtUm93cztcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsQ29udGVudChbYywgbmV3Um93XSk7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWVSYXcoW2MsIG5ld1Jvd10sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgIH0sIFtnZXRDZWxsQ29udGVudCwgbnVtUm93cywgc2V0Q2VsbFZhbHVlUmF3XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPkRhdGEgY2FuIGJlIGFkZGVkIGJ5IGNsaWNraW5nIG9uIHRoZSB0cmFpbGluZyByb3cuPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgS2V5Ym9hcmQgaXMgYWxzbyBzdXBwb3J0ZWQsIGp1c3QgbmF2aWdhdGUgcGFzdCB0aGUgbGFzdCByb3cgYW5kIHByZXNzIDxLZXlOYW1lPkVudGVyPC9LZXlOYW1lPlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGREYXRhIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodFRvTGVmdDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2wsIF9yb3ddID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChjb2wgIT09IDApIHJldHVybiBnZXRDZWxsQ29udGVudChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwi15DXoNeZINeS15PXoteV158sINee15XXnteX15Qg15zXkNek15zXmden16bXmdeV16og15LXnNeZ15nXky5cIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCLXkNeg15kg15LXk9ei15XXnywg157Xldee15fXlCDXnNeQ16TXnNeZ16fXpteZ15XXqiDXktec15nXmdeTLlwiLFxuICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJpZ2h0IFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRoZSBkYXRhIGVkaXRvciBhdXRvbWF0aWNhbGx5IGRldGVjdHMgUlRMIGluIHRleHQgY2VsbHMgYW5kIHJlc3BlY3RzIGl0LjwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJpZ2h0VG9MZWZ0IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZURhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVmFsaWRhdGUgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YSBjYW4gYmUgdmFsaWRhdGVkIHVzaW5nIHRoZSA8UHJvcE5hbWU+dmFsaWRhdGVDZWxsPC9Qcm9wTmFtZT4gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlRoaXMgZXhhbXBsZSBvbmx5IGFsbG93cyB0aGUgd29yZCAmcXVvdDtWYWxpZCZxdW90OyBpbnNpZGUgdGV4dCBjZWxscy48L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDZWxsPXsoX2NlbGwsIG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5raW5kICE9PSBHcmlkQ2VsbEtpbmQuVGV4dCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5kYXRhID09PSBcIlZhbGlkXCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJWYWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBbMCwgM10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFZhbGlkYXRlRGF0YSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRmlsbEhhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoXG4gICAgICAgIDYwLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgICAgIGlmIChpWzBdID09PSAxICYmIHZhbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRmlsbCBoYW5kbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5GaWxsIGhhbmRsZXMgY2FuIGJlIHVzZWQgdG8gZG93bmZpbGwgZGF0YSB3aXRoIHRoZSBtb3VzZS48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBKdXN0IGNsaWNrIGFuZCBkcmFnLCB0aGUgdG9wIHJvdyB3aWxsIGJlIGNvcGllZCBkb3duLiBFbmFibGUgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmZpbGxIYW5kbGU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnRNYW5nbGVkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgZmlsbEhhbmRsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihGaWxsSGFuZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNIaW50OiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAgIDI6IFwiU21vbCB0ZXh0XCIsXG4gICAgMzogXCJBZGRcIixcbiAgICA1OiBcIk5ld1wiLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0ljb246IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7XG4gICAgMjogR3JpZENvbHVtbkljb24uSGVhZGVyQXJyYXksXG4gICAgMzogR3JpZENvbHVtbkljb24uSGVhZGVyRW1vamksXG4gICAgNTogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldDogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHtcbiAgICAyOiAwLFxuICAgIDM6IDAsXG4gICAgNTogMCxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNEaXNhYmxlZDogUmVjb3JkPG51bWJlciwgYm9vbGVhbj4gPSB7XG4gICAgMzogdHJ1ZSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNUaGVtZTogUmVjb3JkPG51bWJlciwgUGFydGlhbDxUaGVtZT4+ID0ge1xuICAgIDI6IHtcbiAgICAgICAgYmFzZUZvbnRTdHlsZTogXCIxMHB4XCIsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBUcmFpbGluZ1Jvd09wdGlvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgY29uc3QgY29sdW1uc1dpdGhSb3dPcHRpb25zOiBHcmlkQ29sdW1uW10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKChjLCBpZHgpID0+ICh7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgaGludDogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0hpbnRbaWR4XSxcbiAgICAgICAgICAgICAgICBhZGRJY29uOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzSWNvbltpZHhdLFxuICAgICAgICAgICAgICAgIHRhcmdldENvbHVtbjogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldFtpZHhdLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzRGlzYWJsZWRbaWR4XSxcbiAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzVGhlbWVbaWR4XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9LCBbY29sc10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVHJhaWxpbmcgcm93IG9wdGlvbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBjdXN0b21pemUgdGhlIHRyYWlsaW5nIHJvdyBpbiBlYWNoIGNvbHVtbiBieSBzZXR0aW5nIGF7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT50cmFpbGluZ1Jvd09wdGlvbnM8L1Byb3BOYW1lPiBpbiB5b3VyIGNvbHVtbnMuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnNXaXRoUm93T3B0aW9uc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRyYWlsaW5nUm93T3B0aW9ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQWRkRGF0YVRvVG9wOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlUmF3LCBzZXRDZWxsVmFsdWUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCBhbGwgb2YgdGhlIGV4aXN0aW5nIGNlbGxzIGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiAwOyB5LS0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFt4LCB5XSwgZ2V0Q2VsbENvbnRlbnQoW3gsIHkgLSAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIDBdKTtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbYywgMF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gXCJ0b3BcIiBhcyBjb25zdDtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQWRkIGRhdGFcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFkZERhdGFUb1RvcCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgQWRkRGF0YVRvTWlkZGxlUHJvcHMge1xuICAgIGluc2VydEluZGV4OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgQWRkRGF0YVRvTWlkZGxlOiBSZWFjdC5GQzxBZGREYXRhVG9NaWRkbGVQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IGluZGV4ID0gcC5pbnNlcnRJbmRleDtcbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCByb3dzIGJlbG93IGluZGV4IGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiBpbmRleDsgeS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDY7IHgrKykge1xuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbeCwgeV0sIGdldENlbGxDb250ZW50KFt4LCB5IC0gMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDY7IGMrKykge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGdldENlbGxDb250ZW50KFtjLCBpbmRleF0pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBpbmRleF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSwgW2dldENlbGxDb250ZW50LCBudW1Sb3dzLCBzZXRDZWxsVmFsdWVSYXcsIGluZGV4XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YSB0byBtaWRkbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCA8S2V5TmFtZT5pbnNlcnRJbmRleDwvS2V5TmFtZT4gaXMgemVyby1iYXNlZCB3aGlsZSB0aGUgbnVtYmVyIGNvbHVtbiBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZ3JpZCBpcyBvbmUtYmFzZWQsIHNvIGluc2VydGluZyBhdCBpbmRleCAmcXVvdDs0JnF1b3Q7IGNyZWF0ZXMgYSBuZXcgcm93IGF0ICZxdW90OzUmcXVvdDtcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIGhpbnQ6IFwiTmV3IHJvdy4uLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpbnNlcnRJbmRleDogMTAsXG59O1xuKEFkZERhdGFUb01pZGRsZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGluc2VydEluZGV4OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICAgIG1heDogNDgsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEFwcGVuZFJvd0hhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3Qgb25DbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdm9pZCByZWYuY3VycmVudD8uYXBwZW5kUm93KDMpO1xuICAgIH0sIFtyZWZdKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiYXBwZW5kUm93IFJlZlwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgQWRkaW5nIGRhdGEgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGZyb20gb3V0c2lkZSBvZiA8UHJvcE5hbWU+RGF0YUVkaXRvcjwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IGNhbGxpbmcgPFByb3BOYW1lPmFwcGVuZFJvdzwvUHJvcE5hbWU+IG9uIGEgPFByb3BOYW1lPnJlZjwvUHJvcE5hbWU+IHRvIHlvdXIgZ3JpZCwgeW91IGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciB0aGUgYXBwZW5kIGVsc2V3aGVyZSwgbGlrZSB0aGlzIDxLZXlOYW1lIG9uQ2xpY2s9e29uQ2xpY2t9PkFwcGVuZDwvS2V5TmFtZT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFwcGVuZFJvd0hhbmRsZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU21hbGxFZGl0YWJsZUdyaWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJFZGl0YWJsZSBHcmlkXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBzdXBwb3J0cyBvdmVybGF5IGVkaXRvcnMgZm9yIGNoYW5naW5nIHZhbHVlcy4gVGhlcmUgYXJlIGJlc3Bva2UgZWRpdG9ycyBmb3IgbnVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncywgaW1hZ2VzLCBib29sZWFucywgbWFya2Rvd24sIGFuZCB1cmkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezIwfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNtYWxsRWRpdGFibGVHcmlkIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVNaWxsaW9uUm93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk9uZSBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5EYXRhIGdyaWQgc3VwcG9ydHMgb3ZlciAxIG1pbGxpb24gcm93cy4gWW91ciBsaW1pdCBpcyBtb3N0bHkgUkFNLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxXzAwMF8wMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oT25lTWlsbGlvblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFNpbGx5TnVtYmVyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIjEwMCBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgMTAwIG1pbGxpb24gcm93cyBpcyBzaWxseS4gT25jZSB3ZSBjcm9zcyBhYm91dCAzMyBtaWxsaW9uIHBpeGVscyBpbiBoZWlnaHQgd2UgY2FuIG5vIGxvbmdlciB0cnVzdFxuICAgICAgICAgICAgICAgICAgICB0aGUgYnJvd3NlciB0byBzY3JvbGwgYWNjdXJhdGVseS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDBfMDAwXzAwMH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibnVtYmVyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTaWxseU51bWJlcnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IE9ic2VydmVWaXNpYmxlUmVnaW9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIGNvbnN0IFt2aXNpYmxlUmVnaW9uLCBzZXRWaXNpYmxlUmVnaW9uXSA9IFJlYWN0LnVzZVN0YXRlPFJlY3RhbmdsZT4oeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT2JzZXJ2ZSBWaXNpYmxlIFJlZ2lvblwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHZpc2libGUgcmVnaW9uIGNhbiBiZSBvYnNlcnZlZCB1c2luZyA8UHJvcE5hbWU+b25WaXNpYmxlUmVnaW9uQ2hhbmdlZDwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZW4gY3VycmVudCB2aXNpYmxlIHJlZ2lvbiBpcyB4OjxLZXlOYW1lPnt2aXNpYmxlUmVnaW9uLnh9PC9LZXlOYW1lPiB5OlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ueX08L0tleU5hbWU+IHdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ud2lkdGh9PC9LZXlOYW1lPiBoZWlnaHQ6PEtleU5hbWU+e3Zpc2libGVSZWdpb24uaGVpZ2h0fTwvS2V5TmFtZT5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPXtzZXRWaXNpYmxlUmVnaW9ufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZU1pbGxpb25Sb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVIdW5kcmVkVGhvdXNhbmRDb2xzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMF8wMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT25lIEh1bmRyZWQgVGhvdXNhbmQgQ29sdW1uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgd2F5IG1vcmUgY29sdW1ucyB0aGFuIHlvdSB3aWxsIGV2ZXIgbmVlZC4gQWxzbyB0aGlzIGlzIHJlbmRlcmluZyAxMCBtaWxsaW9uIGNlbGxzXG4gICAgICAgICAgICAgICAgICAgIGJ1dCB0aGF0JmFwb3M7cyBub3QgaW1wb3J0YW50LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZUh1bmRyZWRUaG91c2FuZENvbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRlbk1pbGxpb25DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJUZW4gTWlsbGlvbiBDZWxsc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPkRhdGEgZ3JpZCBzdXBwb3J0cyBvdmVyIDEwIG1pbGxpb24gY2VsbHMuIEdvIG51dHMgd2l0aCBpdC48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihUZW5NaWxsaW9uQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIFNtb290aFNjcm9sbGluZ0dyaWRQcm9wcyB7XG4gICAgc21vb3RoU2Nyb2xsWDogYm9vbGVhbjtcbiAgICBzbW9vdGhTY3JvbGxZOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgU21vb3RoU2Nyb2xsaW5nR3JpZDogUmVhY3QuRkM8U21vb3RoU2Nyb2xsaW5nR3JpZFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDMwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNtb290aCBzY3JvbGxpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBlbmFibGUgc21vb3RoIHNjcm9sbGluZyB3aXRoIHRoZSA8UHJvcE5hbWU+c21vb3RoU2Nyb2xsWDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPnNtb290aFNjcm9sbFk8L1Byb3BOYW1lPiBwcm9wcy4gRGlzYWJsaW5nIHNtb290aCBzY3JvbGxpbmcgY2FuIGRyYW1hdGljYWxseSBpbmNyZWFzZVxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZSBhbmQgaW1wcm92ZSB2aXN1YWwgc3RhYmlsaXR5IGR1cmluZyByYXBpZCBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17cC5zbW9vdGhTY3JvbGxYfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3Auc21vb3RoU2Nyb2xsWX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU21vb3RoU2Nyb2xsaW5nR3JpZCBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogZmFsc2UsXG4gICAgc21vb3RoU2Nyb2xsWTogZmFsc2UsXG59O1xuKFNtb290aFNjcm9sbGluZ0dyaWQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW5wdXRCbGVuZGluZ0dyaWRQcm9wcyB7XG4gICAgcmFuZ2VCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICBjb2x1bW5CbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByYW5nZU11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwiY2VsbFwiIHwgXCJyZWN0XCIgfCBcIm11bHRpLWNlbGxcIiB8IFwibXVsdGktcmVjdFwiO1xuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwic2luZ2xlXCIgfCBcIm11bHRpXCI7XG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibm9uZVwiIHwgXCJzaW5nbGVcIiB8IFwibXVsdGlcIjtcbn1cblxuZXhwb3J0IGNvbnN0IElucHV0QmxlbmRpbmc6IFJlYWN0LkZDPElucHV0QmxlbmRpbmdHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMzApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiSW5wdXQgYmxlbmRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgSW5wdXQgYmxlbmRpbmcgY2FuIGJlIGVuYWJsZWQgb3IgZGlzYWJsZSBiZXR3ZWVuIHJvdywgY29sdW1uLCBhbmQgcmFuZ2Ugc2VsZWN0aW9ucy4gTXVsdGktc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjYW4gYWxzbyBiZSBlbmFibGVkIG9yIGRpc2FibGVkIHdpdGggdGhlIHNhbWUgbGV2ZWwgb2YgZ3JhbnVsYXJpdHkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17cC5yb3dNdWx0aVNlbGVjdCA9PT0gXCJub25lXCIgPyBcIm51bWJlclwiIDogXCJib3RoXCJ9XG4gICAgICAgICAgICAgICAga2V5YmluZGluZ3M9e3tcbiAgICAgICAgICAgICAgICAgICAgY2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvcHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRvd25GaWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByaWdodEZpbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEb3duOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYWdlVXA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEFsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0Q29sdW1uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RSb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICByYW5nZVNlbGVjdD17cC5yYW5nZU11bHRpU2VsZWN0fVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdD17cC5jb2x1bW5NdWx0aVNlbGVjdH1cbiAgICAgICAgICAgICAgICByb3dTZWxlY3Q9e3Aucm93TXVsdGlTZWxlY3R9XG4gICAgICAgICAgICAgICAgcmFuZ2VTZWxlY3Rpb25CbGVuZGluZz17cC5yYW5nZUJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdGlvbkJsZW5kaW5nPXtwLmNvbHVtbkJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbkJsZW5kaW5nPXtwLnJvd0JsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkuYXJncyA9IHtcbiAgICByYW5nZUJsZW5kaW5nOiBcIm1peGVkXCIsXG4gICAgY29sdW1uQmxlbmRpbmc6IFwibWl4ZWRcIixcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiLFxuICAgIHJhbmdlTXVsdGlTZWxlY3Q6IFwicmVjdFwiLFxuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm11bHRpXCIsXG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibXVsdGlcIixcbn07XG4oSW5wdXRCbGVuZGluZyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJhbmdlQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgY29sdW1uQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcm93QmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcmFuZ2VNdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJjZWxsXCIsIFwicmVjdFwiLCBcIm11bHRpLWNlbGxcIiwgXCJtdWx0aS1yZWN0XCJdIH0sXG4gICAgfSxcbiAgICBjb2x1bW5NdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJzaW5nbGVcIiwgXCJtdWx0aVwiXSB9LFxuICAgIH0sXG4gICAgcm93TXVsdGlTZWxlY3Q6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJub25lXCIsIFwic2luZ2xlXCIsIFwibXVsdGlcIl0gfSxcbiAgICB9LFxufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIEFkZENvbHVtbnNQcm9wcyB7XG4gICAgY29sdW1uc0NvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBBZGRDb2x1bW5zOiBSZWFjdC5GQzxBZGRDb2x1bW5zUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKHAuY29sdW1uc0NvdW50KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkFkZCBhbmQgcmVtb3ZlIGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGFkZCBhbmQgcmVtb3ZlIGNvbHVtbnMgYXQgeW91ciBkaXNwb3NhbDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5Vc2UgdGhlIHN0b3J5JmFwb3M7cyBjb250cm9scyB0byBjaGFuZ2UgdGhlIG51bWJlciBvZiBjb2x1bW5zPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJncyA9IHtcbiAgICBjb2x1bW5zQ291bnQ6IDEwLFxufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgY29sdW1uc0NvdW50OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKEFkZENvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU2Nyb2xsU2hhZG93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IFJlYWN0LnVzZVN0YXRlPEdyaWRTZWxlY3Rpb24+KHtcbiAgICAgICAgcm93czogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBvblNlbGVjdGlvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdTZWw6IEdyaWRTZWxlY3Rpb24pID0+IHtcbiAgICAgICAgbGV0IG5ld1Jvd3MgPSBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIGlmIChuZXdTZWwuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdSb3dzID0gbmV3Um93cy5hZGQoW25ld1NlbC5jdXJyZW50LnJhbmdlLnksIG5ld1NlbC5jdXJyZW50LnJhbmdlLnkgKyBuZXdTZWwuY3VycmVudC5yYW5nZS5oZWlnaHRdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbmV3U2VsLmN1cnJlbnQ/LnJhbmdlU3RhY2sgPz8gW10pIHtcbiAgICAgICAgICAgIG5ld1Jvd3MgPSBuZXdSb3dzLmFkZChbYi55LCBiLnkgKyBiLmhlaWdodF0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAuLi5uZXdTZWwsXG4gICAgICAgICAgICByb3dzOiBuZXdSb3dzLFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB0aGVtZSA9IFJlYWN0LnVzZU1lbW88UGFydGlhbDxUaGVtZT4+KFxuICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgICAgYWNjZW50TGlnaHQ6IFwiI2IxZjZmZlwiLFxuICAgICAgICAgICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBoZWFkZXJCb3R0b21Cb3JkZXJDb2xvcjogXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXCIsXG4gICAgICAgIH0pLFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2socm93ID0+IChyb3cgJSAyID09PSAwID8gdW5kZWZpbmVkIDogeyBiZ0NlbGw6IFwiI2Y1ZjVmNlwiIH0pLCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBdXRvbWF0aWMgUm93IE1hcmtlcnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGVuYWJsZSBhbmQgZGlzYWJsZSB0aGUgaG9yaXpvbnRhbC92ZXJ0aWNhbCBzY3JvbGwgc2hhZG93cy48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcIm51bWJlclwifVxuICAgICAgICAgICAgICAgIGdyaWRTZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBvbkdyaWRTZWxlY3Rpb25DaGFuZ2U9e29uU2VsZWN0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0PXsyNn1cbiAgICAgICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezIyfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICB0aGVtZT17dGhlbWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU2Nyb2xsU2hhZG93cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQXV0b21hdGljUm93TWFya2VyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQXV0b21hdGljIFJvdyBNYXJrZXJzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGVuYWJsZSByb3cgbWFya2VycyB3aXRoIHJpY2ggc2VsZWN0aW9uIGJlaGF2aW9yIHVzaW5nIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5yb3dNYXJrZXJzPC9Qcm9wTmFtZT4gcHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIDxLZXlOYW1lPuKHpzwvS2V5TmFtZT4gKyBjbGljayB0byBtYWtlIHJhbmdlIHNlbGVjdGlvbnMsIGFuZCA8S2V5TmFtZT5DdHJsPC9LZXlOYW1lPiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyBjbGljayB0byBhZGQvcmVtb3ZlIGluZGl2aWR1YWwgcm93cy5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBdXRvbWF0aWNSb3dNYXJrZXJzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBXcmFwcGluZ1RleHQ6IFJlYWN0LlZGQzx7XG4gICAgYWxpZ25tZW50OiBcImxlZnRcIiB8IFwiY2VudGVyXCIgfCBcInJpZ2h0XCI7XG4gICAgbGVuZ3RoOiBudW1iZXI7XG4gICAgaHlwZXJXcmFwcGluZzogYm9vbGVhbjtcbn0+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3Qgc3VmZml4ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCAxMDApLm1hcCgoKSA9PiBmYWtlci5sb3JlbS5zZW50ZW5jZShwLmxlbmd0aCkpO1xuICAgIH0sIFtwLmxlbmd0aF0pO1xuXG4gICAgY29uc3QgbWFuZ2xlZEdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2s8dHlwZW9mIGdldENlbGxDb250ZW50PihcbiAgICAgICAgaSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gaTtcblxuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtyb3d9LFxcbiR7c3VmZml4W3JvdyAlIHN1ZmZpeC5sZW5ndGhdfWAsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd30sICR7c3VmZml4fWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBbGlnbjogcC5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50LCBwLmFsaWdubWVudCwgc3VmZml4XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJXcmFwcGluZyBUZXh0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRleHQgY2VsbHMgY2FuIGhhdmUgd3JhcHBpbmcgdGV4dCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+YWxsb3dXcmFwcGluZzwvUHJvcE5hbWU+IHByb3AgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezgwfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWw9e3tcbiAgICAgICAgICAgICAgICAgICAgaHlwZXJXcmFwcGluZzogcC5oeXBlcldyYXBwaW5nLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oV3JhcHBpbmdUZXh0IGFzIGFueSkuYXJncyA9IHtcbiAgICBhbGlnbm1lbnQ6IFwibGVmdFwiLFxuICAgIGxlbmd0aDogMjAsXG4gICAgaHlwZXJXcmFwcGluZzogZmFsc2UsXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGFsaWdubWVudDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXSB9LFxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBVbmV2ZW5Sb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJVbmV2ZW4gUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBSb3dzIGNhbiBiZSBtYWRlIHVuZXZlbiBieSBwYXNzaW5nIGEgY2FsbGJhY2sgdG8gdGhlIDxQcm9wTmFtZT5yb3dIZWlnaHQ8L1Byb3BOYW1lPiBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXtyID0+IChyICUgMyA9PT0gMCA/IDMwIDogciAlIDIgPyA1MCA6IDYwKX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVuZXZlblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IERyYXdDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhdyBjdXN0b20gY2VsbHNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmF3IGN1c3RvbSBjZWxsIGNvbnRlbnRzIGhvd2V2ZXIgeW91IHdhbnQgdXNpbmcgdGhlIDxQcm9wTmFtZT5kcmF3Q3VzdG9tQ2VsbDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZHJhd0NlbGw9e2FyZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNlbGwsIHJlY3QsIGN0eCB9ID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwua2luZCAhPT0gR3JpZENlbGxLaW5kLlRleHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNYID0gY2VsbC5kaXNwbGF5RGF0YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwieFwiKTsgLy8gYWxsIG15IHgncyBsaXZlIGluIHRleGFzXG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gY2VsbC5kaXNwbGF5RGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGFzWCA/IFwiI2JmZmZjZFwiIDogXCIjZmZlNmU2XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICsgMSwgeSArIDEsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGhhc1ggPyBcIiMwZmMwMzVcIiA6IFwiI2UwMWUxZVwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IFwiYm9sZCAxNHB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRhdGEsIHggKyA4ICsgMC41LCB5ICsgaGVpZ2h0IC8gMiArIDQuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKERyYXdDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUmVhcnJhbmdlQ29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZGlydHkgaGFjayBiZWNhdXNlIHRoZSBtb2NrIGdlbmVyYXRvciBkb2Vzbid0IHJlYWxseSBzdXBwb3J0IGNoYW5naW5nIHRoaXMuIEluIGEgcmVhbCBkYXRhIHNvdXJjZVxuICAgIC8vIHlvdSBzaG91bGQgdHJhY2sgaW5kZXhlcyBwcm9wZXJseVxuICAgIGNvbnN0IFtzb3J0YWJsZUNvbHMsIHNldFNvcnRhYmxlQ29sc10gPSBSZWFjdC51c2VTdGF0ZShjb2xzKTtcblxuICAgIGNvbnN0IG9uQ29sTW92ZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoc3RhcnRJbmRleDogbnVtYmVyLCBlbmRJbmRleDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIHNldFNvcnRhYmxlQ29scyhvbGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29scyA9IFsuLi5vbGRdO1xuICAgICAgICAgICAgY29uc3QgW3RvTW92ZV0gPSBuZXdDb2xzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgICAgICAgIG5ld0NvbHMuc3BsaWNlKGVuZEluZGV4LCAwLCB0b01vdmUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbHM7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldENlbGxDb250ZW50TWFuZ2xlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkQ29sID0gY29scy5maW5kSW5kZXgoYyA9PiBjLnRpdGxlID09PSBzb3J0YWJsZUNvbHNbY29sXS50aXRsZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2VsbENvbnRlbnQoW3JlbWFwcGVkQ29sLCByb3ddKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHMsIGdldENlbGxDb250ZW50LCBzb3J0YWJsZUNvbHNdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlYXJyYW5nZSBDb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgY2FuIGJlIHJlYXJyYW5nZWQgYnkgZHJhZyBhbmQgZHJvcHBpbmcsIGFzIGxvbmcgYXMgeW91IHJlc3BvbmQgdG8gdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25Db2x1bW5Nb3ZlZDwvUHJvcE5hbWU+IGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3NvcnRhYmxlQ29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtvbkNvbE1vdmVkfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVhcnJhbmdlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUm93QW5kSGVhZGVyU2l6ZXNQcm9wcyB7XG4gICAgcm93SGVpZ2h0OiBudW1iZXI7XG4gICAgaGVhZGVySGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgUm93QW5kSGVhZGVyU2l6ZXM6IFJlYWN0LlZGQzxSb3dBbmRIZWFkZXJTaXplc1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJvdyBhbmQgSGVhZGVyIHNpemVzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGUgcm93IHNpemUgY2FuIGJlIGNvbnRyb2xsZWQgd2l0aCA8UHJvcE5hbWU+cm93SGVpZ2h0PC9Qcm9wTmFtZT4gYW5kIHRoZSBoZWFkZXIgc2l6ZSB3aXRoe1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmhlYWRlckhlaWdodDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VXNlIHRoZSBzdG9yeSZhcG9zO3MgY29udHJvbHMgdG8gcmVzaXplIHRoZW08L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9e3Aucm93SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhlYWRlckhlaWdodD17cC5oZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wibnVtYmVyXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgcm93SGVpZ2h0OiAzNCxcbiAgICBoZWFkZXJIZWlnaHQ6IDM0LFxufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJvd0hlaWdodDoge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDIwLFxuICAgICAgICAgICAgbWF4OiAyMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBoZWFkZXJIZWlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAyMCxcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFJvd0FuZEhlYWRlclNpemVzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgS2V5TmFtZSA9IHN0eWxlZC5rYmRgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICBjb2xvcjogIzJiMmIyYjtcbiAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgbWFyZ2luOiAwIDAuMWVtO1xuYDtcblxuZXhwb3J0IGNvbnN0IE11bHRpU2VsZWN0Q29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTXVsdGkgc2VsZWN0IGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gc2VsZWN0IG11bHRpcGxlIGNvbHVtbnMgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5zZWxlY3RlZENvbHVtbnM8L1Byb3BOYW1lPiBhbmR7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25TZWxlY3RlZENvbHVtbnNDaGFuZ2U8L1Byb3BOYW1lPiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBIZXJlIHlvdSBjYW4gbXVsdGkgc2VsZWN0IGNvbHVtbnMgYnkgdXNpbmcgPEtleU5hbWU+Q3RybDwvS2V5TmFtZT4gKG9uIFdpbmRvd3MpIG9ye1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+4oyYPC9LZXlOYW1lPiAob24gTWFjKVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oTXVsdGlTZWxlY3RDb2x1bW5zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGdldENvbHVtbnNGb3JDZWxsVHlwZXMoKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJSb3cgSURcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJSb3dJRCxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Sb3dJRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFrZXIuZGF0YXR5cGUudXVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIlByb3RlY3RlZFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmYWtlci5maW5hbmNlLmJpdGNvaW5BZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkxvYWRpbmdcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJTdHJpbmcsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVGV4dFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTnVtYmVyXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gZmFrZXIuZGF0YXR5cGUubnVtYmVyKDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYWdlLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7YWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckJvb2xlYW4sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb2xsID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcm9sbCA8IDAuMSA/IHVuZGVmaW5lZCA6IHJvbGwgPCAwLjIgPyBudWxsIDogcm9sbCA8IDAuNjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIGVkaXRhYmxlLiBVWCBsb29rcyBiYWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJJbWFnZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYCR7ZmFrZXIuaW1hZ2UuYW5pbWFscyg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVXJpXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyVXJpLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZmFrZXIuaW50ZXJuZXQudXJsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlVyaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1hcmtkb3duXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTWFya2Rvd24sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZG93biA9IGAjIFRpdGxlXG5IZWxsbyBteSBuYW1lIGlzICoke2Zha2VyLm5hbWUuZmlyc3ROYW1lKCl9KlxuXG4jIyBUT0RPOlxuVHJ5IG91dCBbR2xpZGVdKGh0dHBzOi8vd3d3LmdsaWRlYXBwcy5jb20vKVxuYDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1hcmtkb3duLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkJ1YmJsZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2Zha2VyLmxvcmVtLndvcmQoKSwgZmFrZXIubG9yZW0ud29yZCgpLCBmYWtlci5sb3JlbS53b3JkKCldLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRyaWxsZG93blwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkRyaWxsZG93bixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZha2VyLmFkZHJlc3MuY2l0eU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IGAke2Zha2VyLmltYWdlLm5hdHVyZSg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmFrZXIuYWRkcmVzcy5jaXR5TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogYCR7ZmFrZXIuaW1hZ2UubmF0dXJlKDQwLCA0MCl9P3JhbmRvbT0ke2Zha2VyLmRhdGF0eXBlLm51bWJlcigxMDBfMDAwKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZUFsbE1vY2tlZEtpbmRzKCkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKGdldENvbHVtbnNGb3JDZWxsVHlwZXMpO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgW3VwZGF0ZVZlcnNpb24sIHNldFVwZGF0ZVZlcnNpb25dID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiB7XG4gICAgICAgICAgICAvLyBUZXJyaWJsZSBoYWNrIHRvIGZvcmNlIHVwZGF0ZSB3aGVuIHNldENlbGxWYWx1ZSByZXF1ZXN0cyBpdFxuICAgICAgICAgICAgbm9vcCh1cGRhdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBjYWNoZS5jdXJyZW50LmdldChjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbY29sc01hcCwgdXBkYXRlVmVyc2lvbl1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsLCBub0Rpc3BsYXk/OiBib29sZWFuLCBmb3JjZVVwZGF0ZT86IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY2FjaGUuY3VycmVudC5nZXQoY29sLCByb3cpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGVHcmlkQ2VsbCh2YWwpICYmIGlzRWRpdGFibGVHcmlkQ2VsbChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcGllZCA9IGxvc3N5Q29weURhdGEodmFsLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jdXJyZW50LnNldChjb2wsIHJvdywge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb3BpZWQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBub0Rpc3BsYXkgPT09IHRydWUgPyB1bmRlZmluZWQgOiBjb3BpZWQuZGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVVwZGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcGRhdGVWZXJzaW9uKHYgPT4gdiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNNYXBdXG4gICAgKTtcblxuICAgIHJldHVybiB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH07XG59XG5cbmV4cG9ydCBjb25zdCBBbGxDZWxsS2luZHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTG90c2EgY2VsbCBraW5kc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgcGxlbnR5IGNlbGwga2luZHMuIEFueXRoaW5nIHVuZGVyIDxQcm9wTmFtZT5HcmlkQ2VsbEtpbmQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjZmYwMGZmMzNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFsbENlbGxLaW5kcyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5jb25zdCBkYXJrVGhlbWUgPSB7XG4gICAgYWNjZW50Q29sb3I6IFwiIzhjOTZmZlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoMjAyLCAyMDYsIDI1NSwgMC4yNTMpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjZmZmZmZmXCIsXG4gICAgdGV4dE1lZGl1bTogXCIjYjhiOGI4XCIsXG4gICAgdGV4dExpZ2h0OiBcIiNhMGEwYTBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiNmZmZmZmZcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjYjhiOGI4XCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiMwMDAwMDBcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiNhMWExYTFcIixcbiAgICB0ZXh0SGVhZGVyU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdDZWxsOiBcIiMxNjE2MWJcIixcbiAgICBiZ0NlbGxNZWRpdW06IFwiIzIwMjAyN1wiLFxuICAgIGJnSGVhZGVyOiBcIiMyMTIxMjFcIixcbiAgICBiZ0hlYWRlckhhc0ZvY3VzOiBcIiM0NzQ3NDdcIixcbiAgICBiZ0hlYWRlckhvdmVyZWQ6IFwiIzQwNDA0MFwiLFxuXG4gICAgYmdCdWJibGU6IFwiIzIxMjEyMVwiLFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFwiIzQyM2MyNFwiLFxuXG4gICAgYm9yZGVyQ29sb3I6IFwicmdiYSgyMjUsMjI1LDIyNSwwLjIpXCIsXG4gICAgZHJpbGxkb3duQm9yZGVyOiBcInJnYmEoMjI1LDIyNSwyMjUsMC40KVwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmNvbnN0IGhvdGRvZ1N0YW5kID0ge1xuICAgIGFjY2VudENvbG9yOiBcIiM4Yzk2ZmZcIixcbiAgICBhY2NlbnRMaWdodDogXCJyZ2JhKDIwMiwgMjA2LCAyNTUsIDAuMjUzKVwiLFxuXG4gICAgdGV4dERhcms6IFwiI2ZmZmZmZlwiLFxuICAgIHRleHRNZWRpdW06IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpXCIsXG4gICAgdGV4dExpZ2h0OiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KVwiLFxuICAgIHRleHRCdWJibGU6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdJY29uSGVhZGVyOiBcIiM4ODAwMDBcIixcbiAgICBmZ0ljb25IZWFkZXI6IFwiI2ZmNTU1NVwiLFxuICAgIHRleHRIZWFkZXI6IFwicmdiYSgwLCAwLCAwLCAwLjkpXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiMwMDAwMDBcIixcblxuICAgIGJnQ2VsbDogXCIjZmYwMDAwXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNmZjRkNGRcIixcbiAgICBiZ0hlYWRlcjogXCIjZjNmMzAwXCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjZWVlZTAwXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNlMGUwMDBcIixcblxuICAgIGJnQnViYmxlOiBcIiNmZmZmMDBcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNmZmZmMDBcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiM0MjNjMjRcIixcblxuICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmMDBcIixcbiAgICBkcmlsbGRvd25Cb3JkZXI6IFwiI2ZmZmYwMFwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUaGVtZVN1cHBvcnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW3RoZW1lLCBzZXRUaGVtZV0gPSBSZWFjdC51c2VTdGF0ZTxQYXJ0aWFsPFRoZW1lPj4oe30pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMTAwMCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdSb3cgPSBudW1Sb3dzO1xuICAgICAgICBzZXROdW1Sb3dzKGN2ID0+IGN2ICsgMSk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoW2MsIG5ld1Jvd10sIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICB9XG4gICAgfSwgW251bVJvd3MsIHNldENlbGxWYWx1ZV0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YUdyaWQgcmVzcGVjdHMgdGhlIHRoZW1lIHByb3ZpZGVkIGJ5IHRoZSA8UHJvcE5hbWU+dGhlbWU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKHt9KX0+TGlnaHQ8L2J1dHRvbj4gb3J7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKGRhcmtUaGVtZSl9PkRhcms8L2J1dHRvbj4gZXZlbntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0VGhlbWUoaG90ZG9nU3RhbmQpfT5Ib3Rkb2cgU3RhbmQ8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgdGhlbWU9e3RoZW1lfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lU3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgVGhlbWVQZXJDb2x1bW46IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s0XSA9IHtcbiAgICAgICAgICAgIC4uLmNbNF0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s5XSA9IHtcbiAgICAgICAgICAgIC4uLmNbOV0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjWzEwXSA9IHtcbiAgICAgICAgICAgIC4uLmNbMTBdLFxuICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xuICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBiZ0ljb25IZWFkZXI6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudENvbG9yOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBhY2NlbnRMaWdodDogXCIjMDA5Q0E2MjBcIixcbiAgICAgICAgICAgICAgICBmZ0ljb25IZWFkZXI6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlRoZW1lIHBlciBjb2x1bW5cIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5FYWNoIGNvbHVtbiBjYW4gcHJvdmlkZSB0aGVtZSBvdmVycmlkZXMgZm9yIHJlbmRlcmluZyB0aGF0IGNvbHVtbi48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oVGhlbWVQZXJDb2x1bW4gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRoZW1lUGVyUm93OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgcGVyIHJvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRWFjaCByb3cgY2FuIHByb3ZpZGUgdGhlbWUgb3ZlcnJpZGVzIGZvciByZW5kZXJpbmcgdGhhdCByb3cgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmdldFJvd1RoZW1lT3ZlcnJpZGU8L1Byb3BOYW1lPiBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17aSA9PlxuICAgICAgICAgICAgICAgICAgICBpICUgMiA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmMGY4ZmZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzZjkwZTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgcm93cz17MV8wMDBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lUGVyUm93IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDZWxsQWN0aXZhdGVkRXZlbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW2xhc3RBY3RpdmF0ZWQsIHNldExhc3RBY3RpdmF0ZWRdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IG9uQ2VsbEFjdGl2YXRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChjZWxsOiBJdGVtKSA9PiB7XG4gICAgICAgIHNldExhc3RBY3RpdmF0ZWQoY2VsbCk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ2VsbCBBY3RpdmF0ZWQgZXZlbnRcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4geW91IHRhcCA8S2V5TmFtZT5FbnRlcjwvS2V5TmFtZT4sIDxLZXlOYW1lPlNwYWNlPC9LZXlOYW1lPiBvciBkb3VibGUgY2xpY2sgYSBjZWxsLCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsIGlzIGFjdGl2YXRlZC4gWW91IGNhbiB0cmFjayB0aGlzIHdpdGggPFByb3BOYW1lPm9uQ2VsbEFjdGl2YXRlZDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXN0IGFjdGl2YXRlZCBjZWxsOntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtsYXN0QWN0aXZhdGVkID09PSB1bmRlZmluZWQgPyBcIm5vbmVcIiA6IGAoJHtsYXN0QWN0aXZhdGVkWzBdfSwgJHtsYXN0QWN0aXZhdGVkWzFdfSlgfVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25DZWxsQWN0aXZhdGVkPXtvbkNlbGxBY3RpdmF0ZWR9XG4gICAgICAgICAgICAgICAgcm93cz17MTBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKENlbGxBY3RpdmF0ZWRFdmVudCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQnVpbHRJblNlYXJjaDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbc2hvd1NlYXJjaCwgc2V0U2hvd1NlYXJjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwia2V5ZG93blwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgZXZlbnQuY29kZSA9PT0gXCJLZXlGXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRTaG93U2VhcmNoKGN2ID0+ICFjdik7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pLFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNlYXJjaCBpcyBlYXN5XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZWFyY2ggZm9yIGFueSBkYXRhIGluIHlvdXIgZ3JpZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5zaG93U2VhcmNoPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEluIHRoaXMgc3RvcnksIDxLZXlOYW1lPkN0cmw8L0tleU5hbWU+ICg8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyA8S2V5TmFtZT5mPC9LZXlOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZXMgdGhlIHNlYXJjaCBiYXIuIE1ha2Ugc3VyZSB5b3UmYXBvcztyZSBmb2N1c2VkIG9uIHRoZSBEYXRhIEdyaWQhXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgc2hvd1NlYXJjaD17c2hvd1NlYXJjaH1cbiAgICAgICAgICAgICAgICBvblNlYXJjaENsb3NlPXsoKSA9PiBzZXRTaG93U2VhcmNoKGZhbHNlKX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQnVpbHRJblNlYXJjaCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW1wZXJhdGl2ZVNjcm9sbFByb3BzIHtcbiAgICBwYWRkaW5nWTogbnVtYmVyO1xuICAgIHBhZGRpbmdYOiBudW1iZXI7XG4gICAgdkFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG4gICAgaEFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG59XG5cbmV4cG9ydCBjb25zdCBJbXBlcmF0aXZlU2Nyb2xsOiBSZWFjdC5WRkM8SW1wZXJhdGl2ZVNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudD8uc2Nyb2xsVG8oNCwgOTksIFwiYm90aFwiLCBwLnBhZGRpbmdYLCBwLnBhZGRpbmdZLCB7XG4gICAgICAgICAgICB2QWxpZ246IHAudkFsaWduLFxuICAgICAgICAgICAgaEFsaWduOiBwLmhBbGlnbixcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkltcGVyYXRpdmUgc2Nyb2xsaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGltcGVyYXRpdmVseSBzY3JvbGwgdG8gYSBjZWxsIGJ5IGNhbGxpbmcgPFByb3BOYW1lPnNjcm9sbFRvPC9Qcm9wTmFtZT4gb24gYSBEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWNrIDxidXR0b24gb25DbGljaz17b25DbGlja30+SGVyZTwvYnV0dG9uPiB0byBzY3JvbGwgdG8gY29sdW1uIDQgcm93IDEwMFxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiY2xpY2thYmxlLW51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBwYWRkaW5nWTogMCxcbiAgICBwYWRkaW5nWDogMCxcbiAgICB2QWxpZ246IFwic3RhcnRcIixcbiAgICBoQWxpZ246IFwic3RhcnRcIixcbn07XG4oSW1wZXJhdGl2ZVNjcm9sbCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHBhZGRpbmdZOiAwLFxuICAgIHBhZGRpbmdYOiAwLFxuICAgIHZBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxuICAgIGhBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgU2ltcGxlTWVudSA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDE3NXB4O1xuICAgIHBhZGRpbmc6IDhweCAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNyksIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMzUpO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgZm9udC1zaXplOiAxM3B4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIFwiT3BlbiBTYW5zXCIsXG4gICAgICAgIFwiSGVsdmV0aWNhIE5ldWVcIiwgc2Fucy1zZXJpZjtcblxuICAgIC5kYW5nZXIge1xuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMC44KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgNDAsIDQwLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgID4gZGl2IHtcbiAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XG4gICAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTAwbXM7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgSGVhZGVyTWVudXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKGMgPT4gKHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIGNvbnN0IFttZW51LCBzZXRNZW51XSA9XG4gICAgICAgIFJlYWN0LnVzZVN0YXRlPHtcbiAgICAgICAgICAgIGNvbDogbnVtYmVyO1xuICAgICAgICAgICAgYm91bmRzOiBSZWN0YW5nbGU7XG4gICAgICAgIH0+KCk7XG5cbiAgICBjb25zdCBpc09wZW4gPSBtZW51ICE9PSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCB7IGxheWVyUHJvcHMsIHJlbmRlckxheWVyIH0gPSB1c2VMYXllcih7XG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgYXV0bzogdHJ1ZSxcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICAgICAgdHJpZ2dlck9mZnNldDogMixcbiAgICAgICAgb25PdXRzaWRlQ2xpY2s6ICgpID0+IHNldE1lbnUodW5kZWZpbmVkKSxcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG1lbnU/LmJvdW5kcy54ID8/IDAsXG4gICAgICAgICAgICAgICAgdG9wOiBtZW51Py5ib3VuZHMueSA/PyAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBtZW51Py5ib3VuZHMud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICByaWdodDogKG1lbnU/LmJvdW5kcy54ID8/IDApICsgKG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwKSxcbiAgICAgICAgICAgICAgICBib3R0b206IChtZW51Py5ib3VuZHMueSA/PyAwKSArIChtZW51Py5ib3VuZHMuaGVpZ2h0ID8/IDApLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkhlYWRlck1lbnVDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2w6IG51bWJlciwgYm91bmRzOiBSZWN0YW5nbGUpID0+IHtcbiAgICAgICAgc2V0TWVudSh7IGNvbCwgYm91bmRzIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2tlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coXCJIZWFkZXIgY2xpY2tlZFwiKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJIZWFkZXIgbWVudXNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIEhlYWRlcnMgb24gdGhlIGRhdGEgZ3JpZCBjYW4gYmUgY29uZmlndXJlZCB0byBzdXBwb3J0IG1lbnVzLiBXZSBwcm92aWRlIHRoZSBldmVudHMgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUsIHlvdSBwcm92aWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja2VkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtpc09wZW4gJiZcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcbiAgICAgICAgICAgICAgICAgICAgPFNpbXBsZU1lbnUgey4uLmxheWVyUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiBsZWZ0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRhbmdlclwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIZWFkZXJNZW51cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVySWNvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aXRsZTogXCJDVVNUT00gSUNPTlwiLFxuICAgICAgICAgICAgaWNvbjogXCJjdXN0b21cIixcbiAgICAgICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICBjb25zdCBoZWFkZXJJY29ucyA9IFJlYWN0LnVzZU1lbW88U3ByaXRlTWFwPigoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXN0b206IHAgPT4gYDxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgICAgICAgICAgPHJlY3QgeD1cIjIuMDAwMTVcIiB5PVwiMlwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiNFwiIGZpbGw9XCIke3AuYmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTQuNjk3NTkgNi4wMDk3N0M0LjIzNzM1IDYuMDA5NzcgMy44NjQyNiA2LjM4Mjg2IDMuODY0MjYgNi44NDMxQzMuODY0MjYgNy4zMDMzNCA0LjIzNzM1IDcuNjc2NDMgNC42OTc1OSA3LjY3NjQzSDguODY0MjZDOS4zMjQ1IDcuNjc2NDMgOS42OTc1OSA3LjMwMzM0IDkuNjk3NTkgNi44NDMxQzkuNjk3NTkgNi4zODI4NiA5LjMyNDQ5IDYuMDA5NzcgOC44NjQyNiA2LjAwOTc3SDQuNjk3NTlaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNy42MTQyNiA0Ljc2MDA5QzcuNjE0MjYgNC4yOTk4NSA3LjI0MTE2IDMuOTI2NzYgNi43ODA5MiAzLjkyNjc2QzYuMzIwNjkgMy45MjY3NiA1Ljk0NzU5IDQuMjk5ODUgNS45NDc1OSA0Ljc2MDA5TDUuOTQ3NTkgOC45MjY3NkM1Ljk0NzU5IDkuMzg3IDYuMzIwNjkgOS43NjAwOSA2Ljc4MDkyIDkuNzYwMDlDNy4yNDExNiA5Ljc2MDA5IDcuNjE0MjYgOS4zODY5OSA3LjYxNDI2IDguOTI2NzZMNy42MTQyNiA0Ljc2MDA5WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTExLjAzMzYgNi4wMDk3N0MxMC41NzM0IDYuMDA5NzcgMTAuMjAwMyA2LjM4Mjg2IDEwLjIwMDMgNi44NDMxQzEwLjIwMDMgNy4zMDMzNCAxMC41NzM0IDcuNjc2NDMgMTEuMDMzNiA3LjY3NjQzSDE1LjIwMDNDMTUuNjYwNSA3LjY3NjQzIDE2LjAzMzYgNy4zMDMzNCAxNi4wMzM2IDYuODQzMUMxNi4wMzM2IDYuMzgyODYgMTUuNjYwNSA2LjAwOTc3IDE1LjIwMDMgNi4wMDk3N0gxMS4wMzM2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTUuODk3MDQgMTAuOTkxNkM1LjU3MTYgMTAuNjY2MiA1LjA0Mzk3IDEwLjY2NjIgNC43MTg1MyAxMC45OTE2QzQuMzkzMDkgMTEuMzE3IDQuMzkzMDkgMTEuODQ0NyA0LjcxODUzIDEyLjE3MDFMNy42NjQ4MSAxNS4xMTY0QzcuOTkwMjQgMTUuNDQxOCA4LjUxNzg4IDE1LjQ0MTggOC44NDMzMiAxNS4xMTY0QzkuMTY4NzYgMTQuNzkxIDkuMTY4NzYgMTQuMjYzMyA4Ljg0MzMyIDEzLjkzNzlMNS44OTcwNCAxMC45OTE2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTguODQzMzIgMTIuMTcwM0M5LjE2ODc1IDExLjg0NDkgOS4xNjg3NSAxMS4zMTcyIDguODQzMzIgMTAuOTkxOEM4LjUxNzg4IDEwLjY2NjQgNy45OTAyNCAxMC42NjY0IDcuNjY0OCAxMC45OTE4TDQuNzE4NTMgMTMuOTM4MUM0LjM5MzA5IDE0LjI2MzUgNC4zOTMwOSAxNC43OTEyIDQuNzE4NTMgMTUuMTE2NkM1LjA0Mzk2IDE1LjQ0MiA1LjU3MTYgMTUuNDQyIDUuODk3MDQgMTUuMTE2Nkw4Ljg0MzMyIDEyLjE3MDNaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTEuODA0QzEwLjIwMDMgMTEuMzQzOCAxMC41NzM0IDEwLjk3MDcgMTEuMDMzNiAxMC45NzA3SDE1LjIwMDNDMTUuNjYwNSAxMC45NzA3IDE2LjAzMzYgMTEuMzQzOCAxNi4wMzM2IDExLjgwNEMxNi4wMzM2IDEyLjI2NDMgMTUuNjYwNSAxMi42Mzc0IDE1LjIwMDMgMTIuNjM3NEgxMS4wMzM2QzEwLjU3MzQgMTIuNjM3NCAxMC4yMDAzIDEyLjI2NDMgMTAuMjAwMyAxMS44MDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTQuMzA0QzEwLjIwMDMgMTMuODQzOCAxMC41NzM0IDEzLjQ3MDcgMTEuMDMzNiAxMy40NzA3SDE1LjIwMDNDMTUuNjYwNSAxMy40NzA3IDE2LjAzMzYgMTMuODQzOCAxNi4wMzM2IDE0LjMwNEMxNi4wMzM2IDE0Ljc2NDMgMTUuNjYwNSAxNS4xMzc0IDE1LjIwMDMgMTUuMTM3NEgxMS4wMzM2QzEwLjU3MzQgMTUuMTM3NCAxMC4yMDAzIDE0Ljc2NDMgMTAuMjAwMyAxNC4zMDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgIDwvc3ZnPmAsXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGhlYWRlciBpY29uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIG92ZXJyaWRlcyBmb3IgdGhlIGRlZmF1bHQgaWNvbnMgYnkgcGFzc2luZyB0aGUgPFByb3BOYW1lPmhlYWRlckljb25zPC9Qcm9wTmFtZT57XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIGhlYWRlckljb25zPXtoZWFkZXJJY29uc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlckljb25zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodEVsZW1lbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig4LCBmYWxzZSk7XG5cbiAgICBjb25zdCBjb2x1bW5zID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb2xzLm1hcChjID0+ICh7IC4uLmMsIGdyb3c6IDEgfSkpLCBbY29sc10pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMzAwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZShbYywgbmV3Um93XSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgIH1cbiAgICB9LCBbbnVtUm93cywgc2V0Q2VsbFZhbHVlXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSaWdodCBFbGVtZW50XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgRE9NIGVsZW1lbnQgbWF5IGJlIGFkZGVkIGFzIGEgdHJhaWxlciB0byB0aGUgZ3JpZCBieSB1c2luZyB0aGUgPFByb3BOYW1lPnJpZ2h0RWxlbWVudDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgaGludDogXCJOZXcgcm93Li4uXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17eyBzdGlja3k6IHRydWUgfX1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIyMHB4IDIwcHggNDBweCAyMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjUwLCAwLjIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwiMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjE1KVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wRmlsdGVyOiBcImJsdXIoMTJweClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBpcyBhIHJlYWwgRE9NIGVsZW1lbnQuIFlvdSBjYW4gcHV0IHdoYXRldmVyIHlvdSB3YW50IGhlcmUuIFlvdSBjYW4gYWxzbyBzaXplIGl0IGFzIGJpZyBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgeW91IHdhbnQuIHtcIlxcblxcblwifUl0IGFsc28gZG9lcyBub3QgaGF2ZSB0byBiZSBzdGlja3kuXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSaWdodEVsZW1lbnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxubGV0IG51bTogbnVtYmVyID0gMTtcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNl84MDcpICUgMl8xNDdfNDgzXzY0Nyk7XG59XG5cbmV4cG9ydCBjb25zdCBSYXBpZFVwZGF0ZXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3QgY291bnRSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgZGlzcGxheUNvdW50UmVmID0gUmVhY3QudXNlUmVmPEhUTUxFbGVtZW50PihudWxsKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCByYWZJRCA9IDA7XG5cbiAgICAgICAgY29uc3Qgc2VuZFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzOiB7XG4gICAgICAgICAgICAgICAgY2VsbDogSXRlbTtcbiAgICAgICAgICAgIH1bXSA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDUwMDA7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IE1hdGgubWF4KDEwLCByYW5kKCkgJSAxMDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHJhbmQoKSAlIDEwXzAwMDtcblxuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbY29sLCByb3ddLCB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB4LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHt4fWtgLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCAlIDUgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2YyZmZmNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMGQ0MWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2ZmZjZmNlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiNkNDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5vdyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHsgY2VsbDogW2NvbCwgcm93XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50UmVmLmN1cnJlbnQgKz0gNTAwMDtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5Q291bnRSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlDb3VudFJlZi5jdXJyZW50LnRleHRDb250ZW50ID0gYCR7Y291bnRSZWYuY3VycmVudH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWYuY3VycmVudD8udXBkYXRlQ2VsbHMoY2VsbHMpO1xuXG4gICAgICAgICAgICByYWZJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2VuZFVwZGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VuZFVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJRCk7XG4gICAgICAgIH07XG4gICAgfSwgW3NldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUmFwaWQgdXBkYXRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBjYW4gc3VwcG9ydCBtYW55IHRob3VzYW5kcyBvZiB1cGRhdGVzIHBlciBzZWNvbmRzLiBUaGUgZGF0YSBncmlkIGNhbiBlYXNpbHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGZhc3RlciB0aGFuIGEgaHVtYW4gY2FuIHJlYWQgaXQsIG1vcmUgaW1wb3J0YW50bHkgdGhlIGZhc3RlciB0aGUgZGF0YSBncmlkIGNhbiB1cGRhdGUsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZSB0aW1lIHlvdXIgY29kZSBjYW4gc3BlbmQgZG9pbmcgbW9yZSB2YWx1YWJsZSB3b3JrLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGVzIHByb2Nlc3NlZDogPEtleU5hbWUgcmVmPXtkaXNwbGF5Q291bnRSZWZ9IC8+IFdlIGNvdWxkIGRvIHRoaXMgZmFzdGVyIGJ1dCB3ZSB3cm90ZSBhXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsbHkgY3JhcHB5IGRhdGEgc3RvcmUgZm9yIHRoaXMgZGVtbyB3aGljaCBpcyBhY3R1YWxseSBzbG93aW5nIGRvd24gdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSYXBpZFVwZGF0ZXMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvcHlTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICAxMCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29weSBzdXBwb3J0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXJnZSBhbW91bnRzIG9mIGRhdGEgY2FuIGJlIGNvcGllZCBhbmQgY3VzdG9taXplZCB1c2luZ3tcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5nZXRDZWxsc0ZvclNlbGVjdGlvbjwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VGhlIGRhdGEgaXMgY29waWVkIGludG8gYSBmb3JtYXQgcmVhZHkgdG8gYmUgcGFzdGVkIGludG8gRXhjZWwgb3IgR29vZ2xlIFNoZWV0czwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJDb3B5IHNvbWV0aGluZyBiZWxvdyBhbmQgcGFzdGUgaXQgaGVyZS4uLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG1hcmdpbkJvdHRvbTogMjAsIGJvcmRlclJhZGl1czogOSwgbWluSGVpZ2h0OiAyMDAsIHBhZGRpbmc6IDEwIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb3B5U3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUGFzdGVTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA1MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUGFzdGUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZ3JpZCBjYW4gaGFuZGxlIHBhc3RlIGF1dG9tYXRpY2FsbHkgYnkgcmV0dXJuaW5nIHRydWUgZnJvbSA8UHJvcE5hbWU+b25QYXN0ZTwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgICAgICAuIFlvdSBjYW4gYWxzbyByZXR1cm4gZmFsc2UgYW5kIGhhbmRsZSBwYXN0ZSB5b3Vyc2VsZi4gSWYgcGFzdGUgaXMgdW5kZWZpbmVkIHRoZSBEYXRhRWRpdG9yIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIGl0cyBiZXN0IHRvIHBhc3RlIHRvIHRoZSBjdXJyZW50IGNlbGwuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFBhc3RlIHN1cHBvcnRzIHRoZSBjb3B5IGZvcm1hdCBvZiBHb29nbGUgU2hlZXRzIGFuZCBFeGNlbC4gQmVsb3cgaXMgYW4gZXhhbXBsZSBvZiBkYXRhIGNvcGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBleGNlbCB3aXRoIHNvbWUgZXNjYXBlZCB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtgU3VuZGF5XHREb2dzXHRodHRwczovL2dvb2dsZS5jb21cbk1vbmRheVx0Q2F0c1x0aHR0cHM6Ly9nb29nbGUuY29tXG5UdWVzZGF5XHRUdXJ0bGVzXHRodHRwczovL2dvb2dsZS5jb21cbldlZG5lc2RheVx0QmVhcnNcdGh0dHBzOi8vZ29vZ2xlLmNvbVxuVGh1cnNkYXlcdFwiTCAgaW9uc1wiXHRodHRwczovL2dvb2dsZS5jb21cbkZyaWRheVx0UGlnc1x0aHR0cHM6Ly9nb29nbGUuY29tXG5TYXR1cmRheVx0XCJUdXJrZXlzIGFuZCBzb21lIFwiXCJxdW90ZXNcIlwiIGFuZFxuYSBuZXcgbGluZSBjaGFyIFwiXCJtb3JlIHF1b3Rlc1wiXCIgcGx1cyBhIHRhYiAgLlwiXHRodHRwczovL2dvb2dsZS5jb21gfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBtYXJnaW5Cb3R0b206IDIwLCBib3JkZXJSYWRpdXM6IDksIG1pbkhlaWdodDogMjAwLCBwYWRkaW5nOiAxMCB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihQYXN0ZVN1cHBvcnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEZyZWV6ZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkZyZWV6ZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgZ3JpZCBjYW4gYmUgZnJvemVuIGluIHBsYWNlIGJ5IHNldHRpbmdze1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+ZnJlZXplQ29sdW1uczwvUHJvcE5hbWU+IHRvIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXsxfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17YyA9PiBjID4gMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEZyZWV6ZUNvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFJlb3JkZXJSb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29scyA9IFJlYWN0LnVzZU1lbW88R3JpZENvbHVtbltdPihcbiAgICAgICAgKCkgPT4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkNvbCBBXCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQ29sIEJcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgW3Jvd0RhdGEsIHNldFJvd0RhdGFdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgNTApLm1hcCh4ID0+IFtgQTogJHt4fWAsIGBCOiAke3h9YF0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjazxEYXRhRWRpdG9yUHJvcHNbXCJnZXRDZWxsQ29udGVudFwiXT4oXG4gICAgICAgIChbY29sLCByb3ddKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogcm93RGF0YVtyb3ddW2NvbF0sXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IHJvd0RhdGFbcm93XVtjb2xdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW3Jvd0RhdGFdXG4gICAgKTtcblxuICAgIGNvbnN0IHJlb3JkZXJSb3dzID0gUmVhY3QudXNlQ2FsbGJhY2soKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRSb3dEYXRhKGN2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBbLi4uY3ZdO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGQuc3BsaWNlKGZyb20sIDEpO1xuICAgICAgICAgICAgZC5zcGxpY2UodG8sIDAsIC4uLnJlbW92ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlb3JkZXIgUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgUm93cyBjYW4gYmUgcmUtYXJyYW5nZWQgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5vblJvd01vdmVkPC9Qcm9wTmFtZT4gY2FsbGJhY2suIFdoZW4gc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3Qgcm93IGNhbiBiZSB1c2VkIHRvIGRyYWcgYW5kIGRyb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUm93TW92ZWQ9e3Jlb3JkZXJSb3dzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJlb3JkZXJSb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb2x1bW5Hcm91cHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAsIHRydWUsIHRydWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29sdW1uIEdyb3VwaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgaW4gdGhlIGRhdGEgZ3JpZCBtYXkgYmUgZ3JvdXBlZCBieSBzZXR0aW5nIHRoZWlyIDxQcm9wTmFtZT5ncm91cDwvUHJvcE5hbWU+IHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBvbkdyb3VwSGVhZGVyUmVuYW1lZD17KHgsIHkpID0+IHdpbmRvdy5hbGVydChgUGxlYXNlIHJlbmFtZSBncm91cCAke3h9IHRvICR7eX1gKX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17ZyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBnLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBnID09PSBcIlwiID8gdW5kZWZpbmVkIDogR3JpZENvbHVtbkljb24uSGVhZGVyQ29kZSxcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ29sdW1uR3JvdXBzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBTdHJldGNoQ29sdW1uU2l6ZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uLCBvbkNvbHVtblJlc2l6ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBoYXNSZXNpemVkID0gUmVhY3QudXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKCh4LCBpKSA9PiAoeyAuLi54LCBncm93OiBoYXNSZXNpemVkLmN1cnJlbnQuaGFzKGkpID8gdW5kZWZpbmVkIDogKDUgKyBpKSAvIDUgfSkpO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb2x1bW4gR3Jvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDb2x1bW5zIGluIHRoZSBkYXRhIGdyaWQgbWF5IGJlIHNldCB0byBncm93IHRvIGZpbGwgc3BhY2UgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPmdyb3c8L1Byb3BOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgcHJvcC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17KGNvbCwgX25ld1NpemUsIGNvbEluZGV4LCBuZXdTaXplV2l0aEdyb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVzaXplZC5jdXJyZW50LmFkZChjb2xJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplKGNvbCwgbmV3U2l6ZVdpdGhHcm93KTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTdHJldGNoQ29sdW1uU2l6ZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiB1c2VDb2xsYXBzYWJsZUNvbHVtbkdyb3Vwcyhjb2xzOiByZWFkb25seSBHcmlkQ29sdW1uW10pIHtcbiAgICBjb25zdCBbY29sbGFwc2VkLCBzZXRDb2xsYXBzZWRdID0gUmVhY3QudXNlU3RhdGU8cmVhZG9ubHkgc3RyaW5nW10+KFtdKTtcblxuICAgIGNvbnN0IG9uR3JvdXBIZWFkZXJDbGlja2VkID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjb2xJbmRleDogbnVtYmVyLCBhcmdzOiBHcm91cEhlYWRlckNsaWNrZWRFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gY29sc1tjb2xJbmRleF0uZ3JvdXAgPz8gXCJcIjtcbiAgICAgICAgICAgIHNldENvbGxhcHNlZChjdiA9PiAoY3YuaW5jbHVkZXMoZ3JvdXApID8gY3YuZmlsdGVyKGcgPT4gZyAhPT0gZ3JvdXApIDogWy4uLmN2LCBncm91cF0pKTtcbiAgICAgICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNdXG4gICAgKTtcblxuICAgIGNvbnN0IFtzZWxlY3RlZENvbHVtbnMsIHNldFNlbGVjdGVkQ29sdW1uc10gPSBSZWFjdC51c2VTdGF0ZTxDb21wYWN0U2VsZWN0aW9uPihDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCkpO1xuXG4gICAgY29uc3Qgc2V0Q29scyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdWYWw6IENvbXBhY3RTZWxlY3Rpb24sIHRyaWdnZXI6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodHJpZ2dlciA9PT0gXCJncm91cFwiKSByZXR1cm47XG5cbiAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKG5ld1ZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY29scy5tYXAoYyA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbGxhcHNlZC5pbmNsdWRlcyhjLmdyb3VwID8/IFwiXCIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICAgIGhhc01lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgICAgICB3aWR0aDogOCxcbiAgICAgICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvbGxhcHNlZCwgY29sc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgb25Hcm91cEhlYWRlckNsaWNrZWQsXG4gICAgICAgIHNlbGVjdGVkQ29sdW1ucyxcbiAgICAgICAgb25TZWxlY3RlZENvbHVtbnNDaGFuZ2U6IHNldENvbHMsXG4gICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkdyb3VwQ29sbGFwc2U6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAsIHRydWUsIHRydWUpO1xuXG4gICAgY29uc3QgZ3JvdXBIZWFkZXJBcmdzID0gdXNlQ29sbGFwc2FibGVDb2x1bW5Hcm91cHMoY29scyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJHcm91cCBjb2xsYXBzZVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3VnaCBjbGV2ZXIgdXNhZ2Ugb2YgPFByb3BOYW1lPm9uR3JvdXBIZWFkZXJDbGlja2VkPC9Qcm9wTmFtZT4geW91IGNhbiBpbXBsZW1lbnQgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNpbmcuIFRoaXMgaXMgYSB2ZXJ5IGJhc2ljIHZlcnNpb24gaG93ZXZlciBpdCBpcyBwb3NzaWJsZSB0byBnbyBtdWNoIGZ1cnRoZXIuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5DZWxscyB1bmRlciBhIGNlcnRhaW4gc2l6ZSB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbmRlciB0byBzYXZlIHNvbWUgZnJhbWVzLjwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5ncm91cEhlYWRlckFyZ3N9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXsyNH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb2x1bW5Hcm91cENvbGxhcHNlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBNaW5pbWFwOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJNaW5pbWFwXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbWluaW1hcCBjYW4gYmUgZW5hYmxlZCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+c2hvd01pbmltYXA8L1Byb3BOYW1lPiBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBzaG93TWluaW1hcD17dHJ1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXszMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihNaW5pbWFwIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb250ZW50QWxpZ25tZW50OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgX3Jvd10gPSBjZWxsO1xuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdldENlbGxDb250ZW50KGNlbGwpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5nZXRDZWxsQ29udGVudChjZWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb250ZW50IEFsaWdubWVudFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgY29udGVudCBhbGlnbm1lbnQgYnkgc2V0dGluZyA8UHJvcE5hbWU+Y29udGVudEFsaWduPC9Qcm9wTmFtZT4gb2YgYSBjZWxsIHRve1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+bGVmdDwvUHJvcE5hbWU+LCA8UHJvcE5hbWU+cmlnaHQ8L1Byb3BOYW1lPiBvciA8UHJvcE5hbWU+Y2VudGVyPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvciB7Li4uZGVmYXVsdFByb3BzfSBnZXRDZWxsQ29udGVudD17bWFuZ2xlZEdldENlbGxDb250ZW50fSBjb2x1bW5zPXtjb2xzfSByb3dzPXszMDB9IC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFJvd0hvdmVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IFtob3ZlclJvdywgc2V0SG92ZXJSb3ddID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgW18sIHJvd10gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICBzZXRIb3ZlclJvdyhhcmdzLmtpbmQgIT09IFwiY2VsbFwiID8gdW5kZWZpbmVkIDogcm93KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2s8R2V0Um93VGhlbWVDYWxsYmFjaz4oXG4gICAgICAgIHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAocm93ICE9PSBob3ZlclJvdykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmN2Y3ZjdcIixcbiAgICAgICAgICAgICAgICBiZ0NlbGxNZWRpdW06IFwiI2YwZjBmMFwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW2hvdmVyUm93XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSb3cgSG92ZXIgRWZmZWN0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRocm91Z2ggY2FyZWZ1bCB1c2FnZSBvZiB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBjYWxsYmFjayBpdCBpcyBwb3NzaWJsZSB0byBlYXNpbHlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlIGEgcm93IGhvdmVyIGVmZmVjdC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17b25JdGVtSG92ZXJlZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNwYW5DZWxsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwLCB0cnVlLCB0cnVlKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAocm93ID09PSA2ICYmIGNvbCA+PSAzICYmIGNvbCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IFszLCA0XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPT09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJTcGFuIENlbGwgdGhhdCBpcyB2ZXJ5IGxvbmcgYW5kIHdpbGwgZ28gcGFzdCB0aGUgY2VsbCBsaW1pdHNcIixcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogWzAsIDk5XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRDZWxsc0ZvclNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoc2VsZWN0aW9uOiBSZWN0YW5nbGUpOiBDZWxsQXJyYXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBHcmlkQ2VsbFtdW10gPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHNlbGVjdGlvbi55OyB5IDwgc2VsZWN0aW9uLnkgKyBzZWxlY3Rpb24uaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3c6IEdyaWRDZWxsW10gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gc2VsZWN0aW9uLng7IHggPCBzZWxlY3Rpb24ueCArIHNlbGVjdGlvbi53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKG1hbmdsZWRHZXRDZWxsQ29udGVudChbeCwgeV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgW21hbmdsZWRHZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiU3BhbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgQnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnNwYW48L1Byb3BOYW1lPiBvZiBhIGNlbGwgeW91IGNhbiBjcmVhdGUgc3BhbnMgaW4geW91ciBncmlkLiBBbGwgY2VsbHNcbiAgICAgICAgICAgICAgICAgICAgd2l0aGluIGEgc3BhbiBtdXN0IHJldHVybiBjb25zaXN0ZW50IGRhdGEgZm9yIGRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNwYW5zIHdpbGwgYWx3YXlzIGJlIHNwbGl0IGlmIHRoZXkgc3BhbiBmcm96ZW4gYW5kIG5vbi1mcm96ZW4gY29sdW1ucy4gQnkgZGVmYXVsdCBzZWxlY3Rpb25zIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzIGV4cGFuZGVkIHRvIGluY2x1ZGUgYSBzcGFuLiBUaGlzIGNhbiBiZSBkaXNhYmxlZCB1c2luZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+c3BhblJhbmdlQmVoYXZpb3I8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17Mn1cbiAgICAgICAgICAgICAgICByb3dzPXszMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNwYW5DZWxsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHplcm9Cb3VuZHMgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICByaWdodDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBUb29sdGlwczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3Rvb2x0aXAsIHNldFRvb2x0aXBdID0gUmVhY3QudXNlU3RhdGU8eyB2YWw6IHN0cmluZzsgYm91bmRzOiBJQm91bmRzIH0gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gXCJjZWxsXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHNldFRvb2x0aXAodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBgVG9vbHRpcCBmb3IgJHthcmdzLmxvY2F0aW9uWzBdfSwgJHthcmdzLmxvY2F0aW9uWzFdfWAsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIHJlYWN0LWxhYWcgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFyZ3MuYm91bmRzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGFyZ3MuYm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGFyZ3MuYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBhcmdzLmJvdW5kcy54ICsgYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGFyZ3MuYm91bmRzLnkgKyBhcmdzLmJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IDA7XG4gICAgICAgICAgICBzZXRUb29sdGlwKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpLCBbXSk7XG5cbiAgICBjb25zdCBpc09wZW4gPSB0b29sdGlwICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyByZW5kZXJMYXllciwgbGF5ZXJQcm9wcyB9ID0gdXNlTGF5ZXIoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDQsXG4gICAgICAgIGF1dG86IHRydWUsXG4gICAgICAgIGNvbnRhaW5lcjogXCJwb3J0YWxcIixcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiB0b29sdGlwPy5ib3VuZHMgPz8gemVyb0JvdW5kcyxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiVG9vbHRpcHNcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvdWJsZVwiXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBVc2luZyB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBldmVudCBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSB0b29sdGlwcy4gVGhpcyBzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgaXMgaW50ZW50aW9uYWxseSBmb3JjZWQgdG8gc2Nyb2xsIHZlcnRpY2FsbHkgc28gbGF5b3V0IGluIHNjcm9sbGluZyBkb2N1bWVudHMgY2FuIGJlIGNvbmZpcm1lZC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICB9PlxuICAgICAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9e29uSXRlbUhvdmVyZWR9XG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICAgICAgICAge2lzT3BlbiAmJlxuICAgICAgICAgICAgICAgIHJlbmRlckxheWVyKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ubGF5ZXJQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGF5ZXJQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjhweCAxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250OiBcIjUwMCAxM3B4IEludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC44NSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0b29sdGlwLnZhbH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgPC8+XG4gICAgKTtcbn07XG4oVG9vbHRpcHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvbnRyb2xsZWRTZWxlY3Rpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigzMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkNvbnRyb2xsZWQgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBzZWxlY3Rpb24gb2YgdGhlIGdyaWQgY2FuIGJlIGNvbnRyb2xsZWQgdmlhIDxQcm9wTmFtZT5HcmlkU2VsZWN0aW9uPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25HcmlkU2VsZWN0aW9uQ2hhbmdlPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbj17MH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heD17Mjl9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2VsZWN0aW9uLmN1cnJlbnQ/LmNlbGxbMF0gPz8gMH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2wgPSBlLnRhcmdldC52YWx1ZUFzTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvbihjdiA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbDogW25ld0NvbCwgY3YuY3VycmVudD8uY2VsbFsxXSA/PyAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbmV3Q29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN2LmN1cnJlbnQ/LmNlbGxbMV0gPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFjazogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4PXs5OX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxlY3Rpb24uY3VycmVudD8uY2VsbFsxXSA/PyAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGUudGFyZ2V0LnZhbHVlQXNOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKGN2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsOiBbY3YuY3VycmVudD8uY2VsbFswXSA/PyAwLCBuZXdSb3ddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjdi5jdXJyZW50Py5jZWxsWzBdID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogbmV3Um93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTmV3Q29sdW1uQnV0dG9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAsIHRydWUpO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29scy5tYXAoYyA9PiAoeyAuLi5jLCBncm93OiAxIH0pKSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk5ldyBjb2x1bW4gYnV0dG9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbmV3IGNvbHVtbiBidXR0b24gY2FuIGJlIGNyZWF0ZWQgdXNpbmcgdGhlIDxQcm9wTmFtZT5yaWdodEVsZW1lbnQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8Q29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB3aW5kb3cuYWxlcnQoXCJBZGQgYSBjb2x1bW4hXCIpfT4rPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvQ29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17e1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkcmF3SGVhZGVyOiBEcmF3SGVhZGVyQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhhcmdzID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxnID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHJlY3QueSwgMCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICBsZy5hZGRDb2xvclN0b3AoMCwgXCIjZmYwMGQ5MzRcIik7XG4gICAgICAgIGxnLmFkZENvbG9yU3RvcCgxLCBcIiMwMGEyZmYzNFwiKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxnO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gSGVhZGVyXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5NYWtlIGl0IGFzIGZhbmN5IGFzIHlvdSBsaWtlLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtkcmF3SGVhZGVyfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlciBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUGFkZGluZ1Byb3BzIHtcbiAgICBwYWRkaW5nUmlnaHQ6IG51bWJlcjtcbiAgICBwYWRkaW5nQm90dG9tOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBQYWRkaW5nOiBSZWFjdC5WRkM8UGFkZGluZ1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlBhZGRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWRkIHBhZGRpbmcgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnBhZGRpbmdSaWdodDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5wYWRkaW5nQm90dG9tPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt7IHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdUeXBlcyA9IHtcbiAgICBwYWRkaW5nUmlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwYWRkaW5nQm90dG9tOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogNjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdzID0ge1xuICAgIHBhZGRpbmdSaWdodDogMjAwLFxuICAgIHBhZGRpbmdCb3R0b206IDIwMCxcbn07XG4oUGFkZGluZyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHRDZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgW2dyaWRTZWxlY3Rpb24sIHNldEdyaWRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGhpZ2hsaWdodHMgPSBSZWFjdC51c2VNZW1vPERhdGFFZGl0b3JQcm9wc1tcImhpZ2hsaWdodFJlZ2lvbnNcIl0+KCgpID0+IHtcbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGw7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFwiIzQ0QkIwMDIyXCIsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29sICsgMixcbiAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjYjAwMGIwMjFcIixcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJvdyArIDIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSwgW2dyaWRTZWxlY3Rpb25dKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkhpZ2hsaWdodENlbGxzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSA8UHJvcE5hbWU+aGlnaGxpZ2h0UmVnaW9uczwvUHJvcE5hbWU+IHByb3AgY2FuIGJlIHNldCB0byBwcm92aWRlIGFkZGl0aW9uYWwgaGludGluZyBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtncmlkU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17c2V0R3JpZFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdmVydGljYWxCb3JkZXI9e2MgPT4gYyA+IDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIaWdobGlnaHRDZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgTGF5b3V0SW50ZWdyYXRpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAwLCB0cnVlLCB0cnVlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxTdHlsZT5cbiAgICAgICAgICAgIDxoMT5MYXlvdXQgSW50ZWdyYXRpb248L2gxPlxuICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRyeWluZyB0aGUgZ3JpZCBpbiBkaWZmZXJlbnQgc2l0dWF0aW9uczwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezIwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBoZWlnaHQ6IFwiMzAwcHhcIiB9fT5cbiAgICAgICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTB9XG4gICAgICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleFNocmluazogMCB9fT5UaGlzIGlzIHNvbWUgdGV4dCB3aGF0IGhhcHBlbnMgaGVyZT88L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuKExheW91dEludGVncmF0aW9uIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBEcmFnU291cmNlOiBSZWFjdC5WRkM8eyBpc0RyYWdnYWJsZTogYm9vbGVhbiB8IFwiaGVhZGVyXCIgfCBcImNlbGxcIiB9PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigyMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhZyBzb3VyY2VcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmcgdGhlIDxQcm9wTmFtZT5pc0RyYWdnYWJsZTwvUHJvcE5hbWU+IHByb3AgY2FuIGFsbG93IGZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wgb3ZlciB3aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyBkcmFnZ2FibGUgaW4gdGhlIGdyaWQgdmlhIEhUTUwgZHJhZyBhbmQgZHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17KHMsIGUpID0+IHdpbmRvdy5hbGVydChgTW92ZWQgcm93ICR7c30gdG8gJHtlfWApfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9eyhzLCBlKSA9PiB3aW5kb3cuYWxlcnQoYE1vdmVkIGNvbCAke3N9IHRvICR7ZX1gKX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIFwiRHJhZyBkYXRhIGhlcmUhXCIpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJhZ1NvdXJjZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGlzRHJhZ2dhYmxlOiB7XG4gICAgICAgIGNvbnRyb2w6IHsgdHlwZTogXCJzZWxlY3RcIiwgb3B0aW9uczogW3RydWUsIGZhbHNlLCBcImNlbGxcIiwgXCJoZWFkZXJcIl0gfSxcbiAgICB9LFxufTtcbihEcmFnU291cmNlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG59O1xuKERyYWdTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUHJldmVudERpYWdvbmFsU2Nyb2xsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlByZXZlbnQgRGlhZ29uYWwgU2Nyb2xsXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBEaWFnb25hbCBzY3JvbGxpbmcgY2FuIGJlIHByZXZlbnRlZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5wcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUHJldmVudERpYWdvbmFsU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbi8vIEEgZmV3IHN1cHBvcnRlZCBtaW1lIHR5cGVzIGZvciBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMuXG5jb25zdCBTVVBQT1JURURfSU1BR0VfVFlQRVMgPSBuZXcgU2V0KFtcImltYWdlL3BuZ1wiLCBcImltYWdlL2dpZlwiLCBcImltYWdlL2JtcFwiLCBcImltYWdlL2pwZWdcIl0pO1xuXG5leHBvcnQgY29uc3QgRHJvcEV2ZW50czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbaGlnaGxpZ2h0cywgc2V0SGlnaGxpZ2h0c10gPSBSZWFjdC51c2VTdGF0ZTxEYXRhRWRpdG9yUHJvcHNbXCJoaWdobGlnaHRSZWdpb25zXCJdPihbXSk7XG5cbiAgICBjb25zdCBbbGFzdERyb3BDZWxsLCBzZXRMYXN0RHJvcENlbGxdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IG9uRHJvcCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoY2VsbDogSXRlbSwgZGF0YVRyYW5zZmVyOiBEYXRhVHJhbnNmZXIgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBmaWxlcyB9ID0gZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IHN1cHBvcnRzIG9uZSBpbWFnZSwgZm9yIHNpbXBsaWNpdHkuXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBbZmlsZV0gPSBmaWxlcztcbiAgICAgICAgICAgIGlmICghU1VQUE9SVEVEX0lNQUdFX1RZUEVTLmhhcyhmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbWdVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuXG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoXG4gICAgICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5JbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2ltZ1VybF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzZXRMYXN0RHJvcENlbGwoY2VsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtzZXRDZWxsVmFsdWVdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ092ZXJDZWxsID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjZWxsOiBJdGVtLCBkYXRhVHJhbnNmZXI6IERhdGFUcmFuc2ZlciB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IGRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIC8vIFRoaXMgb25seSBzdXBwb3J0cyBvbmUgaW1hZ2UsIGZvciBzaW1wbGljaXR5LlxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2l0ZW1dID0gaXRlbXM7XG4gICAgICAgICAgICBpZiAoIVNVUFBPUlRFRF9JTUFHRV9UWVBFUy5oYXMoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAoZ2V0Q2VsbENvbnRlbnQoY2VsbCkua2luZCA9PT0gR3JpZENlbGxLaW5kLkltYWdlKSB7XG4gICAgICAgICAgICAgICAgc2V0SGlnaGxpZ2h0cyhbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiM0NEJCMDAyMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEhpZ2hsaWdodHMoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ0xlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJEcm9wIGV2ZW50c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMgYnkgdXNpbmcgPFByb3BOYW1lPm9uRHJhZ092ZXJDZWxsPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPm9uRHJvcDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7bGFzdERyb3BDZWxsID09PSB1bmRlZmluZWQgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPk5vdGhpbmcgZHJvcHBlZCwgeWV0PC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWW91IGxhc3QgZHJvcHBlZCBpbiBjZWxsIDxQcm9wTmFtZT57SlNPTi5zdHJpbmdpZnkobGFzdERyb3BDZWxsKX08L1Byb3BOYW1lPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uRHJvcD17b25Ecm9wfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtvbkRyYWdPdmVyQ2VsbH1cbiAgICAgICAgICAgICAgICBvbkRyYWdMZWF2ZT17b25EcmFnTGVhdmV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibm9uZVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJvcEV2ZW50cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".b1nvh7n2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.b1nvh7n2 > a{margin-bottom:20px;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItcmVwcm9zLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5iMW52aDduMiJdLCJtYXBwaW5ncyI6IkFBOEJNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLXJlcHJvcy5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gXCJAc3Rvcnlib29rL2FkZG9uc1wiO1xuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB0aXRsZTogXCJUZXN0cy9UZXN0Q2FzZXMvQnVnc1wiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxMDAwfSBoZWlnaHQ9ezgwMH0+XG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGJ1ZzcwR2VuID0gKFssIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTnVtYmVyLFxuICAgIGRhdGE6IHJvdyxcbiAgICBkaXNwbGF5RGF0YTogcm93LnRvU3RyaW5nKCksXG59KTtcblxuY29uc3QgaWdub3JlID0gKCkgPT4gdW5kZWZpbmVkO1xuXG5jb25zdCBCdWc3MFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICA+IGEge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBCdWc3MCgpIHtcbiAgICBjb25zdCBjb2xzID0gW1xuICAgICAgICB7IHRpdGxlOiBcIkNvbDFcIiwgd2lkdGg6IDEwMCB9LFxuICAgICAgICB7IHRpdGxlOiBcIkNvbDJcIiwgd2lkdGg6IDEwMCB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XCJBcHBcIj5cbiAgICAgICAgICAgIDxwPlRvIGNhdXNlIGVycm9yOiBzY3JvbGwgZG93biBhdCBsZWFzdCBvbmUgcm93LCBlZGl0IGEgY2VsbCBpbiBDb2wyLCBhbmQgaGl0IFRhYjwvcD5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9pc3N1ZXMvNzBcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+XG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXs1MDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2J1ZzcwR2VufVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CdWc3MFN0eWxlPlxuICAgICk7XG59XG5cbmNvbnN0IGZpbHRlckNvbHVtbnNHZW4gPSAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgIGRhdGE6IGAke2NvbH0gLSAke3Jvd31gLFxuICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcbn0pO1xuXG5jb25zdCBmaWx0ZXJpbmdDb2x1bW5zID0gW1xuICAgIHsgdGl0bGU6IFwiQ29sIEFBQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFBQVwiLCB3aWR0aDogMTIwIH0sXG4gICAgeyB0aXRsZTogXCJDb2wgQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sXCIsIHdpZHRoOiAxMjAgfSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBGaWx0ZXJDb2x1bW5zKCkge1xuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gICAgY29uc3QgY29scyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2VhcmNoVGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmluZ0NvbHVtbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucy5maWx0ZXIoYyA9PiBjLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgfSwgW3NlYXJjaFRleHRdKTtcblxuICAgIGNvbnN0IG9uSW5wdXRDaGFuZ2UgPSAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgc2V0U2VhcmNoVGV4dChlLnRhcmdldC52YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9e3NlYXJjaFRleHR9IG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfSAvPlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB3aWR0aD17MTAwMH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17ZmlsdGVyQ29sdW1uc0dlbn1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXt0cnVlfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufVxuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-editor/stories/packages/core/src/data-editor/stories/data-editor-repros.stories.tsx\",\"webpack://./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx\"],\"names\":[\".b1nvh7n2\"],\"mappings\":\"AA8BMA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,cAAAA,kBAAAA,CAAAA;AC7BN,mwIAAmwI\",\"sourcesContent\":[\"import * as React from \\\"react\\\";\\n\\nimport { useState, useMemo } from \\\"@storybook/addons\\\";\\nimport { BuilderThemeWrapper } from \\\"../../stories/story-utils\\\";\\n\\nimport { GridCell, GridCellKind, Item } from \\\"../../data-grid/data-grid-types\\\";\\nimport { DataEditor } from \\\"../data-editor\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\n\\nexport default {\\n    title: \\\"Tests/TestCases/Bugs\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <BuilderThemeWrapper width={1000} height={800}>\\n                <Story />\\n            </BuilderThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst bug70Gen = ([, row]: Item): GridCell => ({\\n    allowOverlay: true,\\n    kind: GridCellKind.Number,\\n    data: row,\\n    displayData: row.toString(),\\n});\\n\\nconst ignore = () => undefined;\\n\\nconst Bug70Style = styled.div`\\n    display: flex;\\n    flex-direction: column;\\n\\n    > a {\\n        margin-bottom: 20px;\\n    }\\n`;\\n\\nexport function Bug70() {\\n    const cols = [\\n        { title: \\\"Col1\\\", width: 100 },\\n        { title: \\\"Col2\\\", width: 100 },\\n    ];\\n\\n    return (\\n        <Bug70Style className=\\\"App\\\">\\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\\n            <a href=\\\"https://github.com/glideapps/glide-data-grid/issues/70\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">\\n                Original report\\n            </a>\\n            <DataEditor\\n                width={500}\\n                height={500}\\n                rows={100}\\n                columns={cols}\\n                getCellContent={bug70Gen}\\n                onCellEdited={ignore}\\n            />\\n        </Bug70Style>\\n    );\\n}\\n\\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\\n    allowOverlay: true,\\n    kind: GridCellKind.Text,\\n    data: `${col} - ${row}`,\\n    displayData: `${col} - ${row}`,\\n});\\n\\nconst filteringColumns = [\\n    { title: \\\"Col AAAA\\\", width: 120 },\\n    { title: \\\"Col AAA\\\", width: 120 },\\n    { title: \\\"Col AA\\\", width: 120 },\\n    { title: \\\"Col A\\\", width: 120 },\\n    { title: \\\"Col\\\", width: 120 },\\n];\\n\\nexport function FilterColumns() {\\n    const [searchText, setSearchText] = useState(\\\"\\\");\\n\\n    const cols = useMemo(() => {\\n        if (searchText === \\\"\\\") {\\n            return filteringColumns;\\n        }\\n\\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\\n    }, [searchText]);\\n\\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n        setSearchText(e.target.value);\\n    };\\n\\n    return (\\n        <div>\\n            <input value={searchText} onChange={onInputChange} />\\n            <DataEditor\\n                width={1000}\\n                height={500}\\n                rows={100}\\n                columns={cols}\\n                getCellContent={filterColumnsGen}\\n                smoothScrollX={true}\\n                smoothScrollY={true}\\n            />\\n        </div>\\n    );\\n}\\n\",\".b1nvh7n2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.b1nvh7n2 > a{margin-bottom:20px;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItcmVwcm9zLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5iMW52aDduMiJdLCJtYXBwaW5ncyI6IkFBOEJNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLXJlcHJvcy5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gXCJAc3Rvcnlib29rL2FkZG9uc1wiO1xuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB0aXRsZTogXCJUZXN0cy9UZXN0Q2FzZXMvQnVnc1wiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxMDAwfSBoZWlnaHQ9ezgwMH0+XG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGJ1ZzcwR2VuID0gKFssIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTnVtYmVyLFxuICAgIGRhdGE6IHJvdyxcbiAgICBkaXNwbGF5RGF0YTogcm93LnRvU3RyaW5nKCksXG59KTtcblxuY29uc3QgaWdub3JlID0gKCkgPT4gdW5kZWZpbmVkO1xuXG5jb25zdCBCdWc3MFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICA+IGEge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBCdWc3MCgpIHtcbiAgICBjb25zdCBjb2xzID0gW1xuICAgICAgICB7IHRpdGxlOiBcIkNvbDFcIiwgd2lkdGg6IDEwMCB9LFxuICAgICAgICB7IHRpdGxlOiBcIkNvbDJcIiwgd2lkdGg6IDEwMCB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XCJBcHBcIj5cbiAgICAgICAgICAgIDxwPlRvIGNhdXNlIGVycm9yOiBzY3JvbGwgZG93biBhdCBsZWFzdCBvbmUgcm93LCBlZGl0IGEgY2VsbCBpbiBDb2wyLCBhbmQgaGl0IFRhYjwvcD5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9pc3N1ZXMvNzBcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+XG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXs1MDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2J1ZzcwR2VufVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CdWc3MFN0eWxlPlxuICAgICk7XG59XG5cbmNvbnN0IGZpbHRlckNvbHVtbnNHZW4gPSAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgIGRhdGE6IGAke2NvbH0gLSAke3Jvd31gLFxuICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcbn0pO1xuXG5jb25zdCBmaWx0ZXJpbmdDb2x1bW5zID0gW1xuICAgIHsgdGl0bGU6IFwiQ29sIEFBQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFBQVwiLCB3aWR0aDogMTIwIH0sXG4gICAgeyB0aXRsZTogXCJDb2wgQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sXCIsIHdpZHRoOiAxMjAgfSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBGaWx0ZXJDb2x1bW5zKCkge1xuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gICAgY29uc3QgY29scyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2VhcmNoVGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmluZ0NvbHVtbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucy5maWx0ZXIoYyA9PiBjLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgfSwgW3NlYXJjaFRleHRdKTtcblxuICAgIGNvbnN0IG9uSW5wdXRDaGFuZ2UgPSAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgc2V0U2VhcmNoVGV4dChlLnRhcmdldC52YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9e3NlYXJjaFRleHR9IG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfSAvPlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB3aWR0aD17MTAwMH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17ZmlsdGVyQ29sdW1uc0dlbn1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXt0cnVlfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufVxuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".c4uqbye{width:120px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#f1f1f1;height:100%;}.c4uqbye button{border:none;outline:none;height:37px;width:120px;font-size:20px;background-color:#f7f7f8;color:#000000dd;border-bottom:1px solid #e1e2e5;-webkit-transition:background-color 200ms;transition:background-color 200ms;cursor:pointer;}.c4uqbye button:hover{background-color:#efeff1;}\\n.b1bsqg7n{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b1bsqg7n.double{height:200vh;}.b1bsqg7n > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b1bsqg7n .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b1bsqg7n .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}.b1bsqg7n.firefox .sizer{border-radius:0;box-shadow:unset;}.b1bsqg7n.firefox .sizer .sizer-clip{border-radius:0;}.b1bsqg7n .white{background-color:white;}\\n.piiq54i{font-family:monospace;font-weight:500;color:#ffe394;}\\n.d1k3yj19{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n.m1j0dy02{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1j0dy02 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5jNHVxYnllIiwiLmIxYnNxZzduIiwiLnBpaXE1NGkiLCIuZDFrM3lqMTkiLCIubTFqMGR5MDIiXSwibWFwcGluZ3MiOiJBQXdIYUE7QUF5QkFDO0FBdURBQztBQU1BQztBQU1BQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL3V0aWxzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQge1xuICAgIENlbGxBcnJheSxcbiAgICBFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEdyaWRDZWxsLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBHcmlkQ29sdW1uLFxuICAgIEdyaWRDb2x1bW5JY29uLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBpc1RleHRFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEl0ZW0sXG4gICAgUmVjdGFuZ2xlLFxufSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBpc0FycmF5IGZyb20gXCJsb2Rhc2gvaXNBcnJheS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3N1cHBvcnRcIjtcbmltcG9ydCB7IGJyb3dzZXJJc0ZpcmVmb3ggfSBmcm9tIFwiLi4vLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCJyZWFjdC1yZXNpemUtZGV0ZWN0b3JcIjtcblxuZmFrZXIuc2VlZCgxMzM3KTtcblxuZnVuY3Rpb24gaXNUcnV0aHkoeDogYW55KTogYm9vbGVhbiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgIHJldHVybiB4ID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNvcHkgZGF0YSBiZXR3ZWVuIGdyaWQgY2VsbHMgb2YgYW55IGtpbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3NzeUNvcHlEYXRhPFQgZXh0ZW5kcyBFZGl0YWJsZUdyaWRDZWxsPihzb3VyY2U6IEVkaXRhYmxlR3JpZENlbGwsIHRhcmdldDogVCk6IEVkaXRhYmxlR3JpZENlbGwge1xuICAgIGNvbnN0IHNvdXJjZURhdGEgPSBzb3VyY2UuZGF0YTtcbiAgICBpZiAodHlwZW9mIHNvdXJjZURhdGEgPT09IHR5cGVvZiB0YXJnZXQuZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YSBhcyBhbnksXG4gICAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICAgIHN3aXRjaCAodGFyZ2V0LmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uua2luZCA9PT0gR3JpZENlbGxLaW5kLkJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGlzVHJ1dGh5KHNvdXJjZURhdGEpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbc291cmNlRGF0YVswXV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW3NvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIl0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk51bWJlcjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVGV4dDpcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk1hcmtkb3duOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlLmRhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQ3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIGRlZmF1bHRcbiAgICAgICAgfVxuICAgIGFzc2VydE5ldmVyKHRhcmdldCk7XG59XG5cbmV4cG9ydCB0eXBlIEdyaWRDb2x1bW5XaXRoTW9ja2luZ0luZm8gPSBHcmlkQ29sdW1uICYge1xuICAgIGdldENvbnRlbnQoKTogR3JpZENlbGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R3JpZENvbHVtbihjb2x1bW5XaXRoTW9jazogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mbyk6IEdyaWRDb2x1bW4ge1xuICAgIGNvbnN0IHsgZ2V0Q29udGVudCwgLi4ucmVzdCB9ID0gY29sdW1uV2l0aE1vY2s7XG5cbiAgICByZXR1cm4gcmVzdDtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkFkZEJ1dHRvbiA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDEyMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjFmMWYxO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBidXR0b24ge1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGhlaWdodDogMzdweDtcbiAgICAgICAgd2lkdGg6IDEyMHB4O1xuICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjg7XG4gICAgICAgIGNvbG9yOiAjMDAwMDAwZGQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTFlMmU1O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VmZWZmMTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmLmRvdWJsZSB7XG4gICAgICAgIGhlaWdodDogMjAwdmg7XG4gICAgfVxuXG4gICAgJiA+IGgxIHtcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xuICAgIH1cblxuICAgIC5zaXplciB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcblxuICAgICAgICAuc2l6ZXItY2xpcCB7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcblxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5maXJlZm94IC5zaXplciB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIGJveC1zaGFkb3c6IHVuc2V0O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAud2hpdGUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxXcmFwcGVyOiBSZWFjdC5GQzxCZWF1dGlmdWxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24sIGNsYXNzTmFtZSB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlIGNsYXNzTmFtZT17Y2xhc3NOYW1lICsgKGJyb3dzZXJJc0ZpcmVmb3gudmFsdWUgPyBcIiBmaXJlZm94XCIgOiBcIlwiKX0+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dENvbHVtbkluZm8oaW5kZXg6IG51bWJlciwgZ3JvdXA6IGJvb2xlYW4pOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogYENvbHVtbiAke2luZGV4fWAsXG4gICAgICAgIGlkOiBgQ29sdW1uICR7aW5kZXh9YCxcbiAgICAgICAgZ3JvdXA6IGdyb3VwID8gYEdyb3VwICR7TWF0aC5yb3VuZChpbmRleCAvIDMpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBmYWtlci5sb3JlbS53b3JkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6YWJsZUNvbHVtbnMoYW1vdW50OiBudW1iZXIsIGdyb3VwOiBib29sZWFuKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sdW1uczogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIk5hbWVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TmFtZSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTGFzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJMYXN0IG5hbWVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiTmFtZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGFzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkF2YXRhclwiLFxuICAgICAgICAgICAgaWQ6IFwiQXZhdGFyXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYGh0dHBzOi8vcGljc3VtLnBob3Rvcy9pZC8ke259LzkwMC85MDBgXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFtgaHR0cHM6Ly9waWNzdW0ucGhvdG9zL2lkLyR7bn0vNDAvNDBgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0FkZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJFbWFpbFwiLFxuICAgICAgICAgICAgaWQ6IFwiRW1haWxcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBmYWtlci5pbnRlcm5ldC5lbWFpbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgaWQ6IFwiVGl0bGVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFueSA9IGZha2VyLm5hbWUuam9iVGl0bGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1vcmUgSW5mb1wiLFxuICAgICAgICAgICAgaWQ6IFwiTW9yZSBJbmZvXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclVyaSxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGZha2VyLmludGVybmV0LnVybCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5VcmksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgaWYgKGFtb3VudCA8IGRlZmF1bHRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvbHVtbnMuc2xpY2UoMCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYUNvbHVtbnNBbW91bnQgPSBhbW91bnQgLSBkZWZhdWx0Q29sdW1ucy5sZW5ndGg7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1uZXctYXJyYXlcbiAgICBjb25zdCBleHRyYUNvbHVtbnMgPSBbLi4ubmV3IEFycmF5KGV4dHJhQ29sdW1uc0Ftb3VudCldLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAgIGNyZWF0ZVRleHRDb2x1bW5JbmZvKGluZGV4ICsgZGVmYXVsdENvbHVtbnMubGVuZ3RoLCBncm91cClcbiAgICApO1xuXG4gICAgcmV0dXJuIFsuLi5kZWZhdWx0Q29sdW1ucywgLi4uZXh0cmFDb2x1bW5zXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRDYWNoZSB7XG4gICAgLy8gY29sdW1uIC0+IHJvdyAtPiB2YWx1ZVxuICAgIHByaXZhdGUgY2FjaGVkQ29udGVudDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgR3JpZENlbGw+PiA9IG5ldyBNYXAoKTtcblxuICAgIGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY29sQ2FjaGUgPSB0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCk7XG5cbiAgICAgICAgaWYgKGNvbENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sQ2FjaGUuZ2V0KHJvdyk7XG4gICAgfVxuXG4gICAgc2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IEdyaWRDZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRDb250ZW50LnNldChjb2wsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3dDYWNoZSA9IHRoaXMuY2FjaGVkQ29udGVudC5nZXQoY29sKSBhcyBNYXA8bnVtYmVyLCBHcmlkQ2VsbD47XG4gICAgICAgIHJvd0NhY2hlLnNldChyb3csIHZhbHVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2NrRGF0YUdlbmVyYXRvcihudW1Db2xzOiBudW1iZXIsIHJlYWRvbmx5OiBib29sZWFuID0gdHJ1ZSwgZ3JvdXA6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGdldFJlc2l6YWJsZUNvbHVtbnMobnVtQ29scywgZ3JvdXApKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAoZ2V0UmVzaXphYmxlQ29sdW1ucyhudW1Db2xzLCBncm91cCkpO1xuICAgIH0sIFtncm91cCwgbnVtQ29sc10pO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgY29sc01hcFJlZiA9IFJlYWN0LnVzZVJlZihjb2xzTWFwKTtcbiAgICBjb2xzTWFwUmVmLmN1cnJlbnQgPSBjb2xzTWFwO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGNvbHNNYXBSZWYuY3VycmVudFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRvbmx5ICYmIGlzVGV4dEVkaXRhYmxlR3JpZENlbGwodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB7IC4uLnZhbCwgcmVhZG9ubHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbcmVhZG9ubHldXG4gICAgKTtcblxuICAgIGNvbnN0IGdldENlbGxzRm9yU2VsZWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChzZWxlY3Rpb246IFJlY3RhbmdsZSk6IENlbGxBcnJheSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEdyaWRDZWxsW11bXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gc2VsZWN0aW9uLnk7IHkgPCBzZWxlY3Rpb24ueSArIHNlbGVjdGlvbi5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdzogR3JpZENlbGxbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBzZWxlY3Rpb24ueDsgeCA8IHNlbGVjdGlvbi54ICsgc2VsZWN0aW9uLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZ2V0Q2VsbENvbnRlbnQoW3gsIHldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIFtnZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlUmF3ID0gUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd106IEl0ZW0sIHZhbDogR3JpZENlbGwpOiB2b2lkID0+IHtcbiAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlR3JpZENlbGwodmFsKSAmJiBpc0VkaXRhYmxlR3JpZENlbGwoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWQgPSBsb3NzeUNvcHlEYXRhKHZhbCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29waWVkLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdHlwZW9mIGNvcGllZC5kYXRhID09PSBcInN0cmluZ1wiID8gY29waWVkLmRhdGEgOiAoY29waWVkIGFzIGFueSkuZGlzcGxheURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtjb2xzTWFwXVxuICAgICk7XG5cbiAgICByZXR1cm4geyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24sIHNldENlbGxWYWx1ZVJhdyB9O1xufVxuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-editor/stories/packages/core/src/data-editor/stories/utils.tsx\",\"webpack://./packages/core/src/data-editor/stories/utils.tsx\"],\"names\":[\".c4uqbye\",\".b1bsqg7n\",\".piiq54i\",\".d1k3yj19\",\".m1j0dy02\"],\"mappings\":\"AAwHaA,SAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,wBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,gBAAAA,WAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,wBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,wBAAAA,CAAAA;AAyBAC,UAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iBAAAA,YAAAA,CAAAA,CAAAA,eAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,6BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yBAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,qCAAAA,eAAAA,CAAAA,CAAAA,iBAAAA,sBAAAA,CAAAA;AAuDAC,SAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA;AAMAC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AAMAC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA;AC/Mb,u1oBAAu1oB\",\"sourcesContent\":[\"import * as React from \\\"react\\\";\\n\\nimport {\\n    CellArray,\\n    EditableGridCell,\\n    GridCell,\\n    GridCellKind,\\n    GridColumn,\\n    GridColumnIcon,\\n    isEditableGridCell,\\n    isTextEditableGridCell,\\n    Item,\\n    Rectangle,\\n} from \\\"../../data-grid/data-grid-types\\\";\\n\\nimport faker from \\\"faker\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport isArray from \\\"lodash/isArray.js\\\";\\nimport { assertNever } from \\\"../../common/support\\\";\\nimport { browserIsFirefox } from \\\"../../common/browser-detect\\\";\\nimport { useResizeDetector } from \\\"react-resize-detector\\\";\\n\\nfaker.seed(1337);\\n\\nfunction isTruthy(x: any): boolean {\\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\\n    return x ? true : false;\\n}\\n\\n/**\\n * Attempts to copy data between grid cells of any kind.\\n */\\nexport function lossyCopyData<T extends EditableGridCell>(source: EditableGridCell, target: T): EditableGridCell {\\n    const sourceData = source.data;\\n    if (typeof sourceData === typeof target.data) {\\n        return {\\n            ...target,\\n            data: sourceData as any,\\n        };\\n    } else\\n        switch (target.kind) {\\n            case GridCellKind.Uri: {\\n                if (isArray(sourceData)) {\\n                    return {\\n                        ...target,\\n                        data: sourceData[0],\\n                    };\\n                }\\n                return {\\n                    ...target,\\n                    data: sourceData?.toString() ?? \\\"\\\",\\n                };\\n            }\\n            case GridCellKind.Boolean: {\\n                if (isArray(sourceData)) {\\n                    return {\\n                        ...target,\\n                        data: sourceData[0] !== undefined,\\n                    };\\n                } else if (source.kind === GridCellKind.Boolean) {\\n                    return {\\n                        ...target,\\n                        data: source.data,\\n                    };\\n                }\\n                return {\\n                    ...target,\\n                    data: isTruthy(sourceData) ? true : false,\\n                };\\n            }\\n            case GridCellKind.Image: {\\n                if (isArray(sourceData)) {\\n                    return {\\n                        ...target,\\n                        data: [sourceData[0]],\\n                    };\\n                }\\n                return {\\n                    ...target,\\n                    data: [sourceData?.toString() ?? \\\"\\\"],\\n                };\\n            }\\n            case GridCellKind.Number: {\\n                return {\\n                    ...target,\\n                    data: 0,\\n                };\\n            }\\n            case GridCellKind.Text:\\n            case GridCellKind.Markdown: {\\n                if (isArray(sourceData)) {\\n                    return {\\n                        ...target,\\n                        data: sourceData[0].toString() ?? \\\"\\\",\\n                    };\\n                }\\n\\n                return {\\n                    ...target,\\n                    data: source.data?.toString() ?? \\\"\\\",\\n                };\\n            }\\n            case GridCellKind.Custom: {\\n                return target;\\n            }\\n            // No default\\n        }\\n    assertNever(target);\\n}\\n\\nexport type GridColumnWithMockingInfo = GridColumn & {\\n    getContent(): GridCell;\\n};\\n\\nexport function getGridColumn(columnWithMock: GridColumnWithMockingInfo): GridColumn {\\n    const { getContent, ...rest } = columnWithMock;\\n\\n    return rest;\\n}\\n\\nexport const ColumnAddButton = styled.div`\\n    width: 120px;\\n    display: flex;\\n    flex-direction: column;\\n    background-color: #f1f1f1;\\n    height: 100%;\\n    button {\\n        border: none;\\n        outline: none;\\n        height: 37px;\\n        width: 120px;\\n        font-size: 20px;\\n        background-color: #f7f7f8;\\n        color: #000000dd;\\n        border-bottom: 1px solid #e1e2e5;\\n\\n        transition: background-color 200ms;\\n\\n        cursor: pointer;\\n        :hover {\\n            background-color: #efeff1;\\n        }\\n    }\\n`;\\n\\nexport const BeautifulStyle = styled.div`\\n    background-color: #2790b9;\\n    background: linear-gradient(90deg, #2790b9, #2070a9);\\n    color: white;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    &.double {\\n        height: 200vh;\\n    }\\n\\n    & > h1 {\\n        font-size: 50px;\\n        font-weight: 600;\\n        flex-shrink: 0;\\n        margin: 0 0 12px 0;\\n    }\\n\\n    .sizer {\\n        flex-grow: 1;\\n\\n        background-color: white;\\n\\n        border-radius: 12px;\\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\\n\\n        .sizer-clip {\\n            border-radius: 12px;\\n            overflow: hidden;\\n            transform: translateZ(0);\\n\\n            height: 100%;\\n        }\\n    }\\n\\n    &.firefox .sizer {\\n        border-radius: 0;\\n        box-shadow: unset;\\n\\n        .sizer-clip {\\n            border-radius: 0;\\n        }\\n    }\\n\\n    .white {\\n        background-color: white;\\n    }\\n`;\\n\\nexport const PropName = styled.span`\\n    font-family: monospace;\\n    font-weight: 500;\\n    color: #ffe394;\\n`;\\n\\nexport const Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nexport const MoreInfo = styled.p`\\n    font-size: 14px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n\\n    button {\\n        background-color: #f4f4f4;\\n        color: #2b2b2b;\\n        padding: 2px 6px;\\n        font-family: monospace;\\n        font-size: 14px;\\n        border-radius: 4px;\\n        box-shadow: 0px 1px 2px #00000040;\\n        margin: 0 0.1em;\\n        border: none;\\n        cursor: pointer;\\n    }\\n`;\\n\\ninterface BeautifulProps {\\n    title: string;\\n    description?: React.ReactNode;\\n    className?: string;\\n}\\n\\nexport const BeautifulWrapper: React.FC<BeautifulProps> = p => {\\n    const { title, children, description, className } = p;\\n\\n    const { ref, width, height } = useResizeDetector();\\n\\n    return (\\n        <BeautifulStyle className={className + (browserIsFirefox.value ? \\\" firefox\\\" : \\\"\\\")}>\\n            <h1>{title}</h1>\\n            {description}\\n            <div className=\\\"sizer\\\">\\n                <div className=\\\"sizer-clip\\\" ref={ref}>\\n                    <div\\n                        style={{\\n                            position: \\\"relative\\\",\\n                            width: width ?? 100,\\n                            height: height ?? 100,\\n                        }}>\\n                        {children}\\n                    </div>\\n                </div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n\\nfunction createTextColumnInfo(index: number, group: boolean): GridColumnWithMockingInfo {\\n    return {\\n        title: `Column ${index}`,\\n        id: `Column ${index}`,\\n        group: group ? `Group ${Math.round(index / 3)}` : undefined,\\n        icon: GridColumnIcon.HeaderString,\\n        hasMenu: false,\\n        getContent: () => {\\n            const text = faker.lorem.word();\\n\\n            return {\\n                kind: GridCellKind.Text,\\n                data: text,\\n                displayData: text,\\n                allowOverlay: true,\\n                readonly: true,\\n            };\\n        },\\n    };\\n}\\n\\nfunction getResizableColumns(amount: number, group: boolean): GridColumnWithMockingInfo[] {\\n    const defaultColumns: GridColumnWithMockingInfo[] = [\\n        {\\n            title: \\\"First name\\\",\\n            id: \\\"First name\\\",\\n            group: group ? \\\"Name\\\" : undefined,\\n            icon: GridColumnIcon.HeaderString,\\n            hasMenu: false,\\n            getContent: () => {\\n                const firstName = faker.name.firstName();\\n                return {\\n                    kind: GridCellKind.Text,\\n                    displayData: firstName,\\n                    data: firstName,\\n                    allowOverlay: true,\\n                    readonly: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Last name\\\",\\n            id: \\\"Last name\\\",\\n            group: group ? \\\"Name\\\" : undefined,\\n            icon: GridColumnIcon.HeaderString,\\n            hasMenu: false,\\n            getContent: () => {\\n                const lastName = faker.name.lastName();\\n                return {\\n                    kind: GridCellKind.Text,\\n                    displayData: lastName,\\n                    data: lastName,\\n                    allowOverlay: true,\\n                    readonly: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Avatar\\\",\\n            id: \\\"Avatar\\\",\\n            group: group ? \\\"Info\\\" : undefined,\\n            icon: GridColumnIcon.HeaderImage,\\n            hasMenu: false,\\n            getContent: () => {\\n                const n = Math.round(Math.random() * 100);\\n                return {\\n                    kind: GridCellKind.Image,\\n                    data: [`https://picsum.photos/id/${n}/900/900`],\\n                    displayData: [`https://picsum.photos/id/${n}/40/40`],\\n                    allowOverlay: true,\\n                    allowAdd: false,\\n                    readonly: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Email\\\",\\n            id: \\\"Email\\\",\\n            group: group ? \\\"Info\\\" : undefined,\\n            icon: GridColumnIcon.HeaderString,\\n            hasMenu: false,\\n            getContent: () => {\\n                const email = faker.internet.email();\\n                return {\\n                    kind: GridCellKind.Text,\\n                    displayData: email,\\n                    data: email,\\n                    allowOverlay: true,\\n                    readonly: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"Title\\\",\\n            id: \\\"Title\\\",\\n            group: group ? \\\"Info\\\" : undefined,\\n            icon: GridColumnIcon.HeaderString,\\n            hasMenu: false,\\n            getContent: () => {\\n                const company = faker.name.jobTitle();\\n                return {\\n                    kind: GridCellKind.Text,\\n                    displayData: company,\\n                    data: company,\\n                    allowOverlay: true,\\n                    readonly: true,\\n                };\\n            },\\n        },\\n        {\\n            title: \\\"More Info\\\",\\n            id: \\\"More Info\\\",\\n            group: group ? \\\"Info\\\" : undefined,\\n            icon: GridColumnIcon.HeaderUri,\\n            hasMenu: false,\\n            getContent: () => {\\n                const url = faker.internet.url();\\n                return {\\n                    kind: GridCellKind.Uri,\\n                    displayData: url,\\n                    data: url,\\n                    allowOverlay: true,\\n                    readonly: true,\\n                };\\n            },\\n        },\\n    ];\\n\\n    if (amount < defaultColumns.length) {\\n        return defaultColumns.slice(0, amount);\\n    }\\n\\n    const extraColumnsAmount = amount - defaultColumns.length;\\n\\n    // eslint-disable-next-line unicorn/no-new-array\\n    const extraColumns = [...new Array(extraColumnsAmount)].map((_, index) =>\\n        createTextColumnInfo(index + defaultColumns.length, group)\\n    );\\n\\n    return [...defaultColumns, ...extraColumns];\\n}\\n\\nexport class ContentCache {\\n    // column -> row -> value\\n    private cachedContent: Map<number, Map<number, GridCell>> = new Map();\\n\\n    get(col: number, row: number) {\\n        const colCache = this.cachedContent.get(col);\\n\\n        if (colCache === undefined) {\\n            return undefined;\\n        }\\n\\n        return colCache.get(row);\\n    }\\n\\n    set(col: number, row: number, value: GridCell) {\\n        if (this.cachedContent.get(col) === undefined) {\\n            this.cachedContent.set(col, new Map());\\n        }\\n\\n        const rowCache = this.cachedContent.get(col) as Map<number, GridCell>;\\n        rowCache.set(row, value);\\n    }\\n}\\n\\nexport function useMockDataGenerator(numCols: number, readonly: boolean = true, group: boolean = false) {\\n    const cache = React.useRef<ContentCache>(new ContentCache());\\n\\n    const [colsMap, setColsMap] = React.useState(() => getResizableColumns(numCols, group));\\n\\n    React.useEffect(() => {\\n        setColsMap(getResizableColumns(numCols, group));\\n    }, [group, numCols]);\\n\\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\\n        setColsMap(prevColsMap => {\\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\\n            const newArray = [...prevColsMap];\\n            newArray.splice(index, 1, {\\n                ...prevColsMap[index],\\n                width: newSize,\\n            });\\n            return newArray;\\n        });\\n    }, []);\\n\\n    const cols = React.useMemo(() => {\\n        return colsMap.map(getGridColumn);\\n    }, [colsMap]);\\n\\n    const colsMapRef = React.useRef(colsMap);\\n    colsMapRef.current = colsMap;\\n    const getCellContent = React.useCallback(\\n        ([col, row]: Item): GridCell => {\\n            let val = cache.current.get(col, row);\\n            if (val === undefined) {\\n                val = colsMapRef.current[col].getContent();\\n                if (!readonly && isTextEditableGridCell(val)) {\\n                    val = { ...val, readonly };\\n                }\\n                cache.current.set(col, row, val);\\n            }\\n            return val;\\n        },\\n        [readonly]\\n    );\\n\\n    const getCellsForSelection = React.useCallback(\\n        (selection: Rectangle): CellArray => {\\n            const result: GridCell[][] = [];\\n\\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\\n                const row: GridCell[] = [];\\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\\n                    row.push(getCellContent([x, y]));\\n                }\\n                result.push(row);\\n            }\\n\\n            return result;\\n        },\\n        [getCellContent]\\n    );\\n\\n    const setCellValueRaw = React.useCallback(([col, row]: Item, val: GridCell): void => {\\n        cache.current.set(col, row, val);\\n    }, []);\\n\\n    const setCellValue = React.useCallback(\\n        ([col, row]: Item, val: GridCell): void => {\\n            let current = cache.current.get(col, row);\\n            if (current === undefined) {\\n                current = colsMap[col].getContent();\\n            }\\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\\n                const copied = lossyCopyData(val, current);\\n                cache.current.set(col, row, {\\n                    ...copied,\\n                    displayData: typeof copied.data === \\\"string\\\" ? copied.data : (copied as any).displayData,\\n                    lastUpdated: performance.now(),\\n                } as any);\\n            }\\n        },\\n        [colsMap]\\n    );\\n\\n    return { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection, setCellValueRaw };\\n}\\n\",\".c4uqbye{width:120px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#f1f1f1;height:100%;}.c4uqbye button{border:none;outline:none;height:37px;width:120px;font-size:20px;background-color:#f7f7f8;color:#000000dd;border-bottom:1px solid #e1e2e5;-webkit-transition:background-color 200ms;transition:background-color 200ms;cursor:pointer;}.c4uqbye button:hover{background-color:#efeff1;}\\n.b1bsqg7n{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b1bsqg7n.double{height:200vh;}.b1bsqg7n > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b1bsqg7n .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b1bsqg7n .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}.b1bsqg7n.firefox .sizer{border-radius:0;box-shadow:unset;}.b1bsqg7n.firefox .sizer .sizer-clip{border-radius:0;}.b1bsqg7n .white{background-color:white;}\\n.piiq54i{font-family:monospace;font-weight:500;color:#ffe394;}\\n.d1k3yj19{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n.m1j0dy02{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1j0dy02 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5jNHVxYnllIiwiLmIxYnNxZzduIiwiLnBpaXE1NGkiLCIuZDFrM3lqMTkiLCIubTFqMGR5MDIiXSwibWFwcGluZ3MiOiJBQXdIYUE7QUF5QkFDO0FBdURBQztBQU1BQztBQU1BQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL3V0aWxzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQge1xuICAgIENlbGxBcnJheSxcbiAgICBFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEdyaWRDZWxsLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBHcmlkQ29sdW1uLFxuICAgIEdyaWRDb2x1bW5JY29uLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBpc1RleHRFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEl0ZW0sXG4gICAgUmVjdGFuZ2xlLFxufSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBpc0FycmF5IGZyb20gXCJsb2Rhc2gvaXNBcnJheS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3N1cHBvcnRcIjtcbmltcG9ydCB7IGJyb3dzZXJJc0ZpcmVmb3ggfSBmcm9tIFwiLi4vLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCJyZWFjdC1yZXNpemUtZGV0ZWN0b3JcIjtcblxuZmFrZXIuc2VlZCgxMzM3KTtcblxuZnVuY3Rpb24gaXNUcnV0aHkoeDogYW55KTogYm9vbGVhbiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgIHJldHVybiB4ID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNvcHkgZGF0YSBiZXR3ZWVuIGdyaWQgY2VsbHMgb2YgYW55IGtpbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3NzeUNvcHlEYXRhPFQgZXh0ZW5kcyBFZGl0YWJsZUdyaWRDZWxsPihzb3VyY2U6IEVkaXRhYmxlR3JpZENlbGwsIHRhcmdldDogVCk6IEVkaXRhYmxlR3JpZENlbGwge1xuICAgIGNvbnN0IHNvdXJjZURhdGEgPSBzb3VyY2UuZGF0YTtcbiAgICBpZiAodHlwZW9mIHNvdXJjZURhdGEgPT09IHR5cGVvZiB0YXJnZXQuZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YSBhcyBhbnksXG4gICAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICAgIHN3aXRjaCAodGFyZ2V0LmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uua2luZCA9PT0gR3JpZENlbGxLaW5kLkJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGlzVHJ1dGh5KHNvdXJjZURhdGEpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbc291cmNlRGF0YVswXV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW3NvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIl0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk51bWJlcjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVGV4dDpcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk1hcmtkb3duOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlLmRhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQ3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIGRlZmF1bHRcbiAgICAgICAgfVxuICAgIGFzc2VydE5ldmVyKHRhcmdldCk7XG59XG5cbmV4cG9ydCB0eXBlIEdyaWRDb2x1bW5XaXRoTW9ja2luZ0luZm8gPSBHcmlkQ29sdW1uICYge1xuICAgIGdldENvbnRlbnQoKTogR3JpZENlbGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R3JpZENvbHVtbihjb2x1bW5XaXRoTW9jazogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mbyk6IEdyaWRDb2x1bW4ge1xuICAgIGNvbnN0IHsgZ2V0Q29udGVudCwgLi4ucmVzdCB9ID0gY29sdW1uV2l0aE1vY2s7XG5cbiAgICByZXR1cm4gcmVzdDtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkFkZEJ1dHRvbiA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDEyMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjFmMWYxO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBidXR0b24ge1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGhlaWdodDogMzdweDtcbiAgICAgICAgd2lkdGg6IDEyMHB4O1xuICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjg7XG4gICAgICAgIGNvbG9yOiAjMDAwMDAwZGQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTFlMmU1O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VmZWZmMTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmLmRvdWJsZSB7XG4gICAgICAgIGhlaWdodDogMjAwdmg7XG4gICAgfVxuXG4gICAgJiA+IGgxIHtcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xuICAgIH1cblxuICAgIC5zaXplciB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcblxuICAgICAgICAuc2l6ZXItY2xpcCB7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcblxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5maXJlZm94IC5zaXplciB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIGJveC1zaGFkb3c6IHVuc2V0O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAud2hpdGUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxXcmFwcGVyOiBSZWFjdC5GQzxCZWF1dGlmdWxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24sIGNsYXNzTmFtZSB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlIGNsYXNzTmFtZT17Y2xhc3NOYW1lICsgKGJyb3dzZXJJc0ZpcmVmb3gudmFsdWUgPyBcIiBmaXJlZm94XCIgOiBcIlwiKX0+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dENvbHVtbkluZm8oaW5kZXg6IG51bWJlciwgZ3JvdXA6IGJvb2xlYW4pOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogYENvbHVtbiAke2luZGV4fWAsXG4gICAgICAgIGlkOiBgQ29sdW1uICR7aW5kZXh9YCxcbiAgICAgICAgZ3JvdXA6IGdyb3VwID8gYEdyb3VwICR7TWF0aC5yb3VuZChpbmRleCAvIDMpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBmYWtlci5sb3JlbS53b3JkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6YWJsZUNvbHVtbnMoYW1vdW50OiBudW1iZXIsIGdyb3VwOiBib29sZWFuKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sdW1uczogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIk5hbWVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TmFtZSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTGFzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJMYXN0IG5hbWVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiTmFtZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGFzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkF2YXRhclwiLFxuICAgICAgICAgICAgaWQ6IFwiQXZhdGFyXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYGh0dHBzOi8vcGljc3VtLnBob3Rvcy9pZC8ke259LzkwMC85MDBgXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFtgaHR0cHM6Ly9waWNzdW0ucGhvdG9zL2lkLyR7bn0vNDAvNDBgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0FkZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJFbWFpbFwiLFxuICAgICAgICAgICAgaWQ6IFwiRW1haWxcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBmYWtlci5pbnRlcm5ldC5lbWFpbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgaWQ6IFwiVGl0bGVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFueSA9IGZha2VyLm5hbWUuam9iVGl0bGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1vcmUgSW5mb1wiLFxuICAgICAgICAgICAgaWQ6IFwiTW9yZSBJbmZvXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclVyaSxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGZha2VyLmludGVybmV0LnVybCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5VcmksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgaWYgKGFtb3VudCA8IGRlZmF1bHRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvbHVtbnMuc2xpY2UoMCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYUNvbHVtbnNBbW91bnQgPSBhbW91bnQgLSBkZWZhdWx0Q29sdW1ucy5sZW5ndGg7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1uZXctYXJyYXlcbiAgICBjb25zdCBleHRyYUNvbHVtbnMgPSBbLi4ubmV3IEFycmF5KGV4dHJhQ29sdW1uc0Ftb3VudCldLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAgIGNyZWF0ZVRleHRDb2x1bW5JbmZvKGluZGV4ICsgZGVmYXVsdENvbHVtbnMubGVuZ3RoLCBncm91cClcbiAgICApO1xuXG4gICAgcmV0dXJuIFsuLi5kZWZhdWx0Q29sdW1ucywgLi4uZXh0cmFDb2x1bW5zXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRDYWNoZSB7XG4gICAgLy8gY29sdW1uIC0+IHJvdyAtPiB2YWx1ZVxuICAgIHByaXZhdGUgY2FjaGVkQ29udGVudDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgR3JpZENlbGw+PiA9IG5ldyBNYXAoKTtcblxuICAgIGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY29sQ2FjaGUgPSB0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCk7XG5cbiAgICAgICAgaWYgKGNvbENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sQ2FjaGUuZ2V0KHJvdyk7XG4gICAgfVxuXG4gICAgc2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IEdyaWRDZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRDb250ZW50LnNldChjb2wsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3dDYWNoZSA9IHRoaXMuY2FjaGVkQ29udGVudC5nZXQoY29sKSBhcyBNYXA8bnVtYmVyLCBHcmlkQ2VsbD47XG4gICAgICAgIHJvd0NhY2hlLnNldChyb3csIHZhbHVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2NrRGF0YUdlbmVyYXRvcihudW1Db2xzOiBudW1iZXIsIHJlYWRvbmx5OiBib29sZWFuID0gdHJ1ZSwgZ3JvdXA6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGdldFJlc2l6YWJsZUNvbHVtbnMobnVtQ29scywgZ3JvdXApKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAoZ2V0UmVzaXphYmxlQ29sdW1ucyhudW1Db2xzLCBncm91cCkpO1xuICAgIH0sIFtncm91cCwgbnVtQ29sc10pO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgY29sc01hcFJlZiA9IFJlYWN0LnVzZVJlZihjb2xzTWFwKTtcbiAgICBjb2xzTWFwUmVmLmN1cnJlbnQgPSBjb2xzTWFwO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGNvbHNNYXBSZWYuY3VycmVudFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRvbmx5ICYmIGlzVGV4dEVkaXRhYmxlR3JpZENlbGwodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB7IC4uLnZhbCwgcmVhZG9ubHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbcmVhZG9ubHldXG4gICAgKTtcblxuICAgIGNvbnN0IGdldENlbGxzRm9yU2VsZWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChzZWxlY3Rpb246IFJlY3RhbmdsZSk6IENlbGxBcnJheSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEdyaWRDZWxsW11bXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gc2VsZWN0aW9uLnk7IHkgPCBzZWxlY3Rpb24ueSArIHNlbGVjdGlvbi5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdzogR3JpZENlbGxbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBzZWxlY3Rpb24ueDsgeCA8IHNlbGVjdGlvbi54ICsgc2VsZWN0aW9uLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZ2V0Q2VsbENvbnRlbnQoW3gsIHldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIFtnZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlUmF3ID0gUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd106IEl0ZW0sIHZhbDogR3JpZENlbGwpOiB2b2lkID0+IHtcbiAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlR3JpZENlbGwodmFsKSAmJiBpc0VkaXRhYmxlR3JpZENlbGwoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWQgPSBsb3NzeUNvcHlEYXRhKHZhbCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29waWVkLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdHlwZW9mIGNvcGllZC5kYXRhID09PSBcInN0cmluZ1wiID8gY29waWVkLmRhdGEgOiAoY29waWVkIGFzIGFueSkuZGlzcGxheURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtjb2xzTWFwXVxuICAgICk7XG5cbiAgICByZXR1cm4geyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24sIHNldENlbGxWYWx1ZVJhdyB9O1xufVxuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".dpsd959{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:hidden;box-sizing:border-box;--overlay-top:var(--dpsd959-0);left:var(--dpsd959-1);top:var(--dpsd959-2);min-width:var(--dpsd959-3);min-height:var(--dpsd959-4);width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:400px;max-height:calc(100vh - var(--dpsd959-5));font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);text-align:start;}@-webkit-keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}@keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}.dpsd959.gdg-style{border-radius:2px;background-color:var(--gdg-bg-cell);box-shadow:0 0 0 1px var(--gdg-accent-color),0px 0px 1px rgba(62,65,86,0.4), 0px 6px 12px rgba(62,65,86,0.15);-webkit-animation:glide_fade_in-dpsd959 60ms 1;animation:glide_fade_in-dpsd959 60ms 1;}.dpsd959.pad{padding:var(--dpsd959-6) 8.5px 3px;}.dpsd959 .clip-region{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow-y:auto;overflow-x:hidden;border-radius:2px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.dpsd959 .clip-region .gdg-growing-entry{height:100%;}.dpsd959 .clip-region input.gdg-input{width:100%;border:none;border-width:0;outline:none;}.dpsd959 .clip-region textarea.gdg-input{border:none;border-width:0;outline:none;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5kcHNkOTU5Il0sIm1hcHBpbmdzIjoiQUFRYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICB0YXJnZXRYOiBudW1iZXI7XG4gICAgdGFyZ2V0WTogbnVtYmVyO1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG4gICAgdGFyZ2V0SGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgRGF0YUdyaWRPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2PFByb3BzPmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgLS1vdmVybGF5LXRvcDogJHtwID0+IHAudGFyZ2V0WX1weDtcblxuICAgIGxlZnQ6ICR7cCA9PiBwLnRhcmdldFggLSAxfXB4O1xuICAgIHRvcDogJHtwID0+IHAudGFyZ2V0WSAtIDF9cHg7XG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aCArIDJ9cHg7XG4gICAgbWluLWhlaWdodDogJHtwID0+IHAudGFyZ2V0SGVpZ2h0ICsgMn1weDtcbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gJHtwID0+IHAudGFyZ2V0WSArIDEwfXB4KTtcblxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZ2RnLWVkaXRvci1mb250LXNpemUpO1xuXG4gICAgQGtleWZyYW1lcyBnbGlkZV9mYWRlX2luIHtcbiAgICAgICAgZnJvbSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmdkZy1zdHlsZSB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYWNjZW50LWNvbG9yKSwgMHB4IDBweCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLFxuICAgICAgICAgICAgMHB4IDZweCAxMnB4IHJnYmEoNjIsIDY1LCA4NiwgMC4xNSk7XG5cbiAgICAgICAgYW5pbWF0aW9uOiBnbGlkZV9mYWRlX2luIDYwbXMgMTtcbiAgICB9XG5cbiAgICAmLnBhZCB7XG4gICAgICAgIHBhZGRpbmc6ICR7cCA9PiBNYXRoLm1heCgwLCAocC50YXJnZXRIZWlnaHQgLSAyOCkgLyAyKX1weCA4LjVweCAzcHg7XG4gICAgfVxuXG4gICAgLmNsaXAtcmVnaW9uIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICAuZ2RnLWdyb3dpbmctZW50cnkge1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG5cbiAgICAgICAgJiBpbnB1dC5nZGctaW5wdXQge1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgJiB0ZXh0YXJlYS5nZGctaW5wdXQge1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHQtYWxpZ246IHN0YXJ0O1xuYDtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-grid-overlay-editor/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx\",\"webpack://./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx\"],\"names\":[\".dpsd959\"],\"mappings\":\"AAQaA,SAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,8BAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,0BAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,yCAAAA,CAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,yCAAAA,KAAAA,UAAAA,CAAAA,CAAAA,GAAAA,YAAAA,CAAAA,CAAAA,CAAAA,iCAAAA,KAAAA,UAAAA,CAAAA,CAAAA,GAAAA,YAAAA,CAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,mCAAAA,CAAAA,6GAAAA,CAAAA,8CAAAA,CAAAA,sCAAAA,CAAAA,CAAAA,aAAAA,kCAAAA,CAAAA,CAAAA,sBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,CAAAA,sCAAAA,UAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA;ACPb,20FAA20F\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\n\\ninterface Props {\\n    targetX: number;\\n    targetY: number;\\n    targetWidth: number;\\n    targetHeight: number;\\n}\\nexport const DataGridOverlayEditorStyle = styled.div<Props>`\\n    position: absolute;\\n\\n    display: flex;\\n    flex-direction: column;\\n    overflow: hidden;\\n    box-sizing: border-box;\\n\\n    --overlay-top: ${p => p.targetY}px;\\n\\n    left: ${p => p.targetX - 1}px;\\n    top: ${p => p.targetY - 1}px;\\n    min-width: ${p => p.targetWidth + 2}px;\\n    min-height: ${p => p.targetHeight + 2}px;\\n    width: max-content;\\n    max-width: 400px;\\n    max-height: calc(100vh - ${p => p.targetY + 10}px);\\n\\n    font-family: var(--gdg-font-family);\\n    font-size: var(--gdg-editor-font-size);\\n\\n    @keyframes glide_fade_in {\\n        from {\\n            opacity: 0%;\\n        }\\n\\n        to {\\n            opacity: 100%;\\n        }\\n    }\\n\\n    &.gdg-style {\\n        border-radius: 2px;\\n        background-color: var(--gdg-bg-cell);\\n\\n        box-shadow: 0 0 0 1px var(--gdg-accent-color), 0px 0px 1px rgba(62, 65, 86, 0.4),\\n            0px 6px 12px rgba(62, 65, 86, 0.15);\\n\\n        animation: glide_fade_in 60ms 1;\\n    }\\n\\n    &.pad {\\n        padding: ${p => Math.max(0, (p.targetHeight - 28) / 2)}px 8.5px 3px;\\n    }\\n\\n    .clip-region {\\n        display: flex;\\n        flex-direction: column;\\n        overflow-y: auto;\\n        overflow-x: hidden;\\n        border-radius: 2px;\\n        flex-grow: 1;\\n\\n        .gdg-growing-entry {\\n            height: 100%;\\n        }\\n\\n        & input.gdg-input {\\n            width: 100%;\\n            border: none;\\n            border-width: 0;\\n            outline: none;\\n        }\\n\\n        & textarea.gdg-input {\\n            border: none;\\n            border-width: 0;\\n            outline: none;\\n        }\\n    }\\n\\n    text-align: start;\\n`;\\n\",\".dpsd959{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:hidden;box-sizing:border-box;--overlay-top:var(--dpsd959-0);left:var(--dpsd959-1);top:var(--dpsd959-2);min-width:var(--dpsd959-3);min-height:var(--dpsd959-4);width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:400px;max-height:calc(100vh - var(--dpsd959-5));font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);text-align:start;}@-webkit-keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}@keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}.dpsd959.gdg-style{border-radius:2px;background-color:var(--gdg-bg-cell);box-shadow:0 0 0 1px var(--gdg-accent-color),0px 0px 1px rgba(62,65,86,0.4), 0px 6px 12px rgba(62,65,86,0.15);-webkit-animation:glide_fade_in-dpsd959 60ms 1;animation:glide_fade_in-dpsd959 60ms 1;}.dpsd959.pad{padding:var(--dpsd959-6) 8.5px 3px;}.dpsd959 .clip-region{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow-y:auto;overflow-x:hidden;border-radius:2px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.dpsd959 .clip-region .gdg-growing-entry{height:100%;}.dpsd959 .clip-region input.gdg-input{width:100%;border:none;border-width:0;outline:none;}.dpsd959 .clip-region textarea.gdg-input{border:none;border-width:0;outline:none;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5kcHNkOTU5Il0sIm1hcHBpbmdzIjoiQUFRYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICB0YXJnZXRYOiBudW1iZXI7XG4gICAgdGFyZ2V0WTogbnVtYmVyO1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG4gICAgdGFyZ2V0SGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgRGF0YUdyaWRPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2PFByb3BzPmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgLS1vdmVybGF5LXRvcDogJHtwID0+IHAudGFyZ2V0WX1weDtcblxuICAgIGxlZnQ6ICR7cCA9PiBwLnRhcmdldFggLSAxfXB4O1xuICAgIHRvcDogJHtwID0+IHAudGFyZ2V0WSAtIDF9cHg7XG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aCArIDJ9cHg7XG4gICAgbWluLWhlaWdodDogJHtwID0+IHAudGFyZ2V0SGVpZ2h0ICsgMn1weDtcbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gJHtwID0+IHAudGFyZ2V0WSArIDEwfXB4KTtcblxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZ2RnLWVkaXRvci1mb250LXNpemUpO1xuXG4gICAgQGtleWZyYW1lcyBnbGlkZV9mYWRlX2luIHtcbiAgICAgICAgZnJvbSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmdkZy1zdHlsZSB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYWNjZW50LWNvbG9yKSwgMHB4IDBweCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLFxuICAgICAgICAgICAgMHB4IDZweCAxMnB4IHJnYmEoNjIsIDY1LCA4NiwgMC4xNSk7XG5cbiAgICAgICAgYW5pbWF0aW9uOiBnbGlkZV9mYWRlX2luIDYwbXMgMTtcbiAgICB9XG5cbiAgICAmLnBhZCB7XG4gICAgICAgIHBhZGRpbmc6ICR7cCA9PiBNYXRoLm1heCgwLCAocC50YXJnZXRIZWlnaHQgLSAyOCkgLyAyKX1weCA4LjVweCAzcHg7XG4gICAgfVxuXG4gICAgLmNsaXAtcmVnaW9uIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICAuZ2RnLWdyb3dpbmctZW50cnkge1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG5cbiAgICAgICAgJiBpbnB1dC5nZGctaW5wdXQge1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgJiB0ZXh0YXJlYS5nZGctaW5wdXQge1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHQtYWxpZ246IHN0YXJ0O1xuYDtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".bvh4xn4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.bvh4xn4 .boe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:20px;background-color:var(--gdg-bg-bubble);color:var(--gdg-text-dark);margin:2px;}.bvh4xn4 textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2J1YmJsZXMtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5idmg0eG40Il0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEJ1YmJsZXNPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuXG4gICAgLmJvZS1idWJibGUge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcblxuICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1idWJibGUpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIG1hcmdpbjogMnB4O1xuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx\",\"webpack://./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx\"],\"names\":[\".bvh4xn4\"],\"mappings\":\"AAEaA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,qCAAAA,CAAAA,0BAAAA,CAAAA,UAAAA,CAAAA,CAAAA,kBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDb,2sCAA2sC\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\n\\nexport const BubblesOverlayEditorStyle = styled.div`\\n    display: flex;\\n    flex-wrap: wrap;\\n\\n    .boe-bubble {\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n\\n        border-radius: 100px;\\n\\n        padding: 0 8px;\\n        height: 20px;\\n\\n        background-color: var(--gdg-bg-bubble);\\n        color: var(--gdg-text-dark);\\n        margin: 2px;\\n    }\\n\\n    textarea {\\n        position: absolute;\\n        top: 0px;\\n        left: 0px;\\n        width: 0px;\\n        height: 0px;\\n\\n        opacity: 0;\\n    }\\n`;\\n\",\".bvh4xn4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.bvh4xn4 .boe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:20px;background-color:var(--gdg-bg-bubble);color:var(--gdg-text-dark);margin:2px;}.bvh4xn4 textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2J1YmJsZXMtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5idmg0eG40Il0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEJ1YmJsZXNPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuXG4gICAgLmJvZS1idWJibGUge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcblxuICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1idWJibGUpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIG1hcmdpbjogMnB4O1xuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".d11gcyta{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.d11gcyta .doe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:24px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);margin:2px;border-radius:6px;box-shadow:0 0 1px rgba(62,65,86,0.4),0 1px 3px rgba(62,65,86,0.4);}.d11gcyta .doe-bubble img{height:16px;object-fit:contain;margin-right:4px;}.d11gcyta textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2RyaWxsZG93bi1vdmVybGF5LWVkaXRvci50c3giXSwibmFtZXMiOlsiLmQxMWdjeXRhIl0sIm1hcHBpbmdzIjoiQUFJTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvZHJpbGxkb3duLW92ZXJsYXktZWRpdG9yLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRHJpbGxkb3duQ2VsbERhdGEgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcblxuICAgIC5kb2UtYnViYmxlIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG5cbiAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgbWFyZ2luOiAycHg7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLCAwIDFweCAzcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpO1xuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuXG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgZHJpbGxkb3duczogcmVhZG9ubHkgRHJpbGxkb3duQ2VsbERhdGFbXTtcbn1cblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBkcmlsbGRvd25zIH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxEcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgICAgICAgICB7ZHJpbGxkb3ducy5tYXAoKGQsIGkpID0+IChcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwiZG9lLWJ1YmJsZVwiPlxuICAgICAgICAgICAgICAgICAgICB7ZC5pbWcgIT09IHVuZGVmaW5lZCAmJiA8aW1nIHNyYz17ZC5pbWd9IC8+fVxuICAgICAgICAgICAgICAgICAgICA8ZGl2PntkLnRleHR9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgPC9EcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yO1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx\",\"webpack://./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx\"],\"names\":[\".d11gcyta\"],\"mappings\":\"AAIMA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,mCAAAA,CAAAA,0BAAAA,CAAAA,UAAAA,CAAAA,iBAAAA,CAAAA,kEAAAA,CAAAA,CAAAA,0BAAAA,WAAAA,CAAAA,kBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACHN,24EAA24E\",\"sourcesContent\":[\"import type { DrilldownCellData } from \\\"../../data-grid/data-grid-types\\\";\\nimport * as React from \\\"react\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\n\\nconst DrilldownOverlayEditorStyle = styled.div`\\n    display: flex;\\n    flex-wrap: wrap;\\n\\n    .doe-bubble {\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n\\n        border-radius: 100px;\\n\\n        padding: 0 8px;\\n        height: 24px;\\n\\n        background-color: var(--gdg-bg-cell);\\n        color: var(--gdg-text-dark);\\n        margin: 2px;\\n\\n        border-radius: 6px;\\n\\n        box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\\n\\n        img {\\n            height: 16px;\\n            object-fit: contain;\\n\\n            margin-right: 4px;\\n        }\\n    }\\n\\n    textarea {\\n        position: absolute;\\n        top: 0px;\\n        left: 0px;\\n        width: 0px;\\n        height: 0px;\\n\\n        opacity: 0;\\n    }\\n`;\\n\\ninterface Props {\\n    readonly drilldowns: readonly DrilldownCellData[];\\n}\\n\\nconst DrilldownOverlayEditor: React.FunctionComponent<Props> = p => {\\n    const { drilldowns } = p;\\n    return (\\n        <DrilldownOverlayEditorStyle>\\n            {drilldowns.map((d, i) => (\\n                <div key={i} className=\\\"doe-bubble\\\">\\n                    {d.img !== undefined && <img src={d.img} />}\\n                    <div>{d.text}</div>\\n                </div>\\n            ))}\\n        </DrilldownOverlayEditorStyle>\\n    );\\n};\\nexport default DrilldownOverlayEditor;\\n\",\".d11gcyta{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.d11gcyta .doe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:24px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);margin:2px;border-radius:6px;box-shadow:0 0 1px rgba(62,65,86,0.4),0 1px 3px rgba(62,65,86,0.4);}.d11gcyta .doe-bubble img{height:16px;object-fit:contain;margin-right:4px;}.d11gcyta textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2RyaWxsZG93bi1vdmVybGF5LWVkaXRvci50c3giXSwibmFtZXMiOlsiLmQxMWdjeXRhIl0sIm1hcHBpbmdzIjoiQUFJTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvZHJpbGxkb3duLW92ZXJsYXktZWRpdG9yLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRHJpbGxkb3duQ2VsbERhdGEgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcblxuICAgIC5kb2UtYnViYmxlIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG5cbiAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgbWFyZ2luOiAycHg7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLCAwIDFweCAzcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpO1xuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuXG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgZHJpbGxkb3duczogcmVhZG9ubHkgRHJpbGxkb3duQ2VsbERhdGFbXTtcbn1cblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBkcmlsbGRvd25zIH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxEcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgICAgICAgICB7ZHJpbGxkb3ducy5tYXAoKGQsIGkpID0+IChcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwiZG9lLWJ1YmJsZVwiPlxuICAgICAgICAgICAgICAgICAgICB7ZC5pbWcgIT09IHVuZGVmaW5lZCAmJiA8aW1nIHNyYz17ZC5pbWd9IC8+fVxuICAgICAgICAgICAgICAgICAgICA8ZGl2PntkLnRleHR9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgPC9EcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yO1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".i1v3763o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100%;}.i1v3763o .centering-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}.i1v3763o .centering-container img,.i1v3763o .centering-container canvas{max-height:calc(100vh - var(--overlay-top) - 20px);object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.i1v3763o .centering-container canvas{max-width:380px;}.i1v3763o .edit-icon{position:absolute;top:12px;right:0;width:48px;height:48px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.i1v3763o .edit-icon > *{width:24px;height:24px;}.i1v3763o textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuaTF2Mzc2M28iXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9pbWFnZS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEltYWdlT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgLmNlbnRlcmluZy1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAgICAgaW1nLFxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtIHZhcigtLW92ZXJsYXktdG9wKSAtIDIwcHgpO1xuICAgICAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzIHtcbiAgICAgICAgICAgIG1heC13aWR0aDogMzgwcHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDEycHg7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx\",\"webpack://./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx\"],\"names\":[\".i1v3763o\"],\"mappings\":\"AAEaA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,CAAAA,+BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yEAAAA,kDAAAA,CAAAA,kBAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,qBAAAA,iBAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,yBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDb,uyDAAuyD\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\n\\nexport const ImageOverlayEditorStyle = styled.div`\\n    display: flex;\\n\\n    height: 100%;\\n\\n    .centering-container {\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n\\n        height: 100%;\\n\\n        img,\\n        canvas {\\n            max-height: calc(100vh - var(--overlay-top) - 20px);\\n            object-fit: contain;\\n            user-select: none;\\n        }\\n\\n        canvas {\\n            max-width: 380px;\\n        }\\n    }\\n\\n    .edit-icon {\\n        position: absolute;\\n        top: 12px;\\n        right: 0;\\n        width: 48px;\\n        height: 48px;\\n        color: var(--gdg-accent-color);\\n\\n        cursor: pointer;\\n\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n\\n        > * {\\n            width: 24px;\\n            height: 24px;\\n        }\\n    }\\n\\n    textarea {\\n        position: absolute;\\n        top: 0px;\\n        left: 0px;\\n        width: 0px;\\n        height: 0px;\\n\\n        opacity: 0;\\n    }\\n`;\\n\",\".i1v3763o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100%;}.i1v3763o .centering-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}.i1v3763o .centering-container img,.i1v3763o .centering-container canvas{max-height:calc(100vh - var(--overlay-top) - 20px);object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.i1v3763o .centering-container canvas{max-width:380px;}.i1v3763o .edit-icon{position:absolute;top:12px;right:0;width:48px;height:48px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.i1v3763o .edit-icon > *{width:24px;height:24px;}.i1v3763o textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuaTF2Mzc2M28iXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9pbWFnZS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEltYWdlT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgLmNlbnRlcmluZy1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAgICAgaW1nLFxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtIHZhcigtLW92ZXJsYXktdG9wKSAtIDIwcHgpO1xuICAgICAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzIHtcbiAgICAgICAgICAgIG1heC13aWR0aDogMzgwcHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDEycHg7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".m1bd3197{min-width:var(--m1bd3197-0);width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;position:relative;color:var(--gdg-text-dark);}.m1bd3197 .gecuh31{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;min-width:0;}.m1bd3197 .spacer{-webkit-flex:1;-ms-flex:1;flex:1;}.m1bd3197 .edit-icon{position:relative;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--gdg-accent-color);padding:0;height:24px;width:24px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:all \\\"0.125s ease\\\";transition:all \\\"0.125s ease\\\";border-radius:6px;}.m1bd3197 .edit-icon > *{width:16px;height:16px;}.m1bd3197 .edit-hover:hover{background-color:var(--gdg-accent-light);-webkit-transition:background-color 150ms;transition:background-color 150ms;}.m1bd3197 .checkmark-hover:hover{color:#ffffff;background-color:var(--gdg-accent-color);}.m1bd3197 .md-edit-textarea{position:relative;top:0px;left:0px;width:0px;height:0px;margin-top:25px;opacity:0;padding:0;}.m1bd3197 .ml-6{margin-left:6px;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIubTFiZDMxOTciXSwibWFwcGluZ3MiOiJBQU9hQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9tYXJrZG93bi1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcm93aW5nRW50cnlTdHlsZSB9IGZyb20gXCIuLi8uLi9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGVcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bk92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXY8UHJvcHM+YFxuICAgIG1pbi13aWR0aDogJHtwID0+IHAudGFyZ2V0V2lkdGh9cHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgICR7R3Jvd2luZ0VudHJ5U3R5bGV9IHtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICB9XG5cbiAgICAuc3BhY2VyIHtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuXG4gICAgICAgIHBhZGRpbmc6IDA7XG5cbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIFwiMC4xMjVzIGVhc2VcIjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmVkaXQtaG92ZXIge1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE1MG1zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmNoZWNrbWFyay1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogI2ZmZmZmZjtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLm1kLWVkaXQtdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAyNXB4O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cblxuICAgIC5tbC02IHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICB9XG5gO1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx\",\"webpack://./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx\"],\"names\":[\".m1bd3197\"],\"mappings\":\"AAOaA,UAAAA,2BAAAA,CAAAA,UAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,8BAAAA,CAAAA,4BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,wBAAAA,CAAAA,qCAAAA,CAAAA,qBAAAA,CAAAA,6BAAAA,CAAAA,iBAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,mBAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,CAAAA,kBAAAA,cAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAAA,CAAAA,qBAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,6BAAAA,CAAAA,SAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,oCAAAA,CAAAA,4BAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,yBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,4BAAAA,wCAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,CAAAA,iCAAAA,aAAAA,CAAAA,wCAAAA,CAAAA,CAAAA,4BAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,gBAAAA,eAAAA,CAAAA;ACNb,+/EAA+/E\",\"sourcesContent\":[\"import { GrowingEntryStyle } from \\\"../../growing-entry/growing-entry-style\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\n\\ninterface Props {\\n    targetWidth: number;\\n}\\n\\nexport const MarkdownOverlayEditorStyle = styled.div<Props>`\\n    min-width: ${p => p.targetWidth}px;\\n    width: 100%;\\n    display: flex;\\n    align-items: flex-start;\\n    justify-content: space-between;\\n    position: relative;\\n    color: var(--gdg-text-dark);\\n\\n    ${GrowingEntryStyle} {\\n        flex-shrink: 1;\\n        min-width: 0;\\n    }\\n\\n    .spacer {\\n        flex: 1;\\n    }\\n\\n    .edit-icon {\\n        position: relative;\\n        cursor: pointer;\\n\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n\\n        color: var(--gdg-accent-color);\\n\\n        padding: 0;\\n\\n        height: 24px;\\n        width: 24px;\\n        flex-shrink: 0;\\n\\n        transition: all \\\"0.125s ease\\\";\\n\\n        border-radius: 6px;\\n\\n        > * {\\n            width: 16px;\\n            height: 16px;\\n        }\\n    }\\n\\n    .edit-hover {\\n        :hover {\\n            background-color: var(--gdg-accent-light);\\n            transition: background-color 150ms;\\n        }\\n    }\\n\\n    .checkmark-hover {\\n        :hover {\\n            color: #ffffff;\\n            background-color: var(--gdg-accent-color);\\n        }\\n    }\\n\\n    .md-edit-textarea {\\n        position: relative;\\n        top: 0px;\\n        left: 0px;\\n        width: 0px;\\n        height: 0px;\\n        margin-top: 25px;\\n        opacity: 0;\\n        padding: 0;\\n    }\\n\\n    .ml-6 {\\n        margin-left: 6px;\\n    }\\n`;\\n\",\".m1bd3197{min-width:var(--m1bd3197-0);width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;position:relative;color:var(--gdg-text-dark);}.m1bd3197 .gecuh31{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;min-width:0;}.m1bd3197 .spacer{-webkit-flex:1;-ms-flex:1;flex:1;}.m1bd3197 .edit-icon{position:relative;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--gdg-accent-color);padding:0;height:24px;width:24px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:all \\\"0.125s ease\\\";transition:all \\\"0.125s ease\\\";border-radius:6px;}.m1bd3197 .edit-icon > *{width:16px;height:16px;}.m1bd3197 .edit-hover:hover{background-color:var(--gdg-accent-light);-webkit-transition:background-color 150ms;transition:background-color 150ms;}.m1bd3197 .checkmark-hover:hover{color:#ffffff;background-color:var(--gdg-accent-color);}.m1bd3197 .md-edit-textarea{position:relative;top:0px;left:0px;width:0px;height:0px;margin-top:25px;opacity:0;padding:0;}.m1bd3197 .ml-6{margin-left:6px;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIubTFiZDMxOTciXSwibWFwcGluZ3MiOiJBQU9hQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9tYXJrZG93bi1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcm93aW5nRW50cnlTdHlsZSB9IGZyb20gXCIuLi8uLi9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGVcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bk92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXY8UHJvcHM+YFxuICAgIG1pbi13aWR0aDogJHtwID0+IHAudGFyZ2V0V2lkdGh9cHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgICR7R3Jvd2luZ0VudHJ5U3R5bGV9IHtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICB9XG5cbiAgICAuc3BhY2VyIHtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuXG4gICAgICAgIHBhZGRpbmc6IDA7XG5cbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIFwiMC4xMjVzIGVhc2VcIjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmVkaXQtaG92ZXIge1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE1MG1zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmNoZWNrbWFyay1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogI2ZmZmZmZjtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLm1kLWVkaXQtdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAyNXB4O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cblxuICAgIC5tbC02IHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICB9XG5gO1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".uvnt6gu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:21px;}.uvnt6gu .link-area{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;cursor:pointer;margin-right:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--gdg-link-color);-webkit-text-decoration:underline !important;text-decoration:underline !important;}.uvnt6gu .edit-icon{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:32px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.uvnt6gu .edit-icon > *{width:24px;height:24px;}.uvnt6gu textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL3VyaS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLnV2bnQ2Z3UiXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS91cmktb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVcmlPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgbWluLWhlaWdodDogMjFweDtcblxuICAgIC5saW5rLWFyZWEge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAxO1xuXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1saW5rLWNvbG9yKTtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIHdpZHRoOiAzMnB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx\",\"webpack://./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx\"],\"names\":[\".uvnt6gu\"],\"mappings\":\"AAEaA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,eAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,2BAAAA,CAAAA,4CAAAA,CAAAA,oCAAAA,CAAAA,CAAAA,oBAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,wBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,kBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDb,uqDAAuqD\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\n\\nexport const UriOverlayEditorStyle = styled.div`\\n    display: flex;\\n\\n    flex-grow: 1;\\n\\n    align-items: center;\\n\\n    min-height: 21px;\\n\\n    .link-area {\\n        flex-grow: 1;\\n        flex-shrink: 1;\\n\\n        cursor: pointer;\\n\\n        margin-right: 8px;\\n        overflow: hidden;\\n        text-overflow: ellipsis;\\n        white-space: nowrap;\\n\\n        color: var(--gdg-link-color);\\n        text-decoration: underline !important;\\n    }\\n\\n    .edit-icon {\\n        flex-shrink: 0;\\n        width: 32px;\\n        color: var(--gdg-accent-color);\\n\\n        cursor: pointer;\\n\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n\\n        > * {\\n            width: 24px;\\n            height: 24px;\\n        }\\n    }\\n\\n    textarea {\\n        position: absolute;\\n        top: 0px;\\n        left: 0px;\\n        width: 0px;\\n        height: 0px;\\n\\n        opacity: 0;\\n    }\\n`;\\n\",\".uvnt6gu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:21px;}.uvnt6gu .link-area{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;cursor:pointer;margin-right:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--gdg-link-color);-webkit-text-decoration:underline !important;text-decoration:underline !important;}.uvnt6gu .edit-icon{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:32px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.uvnt6gu .edit-icon > *{width:24px;height:24px;}.uvnt6gu textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL3VyaS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLnV2bnQ2Z3UiXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS91cmktb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVcmlPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgbWluLWhlaWdodDogMjFweDtcblxuICAgIC5saW5rLWFyZWEge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAxO1xuXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1saW5rLWNvbG9yKTtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIHdpZHRoOiAzMnB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".s11k75lr{position:absolute;top:4px;right:20px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);padding:8px;border:1px solid var(--gdg-border-color);border-radius:6px;font-size:var(--gdg-editor-font-size);-webkit-transform:translateX(var(--s11k75lr-0));-ms-transform:translateX(var(--s11k75lr-0));transform:translateX(var(--s11k75lr-0));-webkit-transition:-webkit-transform 0.15s;-webkit-transition:transform 0.15s;transition:transform 0.15s;}.s11k75lr .search-bar-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.s11k75lr .search-status{padding-top:4px;font-size:11px;}.s11k75lr .search-progress{position:absolute;height:4px;left:0;bottom:0;background-color:var(--gdg-text-light);}.s11k75lr input{width:220px;color:var(--gdg-textDark);background-color:var(--gdg-bg-cell);border:none;border-width:0;outline:none;}.s11k75lr button{width:24px;height:24px;padding:0;border:none;outline:none;background:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;color:var(--gdg-text-medium);}.s11k75lr button:hover{color:var(--gdg-text-dark);}.s11k75lr button .button-icon{width:16px;height:16px;}.s11k75lr button:disabled{opacity:0.4;pointer-events:none;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1zZWFyY2gvZGF0YS1ncmlkLXNlYXJjaC1zdHlsZS50c3giXSwibmFtZXMiOlsiLnMxMWs3NWxyIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgU2VhcmNoV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBzaG93U2VhcmNoOiBib29sZWFuIH0+YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDRweDtcbiAgICByaWdodDogMjBweDtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICBwYWRkaW5nOiA4cHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG5cbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoJHtwID0+IChwLnNob3dTZWFyY2ggPyAwIDogNDAwKX1weCk7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTVzO1xuXG4gICAgLnNlYXJjaC1iYXItaW5uZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtc3RhdHVzIHtcbiAgICAgICAgcGFkZGluZy10b3A6IDRweDtcbiAgICAgICAgZm9udC1zaXplOiAxMXB4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtcHJvZ3Jlc3Mge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuICAgIH1cblxuICAgIGlucHV0IHtcbiAgICAgICAgd2lkdGg6IDIyMHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHREYXJrKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG5cbiAgICBidXR0b24ge1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBwYWRkaW5nOiAwO1xuXG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgLmJ1dHRvbi1pY29uIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgOmRpc2FibGVkIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuYDtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/data-grid-search/packages/core/src/data-grid-search/data-grid-search-style.tsx\",\"webpack://./packages/core/src/data-grid-search/data-grid-search-style.tsx\"],\"names\":[\".s11k75lr\"],\"mappings\":\"AAEaA,UAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,mCAAAA,CAAAA,0BAAAA,CAAAA,WAAAA,CAAAA,wCAAAA,CAAAA,iBAAAA,CAAAA,qCAAAA,CAAAA,+CAAAA,CAAAA,2CAAAA,CAAAA,uCAAAA,CAAAA,0CAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,4BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,CAAAA,yBAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,2BAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,sCAAAA,CAAAA,CAAAA,gBAAAA,WAAAA,CAAAA,yBAAAA,CAAAA,mCAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA,CAAAA,iBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,eAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,uBAAAA,0BAAAA,CAAAA,CAAAA,8BAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,0BAAAA,WAAAA,CAAAA,mBAAAA,CAAAA;ACDb,26EAA26E\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\n\\nexport const SearchWrapper = styled.div<{ showSearch: boolean }>`\\n    position: absolute;\\n    top: 4px;\\n    right: 20px;\\n\\n    background-color: var(--gdg-bg-cell);\\n    color: var(--gdg-text-dark);\\n\\n    padding: 8px;\\n    border: 1px solid var(--gdg-border-color);\\n    border-radius: 6px;\\n\\n    font-size: var(--gdg-editor-font-size);\\n\\n    transform: translateX(${p => (p.showSearch ? 0 : 400)}px);\\n    transition: transform 0.15s;\\n\\n    .search-bar-inner {\\n        display: flex;\\n    }\\n\\n    .search-status {\\n        padding-top: 4px;\\n        font-size: 11px;\\n    }\\n\\n    .search-progress {\\n        position: absolute;\\n        height: 4px;\\n        left: 0;\\n        bottom: 0;\\n\\n        background-color: var(--gdg-text-light);\\n    }\\n\\n    input {\\n        width: 220px;\\n        color: var(--gdg-textDark);\\n        background-color: var(--gdg-bg-cell);\\n        border: none;\\n        border-width: 0;\\n        outline: none;\\n    }\\n\\n    button {\\n        width: 24px;\\n        height: 24px;\\n        padding: 0;\\n\\n        border: none;\\n        outline: none;\\n        background: none;\\n\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        cursor: pointer;\\n        color: var(--gdg-text-medium);\\n\\n        :hover {\\n            color: var(--gdg-text-dark);\\n        }\\n\\n        .button-icon {\\n            width: 16px;\\n            height: 16px;\\n        }\\n\\n        :disabled {\\n            opacity: 0.4;\\n            pointer-events: none;\\n        }\\n    }\\n`;\\n\",\".s11k75lr{position:absolute;top:4px;right:20px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);padding:8px;border:1px solid var(--gdg-border-color);border-radius:6px;font-size:var(--gdg-editor-font-size);-webkit-transform:translateX(var(--s11k75lr-0));-ms-transform:translateX(var(--s11k75lr-0));transform:translateX(var(--s11k75lr-0));-webkit-transition:-webkit-transform 0.15s;-webkit-transition:transform 0.15s;transition:transform 0.15s;}.s11k75lr .search-bar-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.s11k75lr .search-status{padding-top:4px;font-size:11px;}.s11k75lr .search-progress{position:absolute;height:4px;left:0;bottom:0;background-color:var(--gdg-text-light);}.s11k75lr input{width:220px;color:var(--gdg-textDark);background-color:var(--gdg-bg-cell);border:none;border-width:0;outline:none;}.s11k75lr button{width:24px;height:24px;padding:0;border:none;outline:none;background:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;color:var(--gdg-text-medium);}.s11k75lr button:hover{color:var(--gdg-text-dark);}.s11k75lr button .button-icon{width:16px;height:16px;}.s11k75lr button:disabled{opacity:0.4;pointer-events:none;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1zZWFyY2gvZGF0YS1ncmlkLXNlYXJjaC1zdHlsZS50c3giXSwibmFtZXMiOlsiLnMxMWs3NWxyIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgU2VhcmNoV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBzaG93U2VhcmNoOiBib29sZWFuIH0+YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDRweDtcbiAgICByaWdodDogMjBweDtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICBwYWRkaW5nOiA4cHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG5cbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoJHtwID0+IChwLnNob3dTZWFyY2ggPyAwIDogNDAwKX1weCk7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTVzO1xuXG4gICAgLnNlYXJjaC1iYXItaW5uZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtc3RhdHVzIHtcbiAgICAgICAgcGFkZGluZy10b3A6IDRweDtcbiAgICAgICAgZm9udC1zaXplOiAxMXB4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtcHJvZ3Jlc3Mge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuICAgIH1cblxuICAgIGlucHV0IHtcbiAgICAgICAgd2lkdGg6IDIyMHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHREYXJrKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG5cbiAgICBidXR0b24ge1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBwYWRkaW5nOiAwO1xuXG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgLmJ1dHRvbi1pY29uIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgOmRpc2FibGVkIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuYDtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".w1gh5fuv{overflow:hidden;position:relative;border-radius:12px;box-shadow:0 2px 5px rgba(0,0,0,0.2),0 0 1px rgba(0,0,0,0.4);width:100%;height:var(--w1gh5fuv-0);margin:24px 0;}.w1gh5fuv > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\\n.b1bk6rj1{background:white;color:#222222;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;font-family:sans-serif;}.b1bk6rj1 .inner{position:relative;width:900px;}.b1bk6rj1 .inner > pre{font-size:14px;border-radius:9px;}.b1bk6rj1 .marked{font-family:Helvetica,arial,sans-serif;font-size:18px;line-height:1.6;}.b1bk6rj1 .marked > *:first-child{margin-top:0 !important;}.b1bk6rj1 .marked > *:last-child{margin-bottom:0 !important;}.b1bk6rj1 .marked a{color:#4183c4;}.b1bk6rj1 .marked a.absent{color:#cc0000;}.b1bk6rj1 .marked a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0;}.b1bk6rj1 .marked h1,.b1bk6rj1 .marked h2,.b1bk6rj1 .marked h3,.b1bk6rj1 .marked h4,.b1bk6rj1 .marked h5,.b1bk6rj1 .marked h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased;cursor:text;position:relative;}.b1bk6rj1 .marked h1:hover a.anchor,.b1bk6rj1 .marked h2:hover a.anchor,.b1bk6rj1 .marked h3:hover a.anchor,.b1bk6rj1 .marked h4:hover a.anchor,.b1bk6rj1 .marked h5:hover a.anchor,.b1bk6rj1 .marked h6:hover a.anchor{-webkit-text-decoration:none;text-decoration:none;}.b1bk6rj1 .marked h1 tt,.b1bk6rj1 .marked h1 code{font-size:inherit;}.b1bk6rj1 .marked h2 tt,.b1bk6rj1 .marked h2 code{font-size:inherit;}.b1bk6rj1 .marked h3 tt,.b1bk6rj1 .marked h3 code{font-size:inherit;}.b1bk6rj1 .marked h4 tt,.b1bk6rj1 .marked h4 code{font-size:inherit;}.b1bk6rj1 .marked h5 tt,.b1bk6rj1 .marked h5 code{font-size:inherit;}.b1bk6rj1 .marked h6 tt,.b1bk6rj1 .marked h6 code{font-size:inherit;}.b1bk6rj1 .marked h1{font-size:32px;color:black;}.b1bk6rj1 .marked h2{font-size:28px;border-bottom:1px solid #cccccc;color:black;}.b1bk6rj1 .marked h3{font-size:22px;}.b1bk6rj1 .marked h4{font-size:20px;}.b1bk6rj1 .marked h5{font-size:18px;}.b1bk6rj1 .marked h6{color:#777777;font-size:18px;}.b1bk6rj1 .marked p,.b1bk6rj1 .marked blockquote,.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol,.b1bk6rj1 .marked dl,.b1bk6rj1 .marked li,.b1bk6rj1 .marked table,.b1bk6rj1 .marked pre{margin:20px 0;}.b1bk6rj1 .marked hr{border:0 none;color:#cccccc;height:4px;padding:0;}.b1bk6rj1 .marked > h2:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child + h2{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h3:first-child,.b1bk6rj1 .marked > h4:first-child,.b1bk6rj1 .marked > h5:first-child,.b1bk6rj1 .marked > h6:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked a:first-child h1,.b1bk6rj1 .marked a:first-child h2,.b1bk6rj1 .marked a:first-child h3,.b1bk6rj1 .marked a:first-child h4,.b1bk6rj1 .marked a:first-child h5,.b1bk6rj1 .marked a:first-child h6{margin-top:0;padding-top:0;}.b1bk6rj1 .marked h1 p,.b1bk6rj1 .marked h2 p,.b1bk6rj1 .marked h3 p,.b1bk6rj1 .marked h4 p,.b1bk6rj1 .marked h5 p,.b1bk6rj1 .marked h6 p{margin-top:0;}.b1bk6rj1 .marked li p.first{display:inline-block;}.b1bk6rj1 .marked li{margin:0;}.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol{padding-left:30px;}.b1bk6rj1 .marked ul :first-child,.b1bk6rj1 .marked ol :first-child{margin-top:0;}.b1bk6rj1 .marked dl{padding:0;}.b1bk6rj1 .marked dl dt{font-size:18px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px;}.b1bk6rj1 .marked dl dt:first-child{padding:0;}.b1bk6rj1 .marked dl dt > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dt > :last-child{margin-bottom:0;}.b1bk6rj1 .marked dl dd{margin:0 0 15px;padding:0 15px;}.b1bk6rj1 .marked dl dd > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dd > :last-child{margin-bottom:0;}.b1bk6rj1 .marked blockquote{border-left:4px solid #dddddd;padding:0 15px;color:#777777;}.b1bk6rj1 .marked blockquote > :first-child{margin-top:0;}.b1bk6rj1 .marked blockquote > :last-child{margin-bottom:0;}.b1bk6rj1 .marked table{font-size:14px;padding:0;border-collapse:collapse;}.b1bk6rj1 .marked table tr{border-top:1px solid #cccccc;background-color:white;margin:0;padding:0;}.b1bk6rj1 .marked table tr:nth-child(2n){background-color:#f8f8f8;}.b1bk6rj1 .marked table tr th{font-weight:bold;border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr td{border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr th :first-child,.b1bk6rj1 .marked table tr td :first-child{margin-top:0;}.b1bk6rj1 .marked table tr th :last-child,.b1bk6rj1 .marked table tr td :last-child{margin-bottom:0;}.b1bk6rj1 .marked img{max-width:100%;}.b1bk6rj1 .marked span.frame{display:block;overflow:hidden;}.b1bk6rj1 .marked span.frame > span{border:1px solid #dddddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto;}.b1bk6rj1 .marked span.frame span img{display:block;float:left;}.b1bk6rj1 .marked span.frame span span{clear:both;color:#333333;display:block;padding:5px 0 0;}.b1bk6rj1 .marked span.align-center{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center;}.b1bk6rj1 .marked span.align-center span img{margin:0 auto;text-align:center;}.b1bk6rj1 .marked span.align-right{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right;}.b1bk6rj1 .marked span.align-right span img{margin:0;text-align:right;}.b1bk6rj1 .marked span.float-left{display:block;margin-right:13px;overflow:hidden;float:left;}.b1bk6rj1 .marked span.float-left span{margin:13px 0 0;}.b1bk6rj1 .marked span.float-right{display:block;margin-left:13px;overflow:hidden;float:right;}.b1bk6rj1 .marked span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right;}.b1bk6rj1 .marked code,.b1bk6rj1 .marked tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;}.b1bk6rj1 .marked pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent;}.b1bk6rj1 .marked .highlight pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre code,.b1bk6rj1 .marked pre tt{background-color:transparent;border:none;}.b1bk6rj1 .marked sup{font-size:0.83em;vertical-align:super;line-height:0;}.b1bk6rj1 .marked *{-webkit-print-color-adjust:exact;}\\n.p65g85a{font-family:monospace;font-weight:500;color:#ffe394;}\\n.d2b9oy3{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n.mnvl60p{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.mnvl60p button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RvY3MvZG9jLXdyYXBwZXIudHN4Il0sIm5hbWVzIjpbIi53MWdoNWZ1diIsIi5iMWJrNnJqMSIsIi5wNjVnODVhIiwiLmQyYjlveTMiLCIubW52bDYwcCJdLCJtYXBwaW5ncyI6IkFBVWFBO0FBNkNQQztBQStaT0M7QUFNQUM7QUFNQUMiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZG9jcy9kb2Mtd3JhcHBlci50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gXCJtYXJrZWRcIjtcbmltcG9ydCBTeW50YXhIaWdobGlnaHRlciBmcm9tIFwicmVhY3Qtc3ludGF4LWhpZ2hsaWdodGVyXCI7XG5pbXBvcnQgaGlnaGxpZ2h0U3R5bGUgZnJvbSBcInJlYWN0LXN5bnRheC1oaWdobGlnaHRlci9kaXN0L2VzbS9zdHlsZXMvaGxqcy9naXRodWJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGhlaWdodDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8V3JhcHBlclByb3BzPmBcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG5cbiAgICBib3gtc2hhZG93OiAwIDJweCA1cHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcblxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuXG4gICAgbWFyZ2luOiAyNHB4IDA7XG5cbiAgICA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHQ6IFJlYWN0LlZGQzx7IGNoaWxkcmVuOiBzdHJpbmcgfT4gPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8U3ludGF4SGlnaGxpZ2h0ZXJcbiAgICAgICAgICAgIHN0eWxlPXtoaWdobGlnaHRTdHlsZX1cbiAgICAgICAgICAgIHNob3dMaW5lTnVtYmVycz17dHJ1ZX1cbiAgICAgICAgICAgIGxpbmVOdW1iZXJTdHlsZT17eyBvcGFjaXR5OiAwLjUgfX1cbiAgICAgICAgICAgIGxhbmd1YWdlPVwidHlwZXNjcmlwdFwiPlxuICAgICAgICAgICAge3AuY2hpbGRyZW4udHJpbSgpfVxuICAgICAgICA8L1N5bnRheEhpZ2hsaWdodGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTWFya2VkOiBSZWFjdC5WRkM8eyBjaGlsZHJlbjogc3RyaW5nIH0+ID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWFya2VkXCJcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgICAgICAgICAgX19odG1sOiBtYXJrZWQocC5jaGlsZHJlbiksXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICk7XG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgY29sb3I6ICMyMjIyMjI7XG5cbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcblxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuXG4gICAgJiAuaW5uZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiA5MDBweDtcblxuICAgICAgICA+IHByZSB7XG4gICAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWFya2VkIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuNjtcblxuICAgICAgICA+ICo6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgID4gKjpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAgIWltcG9ydGFudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGEge1xuICAgICAgICAgICAgY29sb3I6ICM0MTgzYzQ7XG4gICAgICAgIH1cbiAgICAgICAgYS5hYnNlbnQge1xuICAgICAgICAgICAgY29sb3I6ICNjYzAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgYS5hbmNob3Ige1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6IDMwcHg7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogLTMwcHg7XG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEsXG4gICAgICAgIGgyLFxuICAgICAgICBoMyxcbiAgICAgICAgaDQsXG4gICAgICAgIGg1LFxuICAgICAgICBoNiB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMCAxMHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgICAgICAgICBjdXJzb3I6IHRleHQ7XG4gICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICBoMTpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDI6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGgzOmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoNDpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDU6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGg2OmhvdmVyIGEuYW5jaG9yIHtcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHR0LFxuICAgICAgICBoMSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHR0LFxuICAgICAgICBoMiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgzIHR0LFxuICAgICAgICBoMyBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg0IHR0LFxuICAgICAgICBoNCBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg1IHR0LFxuICAgICAgICBoNSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg2IHR0LFxuICAgICAgICBoNiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcbiAgICAgICAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjhweDtcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaDMge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDQge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDUge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDYge1xuICAgICAgICAgICAgY29sb3I6ICM3Nzc3Nzc7XG4gICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICAgIH1cblxuICAgICAgICBwLFxuICAgICAgICBibG9ja3F1b3RlLFxuICAgICAgICB1bCxcbiAgICAgICAgb2wsXG4gICAgICAgIGRsLFxuICAgICAgICBsaSxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhyIHtcbiAgICAgICAgICAgIGJvcmRlcjogMCBub25lO1xuICAgICAgICAgICAgY29sb3I6ICNjY2NjY2M7XG4gICAgICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cblxuICAgICAgICA+IGgyOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkICsgaDIge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDM6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDQ6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDU6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDY6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMixcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMyxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNCxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNiB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBoMSBwLFxuICAgICAgICBoMiBwLFxuICAgICAgICBoMyBwLFxuICAgICAgICBoNCBwLFxuICAgICAgICBoNSBwLFxuICAgICAgICBoNiBwIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsaSBwLmZpcnN0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgfVxuICAgICAgICBsaSB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIH1cbiAgICAgICAgdWwsXG4gICAgICAgIG9sIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVsIDpmaXJzdC1jaGlsZCxcbiAgICAgICAgb2wgOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkbCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0IHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwIDVweDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkdDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0ID4gOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQgPiA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGRkIHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDE1cHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDE1cHg7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZGQgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkZCA+IDpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICAgIH1cblxuICAgICAgICBibG9ja3F1b3RlIHtcbiAgICAgICAgICAgIGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2RkZGRkZDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICAgICAgICAgIGNvbG9yOiAjNzc3Nzc3O1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrcXVvdGUgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3F1b3RlID4gOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHtcbiAgICAgICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyOm50aC1jaGlsZCgybikge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCB7XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTNweDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0ZCB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDEzcHg7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHIgdGggOmZpcnN0LWNoaWxkLFxuICAgICAgICB0YWJsZSB0ciB0ZCA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCA6bGFzdC1jaGlsZCxcbiAgICAgICAgdGFibGUgdHIgdGQgOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIH1cblxuICAgICAgICBzcGFuLmZyYW1lIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZyYW1lID4gc3BhbiB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkZGRkO1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgcGFkZGluZzogN3B4O1xuICAgICAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mcmFtZSBzcGFuIGltZyB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZnJhbWUgc3BhbiBzcGFuIHtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICAgICAgY29sb3I6ICMzMzMzMzM7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIHBhZGRpbmc6IDVweCAwIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgc3BhbiBpbWcge1xuICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBjbGVhcjogYm90aDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0ID4gc3BhbiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCBzcGFuIGltZyB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LWxlZnQge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mbG9hdC1sZWZ0IHNwYW4ge1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IDAgMDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LXJpZ2h0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtcmlnaHQgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHR0IHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAycHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDVweDtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSBjb2RlIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAuaGlnaGxpZ2h0IHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuICAgICAgICBwcmUgY29kZSxcbiAgICAgICAgcHJlIHR0IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMC44M2VtO1xuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IHN1cGVyO1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgKiB7XG4gICAgICAgICAgICAtd2Via2l0LXByaW50LWNvbG9yLWFkanVzdDogZXhhY3Q7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBEb2NXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbm5lclwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/docs/packages/core/src/docs/doc-wrapper.tsx\",\"webpack://./packages/core/src/docs/doc-wrapper.tsx\"],\"names\":[\".w1gh5fuv\",\".b1bk6rj1\",\".p65g85a\",\".d2b9oy3\",\".mnvl60p\"],\"mappings\":\"AAUaA,UAAAA,eAAAA,CAAAA,iBAAAA,CAAAA,kBAAAA,CAAAA,4DAAAA,CAAAA,UAAAA,CAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,yBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;AA6CPC,UAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,gBAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,uBAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,kBAAAA,sCAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,CAAAA,kCAAAA,uBAAAA,CAAAA,CAAAA,iCAAAA,0BAAAA,CAAAA,CAAAA,oBAAAA,aAAAA,CAAAA,CAAAA,2BAAAA,aAAAA,CAAAA,CAAAA,2BAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,KAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,8HAAAA,kBAAAA,CAAAA,SAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,wNAAAA,4BAAAA,CAAAA,oBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,WAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,+BAAAA,CAAAA,WAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,aAAAA,CAAAA,cAAAA,CAAAA,CAAAA,mLAAAA,aAAAA,CAAAA,CAAAA,qBAAAA,aAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA,CAAAA,mCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,mCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,wCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,4IAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,kNAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,0IAAAA,YAAAA,CAAAA,CAAAA,6BAAAA,oBAAAA,CAAAA,CAAAA,qBAAAA,QAAAA,CAAAA,CAAAA,0CAAAA,iBAAAA,CAAAA,CAAAA,oEAAAA,YAAAA,CAAAA,CAAAA,qBAAAA,SAAAA,CAAAA,CAAAA,wBAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,SAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oCAAAA,SAAAA,CAAAA,CAAAA,uCAAAA,YAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,wBAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,uCAAAA,YAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,6BAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,aAAAA,CAAAA,CAAAA,4CAAAA,YAAAA,CAAAA,CAAAA,2CAAAA,eAAAA,CAAAA,CAAAA,wBAAAA,cAAAA,CAAAA,SAAAA,CAAAA,wBAAAA,CAAAA,CAAAA,2BAAAA,4BAAAA,CAAAA,sBAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,CAAAA,yCAAAA,wBAAAA,CAAAA,CAAAA,8BAAAA,gBAAAA,CAAAA,wBAAAA,CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,8BAAAA,wBAAAA,CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,sFAAAA,YAAAA,CAAAA,CAAAA,oFAAAA,eAAAA,CAAAA,CAAAA,sBAAAA,cAAAA,CAAAA,CAAAA,6BAAAA,aAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oCAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,CAAAA,sCAAAA,aAAAA,CAAAA,UAAAA,CAAAA,CAAAA,uCAAAA,UAAAA,CAAAA,aAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oCAAAA,aAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,2CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,kBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,6CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,mCAAAA,aAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,0CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,4CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,kCAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,uCAAAA,eAAAA,CAAAA,CAAAA,mCAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,CAAAA,0CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,kBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,4CAAAA,YAAAA,CAAAA,aAAAA,CAAAA,kBAAAA,CAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,2BAAAA,QAAAA,CAAAA,SAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iCAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,sBAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oDAAAA,4BAAAA,CAAAA,WAAAA,CAAAA,CAAAA,sBAAAA,gBAAAA,CAAAA,oBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,oBAAAA,gCAAAA,CAAAA;AA+ZOC,SAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA;AAMAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AAMAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,gBAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA;AC7db,uneAAune\",\"sourcesContent\":[\"import React from \\\"react\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport { marked } from \\\"marked\\\";\\nimport SyntaxHighlighter from \\\"react-syntax-highlighter\\\";\\nimport highlightStyle from \\\"react-syntax-highlighter/dist/esm/styles/hljs/github\\\";\\n\\nexport interface WrapperProps {\\n    height: number;\\n}\\n\\nexport const Wrapper = styled.div<WrapperProps>`\\n    overflow: hidden;\\n    position: relative;\\n\\n    border-radius: 12px;\\n\\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2), 0 0 1px rgba(0, 0, 0, 0.4);\\n\\n    width: 100%;\\n    height: ${p => p.height}px;\\n\\n    margin: 24px 0;\\n\\n    > :first-child {\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        width: 100%;\\n        height: 100%;\\n    }\\n`;\\n\\nexport const Highlight: React.VFC<{ children: string }> = p => {\\n    return (\\n        <SyntaxHighlighter\\n            style={highlightStyle}\\n            showLineNumbers={true}\\n            lineNumberStyle={{ opacity: 0.5 }}\\n            language=\\\"typescript\\\">\\n            {p.children.trim()}\\n        </SyntaxHighlighter>\\n    );\\n};\\n\\nexport const Marked: React.VFC<{ children: string }> = p => {\\n    return (\\n        <div\\n            className=\\\"marked\\\"\\n            dangerouslySetInnerHTML={{\\n                __html: marked(p.children),\\n            }}\\n        />\\n    );\\n};\\n\\nconst BeautifulStyle = styled.div`\\n    background: white;\\n    color: #222222;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    align-items: center;\\n    flex-direction: column;\\n    min-height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    & .inner {\\n        position: relative;\\n        width: 900px;\\n\\n        > pre {\\n            font-size: 14px;\\n            border-radius: 9px;\\n        }\\n    }\\n\\n    .marked {\\n        font-family: Helvetica, arial, sans-serif;\\n        font-size: 18px;\\n        line-height: 1.6;\\n\\n        > *:first-child {\\n            margin-top: 0 !important;\\n        }\\n        > *:last-child {\\n            margin-bottom: 0 !important;\\n        }\\n\\n        a {\\n            color: #4183c4;\\n        }\\n        a.absent {\\n            color: #cc0000;\\n        }\\n        a.anchor {\\n            display: block;\\n            padding-left: 30px;\\n            margin-left: -30px;\\n            cursor: pointer;\\n            position: absolute;\\n            top: 0;\\n            left: 0;\\n            bottom: 0;\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n            margin: 20px 0 10px;\\n            padding: 0;\\n            font-weight: bold;\\n            -webkit-font-smoothing: antialiased;\\n            cursor: text;\\n            position: relative;\\n        }\\n\\n        h1:hover a.anchor,\\n        h2:hover a.anchor,\\n        h3:hover a.anchor,\\n        h4:hover a.anchor,\\n        h5:hover a.anchor,\\n        h6:hover a.anchor {\\n            text-decoration: none;\\n        }\\n\\n        h1 tt,\\n        h1 code {\\n            font-size: inherit;\\n        }\\n\\n        h2 tt,\\n        h2 code {\\n            font-size: inherit;\\n        }\\n\\n        h3 tt,\\n        h3 code {\\n            font-size: inherit;\\n        }\\n\\n        h4 tt,\\n        h4 code {\\n            font-size: inherit;\\n        }\\n\\n        h5 tt,\\n        h5 code {\\n            font-size: inherit;\\n        }\\n\\n        h6 tt,\\n        h6 code {\\n            font-size: inherit;\\n        }\\n\\n        h1 {\\n            font-size: 32px;\\n            color: black;\\n        }\\n\\n        h2 {\\n            font-size: 28px;\\n            border-bottom: 1px solid #cccccc;\\n            color: black;\\n        }\\n\\n        h3 {\\n            font-size: 22px;\\n        }\\n\\n        h4 {\\n            font-size: 20px;\\n        }\\n\\n        h5 {\\n            font-size: 18px;\\n        }\\n\\n        h6 {\\n            color: #777777;\\n            font-size: 18px;\\n        }\\n\\n        p,\\n        blockquote,\\n        ul,\\n        ol,\\n        dl,\\n        li,\\n        table,\\n        pre {\\n            margin: 20px 0;\\n        }\\n\\n        hr {\\n            border: 0 none;\\n            color: #cccccc;\\n            height: 4px;\\n            padding: 0;\\n        }\\n\\n        > h2:first-child {\\n            margin-top: 0;\\n            padding-top: 0;\\n        }\\n        > h1:first-child {\\n            margin-top: 0;\\n            padding-top: 0;\\n        }\\n        > h1:first-child + h2 {\\n            margin-top: 0;\\n            padding-top: 0;\\n        }\\n        > h3:first-child,\\n        > h4:first-child,\\n        > h5:first-child,\\n        > h6:first-child {\\n            margin-top: 0;\\n            padding-top: 0;\\n        }\\n\\n        a:first-child h1,\\n        a:first-child h2,\\n        a:first-child h3,\\n        a:first-child h4,\\n        a:first-child h5,\\n        a:first-child h6 {\\n            margin-top: 0;\\n            padding-top: 0;\\n        }\\n\\n        h1 p,\\n        h2 p,\\n        h3 p,\\n        h4 p,\\n        h5 p,\\n        h6 p {\\n            margin-top: 0;\\n        }\\n\\n        li p.first {\\n            display: inline-block;\\n        }\\n        li {\\n            margin: 0;\\n        }\\n        ul,\\n        ol {\\n            padding-left: 30px;\\n        }\\n\\n        ul :first-child,\\n        ol :first-child {\\n            margin-top: 0;\\n        }\\n\\n        dl {\\n            padding: 0;\\n        }\\n        dl dt {\\n            font-size: 18px;\\n            font-weight: bold;\\n            font-style: italic;\\n            padding: 0;\\n            margin: 15px 0 5px;\\n        }\\n        dl dt:first-child {\\n            padding: 0;\\n        }\\n        dl dt > :first-child {\\n            margin-top: 0;\\n        }\\n        dl dt > :last-child {\\n            margin-bottom: 0;\\n        }\\n        dl dd {\\n            margin: 0 0 15px;\\n            padding: 0 15px;\\n        }\\n        dl dd > :first-child {\\n            margin-top: 0;\\n        }\\n        dl dd > :last-child {\\n            margin-bottom: 0;\\n        }\\n\\n        blockquote {\\n            border-left: 4px solid #dddddd;\\n            padding: 0 15px;\\n            color: #777777;\\n        }\\n        blockquote > :first-child {\\n            margin-top: 0;\\n        }\\n        blockquote > :last-child {\\n            margin-bottom: 0;\\n        }\\n\\n        table {\\n            font-size: 14px;\\n            padding: 0;\\n            border-collapse: collapse;\\n        }\\n        table tr {\\n            border-top: 1px solid #cccccc;\\n            background-color: white;\\n            margin: 0;\\n            padding: 0;\\n        }\\n        table tr:nth-child(2n) {\\n            background-color: #f8f8f8;\\n        }\\n        table tr th {\\n            font-weight: bold;\\n            border: 1px solid #cccccc;\\n            margin: 0;\\n            padding: 6px 13px;\\n        }\\n        table tr td {\\n            border: 1px solid #cccccc;\\n            margin: 0;\\n            padding: 6px 13px;\\n        }\\n        table tr th :first-child,\\n        table tr td :first-child {\\n            margin-top: 0;\\n        }\\n        table tr th :last-child,\\n        table tr td :last-child {\\n            margin-bottom: 0;\\n        }\\n\\n        img {\\n            max-width: 100%;\\n        }\\n\\n        span.frame {\\n            display: block;\\n            overflow: hidden;\\n        }\\n        span.frame > span {\\n            border: 1px solid #dddddd;\\n            display: block;\\n            float: left;\\n            overflow: hidden;\\n            margin: 13px 0 0;\\n            padding: 7px;\\n            width: auto;\\n        }\\n        span.frame span img {\\n            display: block;\\n            float: left;\\n        }\\n        span.frame span span {\\n            clear: both;\\n            color: #333333;\\n            display: block;\\n            padding: 5px 0 0;\\n        }\\n        span.align-center {\\n            display: block;\\n            overflow: hidden;\\n            clear: both;\\n        }\\n        span.align-center > span {\\n            display: block;\\n            overflow: hidden;\\n            margin: 13px auto 0;\\n            text-align: center;\\n        }\\n        span.align-center span img {\\n            margin: 0 auto;\\n            text-align: center;\\n        }\\n        span.align-right {\\n            display: block;\\n            overflow: hidden;\\n            clear: both;\\n        }\\n        span.align-right > span {\\n            display: block;\\n            overflow: hidden;\\n            margin: 13px 0 0;\\n            text-align: right;\\n        }\\n        span.align-right span img {\\n            margin: 0;\\n            text-align: right;\\n        }\\n        span.float-left {\\n            display: block;\\n            margin-right: 13px;\\n            overflow: hidden;\\n            float: left;\\n        }\\n        span.float-left span {\\n            margin: 13px 0 0;\\n        }\\n        span.float-right {\\n            display: block;\\n            margin-left: 13px;\\n            overflow: hidden;\\n            float: right;\\n        }\\n        span.float-right > span {\\n            display: block;\\n            overflow: hidden;\\n            margin: 13px auto 0;\\n            text-align: right;\\n        }\\n\\n        code,\\n        tt {\\n            margin: 0 2px;\\n            padding: 0 5px;\\n            white-space: nowrap;\\n            border: 1px solid #eaeaea;\\n            background-color: #f8f8f8;\\n            border-radius: 3px;\\n        }\\n\\n        pre code {\\n            margin: 0;\\n            padding: 0;\\n            white-space: pre;\\n            border: none;\\n            background: transparent;\\n        }\\n\\n        .highlight pre {\\n            background-color: #f8f8f8;\\n            border: 1px solid #cccccc;\\n            font-size: 17px;\\n            line-height: 23px;\\n            overflow: auto;\\n            padding: 6px 10px;\\n            border-radius: 3px;\\n        }\\n\\n        pre {\\n            background-color: #f8f8f8;\\n            border: 1px solid #cccccc;\\n            font-size: 17px;\\n            line-height: 23px;\\n            overflow: auto;\\n            padding: 6px 10px;\\n            border-radius: 3px;\\n        }\\n        pre code,\\n        pre tt {\\n            background-color: transparent;\\n            border: none;\\n        }\\n\\n        sup {\\n            font-size: 0.83em;\\n            vertical-align: super;\\n            line-height: 0;\\n        }\\n        * {\\n            -webkit-print-color-adjust: exact;\\n        }\\n    }\\n`;\\n\\nexport const PropName = styled.span`\\n    font-family: monospace;\\n    font-weight: 500;\\n    color: #ffe394;\\n`;\\n\\nexport const Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nexport const MoreInfo = styled.p`\\n    font-size: 14px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n\\n    button {\\n        background-color: #f4f4f4;\\n        color: #2b2b2b;\\n        padding: 2px 6px;\\n        font-family: monospace;\\n        font-size: 14px;\\n        border-radius: 4px;\\n        box-shadow: 0px 1px 2px #00000040;\\n        margin: 0 0.1em;\\n        border: none;\\n        cursor: pointer;\\n    }\\n`;\\n\\nexport const DocWrapper: React.FC = p => {\\n    const { children } = p;\\n    return (\\n        <BeautifulStyle>\\n            <div className=\\\"inner\\\">{children}</div>\\n        </BeautifulStyle>\\n    );\\n};\\n\",\".w1gh5fuv{overflow:hidden;position:relative;border-radius:12px;box-shadow:0 2px 5px rgba(0,0,0,0.2),0 0 1px rgba(0,0,0,0.4);width:100%;height:var(--w1gh5fuv-0);margin:24px 0;}.w1gh5fuv > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\\n.b1bk6rj1{background:white;color:#222222;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;font-family:sans-serif;}.b1bk6rj1 .inner{position:relative;width:900px;}.b1bk6rj1 .inner > pre{font-size:14px;border-radius:9px;}.b1bk6rj1 .marked{font-family:Helvetica,arial,sans-serif;font-size:18px;line-height:1.6;}.b1bk6rj1 .marked > *:first-child{margin-top:0 !important;}.b1bk6rj1 .marked > *:last-child{margin-bottom:0 !important;}.b1bk6rj1 .marked a{color:#4183c4;}.b1bk6rj1 .marked a.absent{color:#cc0000;}.b1bk6rj1 .marked a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0;}.b1bk6rj1 .marked h1,.b1bk6rj1 .marked h2,.b1bk6rj1 .marked h3,.b1bk6rj1 .marked h4,.b1bk6rj1 .marked h5,.b1bk6rj1 .marked h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased;cursor:text;position:relative;}.b1bk6rj1 .marked h1:hover a.anchor,.b1bk6rj1 .marked h2:hover a.anchor,.b1bk6rj1 .marked h3:hover a.anchor,.b1bk6rj1 .marked h4:hover a.anchor,.b1bk6rj1 .marked h5:hover a.anchor,.b1bk6rj1 .marked h6:hover a.anchor{-webkit-text-decoration:none;text-decoration:none;}.b1bk6rj1 .marked h1 tt,.b1bk6rj1 .marked h1 code{font-size:inherit;}.b1bk6rj1 .marked h2 tt,.b1bk6rj1 .marked h2 code{font-size:inherit;}.b1bk6rj1 .marked h3 tt,.b1bk6rj1 .marked h3 code{font-size:inherit;}.b1bk6rj1 .marked h4 tt,.b1bk6rj1 .marked h4 code{font-size:inherit;}.b1bk6rj1 .marked h5 tt,.b1bk6rj1 .marked h5 code{font-size:inherit;}.b1bk6rj1 .marked h6 tt,.b1bk6rj1 .marked h6 code{font-size:inherit;}.b1bk6rj1 .marked h1{font-size:32px;color:black;}.b1bk6rj1 .marked h2{font-size:28px;border-bottom:1px solid #cccccc;color:black;}.b1bk6rj1 .marked h3{font-size:22px;}.b1bk6rj1 .marked h4{font-size:20px;}.b1bk6rj1 .marked h5{font-size:18px;}.b1bk6rj1 .marked h6{color:#777777;font-size:18px;}.b1bk6rj1 .marked p,.b1bk6rj1 .marked blockquote,.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol,.b1bk6rj1 .marked dl,.b1bk6rj1 .marked li,.b1bk6rj1 .marked table,.b1bk6rj1 .marked pre{margin:20px 0;}.b1bk6rj1 .marked hr{border:0 none;color:#cccccc;height:4px;padding:0;}.b1bk6rj1 .marked > h2:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child + h2{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h3:first-child,.b1bk6rj1 .marked > h4:first-child,.b1bk6rj1 .marked > h5:first-child,.b1bk6rj1 .marked > h6:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked a:first-child h1,.b1bk6rj1 .marked a:first-child h2,.b1bk6rj1 .marked a:first-child h3,.b1bk6rj1 .marked a:first-child h4,.b1bk6rj1 .marked a:first-child h5,.b1bk6rj1 .marked a:first-child h6{margin-top:0;padding-top:0;}.b1bk6rj1 .marked h1 p,.b1bk6rj1 .marked h2 p,.b1bk6rj1 .marked h3 p,.b1bk6rj1 .marked h4 p,.b1bk6rj1 .marked h5 p,.b1bk6rj1 .marked h6 p{margin-top:0;}.b1bk6rj1 .marked li p.first{display:inline-block;}.b1bk6rj1 .marked li{margin:0;}.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol{padding-left:30px;}.b1bk6rj1 .marked ul :first-child,.b1bk6rj1 .marked ol :first-child{margin-top:0;}.b1bk6rj1 .marked dl{padding:0;}.b1bk6rj1 .marked dl dt{font-size:18px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px;}.b1bk6rj1 .marked dl dt:first-child{padding:0;}.b1bk6rj1 .marked dl dt > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dt > :last-child{margin-bottom:0;}.b1bk6rj1 .marked dl dd{margin:0 0 15px;padding:0 15px;}.b1bk6rj1 .marked dl dd > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dd > :last-child{margin-bottom:0;}.b1bk6rj1 .marked blockquote{border-left:4px solid #dddddd;padding:0 15px;color:#777777;}.b1bk6rj1 .marked blockquote > :first-child{margin-top:0;}.b1bk6rj1 .marked blockquote > :last-child{margin-bottom:0;}.b1bk6rj1 .marked table{font-size:14px;padding:0;border-collapse:collapse;}.b1bk6rj1 .marked table tr{border-top:1px solid #cccccc;background-color:white;margin:0;padding:0;}.b1bk6rj1 .marked table tr:nth-child(2n){background-color:#f8f8f8;}.b1bk6rj1 .marked table tr th{font-weight:bold;border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr td{border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr th :first-child,.b1bk6rj1 .marked table tr td :first-child{margin-top:0;}.b1bk6rj1 .marked table tr th :last-child,.b1bk6rj1 .marked table tr td :last-child{margin-bottom:0;}.b1bk6rj1 .marked img{max-width:100%;}.b1bk6rj1 .marked span.frame{display:block;overflow:hidden;}.b1bk6rj1 .marked span.frame > span{border:1px solid #dddddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto;}.b1bk6rj1 .marked span.frame span img{display:block;float:left;}.b1bk6rj1 .marked span.frame span span{clear:both;color:#333333;display:block;padding:5px 0 0;}.b1bk6rj1 .marked span.align-center{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center;}.b1bk6rj1 .marked span.align-center span img{margin:0 auto;text-align:center;}.b1bk6rj1 .marked span.align-right{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right;}.b1bk6rj1 .marked span.align-right span img{margin:0;text-align:right;}.b1bk6rj1 .marked span.float-left{display:block;margin-right:13px;overflow:hidden;float:left;}.b1bk6rj1 .marked span.float-left span{margin:13px 0 0;}.b1bk6rj1 .marked span.float-right{display:block;margin-left:13px;overflow:hidden;float:right;}.b1bk6rj1 .marked span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right;}.b1bk6rj1 .marked code,.b1bk6rj1 .marked tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;}.b1bk6rj1 .marked pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent;}.b1bk6rj1 .marked .highlight pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre code,.b1bk6rj1 .marked pre tt{background-color:transparent;border:none;}.b1bk6rj1 .marked sup{font-size:0.83em;vertical-align:super;line-height:0;}.b1bk6rj1 .marked *{-webkit-print-color-adjust:exact;}\\n.p65g85a{font-family:monospace;font-weight:500;color:#ffe394;}\\n.d2b9oy3{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n.mnvl60p{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.mnvl60p button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RvY3MvZG9jLXdyYXBwZXIudHN4Il0sIm5hbWVzIjpbIi53MWdoNWZ1diIsIi5iMWJrNnJqMSIsIi5wNjVnODVhIiwiLmQyYjlveTMiLCIubW52bDYwcCJdLCJtYXBwaW5ncyI6IkFBVWFBO0FBNkNQQztBQStaT0M7QUFNQUM7QUFNQUMiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZG9jcy9kb2Mtd3JhcHBlci50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gXCJtYXJrZWRcIjtcbmltcG9ydCBTeW50YXhIaWdobGlnaHRlciBmcm9tIFwicmVhY3Qtc3ludGF4LWhpZ2hsaWdodGVyXCI7XG5pbXBvcnQgaGlnaGxpZ2h0U3R5bGUgZnJvbSBcInJlYWN0LXN5bnRheC1oaWdobGlnaHRlci9kaXN0L2VzbS9zdHlsZXMvaGxqcy9naXRodWJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGhlaWdodDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8V3JhcHBlclByb3BzPmBcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG5cbiAgICBib3gtc2hhZG93OiAwIDJweCA1cHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcblxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuXG4gICAgbWFyZ2luOiAyNHB4IDA7XG5cbiAgICA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHQ6IFJlYWN0LlZGQzx7IGNoaWxkcmVuOiBzdHJpbmcgfT4gPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8U3ludGF4SGlnaGxpZ2h0ZXJcbiAgICAgICAgICAgIHN0eWxlPXtoaWdobGlnaHRTdHlsZX1cbiAgICAgICAgICAgIHNob3dMaW5lTnVtYmVycz17dHJ1ZX1cbiAgICAgICAgICAgIGxpbmVOdW1iZXJTdHlsZT17eyBvcGFjaXR5OiAwLjUgfX1cbiAgICAgICAgICAgIGxhbmd1YWdlPVwidHlwZXNjcmlwdFwiPlxuICAgICAgICAgICAge3AuY2hpbGRyZW4udHJpbSgpfVxuICAgICAgICA8L1N5bnRheEhpZ2hsaWdodGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTWFya2VkOiBSZWFjdC5WRkM8eyBjaGlsZHJlbjogc3RyaW5nIH0+ID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWFya2VkXCJcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgICAgICAgICAgX19odG1sOiBtYXJrZWQocC5jaGlsZHJlbiksXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICk7XG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgY29sb3I6ICMyMjIyMjI7XG5cbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcblxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuXG4gICAgJiAuaW5uZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiA5MDBweDtcblxuICAgICAgICA+IHByZSB7XG4gICAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWFya2VkIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuNjtcblxuICAgICAgICA+ICo6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgID4gKjpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAgIWltcG9ydGFudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGEge1xuICAgICAgICAgICAgY29sb3I6ICM0MTgzYzQ7XG4gICAgICAgIH1cbiAgICAgICAgYS5hYnNlbnQge1xuICAgICAgICAgICAgY29sb3I6ICNjYzAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgYS5hbmNob3Ige1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6IDMwcHg7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogLTMwcHg7XG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEsXG4gICAgICAgIGgyLFxuICAgICAgICBoMyxcbiAgICAgICAgaDQsXG4gICAgICAgIGg1LFxuICAgICAgICBoNiB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMCAxMHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgICAgICAgICBjdXJzb3I6IHRleHQ7XG4gICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICBoMTpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDI6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGgzOmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoNDpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDU6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGg2OmhvdmVyIGEuYW5jaG9yIHtcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHR0LFxuICAgICAgICBoMSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHR0LFxuICAgICAgICBoMiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgzIHR0LFxuICAgICAgICBoMyBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg0IHR0LFxuICAgICAgICBoNCBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg1IHR0LFxuICAgICAgICBoNSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg2IHR0LFxuICAgICAgICBoNiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcbiAgICAgICAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjhweDtcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaDMge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDQge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDUge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDYge1xuICAgICAgICAgICAgY29sb3I6ICM3Nzc3Nzc7XG4gICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICAgIH1cblxuICAgICAgICBwLFxuICAgICAgICBibG9ja3F1b3RlLFxuICAgICAgICB1bCxcbiAgICAgICAgb2wsXG4gICAgICAgIGRsLFxuICAgICAgICBsaSxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhyIHtcbiAgICAgICAgICAgIGJvcmRlcjogMCBub25lO1xuICAgICAgICAgICAgY29sb3I6ICNjY2NjY2M7XG4gICAgICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cblxuICAgICAgICA+IGgyOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkICsgaDIge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDM6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDQ6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDU6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDY6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMixcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMyxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNCxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNiB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBoMSBwLFxuICAgICAgICBoMiBwLFxuICAgICAgICBoMyBwLFxuICAgICAgICBoNCBwLFxuICAgICAgICBoNSBwLFxuICAgICAgICBoNiBwIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsaSBwLmZpcnN0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgfVxuICAgICAgICBsaSB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIH1cbiAgICAgICAgdWwsXG4gICAgICAgIG9sIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVsIDpmaXJzdC1jaGlsZCxcbiAgICAgICAgb2wgOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkbCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0IHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwIDVweDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkdDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0ID4gOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQgPiA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGRkIHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDE1cHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDE1cHg7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZGQgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkZCA+IDpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICAgIH1cblxuICAgICAgICBibG9ja3F1b3RlIHtcbiAgICAgICAgICAgIGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2RkZGRkZDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICAgICAgICAgIGNvbG9yOiAjNzc3Nzc3O1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrcXVvdGUgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3F1b3RlID4gOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHtcbiAgICAgICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyOm50aC1jaGlsZCgybikge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCB7XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTNweDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0ZCB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDEzcHg7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHIgdGggOmZpcnN0LWNoaWxkLFxuICAgICAgICB0YWJsZSB0ciB0ZCA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCA6bGFzdC1jaGlsZCxcbiAgICAgICAgdGFibGUgdHIgdGQgOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIH1cblxuICAgICAgICBzcGFuLmZyYW1lIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZyYW1lID4gc3BhbiB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkZGRkO1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgcGFkZGluZzogN3B4O1xuICAgICAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mcmFtZSBzcGFuIGltZyB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZnJhbWUgc3BhbiBzcGFuIHtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICAgICAgY29sb3I6ICMzMzMzMzM7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIHBhZGRpbmc6IDVweCAwIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgc3BhbiBpbWcge1xuICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBjbGVhcjogYm90aDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0ID4gc3BhbiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCBzcGFuIGltZyB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LWxlZnQge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mbG9hdC1sZWZ0IHNwYW4ge1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IDAgMDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LXJpZ2h0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtcmlnaHQgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHR0IHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAycHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDVweDtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSBjb2RlIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAuaGlnaGxpZ2h0IHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuICAgICAgICBwcmUgY29kZSxcbiAgICAgICAgcHJlIHR0IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMC44M2VtO1xuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IHN1cGVyO1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgKiB7XG4gICAgICAgICAgICAtd2Via2l0LXByaW50LWNvbG9yLWFkanVzdDogZXhhY3Q7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBEb2NXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbm5lclwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".ifmjl02{position:absolute;left:0;right:0;top:0;bottom:0;width:100%;height:100%;border-radius:0px;resize:none;white-space:pre-wrap;min-width:100%;overflow:hidden;border:0;background-color:transparent;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;}.ifmjl02::-webkit-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::-moz-placeholder{color:var(--gdg-text-light);}.ifmjl02:-ms-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::placeholder{color:var(--gdg-text-light);}.invalid .ifmjl02{-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration-color:#d60606;text-decoration-color:#d60606;}\\n.s71wzxx{visibility:hidden;white-space:pre-wrap;word-wrap:break-word;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;min-width:100%;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;padding-bottom:2px;}\\n.gecuh31{position:relative;margin-top:6px;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZS50c3giXSwibmFtZXMiOlsiLmlmbWpsMDIiLCIuczcxd3p4eCIsIi5nZWN1aDMxIl0sIm1hcHBpbmdzIjoiQUFFYUE7QUFtQ0FDO0FBb0JBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBJbnB1dEJveCA9IHN0eWxlZC50ZXh0YXJlYWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDBweDtcblxuICAgIHJlc2l6ZTogbm9uZTtcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gICAgbWluLXdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm9yZGVyOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgOjpwbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG4gICAgfVxuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgLmludmFsaWQgJiB7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb24tY29sb3I6ICNkNjA2MDY7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IFNoYWRvd0JveCA9IHN0eWxlZC5kaXZgXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG5cbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuXG4gICAgbWluLXdpZHRoOiAxMDAlO1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcbmA7XG5cbmV4cG9ydCBjb25zdCBHcm93aW5nRW50cnlTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG1hcmdpbi10b3A6IDZweDtcbmA7XG4iXX0=*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/growing-entry/packages/core/src/growing-entry/growing-entry-style.tsx\",\"webpack://./packages/core/src/growing-entry/growing-entry-style.tsx\"],\"names\":[\".ifmjl02\",\".s71wzxx\",\".gecuh31\"],\"mappings\":\"AAEaA,SAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,WAAAA,CAAAA,oBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,QAAAA,CAAAA,4BAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAAA,CAAAA,oCAAAA,2BAAAA,CAAAA,CAAAA,2BAAAA,2BAAAA,CAAAA,CAAAA,+BAAAA,2BAAAA,CAAAA,CAAAA,sBAAAA,2BAAAA,CAAAA,CAAAA,kBAAAA,iCAAAA,CAAAA,yBAAAA,CAAAA,qCAAAA,CAAAA,6BAAAA,CAAAA;AAmCAC,SAAAA,iBAAAA,CAAAA,oBAAAA,CAAAA,oBAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,cAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAAA,kBAAAA,CAAAA;AAoBAC,SAAAA,iBAAAA,CAAAA,cAAAA,CAAAA;ACtDb,u/DAAu/D\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\n\\nexport const InputBox = styled.textarea`\\n    position: absolute;\\n    left: 0;\\n    right: 0;\\n    top: 0;\\n    bottom: 0;\\n    width: 100%;\\n    height: 100%;\\n\\n    border-radius: 0px;\\n\\n    resize: none;\\n    white-space: pre-wrap;\\n    min-width: 100%;\\n    overflow: hidden;\\n    border: 0;\\n    background-color: transparent;\\n\\n    ::placeholder {\\n        color: var(--gdg-text-light);\\n    }\\n\\n    font-size: var(--gdg-editor-font-size);\\n    line-height: 16px;\\n    font-family: var(--gdg-font-family);\\n    color: var(--gdg-text-dark);\\n    padding: 0;\\n    margin: 0;\\n\\n    .invalid & {\\n        text-decoration: underline;\\n        text-decoration-color: #d60606;\\n    }\\n`;\\n\\nexport const ShadowBox = styled.div`\\n    visibility: hidden;\\n    white-space: pre-wrap;\\n    word-wrap: break-word;\\n\\n    width: max-content;\\n    max-width: 100%;\\n\\n    min-width: 100%;\\n\\n    font-size: var(--gdg-editor-font-size);\\n    line-height: 16px;\\n    font-family: var(--gdg-font-family);\\n    color: var(--gdg-text-dark);\\n    padding: 0;\\n    margin: 0;\\n\\n    padding-bottom: 2px;\\n`;\\n\\nexport const GrowingEntryStyle = styled.div`\\n    position: relative;\\n    margin-top: 6px;\\n`;\\n\",\".ifmjl02{position:absolute;left:0;right:0;top:0;bottom:0;width:100%;height:100%;border-radius:0px;resize:none;white-space:pre-wrap;min-width:100%;overflow:hidden;border:0;background-color:transparent;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;}.ifmjl02::-webkit-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::-moz-placeholder{color:var(--gdg-text-light);}.ifmjl02:-ms-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::placeholder{color:var(--gdg-text-light);}.invalid .ifmjl02{-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration-color:#d60606;text-decoration-color:#d60606;}\\n.s71wzxx{visibility:hidden;white-space:pre-wrap;word-wrap:break-word;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;min-width:100%;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;padding-bottom:2px;}\\n.gecuh31{position:relative;margin-top:6px;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZS50c3giXSwibmFtZXMiOlsiLmlmbWpsMDIiLCIuczcxd3p4eCIsIi5nZWN1aDMxIl0sIm1hcHBpbmdzIjoiQUFFYUE7QUFtQ0FDO0FBb0JBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBJbnB1dEJveCA9IHN0eWxlZC50ZXh0YXJlYWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDBweDtcblxuICAgIHJlc2l6ZTogbm9uZTtcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gICAgbWluLXdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm9yZGVyOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgOjpwbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG4gICAgfVxuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgLmludmFsaWQgJiB7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb24tY29sb3I6ICNkNjA2MDY7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IFNoYWRvd0JveCA9IHN0eWxlZC5kaXZgXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG5cbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuXG4gICAgbWluLXdpZHRoOiAxMDAlO1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcbmA7XG5cbmV4cG9ydCBjb25zdCBHcm93aW5nRW50cnlTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG1hcmdpbi10b3A6IDZweDtcbmA7XG4iXX0=*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".m1fme8sm{word-break:break-word;-webkit-touch-callout:default;padding-top:6px;}.m1fme8sm > *{margin:0;}.m1fme8sm *:last-child{margin-bottom:0;}.m1fme8sm p img{width:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL21hcmtkb3duLWRpdi9wcml2YXRlL21hcmtkb3duLWNvbnRhaW5lci50c3giXSwibmFtZXMiOlsiLm0xZm1lOHNtIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgTWFya2Rvd25Db250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBkZWZhdWx0O1xuICAgIHBhZGRpbmctdG9wOiA2cHg7XG5cbiAgICA+ICoge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgfVxuXG4gICAgJiAqOmxhc3QtY2hpbGQge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgIH1cblxuICAgICYgcCBpbWcge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5gO1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/markdown-div/private/packages/core/src/markdown-div/private/markdown-container.tsx\",\"webpack://./packages/core/src/markdown-div/private/markdown-container.tsx\"],\"names\":[\".m1fme8sm\"],\"mappings\":\"AAEaA,UAAAA,qBAAAA,CAAAA,6BAAAA,CAAAA,eAAAA,CAAAA,CAAAA,cAAAA,QAAAA,CAAAA,CAAAA,uBAAAA,eAAAA,CAAAA,CAAAA,gBAAAA,UAAAA,CAAAA;ACDb,mxBAAmxB\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\n\\nexport const MarkdownContainer = styled.div`\\n    word-break: break-word;\\n    -webkit-touch-callout: default;\\n    padding-top: 6px;\\n\\n    > * {\\n        margin: 0;\\n    }\\n\\n    & *:last-child {\\n        margin-bottom: 0;\\n    }\\n\\n    & p img {\\n        width: 100%;\\n    }\\n`;\\n\",\".m1fme8sm{word-break:break-word;-webkit-touch-callout:default;padding-top:6px;}.m1fme8sm > *{margin:0;}.m1fme8sm *:last-child{margin-bottom:0;}.m1fme8sm p img{width:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL21hcmtkb3duLWRpdi9wcml2YXRlL21hcmtkb3duLWNvbnRhaW5lci50c3giXSwibmFtZXMiOlsiLm0xZm1lOHNtIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgTWFya2Rvd25Db250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBkZWZhdWx0O1xuICAgIHBhZGRpbmctdG9wOiA2cHg7XG5cbiAgICA+ICoge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgfVxuXG4gICAgJiAqOmxhc3QtY2hpbGQge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgIH1cblxuICAgICYgcCBpbWcge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5gO1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".s3se5hb .dvn-scroller{overflow:var(--s3se5hb-0);-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0);}.s3se5hb .hidden{visibility:hidden;}.s3se5hb .dvn-scroll-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;pointer-events:none;}.s3se5hb .dvn-scroll-inner > *{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}.s3se5hb .dvn-scroll-inner .dvn-spacer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.s3se5hb .dvn-scroll-inner .dvn-stack{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.s3se5hb .dvn-underlay > *{position:absolute;left:0;top:0;}.s3se5hb canvas{outline:none;}.s3se5hb canvas *{height:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Il0sIm5hbWVzIjpbIi5zM3NlNWhiIl0sIm1hcHBpbmdzIjoiQUE2Qk1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCIuLi9jb21tb24vcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQgeyBicm93c2VySXNTYWZhcmkgfSBmcm9tIFwiLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uL2NvbW1vbi91dGlsc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZT86IHN0cmluZztcbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGRyYWdnYWJsZTogYm9vbGVhbjtcbiAgICByZWFkb25seSBwYWRkaW5nUmlnaHQ/OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgcGFkZGluZ0JvdHRvbT86IG51bWJlcjtcbiAgICByZWFkb25seSBjbGllbnRIZWlnaHQ6IG51bWJlcjtcbiAgICByZWFkb25seSBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kPzogYm9vbGVhbjtcbiAgICByZWFkb25seSBpbml0aWFsU2Nyb2xsUG9zaXRpb24/OiByZWFkb25seSBbc2Nyb2xsWDogbnVtYmVyLCBzY3JvbGxZOiBudW1iZXJdO1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplPzogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wcz86IHtcbiAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgfTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgbWluaW1hcD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICByZWFkb25seSBzY3JvbGxSZWY/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD47XG4gICAgcmVhZG9ubHkgdXBkYXRlOiAocmVnaW9uOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNjcm9sbFJlZ2lvblN0eWxlID0gc3R5bGVkLmRpdjx7IGlzU2FmYXJpOiBib29sZWFuIH0+YFxuICAgIC5kdm4tc2Nyb2xsZXIge1xuICAgICAgICBvdmVyZmxvdzogJHtwID0+IChwLmlzU2FmYXJpID8gXCJzY3JvbGxcIiA6IFwiYXV0b1wiKX07XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgLmhpZGRlbiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuZHZuLXNjcm9sbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3BhY2VyIHtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3RhY2sge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZHZuLXVuZGVybGF5ID4gKiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgIH1cblxuICAgIGNhbnZhcyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG5cbiAgICAgICAgKiB7XG4gICAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG50eXBlIFNjcm9sbExvY2sgPSBbdW5kZWZpbmVkLCBudW1iZXJdIHwgW251bWJlciwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZWF0RXZlbnQoZTogUmVhY3QuTW91c2VFdmVudCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVRvdWNoVXBEZWxheWVkKGRlbGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBbaGFzVG91Y2hlcywgc2V0SGFzVG91Y2hlc10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBjYlRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNiVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRIYXNUb3VjaGVzKHRydWUpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHNldEhhc1RvdWNoZXMoZmFsc2UpLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtkZWxheV1cbiAgICAgICAgKSxcbiAgICAgICAgd2luZG93LFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuZXhwb3J0IGNvbnN0IEluZmluaXRlU2Nyb2xsZXI6IFJlYWN0LkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwLFxuICAgICAgICBwYWRkaW5nUmlnaHQgPSAwLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgbWluaW1hcCxcbiAgICB9ID0gcDtcbiAgICBjb25zdCBwYWRkZXJzOiBSZWFjdC5SZWFjdE5vZGVbXSA9IFtdO1xuXG4gICAgY29uc3QgcmlnaHRFbGVtZW50U3RpY2t5ID0gcmlnaHRFbGVtZW50UHJvcHM/LnN0aWNreSA/PyBmYWxzZTtcbiAgICBjb25zdCByaWdodEVsZW1lbnRGaWxsID0gcmlnaHRFbGVtZW50UHJvcHM/LmZpbGwgPz8gZmFsc2U7XG5cbiAgICBjb25zdCBvZmZzZXRZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IHNjcm9sbGVyID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IHNjcm9sbFRvRW5kICE9PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGg7XG4gICAgfSwgW3Njcm9sbFRvRW5kXSk7XG5cbiAgICBjb25zdCBsYXN0U2Nyb2xsUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIGxvY2tEaXJlY3Rpb246IHVuZGVmaW5lZCBhcyBTY3JvbGxMb2NrLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmlnaHRXcmFwUmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBoYXNUb3VjaGVzID0gdXNlVG91Y2hVcERlbGF5ZWQoMjAwKTtcbiAgICBjb25zdCBbaXNJZGxlLCBzZXRJc0lkbGVdID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgaWRsZVRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0lkbGUgfHwgaGFzVG91Y2hlcyB8fCBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgICAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgW2x4LCBseV0gPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuICAgICAgICBpZiAobHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGx4O1xuICAgICAgICB9IGVsc2UgaWYgKGx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcCA9IGx5O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSwgW2hhc1RvdWNoZXMsIGlzSWRsZV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsVG9wID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsTGVmdCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgY29uc3QgZHggPSBzY3JvbGxMZWZ0IC0gbGFzdFNjcm9sbExlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gc2Nyb2xsVG9wIC0gbGFzdFNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNUb3VjaGVzICYmXG4gICAgICAgICAgICBkeCAhPT0gMCAmJlxuICAgICAgICAgICAgZHkgIT09IDAgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhkeCkgPiAzIHx8IE1hdGguYWJzKGR5KSA+IDMpICYmXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcgJiZcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPVxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGR4KSA8IE1hdGguYWJzKGR5KSA/IFtsYXN0U2Nyb2xsTGVmdCwgdW5kZWZpbmVkXSA6IFt1bmRlZmluZWQsIGxhc3RTY3JvbGxUb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jayA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb247XG5cbiAgICAgICAgc2Nyb2xsTGVmdCA9IGxvY2s/LlswXSA/PyBzY3JvbGxMZWZ0O1xuICAgICAgICBzY3JvbGxUb3AgPSBsb2NrPy5bMV0gPz8gc2Nyb2xsVG9wO1xuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGNvbnN0IG5ld1kgPSBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbGFzdFNjcm9sbFkuY3VycmVudCAtIG5ld1k7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxhc3RTY3JvbGxZLmN1cnJlbnQgPSBuZXdZO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNjcm9sbGFibGVIZWlnaHQgPiAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZGVsdGEpID4gMjAwMCB8fCBuZXdZID09PSAwIHx8IG5ld1kgPT09IHNjcm9sbGFibGVIZWlnaHQpICYmXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPiBlbC5zY3JvbGxIZWlnaHQgKyA1XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcHJvZyA9IG5ld1kgLyBzY3JvbGxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcmVjb21wdXRlZCA9IChzY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQpICogcHJvZztcbiAgICAgICAgICAgIG9mZnNldFkuY3VycmVudCA9IHJlY29tcHV0ZWQgLSBuZXdZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZGxlVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRJc0lkbGUoZmFsc2UpO1xuICAgICAgICAgICAgaWRsZVRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRJc0lkbGUodHJ1ZSksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgeDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IG5ld1kgKyBvZmZzZXRZLmN1cnJlbnQsXG4gICAgICAgICAgICB3aWR0aDogZWwuY2xpZW50V2lkdGggLSBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsLmNsaWVudEhlaWdodCAtIHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHJpZ2h0V3JhcFJlZi5jdXJyZW50Py5jbGllbnRXaWR0aCA/PyAwLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBzY3JvbGxIZWlnaHQsIHVwZGF0ZSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBoYXNUb3VjaGVzXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFJlZiA9IFJlYWN0LnVzZVJlZihvblNjcm9sbCk7XG4gICAgb25TY3JvbGxSZWYuY3VycmVudCA9IG9uU2Nyb2xsO1xuXG4gICAgY29uc3QgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmPHsgd2lkdGg/OiBudW1iZXI7IGhlaWdodD86IG51bWJlciB9PigpO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25TY3JvbGwoKTtcbiAgICB9LCBbb25TY3JvbGwsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodF0pO1xuXG4gICAgY29uc3Qgc2V0UmVmcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoaW5zdGFuY2U6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsZXIuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW3Njcm9sbFJlZl1cbiAgICApO1xuXG4gICAgbGV0IGtleSA9IDA7XG4gICAgbGV0IGggPSAwO1xuICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiBzY3JvbGxXaWR0aCwgaGVpZ2h0OiAwIH19IC8+KTtcbiAgICB3aGlsZSAoaCA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBjb25zdCB0b0FkZCA9IE1hdGgubWluKDVfMDAwXzAwMCwgc2Nyb2xsSGVpZ2h0IC0gaCk7XG4gICAgICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiAwLCBoZWlnaHQ6IHRvQWRkIH19IC8+KTtcbiAgICAgICAgaCArPSB0b0FkZDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3I8SFRNTERpdkVsZW1lbnQ+KGluaXRpYWxTaXplKTtcblxuICAgIGlmIChsYXN0UHJvcHMuY3VycmVudD8uaGVpZ2h0ICE9PSBoZWlnaHQgfHwgbGFzdFByb3BzLmN1cnJlbnQ/LndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBvblNjcm9sbFJlZi5jdXJyZW50KCksIDApO1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cblxuICAgIGlmICgod2lkdGggPz8gMCkgPT09IDAgfHwgKGhlaWdodCA/PyAwKSA9PT0gMCkgcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiByZWY9e3JlZn0+XG4gICAgICAgICAgICA8U2Nyb2xsUmVnaW9uU3R5bGUgaXNTYWZhcmk9e2Jyb3dzZXJJc1NhZmFyaS52YWx1ZX0+XG4gICAgICAgICAgICAgICAge21pbmltYXB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tdW5kZXJsYXlcIj57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByZWY9e3NldFJlZnN9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtsYXN0UHJvcHMuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlPXtkcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsZXIgXCIgKyAoY2xhc3NOYW1lID8/IFwiXCIpfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsLWlubmVyXCIgKyAocmlnaHRFbGVtZW50ID09PSB1bmRlZmluZWQgPyBcIiBoaWRkZW5cIiA6IFwiXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXN0YWNrXCI+e3BhZGRlcnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmlnaHRFbGVtZW50RmlsbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImR2bi1zcGFjZXJcIiAvPn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyaWdodFdyYXBSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBjbGllbnRIZWlnaHQgLSBNYXRoLmNlaWwoZHByICUgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogLTQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3c6IHJpZ2h0RWxlbWVudEZpbGwgPyAxIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodEVsZW1lbnRTdGlja3kgPyBwYWRkaW5nUmlnaHQgPz8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvU2Nyb2xsUmVnaW9uU3R5bGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuIl19*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/scrolling-data-grid/packages/core/src/scrolling-data-grid/infinite-scroller.tsx\",\"webpack://./packages/core/src/scrolling-data-grid/infinite-scroller.tsx\"],\"names\":[\".s3se5hb\"],\"mappings\":\"AA6BMA,uBAAAA,yBAAAA,CAAAA,oCAAAA,CAAAA,gCAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,CAAAA,2BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,+BAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,uCAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,sCAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,2BAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,gBAAAA,YAAAA,CAAAA,CAAAA,kBAAAA,QAAAA,CAAAA;AC5BN,2ycAA2yc\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\nimport type { Rectangle } from \\\"..\\\";\\nimport * as React from \\\"react\\\";\\nimport { useResizeDetector } from \\\"../common/resize-detector\\\";\\nimport { browserIsSafari } from \\\"../common/browser-detect\\\";\\nimport { useEventListener } from \\\"../common/utils\\\";\\n\\ninterface Props {\\n    readonly className?: string;\\n    readonly preventDiagonalScrolling?: boolean;\\n    readonly draggable: boolean;\\n    readonly paddingRight?: number;\\n    readonly paddingBottom?: number;\\n    readonly clientHeight: number;\\n    readonly scrollWidth: number;\\n    readonly scrollHeight: number;\\n    readonly scrollToEnd?: boolean;\\n    readonly initialScrollPosition?: readonly [scrollX: number, scrollY: number];\\n    readonly initialSize?: readonly [width: number, height: number];\\n    readonly rightElementProps?: {\\n        readonly sticky?: boolean;\\n        readonly fill?: boolean;\\n    };\\n    readonly rightElement?: React.ReactNode;\\n    readonly minimap?: React.ReactNode;\\n    readonly scrollRef?: React.MutableRefObject<HTMLDivElement | null>;\\n    readonly update: (region: Rectangle & { paddingRight: number }) => void;\\n}\\n\\nconst ScrollRegionStyle = styled.div<{ isSafari: boolean }>`\\n    .dvn-scroller {\\n        overflow: ${p => (p.isSafari ? \\\"scroll\\\" : \\\"auto\\\")};\\n        transform: translate3d(0, 0, 0);\\n    }\\n\\n    .hidden {\\n        visibility: hidden;\\n    }\\n\\n    .dvn-scroll-inner {\\n        display: flex;\\n        pointer-events: none;\\n\\n        > * {\\n            flex-shrink: 0;\\n        }\\n\\n        .dvn-spacer {\\n            flex-grow: 1;\\n        }\\n\\n        .dvn-stack {\\n            display: flex;\\n            flex-direction: column;\\n        }\\n    }\\n\\n    .dvn-underlay > * {\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n    }\\n\\n    canvas {\\n        outline: none;\\n\\n        * {\\n            height: 0;\\n        }\\n    }\\n`;\\n\\ntype ScrollLock = [undefined, number] | [number, undefined] | undefined;\\n\\nfunction eatEvent(e: React.MouseEvent) {\\n    e.stopPropagation();\\n}\\n\\nfunction useTouchUpDelayed(delay: number): boolean {\\n    const [hasTouches, setHasTouches] = React.useState(false);\\n\\n    const cbTimer = React.useRef(0);\\n    useEventListener(\\n        \\\"touchstart\\\",\\n        React.useCallback(() => {\\n            window.clearTimeout(cbTimer.current);\\n            setHasTouches(true);\\n        }, []),\\n        window,\\n        true,\\n        false\\n    );\\n\\n    useEventListener(\\n        \\\"touchend\\\",\\n        React.useCallback(\\n            e => {\\n                if (e.touches.length === 0) {\\n                    cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\\n                }\\n            },\\n            [delay]\\n        ),\\n        window,\\n        true,\\n        false\\n    );\\n\\n    return hasTouches;\\n}\\n\\nexport const InfiniteScroller: React.FC<Props> = p => {\\n    const {\\n        children,\\n        clientHeight,\\n        scrollHeight,\\n        scrollWidth,\\n        update,\\n        draggable,\\n        className,\\n        preventDiagonalScrolling = false,\\n        paddingBottom = 0,\\n        paddingRight = 0,\\n        rightElement,\\n        rightElementProps,\\n        scrollRef,\\n        scrollToEnd,\\n        initialSize,\\n        minimap,\\n    } = p;\\n    const padders: React.ReactNode[] = [];\\n\\n    const rightElementSticky = rightElementProps?.sticky ?? false;\\n    const rightElementFill = rightElementProps?.fill ?? false;\\n\\n    const offsetY = React.useRef(0);\\n    const lastScrollY = React.useRef(0);\\n    const scroller = React.useRef<HTMLDivElement | null>(null);\\n\\n    const dpr = window.devicePixelRatio;\\n\\n    React.useEffect(() => {\\n        const el = scroller.current;\\n        if (el === null || scrollToEnd !== true) return;\\n\\n        el.scrollLeft = el.scrollWidth - el.clientWidth;\\n    }, [scrollToEnd]);\\n\\n    const lastScrollPosition = React.useRef({\\n        scrollLeft: 0,\\n        scrollTop: 0,\\n        lockDirection: undefined as ScrollLock,\\n    });\\n\\n    const rightWrapRef = React.useRef<HTMLDivElement | null>(null);\\n\\n    const hasTouches = useTouchUpDelayed(200);\\n    const [isIdle, setIsIdle] = React.useState(true);\\n    const idleTimer = React.useRef(0);\\n\\n    React.useEffect(() => {\\n        if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;\\n        const el = scroller.current;\\n        if (el === null) return;\\n        const [lx, ly] = lastScrollPosition.current.lockDirection;\\n        if (lx !== undefined) {\\n            el.scrollLeft = lx;\\n        } else if (ly !== undefined) {\\n            el.scrollTop = ly;\\n        }\\n        lastScrollPosition.current.lockDirection = undefined;\\n    }, [hasTouches, isIdle]);\\n\\n    const onScroll = React.useCallback(() => {\\n        const el = scroller.current;\\n        if (el === null) return;\\n\\n        let scrollTop = el.scrollTop;\\n        let scrollLeft = el.scrollLeft;\\n        const lastScrollTop = lastScrollPosition.current.scrollTop;\\n        const lastScrollLeft = lastScrollPosition.current.scrollLeft;\\n\\n        const dx = scrollLeft - lastScrollLeft;\\n        const dy = scrollTop - lastScrollTop;\\n\\n        if (\\n            hasTouches &&\\n            dx !== 0 &&\\n            dy !== 0 &&\\n            (Math.abs(dx) > 3 || Math.abs(dy) > 3) &&\\n            preventDiagonalScrolling &&\\n            lastScrollPosition.current.lockDirection === undefined\\n        ) {\\n            lastScrollPosition.current.lockDirection =\\n                Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];\\n        }\\n\\n        const lock = lastScrollPosition.current.lockDirection;\\n\\n        scrollLeft = lock?.[0] ?? scrollLeft;\\n        scrollTop = lock?.[1] ?? scrollTop;\\n        lastScrollPosition.current.scrollLeft = scrollLeft;\\n        lastScrollPosition.current.scrollTop = scrollTop;\\n\\n        const newY = scrollTop;\\n        const delta = lastScrollY.current - newY;\\n        const scrollableHeight = el.scrollHeight - el.clientHeight;\\n        lastScrollY.current = newY;\\n\\n        if (\\n            scrollableHeight > 0 &&\\n            (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) &&\\n            scrollHeight > el.scrollHeight + 5\\n        ) {\\n            const prog = newY / scrollableHeight;\\n            const recomputed = (scrollHeight - el.clientHeight) * prog;\\n            offsetY.current = recomputed - newY;\\n        }\\n\\n        if (lock !== undefined) {\\n            window.clearTimeout(idleTimer.current);\\n            setIsIdle(false);\\n            idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\\n        }\\n\\n        update({\\n            x: scrollLeft,\\n            y: newY + offsetY.current,\\n            width: el.clientWidth - paddingRight,\\n            height: el.clientHeight - paddingBottom,\\n            paddingRight: rightWrapRef.current?.clientWidth ?? 0,\\n        });\\n    }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\\n\\n    const onScrollRef = React.useRef(onScroll);\\n    onScrollRef.current = onScroll;\\n\\n    const lastProps = React.useRef<{ width?: number; height?: number }>();\\n\\n    React.useEffect(() => {\\n        onScroll();\\n    }, [onScroll, paddingBottom, paddingRight]);\\n\\n    const setRefs = React.useCallback(\\n        (instance: HTMLDivElement | null) => {\\n            scroller.current = instance;\\n            if (scrollRef !== undefined) {\\n                scrollRef.current = instance;\\n            }\\n        },\\n        [scrollRef]\\n    );\\n\\n    let key = 0;\\n    let h = 0;\\n    padders.push(<div key={key++} style={{ width: scrollWidth, height: 0 }} />);\\n    while (h < scrollHeight) {\\n        const toAdd = Math.min(5_000_000, scrollHeight - h);\\n        padders.push(<div key={key++} style={{ width: 0, height: toAdd }} />);\\n        h += toAdd;\\n    }\\n\\n    const { ref, width, height } = useResizeDetector<HTMLDivElement>(initialSize);\\n\\n    if (lastProps.current?.height !== height || lastProps.current?.width !== width) {\\n        window.setTimeout(() => onScrollRef.current(), 0);\\n        lastProps.current = { width, height };\\n    }\\n\\n    if ((width ?? 0) === 0 || (height ?? 0) === 0) return <div ref={ref} />;\\n\\n    return (\\n        <div ref={ref}>\\n            <ScrollRegionStyle isSafari={browserIsSafari.value}>\\n                {minimap}\\n                <div className=\\\"dvn-underlay\\\">{children}</div>\\n                <div\\n                    ref={setRefs}\\n                    style={lastProps.current}\\n                    draggable={draggable}\\n                    onDragStart={e => {\\n                        if (!draggable) {\\n                            e.stopPropagation();\\n                            e.preventDefault();\\n                        }\\n                    }}\\n                    className={\\\"dvn-scroller \\\" + (className ?? \\\"\\\")}\\n                    onScroll={onScroll}>\\n                    <div className={\\\"dvn-scroll-inner\\\" + (rightElement === undefined ? \\\" hidden\\\" : \\\"\\\")}>\\n                        <div className=\\\"dvn-stack\\\">{padders}</div>\\n                        {rightElement !== undefined && (\\n                            <>\\n                                {!rightElementFill && <div className=\\\"dvn-spacer\\\" />}\\n                                <div\\n                                    ref={rightWrapRef}\\n                                    onMouseDown={eatEvent}\\n                                    onMouseUp={eatEvent}\\n                                    onMouseMove={eatEvent}\\n                                    style={{\\n                                        height,\\n                                        maxHeight: clientHeight - Math.ceil(dpr % 1),\\n                                        position: \\\"sticky\\\",\\n                                        top: 0,\\n                                        paddingLeft: 1,\\n                                        marginBottom: -40,\\n                                        marginRight: paddingRight,\\n                                        flexGrow: rightElementFill ? 1 : undefined,\\n                                        right: rightElementSticky ? paddingRight ?? 0 : undefined,\\n                                        pointerEvents: \\\"auto\\\",\\n                                    }}>\\n                                    {rightElement}\\n                                </div>\\n                            </>\\n                        )}\\n                    </div>\\n                </div>\\n            </ScrollRegionStyle>\\n        </div>\\n    );\\n};\\n\",\".s3se5hb .dvn-scroller{overflow:var(--s3se5hb-0);-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0);}.s3se5hb .hidden{visibility:hidden;}.s3se5hb .dvn-scroll-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;pointer-events:none;}.s3se5hb .dvn-scroll-inner > *{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}.s3se5hb .dvn-scroll-inner .dvn-spacer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.s3se5hb .dvn-scroll-inner .dvn-stack{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.s3se5hb .dvn-underlay > *{position:absolute;left:0;top:0;}.s3se5hb canvas{outline:none;}.s3se5hb canvas *{height:0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Il0sIm5hbWVzIjpbIi5zM3NlNWhiIl0sIm1hcHBpbmdzIjoiQUE2Qk1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCIuLi9jb21tb24vcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQgeyBicm93c2VySXNTYWZhcmkgfSBmcm9tIFwiLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uL2NvbW1vbi91dGlsc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZT86IHN0cmluZztcbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGRyYWdnYWJsZTogYm9vbGVhbjtcbiAgICByZWFkb25seSBwYWRkaW5nUmlnaHQ/OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgcGFkZGluZ0JvdHRvbT86IG51bWJlcjtcbiAgICByZWFkb25seSBjbGllbnRIZWlnaHQ6IG51bWJlcjtcbiAgICByZWFkb25seSBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kPzogYm9vbGVhbjtcbiAgICByZWFkb25seSBpbml0aWFsU2Nyb2xsUG9zaXRpb24/OiByZWFkb25seSBbc2Nyb2xsWDogbnVtYmVyLCBzY3JvbGxZOiBudW1iZXJdO1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplPzogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wcz86IHtcbiAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgfTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgbWluaW1hcD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICByZWFkb25seSBzY3JvbGxSZWY/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD47XG4gICAgcmVhZG9ubHkgdXBkYXRlOiAocmVnaW9uOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNjcm9sbFJlZ2lvblN0eWxlID0gc3R5bGVkLmRpdjx7IGlzU2FmYXJpOiBib29sZWFuIH0+YFxuICAgIC5kdm4tc2Nyb2xsZXIge1xuICAgICAgICBvdmVyZmxvdzogJHtwID0+IChwLmlzU2FmYXJpID8gXCJzY3JvbGxcIiA6IFwiYXV0b1wiKX07XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgLmhpZGRlbiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuZHZuLXNjcm9sbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3BhY2VyIHtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3RhY2sge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZHZuLXVuZGVybGF5ID4gKiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgIH1cblxuICAgIGNhbnZhcyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG5cbiAgICAgICAgKiB7XG4gICAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG50eXBlIFNjcm9sbExvY2sgPSBbdW5kZWZpbmVkLCBudW1iZXJdIHwgW251bWJlciwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZWF0RXZlbnQoZTogUmVhY3QuTW91c2VFdmVudCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVRvdWNoVXBEZWxheWVkKGRlbGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBbaGFzVG91Y2hlcywgc2V0SGFzVG91Y2hlc10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBjYlRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNiVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRIYXNUb3VjaGVzKHRydWUpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHNldEhhc1RvdWNoZXMoZmFsc2UpLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtkZWxheV1cbiAgICAgICAgKSxcbiAgICAgICAgd2luZG93LFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuZXhwb3J0IGNvbnN0IEluZmluaXRlU2Nyb2xsZXI6IFJlYWN0LkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwLFxuICAgICAgICBwYWRkaW5nUmlnaHQgPSAwLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgbWluaW1hcCxcbiAgICB9ID0gcDtcbiAgICBjb25zdCBwYWRkZXJzOiBSZWFjdC5SZWFjdE5vZGVbXSA9IFtdO1xuXG4gICAgY29uc3QgcmlnaHRFbGVtZW50U3RpY2t5ID0gcmlnaHRFbGVtZW50UHJvcHM/LnN0aWNreSA/PyBmYWxzZTtcbiAgICBjb25zdCByaWdodEVsZW1lbnRGaWxsID0gcmlnaHRFbGVtZW50UHJvcHM/LmZpbGwgPz8gZmFsc2U7XG5cbiAgICBjb25zdCBvZmZzZXRZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IHNjcm9sbGVyID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IHNjcm9sbFRvRW5kICE9PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGg7XG4gICAgfSwgW3Njcm9sbFRvRW5kXSk7XG5cbiAgICBjb25zdCBsYXN0U2Nyb2xsUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIGxvY2tEaXJlY3Rpb246IHVuZGVmaW5lZCBhcyBTY3JvbGxMb2NrLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmlnaHRXcmFwUmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBoYXNUb3VjaGVzID0gdXNlVG91Y2hVcERlbGF5ZWQoMjAwKTtcbiAgICBjb25zdCBbaXNJZGxlLCBzZXRJc0lkbGVdID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgaWRsZVRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0lkbGUgfHwgaGFzVG91Y2hlcyB8fCBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgICAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgW2x4LCBseV0gPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuICAgICAgICBpZiAobHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGx4O1xuICAgICAgICB9IGVsc2UgaWYgKGx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcCA9IGx5O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSwgW2hhc1RvdWNoZXMsIGlzSWRsZV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsVG9wID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsTGVmdCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgY29uc3QgZHggPSBzY3JvbGxMZWZ0IC0gbGFzdFNjcm9sbExlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gc2Nyb2xsVG9wIC0gbGFzdFNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNUb3VjaGVzICYmXG4gICAgICAgICAgICBkeCAhPT0gMCAmJlxuICAgICAgICAgICAgZHkgIT09IDAgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhkeCkgPiAzIHx8IE1hdGguYWJzKGR5KSA+IDMpICYmXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcgJiZcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPVxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGR4KSA8IE1hdGguYWJzKGR5KSA/IFtsYXN0U2Nyb2xsTGVmdCwgdW5kZWZpbmVkXSA6IFt1bmRlZmluZWQsIGxhc3RTY3JvbGxUb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jayA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb247XG5cbiAgICAgICAgc2Nyb2xsTGVmdCA9IGxvY2s/LlswXSA/PyBzY3JvbGxMZWZ0O1xuICAgICAgICBzY3JvbGxUb3AgPSBsb2NrPy5bMV0gPz8gc2Nyb2xsVG9wO1xuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGNvbnN0IG5ld1kgPSBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbGFzdFNjcm9sbFkuY3VycmVudCAtIG5ld1k7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxhc3RTY3JvbGxZLmN1cnJlbnQgPSBuZXdZO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNjcm9sbGFibGVIZWlnaHQgPiAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZGVsdGEpID4gMjAwMCB8fCBuZXdZID09PSAwIHx8IG5ld1kgPT09IHNjcm9sbGFibGVIZWlnaHQpICYmXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPiBlbC5zY3JvbGxIZWlnaHQgKyA1XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcHJvZyA9IG5ld1kgLyBzY3JvbGxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcmVjb21wdXRlZCA9IChzY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQpICogcHJvZztcbiAgICAgICAgICAgIG9mZnNldFkuY3VycmVudCA9IHJlY29tcHV0ZWQgLSBuZXdZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZGxlVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRJc0lkbGUoZmFsc2UpO1xuICAgICAgICAgICAgaWRsZVRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRJc0lkbGUodHJ1ZSksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgeDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IG5ld1kgKyBvZmZzZXRZLmN1cnJlbnQsXG4gICAgICAgICAgICB3aWR0aDogZWwuY2xpZW50V2lkdGggLSBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsLmNsaWVudEhlaWdodCAtIHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHJpZ2h0V3JhcFJlZi5jdXJyZW50Py5jbGllbnRXaWR0aCA/PyAwLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBzY3JvbGxIZWlnaHQsIHVwZGF0ZSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBoYXNUb3VjaGVzXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFJlZiA9IFJlYWN0LnVzZVJlZihvblNjcm9sbCk7XG4gICAgb25TY3JvbGxSZWYuY3VycmVudCA9IG9uU2Nyb2xsO1xuXG4gICAgY29uc3QgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmPHsgd2lkdGg/OiBudW1iZXI7IGhlaWdodD86IG51bWJlciB9PigpO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25TY3JvbGwoKTtcbiAgICB9LCBbb25TY3JvbGwsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodF0pO1xuXG4gICAgY29uc3Qgc2V0UmVmcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoaW5zdGFuY2U6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsZXIuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW3Njcm9sbFJlZl1cbiAgICApO1xuXG4gICAgbGV0IGtleSA9IDA7XG4gICAgbGV0IGggPSAwO1xuICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiBzY3JvbGxXaWR0aCwgaGVpZ2h0OiAwIH19IC8+KTtcbiAgICB3aGlsZSAoaCA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBjb25zdCB0b0FkZCA9IE1hdGgubWluKDVfMDAwXzAwMCwgc2Nyb2xsSGVpZ2h0IC0gaCk7XG4gICAgICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiAwLCBoZWlnaHQ6IHRvQWRkIH19IC8+KTtcbiAgICAgICAgaCArPSB0b0FkZDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3I8SFRNTERpdkVsZW1lbnQ+KGluaXRpYWxTaXplKTtcblxuICAgIGlmIChsYXN0UHJvcHMuY3VycmVudD8uaGVpZ2h0ICE9PSBoZWlnaHQgfHwgbGFzdFByb3BzLmN1cnJlbnQ/LndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBvblNjcm9sbFJlZi5jdXJyZW50KCksIDApO1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cblxuICAgIGlmICgod2lkdGggPz8gMCkgPT09IDAgfHwgKGhlaWdodCA/PyAwKSA9PT0gMCkgcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiByZWY9e3JlZn0+XG4gICAgICAgICAgICA8U2Nyb2xsUmVnaW9uU3R5bGUgaXNTYWZhcmk9e2Jyb3dzZXJJc1NhZmFyaS52YWx1ZX0+XG4gICAgICAgICAgICAgICAge21pbmltYXB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tdW5kZXJsYXlcIj57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByZWY9e3NldFJlZnN9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtsYXN0UHJvcHMuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlPXtkcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsZXIgXCIgKyAoY2xhc3NOYW1lID8/IFwiXCIpfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsLWlubmVyXCIgKyAocmlnaHRFbGVtZW50ID09PSB1bmRlZmluZWQgPyBcIiBoaWRkZW5cIiA6IFwiXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXN0YWNrXCI+e3BhZGRlcnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmlnaHRFbGVtZW50RmlsbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImR2bi1zcGFjZXJcIiAvPn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyaWdodFdyYXBSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBjbGllbnRIZWlnaHQgLSBNYXRoLmNlaWwoZHByICUgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogLTQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3c6IHJpZ2h0RWxlbWVudEZpbGwgPyAxIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodEVsZW1lbnRTdGlja3kgPyBwYWRkaW5nUmlnaHQgPz8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvU2Nyb2xsUmVnaW9uU3R5bGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuIl19*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".i1ua65x0{width:100%;height:100px;}.i1ua65x0 > *{position:absolute;width:100%;height:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC5zdG9yaWVzLnRzeCJdLCJuYW1lcyI6WyIuaTF1YTY1eDAiXSwibWFwcGluZ3MiOiJBQVVNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgR3JpZFNjcm9sbGVyIGZyb20gXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgQ29tcGFjdFNlbGVjdGlvbiwgR3JpZENlbGwsIEdyaWRDZWxsS2luZCwgUmVjdGFuZ2xlLCBJdGVtIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRUaGVtZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHMvY2VsbC10eXBlc1wiO1xuaW1wb3J0IHsgQ2VsbFJlbmRlcmVycyB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHNcIjtcblxuY29uc3QgSW5uZXJDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwcHg7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuY29uc3QgZ2V0Q2VsbFJlbmRlcmVyOiBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayA9IGNlbGwgPT4ge1xuICAgIGlmIChjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFwiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPEJ1aWxkZXJUaGVtZVdyYXBwZXIgd2lkdGg9ezE1MDB9IGhlaWdodD17MTAwMH0+XG4gICAgICAgICAgICAgICAgICAgIDxJbm5lckNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgICAgICAgICA8L0lubmVyQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvQnVpbGRlclRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gU2ltcGxlbm90ZXN0KCkge1xuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XG4gICAgY29uc3QgW3ksIHNldFldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWCwgc2V0VHhdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcblxuICAgIGNvbnN0IG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQgPSBSZWFjdC51c2VDYWxsYmFjaygocmFuZ2U6IFJlY3RhbmdsZSwgdHg/OiBudW1iZXIsIHR5PzogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldFgocmFuZ2UueCk7XG4gICAgICAgIHNldFkocmFuZ2UueSk7XG4gICAgICAgIHNldFR4KHR4KTtcbiAgICAgICAgc2V0VHkodHkpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICByZXR1cm4gW1wiT25lXCIsIFwiVHdvXCIsIFwiVGhyZWVcIiwgXCJGb3VyXCIsIFwiRml2ZVwiLCBcIlNpeFwiLCBcIlNldmVuXCIsIFwiRWlnaHRcIiwgXCJOaW5lXCIsIFwiVGVuXCJdLm1hcCh0ID0+ICh7XG4gICAgICAgICAgICB0aXRsZTogdCxcbiAgICAgICAgICAgIHdpZHRoOiAxMjIgKyAoaiArPSA1MCksXG4gICAgICAgIH0pKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxuICAgICAgICAgICAgZGF0YTogYCR7Y29sfSwke3Jvd30gVGVzdGluZyB0aGluZ3MgdGhhdCBhcmUgd2F5IHRvbyBsb25nYCxcbiAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIFtdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxHcmlkU2Nyb2xsZXJcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxuICAgICAgICAgICAgb25Nb3VzZU1vdmU9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XG4gICAgICAgICAgICBjbGllbnRTaXplPXtbMTAwMCwgMTAwMF19XG4gICAgICAgICAgICBjZWxsWE9mZnNldD17eH1cbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxuICAgICAgICAgICAgZHJhd0hlYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uQ2FudmFzQmx1cj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNlbGxGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51PXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdPdmVyQ2VsbD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJvcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbktleVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBjYW52YXNSZWY9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaWxsSGFuZGxlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaXhlZFNoYWRvd1g9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZ2V0R3JvdXBEZXRhaWxzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG92ZXJzY3JvbGxZPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgc2hvd01pbmltYXA9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XG4gICAgICAgICAgICBpc0ZvY3VzZWQ9e3RydWV9XG4gICAgICAgICAgICB0aGVtZT17Z2V0RGVmYXVsdFRoZW1lKCl9XG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9ezUwMH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlIZWlnaHQ9ezUwfVxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cbiAgICAgICAgICAgIHRyYW5zbGF0ZVk9e3RyYW5zbGF0ZVl9XG4gICAgICAgICAgICBsb2NrQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGZpcnN0Q29sQWNjZXNzaWJsZT17dHJ1ZX1cbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cbiAgICAgICAgICAgIGhlYWRlckhlaWdodD17NDR9XG4gICAgICAgICAgICB0cmFpbGluZ1Jvd1R5cGU9e1wibm9uZVwifVxuICAgICAgICAgICAgcm93SGVpZ2h0PXszNH1cbiAgICAgICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ9e29uVmlzaWJsZVJlZ2lvbkNoYW5nZWR9XG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17dHJ1ZX1cbiAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgIC8+XG4gICAgKTtcbn1cbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/scrolling-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx\",\"webpack://./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx\"],\"names\":[\".i1ua65x0\"],\"mappings\":\"AAUMA,UAAAA,UAAAA,CAAAA,YAAAA,CAAAA,CAAAA,cAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACTN,+tOAA+tO\",\"sourcesContent\":[\"import * as React from \\\"react\\\";\\n\\nimport { BuilderThemeWrapper } from \\\"../stories/story-utils\\\";\\nimport GridScroller from \\\"./scrolling-data-grid\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \\\"../data-grid/data-grid-types\\\";\\nimport { getDefaultTheme } from \\\"..\\\";\\nimport type { GetCellRendererCallback } from \\\"../data-grid/cells/cell-types\\\";\\nimport { CellRenderers } from \\\"../data-grid/cells\\\";\\n\\nconst InnerContainer = styled.div`\\n    width: 100%;\\n    height: 100px;\\n\\n    > * {\\n        position: absolute;\\n        width: 100%;\\n        height: 100%;\\n    }\\n`;\\n\\nconst getCellRenderer: GetCellRendererCallback = cell => {\\n    if (cell.kind === GridCellKind.Custom) return undefined;\\n    return CellRenderers[cell.kind] as any;\\n};\\n\\nexport default {\\n    title: \\\"Subcomponents/ScrollingDataGrid\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <div>\\n                <BuilderThemeWrapper width={1500} height={1000}>\\n                    <InnerContainer>\\n                        <Story />\\n                    </InnerContainer>\\n                </BuilderThemeWrapper>\\n            </div>\\n        ),\\n    ],\\n};\\n\\nexport function Simplenotest() {\\n    const [x, setX] = React.useState<number>(0);\\n    const [y, setY] = React.useState<number>(0);\\n    const [translateX, setTx] = React.useState<number | undefined>(0);\\n    const [translateY, setTy] = React.useState<number | undefined>(0);\\n\\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\\n        setX(range.x);\\n        setY(range.y);\\n        setTx(tx);\\n        setTy(ty);\\n    }, []);\\n\\n    const columns = React.useMemo(() => {\\n        let j = 0;\\n        return [\\\"One\\\", \\\"Two\\\", \\\"Three\\\", \\\"Four\\\", \\\"Five\\\", \\\"Six\\\", \\\"Seven\\\", \\\"Eight\\\", \\\"Nine\\\", \\\"Ten\\\"].map(t => ({\\n            title: t,\\n            width: 122 + (j += 50),\\n        }));\\n    }, []);\\n\\n    const getCellContent = React.useCallback(\\n        ([col, row]: Item): GridCell => ({\\n            kind: GridCellKind.Text,\\n            displayData: `${col},${row} Testing things that are way too long`,\\n            data: `${col},${row} Testing things that are way too long`,\\n            allowOverlay: true,\\n        }),\\n        []\\n    );\\n\\n    return (\\n        <GridScroller\\n            getCellRenderer={getCellRenderer}\\n            onMouseMove={() => undefined}\\n            rows={10_000}\\n            enableGroups={false}\\n            clientSize={[1000, 1000]}\\n            cellXOffset={x}\\n            cellYOffset={y}\\n            drawHeader={undefined}\\n            experimental={undefined}\\n            headerIcons={undefined}\\n            isDraggable={undefined}\\n            onCanvasBlur={() => undefined}\\n            onCanvasFocused={() => undefined}\\n            onCellFocused={() => undefined}\\n            onContextMenu={() => undefined}\\n            onDragEnd={() => undefined}\\n            onDragLeave={() => undefined}\\n            onDragOverCell={() => undefined}\\n            onDragStart={() => undefined}\\n            onDrop={() => undefined}\\n            onItemHovered={() => undefined}\\n            onKeyDown={() => undefined}\\n            onKeyUp={() => undefined}\\n            onMouseDown={() => undefined}\\n            onMouseUp={() => undefined}\\n            canvasRef={undefined}\\n            className={undefined}\\n            disabledRows={undefined}\\n            fillHandle={undefined}\\n            fixedShadowX={undefined}\\n            fixedShadowY={undefined}\\n            getGroupDetails={undefined}\\n            getRowThemeOverride={undefined}\\n            highlightRegions={undefined}\\n            imageWindowLoader={undefined}\\n            onHeaderMenuClick={undefined}\\n            prelightCells={undefined}\\n            drawCustomCell={undefined}\\n            drawFocusRing={undefined}\\n            initialSize={undefined}\\n            overscrollX={undefined}\\n            overscrollY={undefined}\\n            preventDiagonalScrolling={undefined}\\n            rightElement={undefined}\\n            rightElementProps={undefined}\\n            scrollRef={undefined}\\n            showMinimap={undefined}\\n            scrollToEnd={undefined}\\n            minColumnWidth={50}\\n            isFocused={true}\\n            theme={getDefaultTheme()}\\n            isFilling={false}\\n            maxColumnWidth={500}\\n            accessibilityHeight={50}\\n            translateX={translateX}\\n            translateY={translateY}\\n            lockColumns={0}\\n            selection={{\\n                current: undefined,\\n                rows: CompactSelection.empty(),\\n                columns: CompactSelection.empty(),\\n            }}\\n            firstColAccessible={true}\\n            groupHeaderHeight={34}\\n            headerHeight={44}\\n            trailingRowType={\\\"none\\\"}\\n            rowHeight={34}\\n            onVisibleRegionChanged={onVisibleRegionChanged}\\n            columns={columns}\\n            getCellContent={getCellContent}\\n            freezeColumns={0}\\n            verticalBorder={() => true}\\n            smoothScrollX={true}\\n            smoothScrollY={true}\\n        />\\n    );\\n}\\n\",\".i1ua65x0{width:100%;height:100px;}.i1ua65x0 > *{position:absolute;width:100%;height:100%;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC5zdG9yaWVzLnRzeCJdLCJuYW1lcyI6WyIuaTF1YTY1eDAiXSwibWFwcGluZ3MiOiJBQVVNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgR3JpZFNjcm9sbGVyIGZyb20gXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgQ29tcGFjdFNlbGVjdGlvbiwgR3JpZENlbGwsIEdyaWRDZWxsS2luZCwgUmVjdGFuZ2xlLCBJdGVtIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRUaGVtZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHMvY2VsbC10eXBlc1wiO1xuaW1wb3J0IHsgQ2VsbFJlbmRlcmVycyB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHNcIjtcblxuY29uc3QgSW5uZXJDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwcHg7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuY29uc3QgZ2V0Q2VsbFJlbmRlcmVyOiBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayA9IGNlbGwgPT4ge1xuICAgIGlmIChjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFwiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPEJ1aWxkZXJUaGVtZVdyYXBwZXIgd2lkdGg9ezE1MDB9IGhlaWdodD17MTAwMH0+XG4gICAgICAgICAgICAgICAgICAgIDxJbm5lckNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgICAgICAgICA8L0lubmVyQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvQnVpbGRlclRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gU2ltcGxlbm90ZXN0KCkge1xuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XG4gICAgY29uc3QgW3ksIHNldFldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWCwgc2V0VHhdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcblxuICAgIGNvbnN0IG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQgPSBSZWFjdC51c2VDYWxsYmFjaygocmFuZ2U6IFJlY3RhbmdsZSwgdHg/OiBudW1iZXIsIHR5PzogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldFgocmFuZ2UueCk7XG4gICAgICAgIHNldFkocmFuZ2UueSk7XG4gICAgICAgIHNldFR4KHR4KTtcbiAgICAgICAgc2V0VHkodHkpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICByZXR1cm4gW1wiT25lXCIsIFwiVHdvXCIsIFwiVGhyZWVcIiwgXCJGb3VyXCIsIFwiRml2ZVwiLCBcIlNpeFwiLCBcIlNldmVuXCIsIFwiRWlnaHRcIiwgXCJOaW5lXCIsIFwiVGVuXCJdLm1hcCh0ID0+ICh7XG4gICAgICAgICAgICB0aXRsZTogdCxcbiAgICAgICAgICAgIHdpZHRoOiAxMjIgKyAoaiArPSA1MCksXG4gICAgICAgIH0pKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxuICAgICAgICAgICAgZGF0YTogYCR7Y29sfSwke3Jvd30gVGVzdGluZyB0aGluZ3MgdGhhdCBhcmUgd2F5IHRvbyBsb25nYCxcbiAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIFtdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxHcmlkU2Nyb2xsZXJcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxuICAgICAgICAgICAgb25Nb3VzZU1vdmU9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XG4gICAgICAgICAgICBjbGllbnRTaXplPXtbMTAwMCwgMTAwMF19XG4gICAgICAgICAgICBjZWxsWE9mZnNldD17eH1cbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxuICAgICAgICAgICAgZHJhd0hlYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uQ2FudmFzQmx1cj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNlbGxGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51PXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdPdmVyQ2VsbD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJvcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbktleVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBjYW52YXNSZWY9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaWxsSGFuZGxlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaXhlZFNoYWRvd1g9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZ2V0R3JvdXBEZXRhaWxzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG92ZXJzY3JvbGxZPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgc2hvd01pbmltYXA9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XG4gICAgICAgICAgICBpc0ZvY3VzZWQ9e3RydWV9XG4gICAgICAgICAgICB0aGVtZT17Z2V0RGVmYXVsdFRoZW1lKCl9XG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9ezUwMH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlIZWlnaHQ9ezUwfVxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cbiAgICAgICAgICAgIHRyYW5zbGF0ZVk9e3RyYW5zbGF0ZVl9XG4gICAgICAgICAgICBsb2NrQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGZpcnN0Q29sQWNjZXNzaWJsZT17dHJ1ZX1cbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cbiAgICAgICAgICAgIGhlYWRlckhlaWdodD17NDR9XG4gICAgICAgICAgICB0cmFpbGluZ1Jvd1R5cGU9e1wibm9uZVwifVxuICAgICAgICAgICAgcm93SGVpZ2h0PXszNH1cbiAgICAgICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ9e29uVmlzaWJsZVJlZ2lvbkNoYW5nZWR9XG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17dHJ1ZX1cbiAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgIC8+XG4gICAgKTtcbn1cbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".m3brspx{position:absolute;right:44px;bottom:44px;background-color:var(--gdg-bg-cell);background:linear-gradient(var(--gdg-bg-cell),var(--gdg-bg-cell-medium));border-radius:4px;z-index:1;box-shadow:0 0 0 1px var(--gdg-border-color),0 2px 5px rgba(0,0,0,0.08);overflow:hidden;}.m3brspx .header{position:absolute;left:0;top:0;width:100%;height:4px;background-color:var(--gdg-bg-header);box-shadow:0 0 0 1px var(--gdg-border-color);}.m3brspx .locationMarker{position:absolute;border:1px solid var(--gdg-accent-color);background-color:var(--gdg-accent-light);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC50c3giXSwibmFtZXMiOlsiLm0zYnJzcHgiXSwibWFwcGluZ3MiOiJBQW9GTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgRGF0YUdyaWREbmQsIHsgRGF0YUdyaWREbmRQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWdyaWQtZG5kL2RhdGEtZ3JpZC1kbmRcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsZXIgfSBmcm9tIFwiLi9pbmZpbml0ZS1zY3JvbGxlclwiO1xuaW1wb3J0IGNsYW1wIGZyb20gXCJsb2Rhc2gvY2xhbXAuanNcIjtcblxudHlwZSBQcm9wcyA9IE9taXQ8RGF0YUdyaWREbmRQcm9wcywgXCJ3aWR0aFwiIHwgXCJoZWlnaHRcIiB8IFwiZXZlbnRUYXJnZXRSZWZcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsaW5nRGF0YUdyaWRQcm9wcyBleHRlbmRzIFByb3BzIHtcbiAgICByZWFkb25seSBjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBvblZpc2libGVSZWdpb25DaGFuZ2VkOlxuICAgICAgICB8ICgoXG4gICAgICAgICAgICAgIHJhbmdlOiBSZWN0YW5nbGUsXG4gICAgICAgICAgICAgIGNsaWVudFdpZHRoOiBudW1iZXIsXG4gICAgICAgICAgICAgIGNsaWVudEhlaWdodDogbnVtYmVyLFxuICAgICAgICAgICAgICByaWdodEVsV2lkdGg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHk6IG51bWJlclxuICAgICAgICAgICkgPT4gdm9pZClcbiAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBncmlkIHRvIHNjcm9sbCB0byB0aGUgZW5kIHdoZW4gZmxpcHBlZCB0byB0cnVlXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBEYXRhRWRpdG9yUmVmLnNjcm9sbFRvfSBpbnN0ZWFkXG4gICAgICogQGdyb3VwIERlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzY3JvbGxUb0VuZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBzY3JvbGxSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQgfCBudWxsPiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdmVyc2Nyb2xsIHByb3BlcnRpZXMgYXJlIHVzZWQgdG8gYWxsb3cgdGhlIGdyaWQgdG8gc2Nyb2xsIHBhc3QgdGhlIGxvZ2ljYWwgZW5kIG9mIHRoZSBjb250ZW50IGJ5IGEgZml4ZWRcbiAgICAgKiBudW1iZXIgb2YgcGl4ZWxzLiBUaGlzIGlzIHVzZWZ1bCBwYXJ0aWN1bGFybHkgb24gdGhlIFggYXhpcyBpZiB5b3UgYWxsb3cgZm9yIHJlc2l6aW5nIGNvbHVtbnMgYXMgaXQgY2FuIG1ha2VcbiAgICAgKiByZXNpemluZyB0aGUgZmluYWwgY29sdW1uIHNpZ25pZmljYW50bHkgZWFzaWVyLlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgb3ZlcnNjcm9sbFg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKioge0Bpbmhlcml0RG9jIG92ZXJzY3JvbGxYfVxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IG92ZXJzY3JvbGxZOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW5pdGlhbCBzaXplIGZvciB0aGUgZ3JpZCB3aGljaCBjYW4gcHJldmVudCBhIGZsaWNrZXIgb24gbG9hZCBpZiB0aGUgaW5pdGlhbCBzaXplIGlzIGtub3duIHByaW9yIHRvXG4gICAgICogbGF5b3V0LlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgaW5pdGlhbFNpemU6IHJlYWRvbmx5IFt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcl0gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gcHJldmVudCBhbnkgZGlhZ29uYWwgc2Nyb2xsaW5nLlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHByZXZlbnREaWFnb25hbFNjcm9sbGluZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIElmIGByaWdodEVsZW1lbnRQcm9wcy5zdGlja3lgIGlzIHNldCB0byB0cnVlIHRoZSByaWdodCBlbGVtZW50IHdpbGwgYmUgdmlzaWJsZSBhdCBhbGwgdGltZXMsIG90aGVyd2lzZSB0aGUgdXNlclxuICAgICAqIHdpbGwgbmVlZCB0byBzY3JvbGwgdG8gdGhlIGVuZCB0byByZXZlYWwgaXQuXG4gICAgICpcbiAgICAgKiBJZiBgcmlnaHRFbGVtZW50UHJvcHMuZmlsbGAgaXMgc2V0LCB0aGUgcmlnaHQgZWxlbWVudHMgY29udGFpbmVyIHdpbGwgZmlsbCB0byBjb25zdW1lIGFsbCByZW1haW5pbmcgc3BhY2UgKGlmXG4gICAgICogYW55KSBhdCB0aGUgZW5kIG9mIHRoZSBncmlkLiBUaGlzIGRvZXMgbm90IHBsYXkgbmljZSB3aXRoIGdyb3dpbmcgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJpZ2h0RWxlbWVudFByb3BzOlxuICAgICAgICB8IHtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgICAgICAgfVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmlnaHQgZWxlbWVudCBpcyBhIERPTSBub2RlIHdoaWNoIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCByZWdpb24uIFRoaXMgY2FuIGJlXG4gICAgICogdXNlZCB0byBjcmVhdGUgYSByaWdodCBoYW5kbGUgcGFuZWwsIG1ha2UgYSBiaWcgYWRkIGJ1dHRvbiwgb3IgZGlzcGxheSBtZXNzYWdlcy5cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHRoZSBpbnRlcmFjdGl2ZSBtaW5pbWFwLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgZmFsc2VcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzaG93TWluaW1hcDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBjbGllbnRTaXplOiByZWFkb25seSBbbnVtYmVyLCBudW1iZXJdO1xufVxuXG5jb25zdCBNaW5pbWFwU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogNDRweDtcbiAgICBib3R0b206IDQ0cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh2YXIoLS1nZGctYmctY2VsbCksIHZhcigtLWdkZy1iZy1jZWxsLW1lZGl1bSkpO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB6LWluZGV4OiAxO1xuICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKSwgMCAycHggNXB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgLmhlYWRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiA0cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXIpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuXG4gICAgLmxvY2F0aW9uTWFya2VyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICB9XG5gO1xuXG5jb25zdCBHcmlkU2Nyb2xsZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFNjcm9sbGluZ0RhdGFHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBjb2x1bW5zLFxuICAgICAgICByb3dzLFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgICAgZ3JvdXBIZWFkZXJIZWlnaHQsXG4gICAgICAgIGVuYWJsZUdyb3VwcyxcbiAgICAgICAgZnJlZXplQ29sdW1ucyxcbiAgICAgICAgZXhwZXJpbWVudGFsLFxuICAgICAgICBjbGllbnRTaXplLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZyxcbiAgICAgICAgcmlnaHRFbGVtZW50LFxuICAgICAgICByaWdodEVsZW1lbnRQcm9wcyxcbiAgICAgICAgb3ZlcnNjcm9sbFgsXG4gICAgICAgIG92ZXJzY3JvbGxZLFxuICAgICAgICBzaG93TWluaW1hcCA9IGZhbHNlLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgc21vb3RoU2Nyb2xsWCA9IGZhbHNlLFxuICAgICAgICBzbW9vdGhTY3JvbGxZID0gZmFsc2UsXG4gICAgICAgIGlzRHJhZ2dhYmxlLFxuICAgIH0gPSBwO1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBleHBlcmltZW50YWwgPz8ge307XG5cbiAgICBjb25zdCBbY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodF0gPSBjbGllbnRTaXplO1xuICAgIGNvbnN0IGxhc3QgPSBSZWFjdC51c2VSZWY8UmVjdGFuZ2xlIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RYID0gUmVhY3QudXNlUmVmPG51bWJlciB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0WSA9IFJlYWN0LnVzZVJlZjxudW1iZXIgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFNpemUgPSBSZWFjdC51c2VSZWY8cmVhZG9ubHkgW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IHdpZHRoID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCByID0gTWF0aC5tYXgoMCwgb3ZlcnNjcm9sbFggPz8gMCk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgICByICs9IGMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSwgW2NvbHVtbnMsIG92ZXJzY3JvbGxYXSk7XG5cbiAgICBsZXQgaGVpZ2h0ID0gZW5hYmxlR3JvdXBzID8gaGVhZGVySGVpZ2h0ICsgZ3JvdXBIZWFkZXJIZWlnaHQgOiBoZWFkZXJIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHJvd3MgKiByb3dIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICAgIGhlaWdodCArPSByb3dIZWlnaHQocik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJzY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ICs9IG92ZXJzY3JvbGxZO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RBcmdzID0gUmVhY3QudXNlUmVmPFJlY3RhbmdsZSAmIHsgcGFkZGluZ1JpZ2h0OiBudW1iZXIgfT4oKTtcblxuICAgIGNvbnN0IHByb2Nlc3NBcmdzID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAobGFzdEFyZ3MuY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7IC4uLmxhc3RBcmdzLmN1cnJlbnQgfTtcblxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB0eCA9IGFyZ3MueCA8IDAgPyAtYXJncy54IDogMDtcbiAgICAgICAgbGV0IGNlbGxSaWdodCA9IDA7XG4gICAgICAgIGxldCBjZWxsWCA9IDA7XG5cbiAgICAgICAgYXJncy54ID0gYXJncy54IDwgMCA/IDAgOiBhcmdzLng7XG5cbiAgICAgICAgbGV0IHN0aWNreUNvbFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmVlemVDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIHN0aWNreUNvbFdpZHRoICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sdW1ucykge1xuICAgICAgICAgICAgY29uc3QgY3ggPSB4IC0gc3RpY2t5Q29sV2lkdGg7XG4gICAgICAgICAgICBpZiAoYXJncy54ID49IGN4ICsgYy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnggPiBjeCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSBjeCAtIGFyZ3MueDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy54ICsgYXJncy53aWR0aCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0eSA9IDA7XG4gICAgICAgIGxldCBjZWxsWSA9IDA7XG4gICAgICAgIGxldCBjZWxsQm90dG9tID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmZsb29yKGFyZ3MueSAvIHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgdHkgPSBjZWxsWSAqIHJvd0hlaWdodCAtIGFyZ3MueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmNlaWwoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxCb3R0b20gPSBNYXRoLmNlaWwoYXJncy5oZWlnaHQgLyByb3dIZWlnaHQpICsgY2VsbFk7XG4gICAgICAgICAgICBpZiAodHkgPCAwKSBjZWxsQm90dG9tKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJoID0gcm93SGVpZ2h0KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3kgPSB5ICsgKHNtb290aFNjcm9sbFkgPyAwIDogcmggLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy55ID49IHkgKyByaCkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnkgPiBjeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHkgKz0gY3kgLSBhcmdzLnk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueSArIGFyZ3MuaGVpZ2h0ID4gcmggLyAyICsgeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjdDogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogY2VsbFgsXG4gICAgICAgICAgICB5OiBjZWxsWSxcbiAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgIGhlaWdodDogY2VsbEJvdHRvbSAtIGNlbGxZLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9sZFJlY3QgPSBsYXN0LmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2xkUmVjdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBvbGRSZWN0LnkgIT09IHJlY3QueSB8fFxuICAgICAgICAgICAgb2xkUmVjdC54ICE9PSByZWN0LnggfHxcbiAgICAgICAgICAgIG9sZFJlY3QuaGVpZ2h0ICE9PSByZWN0LmhlaWdodCB8fFxuICAgICAgICAgICAgb2xkUmVjdC53aWR0aCAhPT0gcmVjdC53aWR0aCB8fFxuICAgICAgICAgICAgbGFzdFguY3VycmVudCAhPT0gdHggfHxcbiAgICAgICAgICAgIGxhc3RZLmN1cnJlbnQgIT09IHR5IHx8XG4gICAgICAgICAgICBhcmdzLndpZHRoICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMF0gfHxcbiAgICAgICAgICAgIGFyZ3MuaGVpZ2h0ICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPy4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4OiBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjZWxsQm90dG9tIC0gY2VsbFksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmdzLndpZHRoLFxuICAgICAgICAgICAgICAgIGFyZ3MuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFyZ3MucGFkZGluZ1JpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgdHgsXG4gICAgICAgICAgICAgICAgdHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsYXN0LmN1cnJlbnQgPSByZWN0O1xuICAgICAgICAgICAgbGFzdFguY3VycmVudCA9IHR4O1xuICAgICAgICAgICAgbGFzdFkuY3VycmVudCA9IHR5O1xuICAgICAgICAgICAgbGFzdFNpemUuY3VycmVudCA9IFthcmdzLndpZHRoLCBhcmdzLmhlaWdodF07XG4gICAgICAgIH1cbiAgICB9LCBbY29sdW1ucywgcm93SGVpZ2h0LCByb3dzLCBvblZpc2libGVSZWdpb25DaGFuZ2VkLCBmcmVlemVDb2x1bW5zLCBzbW9vdGhTY3JvbGxYLCBzbW9vdGhTY3JvbGxZXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoYXJnczogUmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBsYXN0QXJncy5jdXJyZW50ID0gYXJncztcbiAgICAgICAgICAgIHByb2Nlc3NBcmdzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtwcm9jZXNzQXJnc11cbiAgICApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvY2Vzc0FyZ3MoKTtcbiAgICB9LCBbcHJvY2Vzc0FyZ3NdKTtcblxuICAgIGNvbnN0IHNjcm9sbGVyID0gc2Nyb2xsUmVmPy5jdXJyZW50ID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhc3BlY3QgPSBjbGFtcCh3aWR0aCAvIGhlaWdodCwgMiAvIDMsIDEuNSk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IDIwMDtcbiAgICBjb25zdCB3ID0gYXNwZWN0ID4gMSA/IG1heFNpemUgOiBNYXRoLmNlaWwobWF4U2l6ZSAqIGFzcGVjdCk7XG4gICAgY29uc3QgaCA9IGFzcGVjdCA+IDEgPyBNYXRoLmNlaWwobWF4U2l6ZSAvIGFzcGVjdCkgOiBtYXhTaXplO1xuICAgIGNvbnN0IGhSYXRpbyA9IHcgLyB3aWR0aDtcbiAgICBjb25zdCB2UmF0aW8gPSBoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHZXaWR0aCA9IE1hdGgubWluKGNsaWVudFdpZHRoICogTWF0aC5tYXgoaFJhdGlvLCAwLjAxKSwgdyk7XG4gICAgY29uc3QgdkhlaWdodCA9IE1hdGgubWluKGNsaWVudEhlaWdodCAqIE1hdGgubWF4KHZSYXRpbywgMC4wMSksIGgpO1xuICAgIGNvbnN0IGxlZnQgPSAoKHNjcm9sbGVyPy5zY3JvbGxMZWZ0ID8/IDApIC8gKHdpZHRoIC0gY2xpZW50V2lkdGgpKSAqICh3IC0gdldpZHRoKTtcbiAgICBjb25zdCB0b3AgPSAoKHNjcm9sbGVyPy5zY3JvbGxUb3AgPz8gMCkgLyAoaGVpZ2h0IC0gY2xpZW50SGVpZ2h0KSkgKiAoaCAtIHZIZWlnaHQpO1xuXG4gICAgY29uc3QgbWluaW1hcDogUmVhY3QuUmVhY3ROb2RlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvd01pbmltYXAgfHwgdldpZHRoID09PSAwIHx8IHZIZWlnaHQgPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlTW91c2UgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSBib3VuZHMueCAtIHZXaWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gYm91bmRzLnkgLSB2SGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsTGVmdCA9ICh3aWR0aCAtIHNjcm9sbGVyLmNsaWVudFdpZHRoKSAqICh4IC8gKHcgLSB2V2lkdGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbFRvcCA9IChoZWlnaHQgLSBzY3JvbGxlci5jbGllbnRIZWlnaHQpICogKHkgLyAoaCAtIHZIZWlnaHQpKTtcblxuICAgICAgICAgICAgc2Nyb2xsZXIuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG5ld1Njcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBuZXdTY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IGUudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiA/IFwiYXV0b1wiIDogXCJzbW9vdGhcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TWluaW1hcFN0eWxlXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IHcsIGhlaWdodDogaCB9fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwibWluaW1hcC1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9ucyAhPT0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZShlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1vdXNlfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiIC8+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsb2NhdGlvbk1hcmtlclwiXG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IGUucHJldmVudERlZmF1bHQoKX1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBNYXRoLm1pbih2V2lkdGgsIHZIZWlnaHQgKiAwLjIsIDkpLFxuICAgICAgICAgICAgICAgICAgICB9fT48L2Rpdj5cbiAgICAgICAgICAgIDwvTWluaW1hcFN0eWxlPlxuICAgICAgICApO1xuICAgIH0sIFtoLCBoZWlnaHQsIGxlZnQsIHNjcm9sbGVyLCBzaG93TWluaW1hcCwgdG9wLCB2SGVpZ2h0LCB2V2lkdGgsIHcsIHdpZHRoXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8SW5maW5pdGVTY3JvbGxlclxuICAgICAgICAgICAgc2Nyb2xsUmVmPXtzY3JvbGxSZWZ9XG4gICAgICAgICAgICBtaW5pbWFwPXttaW5pbWFwfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3ByZXZlbnREaWFnb25hbFNjcm9sbGluZ31cbiAgICAgICAgICAgIGRyYWdnYWJsZT17aXNEcmFnZ2FibGUgPT09IHRydWUgfHwgdHlwZW9mIGlzRHJhZ2dhYmxlID09PSBcInN0cmluZ1wifVxuICAgICAgICAgICAgc2Nyb2xsV2lkdGg9e3dpZHRoICsgKHBhZGRpbmdSaWdodCA/PyAwKX1cbiAgICAgICAgICAgIHNjcm9sbEhlaWdodD17aGVpZ2h0ICsgKHBhZGRpbmdCb3R0b20gPz8gMCl9XG4gICAgICAgICAgICBjbGllbnRIZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17cmlnaHRFbGVtZW50fVxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbT17cGFkZGluZ0JvdHRvbX1cbiAgICAgICAgICAgIHBhZGRpbmdSaWdodD17cGFkZGluZ1JpZ2h0fVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3JpZ2h0RWxlbWVudFByb3BzfVxuICAgICAgICAgICAgdXBkYXRlPXtvblNjcm9sbFVwZGF0ZX1cbiAgICAgICAgICAgIGluaXRpYWxTaXplPXtpbml0aWFsU2l6ZX1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXtzY3JvbGxUb0VuZH0+XG4gICAgICAgICAgICA8RGF0YUdyaWREbmRcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldFJlZj17c2Nyb2xsUmVmfVxuICAgICAgICAgICAgICAgIHdpZHRoPXtjbGllbnRXaWR0aH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5SGVpZ2h0PXtwLmFjY2Vzc2liaWxpdHlIZWlnaHR9XG4gICAgICAgICAgICAgICAgY2FudmFzUmVmPXtwLmNhbnZhc1JlZn1cbiAgICAgICAgICAgICAgICBjZWxsWE9mZnNldD17cC5jZWxsWE9mZnNldH1cbiAgICAgICAgICAgICAgICBjZWxsWU9mZnNldD17cC5jZWxsWU9mZnNldH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtwLmNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXtwLmRpc2FibGVkUm93c31cbiAgICAgICAgICAgICAgICBlbmFibGVHcm91cHM9e3AuZW5hYmxlR3JvdXBzfVxuICAgICAgICAgICAgICAgIGZpbGxIYW5kbGU9e3AuZmlsbEhhbmRsZX1cbiAgICAgICAgICAgICAgICBmaXJzdENvbEFjY2Vzc2libGU9e3AuZmlyc3RDb2xBY2Nlc3NpYmxlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17cC5maXhlZFNoYWRvd1h9XG4gICAgICAgICAgICAgICAgZml4ZWRTaGFkb3dZPXtwLmZpeGVkU2hhZG93WX1cbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXtwLmZyZWV6ZUNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e3AuZ2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbFJlbmRlcmVyPXtwLmdldENlbGxSZW5kZXJlcn1cbiAgICAgICAgICAgICAgICBnZXRHcm91cERldGFpbHM9e3AuZ2V0R3JvdXBEZXRhaWxzfVxuICAgICAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3AuZ2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBncm91cEhlYWRlckhlaWdodD17cC5ncm91cEhlYWRlckhlaWdodH1cbiAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQ9e3AuaGVhZGVySGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnM9e3AuaGlnaGxpZ2h0UmVnaW9uc31cbiAgICAgICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17cC5pbWFnZVdpbmRvd0xvYWRlcn1cbiAgICAgICAgICAgICAgICBpc0ZpbGxpbmc9e3AuaXNGaWxsaW5nfVxuICAgICAgICAgICAgICAgIGlzRm9jdXNlZD17cC5pc0ZvY3VzZWR9XG4gICAgICAgICAgICAgICAgbG9ja0NvbHVtbnM9e3AubG9ja0NvbHVtbnN9XG4gICAgICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9e3AubWF4Q29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgbWluQ29sdW1uV2lkdGg9e3AubWluQ29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3Aub25IZWFkZXJNZW51Q2xpY2t9XG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e3Aub25Nb3VzZU1vdmV9XG4gICAgICAgICAgICAgICAgcHJlbGlnaHRDZWxscz17cC5wcmVsaWdodENlbGxzfVxuICAgICAgICAgICAgICAgIHJvd0hlaWdodD17cC5yb3dIZWlnaHR9XG4gICAgICAgICAgICAgICAgcm93cz17cC5yb3dzfVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbj17cC5zZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgdGhlbWU9e3AudGhlbWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dUeXBlPXtwLnRyYWlsaW5nUm93VHlwZX1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYPXtwLnRyYW5zbGF0ZVh9XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWT17cC50cmFuc2xhdGVZfVxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXtwLnZlcnRpY2FsQm9yZGVyfVxuICAgICAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXtwLmRyYXdDdXN0b21DZWxsfVxuICAgICAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3AuZHJhd0ZvY3VzUmluZ31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtwLmRyYXdIZWFkZXJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXtwLmV4cGVyaW1lbnRhbH1cbiAgICAgICAgICAgICAgICBncmlkUmVmPXtwLmdyaWRSZWZ9XG4gICAgICAgICAgICAgICAgaGVhZGVySWNvbnM9e3AuaGVhZGVySWNvbnN9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25DYW52YXNCbHVyPXtwLm9uQ2FudmFzQmx1cn1cbiAgICAgICAgICAgICAgICBvbkNhbnZhc0ZvY3VzZWQ9e3Aub25DYW52YXNGb2N1c2VkfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEZvY3VzZWQ9e3Aub25DZWxsRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtwLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e3Aub25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVFbmQ9e3Aub25Db2x1bW5SZXNpemVFbmR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVTdGFydD17cC5vbkNvbHVtblJlc2l6ZVN0YXJ0fVxuICAgICAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9e3Aub25Db250ZXh0TWVudX1cbiAgICAgICAgICAgICAgICBvbkRyYWdFbmQ9e3Aub25EcmFnRW5kfVxuICAgICAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXtwLm9uRHJhZ0xlYXZlfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtwLm9uRHJhZ092ZXJDZWxsfVxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtwLm9uRHJhZ1N0YXJ0fVxuICAgICAgICAgICAgICAgIG9uRHJvcD17cC5vbkRyb3B9XG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17cC5vbkl0ZW1Ib3ZlcmVkfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17cC5vbktleURvd259XG4gICAgICAgICAgICAgICAgb25LZXlVcD17cC5vbktleVVwfVxuICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtwLm9uTW91c2VEb3dufVxuICAgICAgICAgICAgICAgIG9uTW91c2VVcD17cC5vbk1vdXNlVXB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17cC5vblJvd01vdmVkfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3Auc21vb3RoU2Nyb2xsWH1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXtwLnNtb290aFNjcm9sbFl9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0luZmluaXRlU2Nyb2xsZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdyaWRTY3JvbGxlcjtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/scrolling-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx\",\"webpack://./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx\"],\"names\":[\".m3brspx\"],\"mappings\":\"AAoFMA,SAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,mCAAAA,CAAAA,wEAAAA,CAAAA,iBAAAA,CAAAA,SAAAA,CAAAA,uEAAAA,CAAAA,eAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,UAAAA,CAAAA,qCAAAA,CAAAA,4CAAAA,CAAAA,CAAAA,yBAAAA,iBAAAA,CAAAA,wCAAAA,CAAAA,wCAAAA,CAAAA;ACnFN,+tqBAA+tqB\",\"sourcesContent\":[\"import * as React from \\\"react\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport DataGridDnd, { DataGridDndProps } from \\\"../data-grid-dnd/data-grid-dnd\\\";\\nimport type { Rectangle } from \\\"../data-grid/data-grid-types\\\";\\nimport { InfiniteScroller } from \\\"./infinite-scroller\\\";\\nimport clamp from \\\"lodash/clamp.js\\\";\\n\\ntype Props = Omit<DataGridDndProps, \\\"width\\\" | \\\"height\\\" | \\\"eventTargetRef\\\">;\\n\\nexport interface ScrollingDataGridProps extends Props {\\n    readonly className: string | undefined;\\n    readonly onVisibleRegionChanged:\\n        | ((\\n              range: Rectangle,\\n              clientWidth: number,\\n              clientHeight: number,\\n              rightElWidth: number,\\n              tx: number,\\n              ty: number\\n          ) => void)\\n        | undefined;\\n    /**\\n     * Causes the grid to scroll to the end when flipped to true\\n     * @deprecated Use {@link DataEditorRef.scrollTo} instead\\n     * @group Deprecated\\n     */\\n    readonly scrollToEnd: boolean | undefined;\\n    readonly scrollRef: React.MutableRefObject<HTMLDivElement | null> | undefined;\\n\\n    /**\\n     * The overscroll properties are used to allow the grid to scroll past the logical end of the content by a fixed\\n     * number of pixels. This is useful particularly on the X axis if you allow for resizing columns as it can make\\n     * resizing the final column significantly easier.\\n     *\\n     * @group Advanced\\n     */\\n    readonly overscrollX: number | undefined;\\n    /** {@inheritDoc overscrollX}\\n     * @group Advanced\\n     */\\n    readonly overscrollY: number | undefined;\\n    /**\\n     * Provides an initial size for the grid which can prevent a flicker on load if the initial size is known prior to\\n     * layout.\\n     *\\n     * @group Advanced\\n     */\\n    readonly initialSize: readonly [width: number, height: number] | undefined;\\n    /**\\n     * Set to true to prevent any diagonal scrolling.\\n     * @group Advanced\\n     */\\n    readonly preventDiagonalScrolling: boolean | undefined;\\n\\n    /**\\n     * If `rightElementProps.sticky` is set to true the right element will be visible at all times, otherwise the user\\n     * will need to scroll to the end to reveal it.\\n     *\\n     * If `rightElementProps.fill` is set, the right elements container will fill to consume all remaining space (if\\n     * any) at the end of the grid. This does not play nice with growing columns.\\n     *\\n     * @group Advanced\\n     */\\n    readonly rightElementProps:\\n        | {\\n              readonly sticky?: boolean;\\n              readonly fill?: boolean;\\n          }\\n        | undefined;\\n    /**\\n     * The right element is a DOM node which can be inserted at the end of the horizontal scroll region. This can be\\n     * used to create a right handle panel, make a big add button, or display messages.\\n     * @group Advanced\\n     */\\n    readonly rightElement: React.ReactNode | undefined;\\n    /**\\n     * Enables/disables the interactive minimap.\\n     * @defaultValue false\\n     * @group Advanced\\n     */\\n    readonly showMinimap: boolean | undefined;\\n    readonly clientSize: readonly [number, number];\\n}\\n\\nconst MinimapStyle = styled.div`\\n    position: absolute;\\n    right: 44px;\\n    bottom: 44px;\\n    background-color: var(--gdg-bg-cell);\\n    background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\\n    border-radius: 4px;\\n    z-index: 1;\\n    box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\\n\\n    overflow: hidden;\\n\\n    .header {\\n        position: absolute;\\n        left: 0;\\n        top: 0;\\n        width: 100%;\\n        height: 4px;\\n        background-color: var(--gdg-bg-header);\\n        box-shadow: 0 0 0 1px var(--gdg-border-color);\\n    }\\n\\n    .locationMarker {\\n        position: absolute;\\n\\n        border: 1px solid var(--gdg-accent-color);\\n        background-color: var(--gdg-accent-light);\\n    }\\n`;\\n\\nconst GridScroller: React.FunctionComponent<ScrollingDataGridProps> = p => {\\n    const {\\n        columns,\\n        rows,\\n        rowHeight,\\n        headerHeight,\\n        groupHeaderHeight,\\n        enableGroups,\\n        freezeColumns,\\n        experimental,\\n        clientSize,\\n        className,\\n        onVisibleRegionChanged,\\n        scrollToEnd,\\n        scrollRef,\\n        preventDiagonalScrolling,\\n        rightElement,\\n        rightElementProps,\\n        overscrollX,\\n        overscrollY,\\n        showMinimap = false,\\n        initialSize,\\n        smoothScrollX = false,\\n        smoothScrollY = false,\\n        isDraggable,\\n    } = p;\\n    const { paddingRight, paddingBottom } = experimental ?? {};\\n\\n    const [clientWidth, clientHeight] = clientSize;\\n    const last = React.useRef<Rectangle | undefined>();\\n    const lastX = React.useRef<number | undefined>();\\n    const lastY = React.useRef<number | undefined>();\\n    const lastSize = React.useRef<readonly [number, number] | undefined>();\\n\\n    const width = React.useMemo(() => {\\n        let r = Math.max(0, overscrollX ?? 0);\\n        for (const c of columns) {\\n            r += c.width;\\n        }\\n        return r;\\n    }, [columns, overscrollX]);\\n\\n    let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\\n    if (typeof rowHeight === \\\"number\\\") {\\n        height += rows * rowHeight;\\n    } else {\\n        for (let r = 0; r < rows; r++) {\\n            height += rowHeight(r);\\n        }\\n    }\\n    if (overscrollY !== undefined) {\\n        height += overscrollY;\\n    }\\n\\n    const lastArgs = React.useRef<Rectangle & { paddingRight: number }>();\\n\\n    const processArgs = React.useCallback(() => {\\n        if (lastArgs.current === undefined) return;\\n        const args = { ...lastArgs.current };\\n\\n        let x = 0;\\n        let tx = args.x < 0 ? -args.x : 0;\\n        let cellRight = 0;\\n        let cellX = 0;\\n\\n        args.x = args.x < 0 ? 0 : args.x;\\n\\n        let stickyColWidth = 0;\\n        for (let i = 0; i < freezeColumns; i++) {\\n            stickyColWidth += columns[i].width;\\n        }\\n\\n        for (const c of columns) {\\n            const cx = x - stickyColWidth;\\n            if (args.x >= cx + c.width) {\\n                x += c.width;\\n                cellX++;\\n                cellRight++;\\n            } else if (args.x > cx) {\\n                x += c.width;\\n                if (smoothScrollX) {\\n                    tx += cx - args.x;\\n                } else {\\n                    cellX++;\\n                }\\n                cellRight++;\\n            } else if (args.x + args.width > cx) {\\n                x += c.width;\\n                cellRight++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        let ty = 0;\\n        let cellY = 0;\\n        let cellBottom = 0;\\n        if (typeof rowHeight === \\\"number\\\") {\\n            if (smoothScrollY) {\\n                cellY = Math.floor(args.y / rowHeight);\\n                ty = cellY * rowHeight - args.y;\\n            } else {\\n                cellY = Math.ceil(args.y / rowHeight);\\n            }\\n            cellBottom = Math.ceil(args.height / rowHeight) + cellY;\\n            if (ty < 0) cellBottom++;\\n        } else {\\n            let y = 0;\\n            for (let row = 0; row < rows; row++) {\\n                const rh = rowHeight(row);\\n                const cy = y + (smoothScrollY ? 0 : rh / 2);\\n                if (args.y >= y + rh) {\\n                    y += rh;\\n                    cellY++;\\n                    cellBottom++;\\n                } else if (args.y > cy) {\\n                    y += rh;\\n                    if (smoothScrollY) {\\n                        ty += cy - args.y;\\n                    } else {\\n                        cellY++;\\n                    }\\n                    cellBottom++;\\n                } else if (args.y + args.height > rh / 2 + y) {\\n                    y += rh;\\n                    cellBottom++;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        const rect: Rectangle = {\\n            x: cellX,\\n            y: cellY,\\n            width: cellRight - cellX,\\n            height: cellBottom - cellY,\\n        };\\n\\n        const oldRect = last.current;\\n\\n        if (\\n            oldRect === undefined ||\\n            oldRect.y !== rect.y ||\\n            oldRect.x !== rect.x ||\\n            oldRect.height !== rect.height ||\\n            oldRect.width !== rect.width ||\\n            lastX.current !== tx ||\\n            lastY.current !== ty ||\\n            args.width !== lastSize.current?.[0] ||\\n            args.height !== lastSize.current?.[1]\\n        ) {\\n            onVisibleRegionChanged?.(\\n                {\\n                    x: cellX,\\n                    y: cellY,\\n                    width: cellRight - cellX,\\n                    height: cellBottom - cellY,\\n                },\\n                args.width,\\n                args.height,\\n                args.paddingRight ?? 0,\\n                tx,\\n                ty\\n            );\\n            last.current = rect;\\n            lastX.current = tx;\\n            lastY.current = ty;\\n            lastSize.current = [args.width, args.height];\\n        }\\n    }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\\n\\n    const onScrollUpdate = React.useCallback(\\n        (args: Rectangle & { paddingRight: number }) => {\\n            lastArgs.current = args;\\n            processArgs();\\n        },\\n        [processArgs]\\n    );\\n\\n    React.useEffect(() => {\\n        processArgs();\\n    }, [processArgs]);\\n\\n    const scroller = scrollRef?.current ?? undefined;\\n    const aspect = clamp(width / height, 2 / 3, 1.5);\\n    const maxSize = 200;\\n    const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);\\n    const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;\\n    const hRatio = w / width;\\n    const vRatio = h / height;\\n    const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);\\n    const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);\\n    const left = ((scroller?.scrollLeft ?? 0) / (width - clientWidth)) * (w - vWidth);\\n    const top = ((scroller?.scrollTop ?? 0) / (height - clientHeight)) * (h - vHeight);\\n\\n    const minimap: React.ReactNode = React.useMemo(() => {\\n        if (!showMinimap || vWidth === 0 || vHeight === 0) return undefined;\\n\\n        const handleMouse = (e: React.MouseEvent) => {\\n            if (scroller === undefined) return;\\n            const bounds = e.currentTarget.getBoundingClientRect();\\n            const x = e.clientX - bounds.x - vWidth / 2;\\n            const y = e.clientY - bounds.y - vHeight / 2;\\n\\n            const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));\\n            const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));\\n\\n            scroller.scrollTo({\\n                left: newScrollLeft,\\n                top: newScrollTop,\\n                behavior: e.type === \\\"mousemove\\\" ? \\\"auto\\\" : \\\"smooth\\\",\\n            });\\n        };\\n\\n        return (\\n            <MinimapStyle\\n                style={{ width: w, height: h }}\\n                data-testid=\\\"minimap-container\\\"\\n                onMouseMove={e => {\\n                    if (e.buttons !== 1) return;\\n                    handleMouse(e);\\n                }}\\n                onClick={handleMouse}>\\n                <div className=\\\"header\\\" />\\n                <div\\n                    className=\\\"locationMarker\\\"\\n                    onDragStart={e => e.preventDefault()}\\n                    style={{\\n                        left,\\n                        top,\\n                        width: vWidth,\\n                        height: vHeight,\\n                        borderRadius: Math.min(vWidth, vHeight * 0.2, 9),\\n                    }}></div>\\n            </MinimapStyle>\\n        );\\n    }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);\\n\\n    return (\\n        <InfiniteScroller\\n            scrollRef={scrollRef}\\n            minimap={minimap}\\n            className={className}\\n            preventDiagonalScrolling={preventDiagonalScrolling}\\n            draggable={isDraggable === true || typeof isDraggable === \\\"string\\\"}\\n            scrollWidth={width + (paddingRight ?? 0)}\\n            scrollHeight={height + (paddingBottom ?? 0)}\\n            clientHeight={clientHeight}\\n            rightElement={rightElement}\\n            paddingBottom={paddingBottom}\\n            paddingRight={paddingRight}\\n            rightElementProps={rightElementProps}\\n            update={onScrollUpdate}\\n            initialSize={initialSize}\\n            scrollToEnd={scrollToEnd}>\\n            <DataGridDnd\\n                eventTargetRef={scrollRef}\\n                width={clientWidth}\\n                height={clientHeight}\\n                accessibilityHeight={p.accessibilityHeight}\\n                canvasRef={p.canvasRef}\\n                cellXOffset={p.cellXOffset}\\n                cellYOffset={p.cellYOffset}\\n                columns={p.columns}\\n                disabledRows={p.disabledRows}\\n                enableGroups={p.enableGroups}\\n                fillHandle={p.fillHandle}\\n                firstColAccessible={p.firstColAccessible}\\n                fixedShadowX={p.fixedShadowX}\\n                fixedShadowY={p.fixedShadowY}\\n                freezeColumns={p.freezeColumns}\\n                getCellContent={p.getCellContent}\\n                getCellRenderer={p.getCellRenderer}\\n                getGroupDetails={p.getGroupDetails}\\n                getRowThemeOverride={p.getRowThemeOverride}\\n                groupHeaderHeight={p.groupHeaderHeight}\\n                headerHeight={p.headerHeight}\\n                highlightRegions={p.highlightRegions}\\n                imageWindowLoader={p.imageWindowLoader}\\n                isFilling={p.isFilling}\\n                isFocused={p.isFocused}\\n                lockColumns={p.lockColumns}\\n                maxColumnWidth={p.maxColumnWidth}\\n                minColumnWidth={p.minColumnWidth}\\n                onHeaderMenuClick={p.onHeaderMenuClick}\\n                onMouseMove={p.onMouseMove}\\n                prelightCells={p.prelightCells}\\n                rowHeight={p.rowHeight}\\n                rows={p.rows}\\n                selection={p.selection}\\n                theme={p.theme}\\n                trailingRowType={p.trailingRowType}\\n                translateX={p.translateX}\\n                translateY={p.translateY}\\n                verticalBorder={p.verticalBorder}\\n                drawCustomCell={p.drawCustomCell}\\n                drawFocusRing={p.drawFocusRing}\\n                drawHeader={p.drawHeader}\\n                experimental={p.experimental}\\n                gridRef={p.gridRef}\\n                headerIcons={p.headerIcons}\\n                isDraggable={p.isDraggable}\\n                onCanvasBlur={p.onCanvasBlur}\\n                onCanvasFocused={p.onCanvasFocused}\\n                onCellFocused={p.onCellFocused}\\n                onColumnMoved={p.onColumnMoved}\\n                onColumnResize={p.onColumnResize}\\n                onColumnResizeEnd={p.onColumnResizeEnd}\\n                onColumnResizeStart={p.onColumnResizeStart}\\n                onContextMenu={p.onContextMenu}\\n                onDragEnd={p.onDragEnd}\\n                onDragLeave={p.onDragLeave}\\n                onDragOverCell={p.onDragOverCell}\\n                onDragStart={p.onDragStart}\\n                onDrop={p.onDrop}\\n                onItemHovered={p.onItemHovered}\\n                onKeyDown={p.onKeyDown}\\n                onKeyUp={p.onKeyUp}\\n                onMouseDown={p.onMouseDown}\\n                onMouseUp={p.onMouseUp}\\n                onRowMoved={p.onRowMoved}\\n                smoothScrollX={p.smoothScrollX}\\n                smoothScrollY={p.smoothScrollY}\\n            />\\n        </InfiniteScroller>\\n    );\\n};\\n\\nexport default GridScroller;\\n\",\".m3brspx{position:absolute;right:44px;bottom:44px;background-color:var(--gdg-bg-cell);background:linear-gradient(var(--gdg-bg-cell),var(--gdg-bg-cell-medium));border-radius:4px;z-index:1;box-shadow:0 0 0 1px var(--gdg-border-color),0 2px 5px rgba(0,0,0,0.08);overflow:hidden;}.m3brspx .header{position:absolute;left:0;top:0;width:100%;height:4px;background-color:var(--gdg-bg-header);box-shadow:0 0 0 1px var(--gdg-border-color);}.m3brspx .locationMarker{position:absolute;border:1px solid var(--gdg-accent-color);background-color:var(--gdg-accent-light);}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC50c3giXSwibmFtZXMiOlsiLm0zYnJzcHgiXSwibWFwcGluZ3MiOiJBQW9GTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgRGF0YUdyaWREbmQsIHsgRGF0YUdyaWREbmRQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWdyaWQtZG5kL2RhdGEtZ3JpZC1kbmRcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsZXIgfSBmcm9tIFwiLi9pbmZpbml0ZS1zY3JvbGxlclwiO1xuaW1wb3J0IGNsYW1wIGZyb20gXCJsb2Rhc2gvY2xhbXAuanNcIjtcblxudHlwZSBQcm9wcyA9IE9taXQ8RGF0YUdyaWREbmRQcm9wcywgXCJ3aWR0aFwiIHwgXCJoZWlnaHRcIiB8IFwiZXZlbnRUYXJnZXRSZWZcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsaW5nRGF0YUdyaWRQcm9wcyBleHRlbmRzIFByb3BzIHtcbiAgICByZWFkb25seSBjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBvblZpc2libGVSZWdpb25DaGFuZ2VkOlxuICAgICAgICB8ICgoXG4gICAgICAgICAgICAgIHJhbmdlOiBSZWN0YW5nbGUsXG4gICAgICAgICAgICAgIGNsaWVudFdpZHRoOiBudW1iZXIsXG4gICAgICAgICAgICAgIGNsaWVudEhlaWdodDogbnVtYmVyLFxuICAgICAgICAgICAgICByaWdodEVsV2lkdGg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHk6IG51bWJlclxuICAgICAgICAgICkgPT4gdm9pZClcbiAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBncmlkIHRvIHNjcm9sbCB0byB0aGUgZW5kIHdoZW4gZmxpcHBlZCB0byB0cnVlXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBEYXRhRWRpdG9yUmVmLnNjcm9sbFRvfSBpbnN0ZWFkXG4gICAgICogQGdyb3VwIERlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzY3JvbGxUb0VuZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBzY3JvbGxSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQgfCBudWxsPiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdmVyc2Nyb2xsIHByb3BlcnRpZXMgYXJlIHVzZWQgdG8gYWxsb3cgdGhlIGdyaWQgdG8gc2Nyb2xsIHBhc3QgdGhlIGxvZ2ljYWwgZW5kIG9mIHRoZSBjb250ZW50IGJ5IGEgZml4ZWRcbiAgICAgKiBudW1iZXIgb2YgcGl4ZWxzLiBUaGlzIGlzIHVzZWZ1bCBwYXJ0aWN1bGFybHkgb24gdGhlIFggYXhpcyBpZiB5b3UgYWxsb3cgZm9yIHJlc2l6aW5nIGNvbHVtbnMgYXMgaXQgY2FuIG1ha2VcbiAgICAgKiByZXNpemluZyB0aGUgZmluYWwgY29sdW1uIHNpZ25pZmljYW50bHkgZWFzaWVyLlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgb3ZlcnNjcm9sbFg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKioge0Bpbmhlcml0RG9jIG92ZXJzY3JvbGxYfVxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IG92ZXJzY3JvbGxZOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW5pdGlhbCBzaXplIGZvciB0aGUgZ3JpZCB3aGljaCBjYW4gcHJldmVudCBhIGZsaWNrZXIgb24gbG9hZCBpZiB0aGUgaW5pdGlhbCBzaXplIGlzIGtub3duIHByaW9yIHRvXG4gICAgICogbGF5b3V0LlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgaW5pdGlhbFNpemU6IHJlYWRvbmx5IFt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcl0gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gcHJldmVudCBhbnkgZGlhZ29uYWwgc2Nyb2xsaW5nLlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHByZXZlbnREaWFnb25hbFNjcm9sbGluZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIElmIGByaWdodEVsZW1lbnRQcm9wcy5zdGlja3lgIGlzIHNldCB0byB0cnVlIHRoZSByaWdodCBlbGVtZW50IHdpbGwgYmUgdmlzaWJsZSBhdCBhbGwgdGltZXMsIG90aGVyd2lzZSB0aGUgdXNlclxuICAgICAqIHdpbGwgbmVlZCB0byBzY3JvbGwgdG8gdGhlIGVuZCB0byByZXZlYWwgaXQuXG4gICAgICpcbiAgICAgKiBJZiBgcmlnaHRFbGVtZW50UHJvcHMuZmlsbGAgaXMgc2V0LCB0aGUgcmlnaHQgZWxlbWVudHMgY29udGFpbmVyIHdpbGwgZmlsbCB0byBjb25zdW1lIGFsbCByZW1haW5pbmcgc3BhY2UgKGlmXG4gICAgICogYW55KSBhdCB0aGUgZW5kIG9mIHRoZSBncmlkLiBUaGlzIGRvZXMgbm90IHBsYXkgbmljZSB3aXRoIGdyb3dpbmcgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJpZ2h0RWxlbWVudFByb3BzOlxuICAgICAgICB8IHtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgICAgICAgfVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmlnaHQgZWxlbWVudCBpcyBhIERPTSBub2RlIHdoaWNoIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCByZWdpb24uIFRoaXMgY2FuIGJlXG4gICAgICogdXNlZCB0byBjcmVhdGUgYSByaWdodCBoYW5kbGUgcGFuZWwsIG1ha2UgYSBiaWcgYWRkIGJ1dHRvbiwgb3IgZGlzcGxheSBtZXNzYWdlcy5cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHRoZSBpbnRlcmFjdGl2ZSBtaW5pbWFwLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgZmFsc2VcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzaG93TWluaW1hcDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBjbGllbnRTaXplOiByZWFkb25seSBbbnVtYmVyLCBudW1iZXJdO1xufVxuXG5jb25zdCBNaW5pbWFwU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogNDRweDtcbiAgICBib3R0b206IDQ0cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh2YXIoLS1nZGctYmctY2VsbCksIHZhcigtLWdkZy1iZy1jZWxsLW1lZGl1bSkpO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB6LWluZGV4OiAxO1xuICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKSwgMCAycHggNXB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgLmhlYWRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiA0cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXIpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuXG4gICAgLmxvY2F0aW9uTWFya2VyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICB9XG5gO1xuXG5jb25zdCBHcmlkU2Nyb2xsZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFNjcm9sbGluZ0RhdGFHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBjb2x1bW5zLFxuICAgICAgICByb3dzLFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgICAgZ3JvdXBIZWFkZXJIZWlnaHQsXG4gICAgICAgIGVuYWJsZUdyb3VwcyxcbiAgICAgICAgZnJlZXplQ29sdW1ucyxcbiAgICAgICAgZXhwZXJpbWVudGFsLFxuICAgICAgICBjbGllbnRTaXplLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZyxcbiAgICAgICAgcmlnaHRFbGVtZW50LFxuICAgICAgICByaWdodEVsZW1lbnRQcm9wcyxcbiAgICAgICAgb3ZlcnNjcm9sbFgsXG4gICAgICAgIG92ZXJzY3JvbGxZLFxuICAgICAgICBzaG93TWluaW1hcCA9IGZhbHNlLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgc21vb3RoU2Nyb2xsWCA9IGZhbHNlLFxuICAgICAgICBzbW9vdGhTY3JvbGxZID0gZmFsc2UsXG4gICAgICAgIGlzRHJhZ2dhYmxlLFxuICAgIH0gPSBwO1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBleHBlcmltZW50YWwgPz8ge307XG5cbiAgICBjb25zdCBbY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodF0gPSBjbGllbnRTaXplO1xuICAgIGNvbnN0IGxhc3QgPSBSZWFjdC51c2VSZWY8UmVjdGFuZ2xlIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RYID0gUmVhY3QudXNlUmVmPG51bWJlciB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0WSA9IFJlYWN0LnVzZVJlZjxudW1iZXIgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFNpemUgPSBSZWFjdC51c2VSZWY8cmVhZG9ubHkgW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IHdpZHRoID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCByID0gTWF0aC5tYXgoMCwgb3ZlcnNjcm9sbFggPz8gMCk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgICByICs9IGMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSwgW2NvbHVtbnMsIG92ZXJzY3JvbGxYXSk7XG5cbiAgICBsZXQgaGVpZ2h0ID0gZW5hYmxlR3JvdXBzID8gaGVhZGVySGVpZ2h0ICsgZ3JvdXBIZWFkZXJIZWlnaHQgOiBoZWFkZXJIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHJvd3MgKiByb3dIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICAgIGhlaWdodCArPSByb3dIZWlnaHQocik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJzY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ICs9IG92ZXJzY3JvbGxZO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RBcmdzID0gUmVhY3QudXNlUmVmPFJlY3RhbmdsZSAmIHsgcGFkZGluZ1JpZ2h0OiBudW1iZXIgfT4oKTtcblxuICAgIGNvbnN0IHByb2Nlc3NBcmdzID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAobGFzdEFyZ3MuY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7IC4uLmxhc3RBcmdzLmN1cnJlbnQgfTtcblxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB0eCA9IGFyZ3MueCA8IDAgPyAtYXJncy54IDogMDtcbiAgICAgICAgbGV0IGNlbGxSaWdodCA9IDA7XG4gICAgICAgIGxldCBjZWxsWCA9IDA7XG5cbiAgICAgICAgYXJncy54ID0gYXJncy54IDwgMCA/IDAgOiBhcmdzLng7XG5cbiAgICAgICAgbGV0IHN0aWNreUNvbFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmVlemVDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIHN0aWNreUNvbFdpZHRoICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sdW1ucykge1xuICAgICAgICAgICAgY29uc3QgY3ggPSB4IC0gc3RpY2t5Q29sV2lkdGg7XG4gICAgICAgICAgICBpZiAoYXJncy54ID49IGN4ICsgYy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnggPiBjeCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSBjeCAtIGFyZ3MueDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy54ICsgYXJncy53aWR0aCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0eSA9IDA7XG4gICAgICAgIGxldCBjZWxsWSA9IDA7XG4gICAgICAgIGxldCBjZWxsQm90dG9tID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmZsb29yKGFyZ3MueSAvIHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgdHkgPSBjZWxsWSAqIHJvd0hlaWdodCAtIGFyZ3MueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmNlaWwoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxCb3R0b20gPSBNYXRoLmNlaWwoYXJncy5oZWlnaHQgLyByb3dIZWlnaHQpICsgY2VsbFk7XG4gICAgICAgICAgICBpZiAodHkgPCAwKSBjZWxsQm90dG9tKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJoID0gcm93SGVpZ2h0KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3kgPSB5ICsgKHNtb290aFNjcm9sbFkgPyAwIDogcmggLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy55ID49IHkgKyByaCkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnkgPiBjeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHkgKz0gY3kgLSBhcmdzLnk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueSArIGFyZ3MuaGVpZ2h0ID4gcmggLyAyICsgeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjdDogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogY2VsbFgsXG4gICAgICAgICAgICB5OiBjZWxsWSxcbiAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgIGhlaWdodDogY2VsbEJvdHRvbSAtIGNlbGxZLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9sZFJlY3QgPSBsYXN0LmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2xkUmVjdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBvbGRSZWN0LnkgIT09IHJlY3QueSB8fFxuICAgICAgICAgICAgb2xkUmVjdC54ICE9PSByZWN0LnggfHxcbiAgICAgICAgICAgIG9sZFJlY3QuaGVpZ2h0ICE9PSByZWN0LmhlaWdodCB8fFxuICAgICAgICAgICAgb2xkUmVjdC53aWR0aCAhPT0gcmVjdC53aWR0aCB8fFxuICAgICAgICAgICAgbGFzdFguY3VycmVudCAhPT0gdHggfHxcbiAgICAgICAgICAgIGxhc3RZLmN1cnJlbnQgIT09IHR5IHx8XG4gICAgICAgICAgICBhcmdzLndpZHRoICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMF0gfHxcbiAgICAgICAgICAgIGFyZ3MuaGVpZ2h0ICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPy4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4OiBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjZWxsQm90dG9tIC0gY2VsbFksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmdzLndpZHRoLFxuICAgICAgICAgICAgICAgIGFyZ3MuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFyZ3MucGFkZGluZ1JpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgdHgsXG4gICAgICAgICAgICAgICAgdHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsYXN0LmN1cnJlbnQgPSByZWN0O1xuICAgICAgICAgICAgbGFzdFguY3VycmVudCA9IHR4O1xuICAgICAgICAgICAgbGFzdFkuY3VycmVudCA9IHR5O1xuICAgICAgICAgICAgbGFzdFNpemUuY3VycmVudCA9IFthcmdzLndpZHRoLCBhcmdzLmhlaWdodF07XG4gICAgICAgIH1cbiAgICB9LCBbY29sdW1ucywgcm93SGVpZ2h0LCByb3dzLCBvblZpc2libGVSZWdpb25DaGFuZ2VkLCBmcmVlemVDb2x1bW5zLCBzbW9vdGhTY3JvbGxYLCBzbW9vdGhTY3JvbGxZXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoYXJnczogUmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBsYXN0QXJncy5jdXJyZW50ID0gYXJncztcbiAgICAgICAgICAgIHByb2Nlc3NBcmdzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtwcm9jZXNzQXJnc11cbiAgICApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvY2Vzc0FyZ3MoKTtcbiAgICB9LCBbcHJvY2Vzc0FyZ3NdKTtcblxuICAgIGNvbnN0IHNjcm9sbGVyID0gc2Nyb2xsUmVmPy5jdXJyZW50ID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhc3BlY3QgPSBjbGFtcCh3aWR0aCAvIGhlaWdodCwgMiAvIDMsIDEuNSk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IDIwMDtcbiAgICBjb25zdCB3ID0gYXNwZWN0ID4gMSA/IG1heFNpemUgOiBNYXRoLmNlaWwobWF4U2l6ZSAqIGFzcGVjdCk7XG4gICAgY29uc3QgaCA9IGFzcGVjdCA+IDEgPyBNYXRoLmNlaWwobWF4U2l6ZSAvIGFzcGVjdCkgOiBtYXhTaXplO1xuICAgIGNvbnN0IGhSYXRpbyA9IHcgLyB3aWR0aDtcbiAgICBjb25zdCB2UmF0aW8gPSBoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHZXaWR0aCA9IE1hdGgubWluKGNsaWVudFdpZHRoICogTWF0aC5tYXgoaFJhdGlvLCAwLjAxKSwgdyk7XG4gICAgY29uc3QgdkhlaWdodCA9IE1hdGgubWluKGNsaWVudEhlaWdodCAqIE1hdGgubWF4KHZSYXRpbywgMC4wMSksIGgpO1xuICAgIGNvbnN0IGxlZnQgPSAoKHNjcm9sbGVyPy5zY3JvbGxMZWZ0ID8/IDApIC8gKHdpZHRoIC0gY2xpZW50V2lkdGgpKSAqICh3IC0gdldpZHRoKTtcbiAgICBjb25zdCB0b3AgPSAoKHNjcm9sbGVyPy5zY3JvbGxUb3AgPz8gMCkgLyAoaGVpZ2h0IC0gY2xpZW50SGVpZ2h0KSkgKiAoaCAtIHZIZWlnaHQpO1xuXG4gICAgY29uc3QgbWluaW1hcDogUmVhY3QuUmVhY3ROb2RlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvd01pbmltYXAgfHwgdldpZHRoID09PSAwIHx8IHZIZWlnaHQgPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlTW91c2UgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSBib3VuZHMueCAtIHZXaWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gYm91bmRzLnkgLSB2SGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsTGVmdCA9ICh3aWR0aCAtIHNjcm9sbGVyLmNsaWVudFdpZHRoKSAqICh4IC8gKHcgLSB2V2lkdGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbFRvcCA9IChoZWlnaHQgLSBzY3JvbGxlci5jbGllbnRIZWlnaHQpICogKHkgLyAoaCAtIHZIZWlnaHQpKTtcblxuICAgICAgICAgICAgc2Nyb2xsZXIuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG5ld1Njcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBuZXdTY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IGUudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiA/IFwiYXV0b1wiIDogXCJzbW9vdGhcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TWluaW1hcFN0eWxlXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IHcsIGhlaWdodDogaCB9fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwibWluaW1hcC1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9ucyAhPT0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZShlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1vdXNlfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiIC8+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsb2NhdGlvbk1hcmtlclwiXG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IGUucHJldmVudERlZmF1bHQoKX1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBNYXRoLm1pbih2V2lkdGgsIHZIZWlnaHQgKiAwLjIsIDkpLFxuICAgICAgICAgICAgICAgICAgICB9fT48L2Rpdj5cbiAgICAgICAgICAgIDwvTWluaW1hcFN0eWxlPlxuICAgICAgICApO1xuICAgIH0sIFtoLCBoZWlnaHQsIGxlZnQsIHNjcm9sbGVyLCBzaG93TWluaW1hcCwgdG9wLCB2SGVpZ2h0LCB2V2lkdGgsIHcsIHdpZHRoXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8SW5maW5pdGVTY3JvbGxlclxuICAgICAgICAgICAgc2Nyb2xsUmVmPXtzY3JvbGxSZWZ9XG4gICAgICAgICAgICBtaW5pbWFwPXttaW5pbWFwfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3ByZXZlbnREaWFnb25hbFNjcm9sbGluZ31cbiAgICAgICAgICAgIGRyYWdnYWJsZT17aXNEcmFnZ2FibGUgPT09IHRydWUgfHwgdHlwZW9mIGlzRHJhZ2dhYmxlID09PSBcInN0cmluZ1wifVxuICAgICAgICAgICAgc2Nyb2xsV2lkdGg9e3dpZHRoICsgKHBhZGRpbmdSaWdodCA/PyAwKX1cbiAgICAgICAgICAgIHNjcm9sbEhlaWdodD17aGVpZ2h0ICsgKHBhZGRpbmdCb3R0b20gPz8gMCl9XG4gICAgICAgICAgICBjbGllbnRIZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17cmlnaHRFbGVtZW50fVxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbT17cGFkZGluZ0JvdHRvbX1cbiAgICAgICAgICAgIHBhZGRpbmdSaWdodD17cGFkZGluZ1JpZ2h0fVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3JpZ2h0RWxlbWVudFByb3BzfVxuICAgICAgICAgICAgdXBkYXRlPXtvblNjcm9sbFVwZGF0ZX1cbiAgICAgICAgICAgIGluaXRpYWxTaXplPXtpbml0aWFsU2l6ZX1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXtzY3JvbGxUb0VuZH0+XG4gICAgICAgICAgICA8RGF0YUdyaWREbmRcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldFJlZj17c2Nyb2xsUmVmfVxuICAgICAgICAgICAgICAgIHdpZHRoPXtjbGllbnRXaWR0aH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5SGVpZ2h0PXtwLmFjY2Vzc2liaWxpdHlIZWlnaHR9XG4gICAgICAgICAgICAgICAgY2FudmFzUmVmPXtwLmNhbnZhc1JlZn1cbiAgICAgICAgICAgICAgICBjZWxsWE9mZnNldD17cC5jZWxsWE9mZnNldH1cbiAgICAgICAgICAgICAgICBjZWxsWU9mZnNldD17cC5jZWxsWU9mZnNldH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtwLmNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXtwLmRpc2FibGVkUm93c31cbiAgICAgICAgICAgICAgICBlbmFibGVHcm91cHM9e3AuZW5hYmxlR3JvdXBzfVxuICAgICAgICAgICAgICAgIGZpbGxIYW5kbGU9e3AuZmlsbEhhbmRsZX1cbiAgICAgICAgICAgICAgICBmaXJzdENvbEFjY2Vzc2libGU9e3AuZmlyc3RDb2xBY2Nlc3NpYmxlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17cC5maXhlZFNoYWRvd1h9XG4gICAgICAgICAgICAgICAgZml4ZWRTaGFkb3dZPXtwLmZpeGVkU2hhZG93WX1cbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXtwLmZyZWV6ZUNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e3AuZ2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbFJlbmRlcmVyPXtwLmdldENlbGxSZW5kZXJlcn1cbiAgICAgICAgICAgICAgICBnZXRHcm91cERldGFpbHM9e3AuZ2V0R3JvdXBEZXRhaWxzfVxuICAgICAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3AuZ2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBncm91cEhlYWRlckhlaWdodD17cC5ncm91cEhlYWRlckhlaWdodH1cbiAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQ9e3AuaGVhZGVySGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnM9e3AuaGlnaGxpZ2h0UmVnaW9uc31cbiAgICAgICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17cC5pbWFnZVdpbmRvd0xvYWRlcn1cbiAgICAgICAgICAgICAgICBpc0ZpbGxpbmc9e3AuaXNGaWxsaW5nfVxuICAgICAgICAgICAgICAgIGlzRm9jdXNlZD17cC5pc0ZvY3VzZWR9XG4gICAgICAgICAgICAgICAgbG9ja0NvbHVtbnM9e3AubG9ja0NvbHVtbnN9XG4gICAgICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9e3AubWF4Q29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgbWluQ29sdW1uV2lkdGg9e3AubWluQ29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3Aub25IZWFkZXJNZW51Q2xpY2t9XG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e3Aub25Nb3VzZU1vdmV9XG4gICAgICAgICAgICAgICAgcHJlbGlnaHRDZWxscz17cC5wcmVsaWdodENlbGxzfVxuICAgICAgICAgICAgICAgIHJvd0hlaWdodD17cC5yb3dIZWlnaHR9XG4gICAgICAgICAgICAgICAgcm93cz17cC5yb3dzfVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbj17cC5zZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgdGhlbWU9e3AudGhlbWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dUeXBlPXtwLnRyYWlsaW5nUm93VHlwZX1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYPXtwLnRyYW5zbGF0ZVh9XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWT17cC50cmFuc2xhdGVZfVxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXtwLnZlcnRpY2FsQm9yZGVyfVxuICAgICAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXtwLmRyYXdDdXN0b21DZWxsfVxuICAgICAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3AuZHJhd0ZvY3VzUmluZ31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtwLmRyYXdIZWFkZXJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXtwLmV4cGVyaW1lbnRhbH1cbiAgICAgICAgICAgICAgICBncmlkUmVmPXtwLmdyaWRSZWZ9XG4gICAgICAgICAgICAgICAgaGVhZGVySWNvbnM9e3AuaGVhZGVySWNvbnN9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25DYW52YXNCbHVyPXtwLm9uQ2FudmFzQmx1cn1cbiAgICAgICAgICAgICAgICBvbkNhbnZhc0ZvY3VzZWQ9e3Aub25DYW52YXNGb2N1c2VkfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEZvY3VzZWQ9e3Aub25DZWxsRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtwLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e3Aub25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVFbmQ9e3Aub25Db2x1bW5SZXNpemVFbmR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVTdGFydD17cC5vbkNvbHVtblJlc2l6ZVN0YXJ0fVxuICAgICAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9e3Aub25Db250ZXh0TWVudX1cbiAgICAgICAgICAgICAgICBvbkRyYWdFbmQ9e3Aub25EcmFnRW5kfVxuICAgICAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXtwLm9uRHJhZ0xlYXZlfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtwLm9uRHJhZ092ZXJDZWxsfVxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtwLm9uRHJhZ1N0YXJ0fVxuICAgICAgICAgICAgICAgIG9uRHJvcD17cC5vbkRyb3B9XG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17cC5vbkl0ZW1Ib3ZlcmVkfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17cC5vbktleURvd259XG4gICAgICAgICAgICAgICAgb25LZXlVcD17cC5vbktleVVwfVxuICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtwLm9uTW91c2VEb3dufVxuICAgICAgICAgICAgICAgIG9uTW91c2VVcD17cC5vbk1vdXNlVXB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17cC5vblJvd01vdmVkfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3Auc21vb3RoU2Nyb2xsWH1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXtwLnNtb290aFNjcm9sbFl9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0luZmluaXRlU2Nyb2xsZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdyaWRTY3JvbGxlcjtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".bheiboo{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100vh;width:100vw;position:relative;}.bheiboo > .content{display:block;width:var(--bheiboo-0);height:var(--bheiboo-1);-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;position:relative;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:border-box;}.bheiboo > .content *,.bheiboo > .content *::before,.bheiboo > .content *::after{box-sizing:inherit;}\\n.s15ez7jv{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s15ez7jv *,.s15ez7jv *::before,.s15ez7jv *::after{box-sizing:inherit;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5iaGVpYm9vIiwiLnMxNWV6N2p2Il0sIm1hcHBpbmdzIjoiQUFhTUE7QUFnQ0FDIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgU3RvcnlDb250ZXh0IH0gZnJvbSBcIkBzdG9yeWJvb2svYWRkb25zXCI7XG5pbXBvcnQgXCJyZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9zdHlsZXMvY2Fyb3VzZWwubWluLmNzc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgdXNlTW9yZVRvcFBhZGRpbmc/OiBib29sZWFuO1xuICAgIGZpZ21hRG9jPzogc3RyaW5nO1xuICAgIGNvbnRleHQ/OiBTdG9yeUNvbnRleHQ7XG59XG5cbmNvbnN0IEJ1aWxkZXJXcmFwcGVyID0gc3R5bGVkLmRpdjxQaWNrPFByb3BzLCBcIndpZHRoXCIgfCBcImhlaWdodFwiPj5gXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmID4gLmNvbnRlbnQge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcblxuICAgICAgICB3aWR0aDogJHtwID0+IHAud2lkdGh9cHg7XG4gICAgICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG5cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblxuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcblxuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgICAgICosXG4gICAgICAgICo6OmJlZm9yZSxcbiAgICAgICAgKjo6YWZ0ZXIge1xuICAgICAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgKixcbiAgICAqOjpiZWZvcmUsXG4gICAgKjo6YWZ0ZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjbGFzcyBCdWlsZGVyVGhlbWVXcmFwcGVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4+IHtcbiAgICBwdWJsaWMgcmVuZGVyKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxCdWlsZGVyV3JhcHBlciB7Li4ucmVzdH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudFwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L0J1aWxkZXJXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJwb3J0YWxcIiAvPlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e3AuY2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/src/stories/packages/core/src/stories/story-utils.tsx\",\"webpack://./packages/core/src/stories/story-utils.tsx\"],\"names\":[\".bheiboo\",\".s15ez7jv\"],\"mappings\":\"AAaMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oBAAAA,aAAAA,CAAAA,sBAAAA,CAAAA,uBAAAA,CAAAA,yBAAAA,CAAAA,0BAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,yCAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,gBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,iFAAAA,kBAAAA,CAAAA;AAgCAC,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AC3CN,uyFAAuyF\",\"sourcesContent\":[\"import * as React from \\\"react\\\";\\nimport { styled } from \\\"@linaria/react\\\";\\nimport type { StoryContext } from \\\"@storybook/addons\\\";\\nimport \\\"react-responsive-carousel/lib/styles/carousel.min.css\\\";\\n\\ninterface Props {\\n    width: number;\\n    height: number;\\n    useMoreTopPadding?: boolean;\\n    figmaDoc?: string;\\n    context?: StoryContext;\\n}\\n\\nconst BuilderWrapper = styled.div<Pick<Props, \\\"width\\\" | \\\"height\\\">>`\\n    display: flex;\\n    height: 100vh;\\n    width: 100vw;\\n    position: relative;\\n\\n    & > .content {\\n        display: block;\\n\\n        width: ${p => p.width}px;\\n        height: ${p => p.height}px;\\n        align-self: center;\\n\\n        position: relative;\\n\\n        text-rendering: optimizeLegibility;\\n        -webkit-font-smoothing: antialiased;\\n\\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n\\n        user-select: none;\\n\\n        box-sizing: border-box;\\n\\n        *,\\n        *::before,\\n        *::after {\\n            box-sizing: inherit;\\n        }\\n    }\\n`;\\n\\nconst SimpleWrapper = styled.div`\\n    text-rendering: optimizeLegibility;\\n    -webkit-font-smoothing: antialiased;\\n\\n    box-sizing: border-box;\\n\\n    *,\\n    *::before,\\n    *::after {\\n        box-sizing: inherit;\\n    }\\n`;\\n\\nexport class BuilderThemeWrapper extends React.PureComponent<React.PropsWithChildren<Props>> {\\n    public render(): React.ReactNode {\\n        const { context, children, ...rest } = this.props;\\n        return (\\n            <>\\n                <BuilderWrapper {...rest}>\\n                    <div className=\\\"content\\\">{children}</div>\\n                </BuilderWrapper>\\n                <div id=\\\"portal\\\" />\\n            </>\\n        );\\n    }\\n}\\n\\nexport const SimpleThemeWrapper: React.FC = p => {\\n    return (\\n        <SimpleWrapper>\\n            <div className=\\\"content\\\">{p.children}</div>\\n        </SimpleWrapper>\\n    );\\n};\\n\",\".bheiboo{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100vh;width:100vw;position:relative;}.bheiboo > .content{display:block;width:var(--bheiboo-0);height:var(--bheiboo-1);-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;position:relative;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:border-box;}.bheiboo > .content *,.bheiboo > .content *::before,.bheiboo > .content *::after{box-sizing:inherit;}\\n.s15ez7jv{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s15ez7jv *,.s15ez7jv *::before,.s15ez7jv *::after{box-sizing:inherit;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5iaGVpYm9vIiwiLnMxNWV6N2p2Il0sIm1hcHBpbmdzIjoiQUFhTUE7QUFnQ0FDIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgU3RvcnlDb250ZXh0IH0gZnJvbSBcIkBzdG9yeWJvb2svYWRkb25zXCI7XG5pbXBvcnQgXCJyZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9zdHlsZXMvY2Fyb3VzZWwubWluLmNzc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgdXNlTW9yZVRvcFBhZGRpbmc/OiBib29sZWFuO1xuICAgIGZpZ21hRG9jPzogc3RyaW5nO1xuICAgIGNvbnRleHQ/OiBTdG9yeUNvbnRleHQ7XG59XG5cbmNvbnN0IEJ1aWxkZXJXcmFwcGVyID0gc3R5bGVkLmRpdjxQaWNrPFByb3BzLCBcIndpZHRoXCIgfCBcImhlaWdodFwiPj5gXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmID4gLmNvbnRlbnQge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcblxuICAgICAgICB3aWR0aDogJHtwID0+IHAud2lkdGh9cHg7XG4gICAgICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG5cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblxuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcblxuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgICAgICosXG4gICAgICAgICo6OmJlZm9yZSxcbiAgICAgICAgKjo6YWZ0ZXIge1xuICAgICAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgKixcbiAgICAqOjpiZWZvcmUsXG4gICAgKjo6YWZ0ZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjbGFzcyBCdWlsZGVyVGhlbWVXcmFwcGVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4+IHtcbiAgICBwdWJsaWMgcmVuZGVyKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxCdWlsZGVyV3JhcHBlciB7Li4ucmVzdH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudFwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L0J1aWxkZXJXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJwb3J0YWxcIiAvPlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e3AuY2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".s1qcunhi{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1qcunhi *,.s1qcunhi *::before,.s1qcunhi *::after{box-sizing:inherit;}\\n.bd6h1gz{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.bd6h1gz > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.bd6h1gz .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.bd6h1gz .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\\n.d8qm2x5{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXFjdW5oaSIsIi5iZDZoMWd6IiwiLmQ4cW0yeDUiXSwibWFwcGluZ3MiOiJBQVNNQTtBQWlDQUM7QUFvRUFDIiwiZmlsZSI6InBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQsIEdyaWRDb2x1bW4sIFRoZW1lIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyB1c2VDb2xsYXBzaW5nR3JvdXBzLCB1c2VDb2x1bW5Tb3J0LCB1c2VNb3ZlYWJsZUNvbHVtbnMgfSBmcm9tIFwiLlwiO1xuXG5mYWtlci5zZWVkKDEzMzcpO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvU291cmNlXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxuICAgICAgICAgICAge2Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXItY2xpcFwiIHJlZj17cmVmfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XG4gICAgKTtcbn07XG5cbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcbmA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcbiAgICBhY2NlbnRDb2xvcjogXCIjNEY1REZGXCIsXG4gICAgYWNjZW50Rmc6IFwiI0ZGRkZGRlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoNjIsIDExNiwgMjUzLCAwLjEpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjMzEzMTM5XCIsXG4gICAgdGV4dE1lZGl1bTogXCIjNzM3MzgzXCIsXG4gICAgdGV4dExpZ2h0OiBcIiNCMkIyQzBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiMzMTMxMzlcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjNzM3MzgzXCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiNGRkZGRkZcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0R3JvdXBIZWFkZXI6IFwiIzMxMzEzOUJCXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnQ2VsbDogXCIjRkZGRkZGXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNGQUZBRkJcIixcbiAgICBiZ0hlYWRlcjogXCIjRjdGN0Y4XCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjRTlFOUVCXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNFRkVGRjFcIixcblxuICAgIGJnQnViYmxlOiBcIiNFREVERjNcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiNmZmY5ZTNcIixcblxuICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMTE1LCAxMTYsIDEzMSwgMC4xNilcIixcbiAgICBob3Jpem9udGFsQm9yZGVyQ29sb3I6IFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVwiLFxuICAgIGRyaWxsZG93bkJvcmRlcjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cbiAgICBsaW5rQ29sb3I6IFwiIzRGNURGRlwiLFxuXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxuICAgIGNlbGxWZXJ0aWNhbFBhZGRpbmc6IDMsXG5cbiAgICBoZWFkZXJGb250U3R5bGU6IFwiNjAwIDEzcHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBlZGl0b3JGb250U2l6ZTogXCIxM3B4XCIsXG4gICAgbGluZUhlaWdodDogMS40LFxuICAgIGZvbnRGYW1pbHk6XG4gICAgICAgIFwiSW50ZXIsIFJvYm90bywgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBhdmVuaXIgbmV4dCwgYXZlbmlyLCBzZWdvZSB1aSwgaGVsdmV0aWNhIG5ldWUsIGhlbHZldGljYSwgVWJ1bnR1LCBub3RvLCBhcmlhbCwgc2Fucy1zZXJpZlwiLFxufTtcblxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQVwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAxXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkJcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogXCJDXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiRFwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAyXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkVcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMlwiLFxuICAgIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgVXNlRGF0YVNvdXJjZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcblxuICAgIGNvbnN0IHJvd3MgPSAxMDBfMDAwO1xuXG4gICAgY29uc3QgbW92ZUFyZ3MgPSB1c2VNb3ZlYWJsZUNvbHVtbnMoe1xuICAgICAgICBjb2x1bW5zOiBjb2xzLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2wgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBgJHtyb3d9YCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2NvbH0sJHtyb3d9YDtcbiAgICAgICAgICAgIGlmIChjYWNoZS5jdXJyZW50W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcIiBcIiArIGZha2VyLm5hbWUubGFzdE5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbXSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBbc29ydCwgc2V0U29ydF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KCk7XG5cbiAgICBjb25zdCBzb3J0QXJncyA9IHVzZUNvbHVtblNvcnQoe1xuICAgICAgICBjb2x1bW5zOiBtb3ZlQXJncy5jb2x1bW5zLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHNvcnQ6XG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZGVzY1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic21hcnRcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb2xsYXBzZUFyZ3MgPSB1c2VDb2xsYXBzaW5nR3JvdXBzKHtcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcbiAgICAgICAgdGhlbWU6IHRlc3RUaGVtZSxcbiAgICAgICAgZnJlZXplQ29sdW1uczogMCxcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRTb3J0KGluZGV4KTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlciB0aXRsZT1cIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1wiIGRlc2NyaXB0aW9uPXs8RGVzY3JpcHRpb24+Rml4bWUuPC9EZXNjcmlwdGlvbj59PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5tb3ZlQXJnc31cbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XG4gICAgICAgICAgICAgICAgey4uLmNvbGxhcHNlQXJnc31cbiAgICAgICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJDbGlja2VkPXtvbkhlYWRlckNsaWNrfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcbiJdfQ==*/\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/source/src/packages/source/src/use-data-source.stories.tsx\",\"webpack://./packages/source/src/use-data-source.stories.tsx\"],\"names\":[\".s1qcunhi\",\".bd6h1gz\",\".d8qm2x5\"],\"mappings\":\"AASMA,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AAiCAC,SAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,cAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,gBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,4BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA;AAoEAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AC3GN,u5SAAu5S\",\"sourcesContent\":[\"import { styled } from \\\"@linaria/react\\\";\\nimport * as React from \\\"react\\\";\\nimport { useResizeDetector } from \\\"react-resize-detector\\\";\\nimport { DataEditor, DataEditorProps, GridCellKind, GridColumn, Theme } from \\\"@glideapps/glide-data-grid\\\";\\nimport faker from \\\"faker\\\";\\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \\\".\\\";\\n\\nfaker.seed(1337);\\n\\nconst SimpleWrapper = styled.div`\\n    text-rendering: optimizeLegibility;\\n    -webkit-font-smoothing: antialiased;\\n\\n    box-sizing: border-box;\\n\\n    *,\\n    *::before,\\n    *::after {\\n        box-sizing: inherit;\\n    }\\n`;\\n\\nconst SimpleThemeWrapper: React.FC = p => {\\n    return (\\n        <SimpleWrapper>\\n            <div className=\\\"content\\\">{p.children}</div>\\n        </SimpleWrapper>\\n    );\\n};\\n\\nexport default {\\n    title: \\\"Extra Packages/Source\\\",\\n\\n    decorators: [\\n        (Story: React.ComponentType) => (\\n            <SimpleThemeWrapper>\\n                <Story />\\n            </SimpleThemeWrapper>\\n        ),\\n    ],\\n};\\n\\nconst BeautifulStyle = styled.div`\\n    background-color: #2790b9;\\n    background: linear-gradient(90deg, #2790b9, #2070a9);\\n    color: white;\\n\\n    padding: 32px 48px;\\n\\n    display: flex;\\n    flex-direction: column;\\n    height: 100vh;\\n\\n    font-family: sans-serif;\\n\\n    & > h1 {\\n        font-size: 50px;\\n        font-weight: 600;\\n        flex-shrink: 0;\\n        margin: 0 0 12px 0;\\n    }\\n\\n    .sizer {\\n        flex-grow: 1;\\n\\n        background-color: white;\\n\\n        border-radius: 12px;\\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\\n\\n        .sizer-clip {\\n            border-radius: 12px;\\n            overflow: hidden;\\n            transform: translateZ(0);\\n\\n            height: 100%;\\n        }\\n    }\\n`;\\n\\ninterface BeautifulProps {\\n    title: string;\\n    description?: React.ReactNode;\\n}\\n\\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\\n    const { title, children, description } = p;\\n\\n    const { ref, width, height } = useResizeDetector();\\n\\n    return (\\n        <BeautifulStyle>\\n            <h1>{title}</h1>\\n            {description}\\n            <div className=\\\"sizer\\\">\\n                <div className=\\\"sizer-clip\\\" ref={ref}>\\n                    <div\\n                        style={{\\n                            position: \\\"relative\\\",\\n                            width: width ?? 100,\\n                            height: height ?? 100,\\n                        }}>\\n                        {children}\\n                    </div>\\n                </div>\\n            </div>\\n        </BeautifulStyle>\\n    );\\n};\\n\\nconst Description = styled.p`\\n    font-size: 18px;\\n    flex-shrink: 0;\\n    margin: 0 0 20px 0;\\n`;\\n\\nconst defaultProps: Partial<DataEditorProps> = {\\n    smoothScrollX: true,\\n    smoothScrollY: true,\\n    isDraggable: false,\\n    rowMarkers: \\\"none\\\",\\n    width: \\\"100%\\\",\\n};\\n\\nconst testTheme: Theme = {\\n    accentColor: \\\"#4F5DFF\\\",\\n    accentFg: \\\"#FFFFFF\\\",\\n    accentLight: \\\"rgba(62, 116, 253, 0.1)\\\",\\n\\n    textDark: \\\"#313139\\\",\\n    textMedium: \\\"#737383\\\",\\n    textLight: \\\"#B2B2C0\\\",\\n    textBubble: \\\"#313139\\\",\\n\\n    bgIconHeader: \\\"#737383\\\",\\n    fgIconHeader: \\\"#FFFFFF\\\",\\n    textHeader: \\\"#313139\\\",\\n    textGroupHeader: \\\"#313139BB\\\",\\n    textHeaderSelected: \\\"#FFFFFF\\\",\\n\\n    bgCell: \\\"#FFFFFF\\\",\\n    bgCellMedium: \\\"#FAFAFB\\\",\\n    bgHeader: \\\"#F7F7F8\\\",\\n    bgHeaderHasFocus: \\\"#E9E9EB\\\",\\n    bgHeaderHovered: \\\"#EFEFF1\\\",\\n\\n    bgBubble: \\\"#EDEDF3\\\",\\n    bgBubbleSelected: \\\"#FFFFFF\\\",\\n\\n    bgSearchResult: \\\"#fff9e3\\\",\\n\\n    borderColor: \\\"rgba(115, 116, 131, 0.16)\\\",\\n    horizontalBorderColor: \\\"rgba(115, 116, 131, 0.16)\\\",\\n    drilldownBorder: \\\"rgba(0, 0, 0, 0)\\\",\\n\\n    linkColor: \\\"#4F5DFF\\\",\\n\\n    cellHorizontalPadding: 8,\\n    cellVerticalPadding: 3,\\n\\n    headerFontStyle: \\\"600 13px\\\",\\n    baseFontStyle: \\\"13px\\\",\\n    editorFontSize: \\\"13px\\\",\\n    lineHeight: 1.4,\\n    fontFamily:\\n        \\\"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\\\",\\n};\\n\\nconst cols: GridColumn[] = [\\n    {\\n        title: \\\"A\\\",\\n        width: 200,\\n        group: \\\"Group 1\\\",\\n    },\\n    {\\n        title: \\\"B\\\",\\n        width: 200,\\n        group: \\\"Group 1\\\",\\n    },\\n    {\\n        title: \\\"C\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n    {\\n        title: \\\"D\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n    {\\n        title: \\\"E\\\",\\n        width: 200,\\n        group: \\\"Group 2\\\",\\n    },\\n];\\n\\nexport const UseDataSource: React.VFC = () => {\\n    const cache = React.useRef<Record<string, string>>({});\\n\\n    const rows = 100_000;\\n\\n    const moveArgs = useMoveableColumns({\\n        columns: cols,\\n        getCellContent: React.useCallback(([col, row]) => {\\n            if (col === 0) {\\n                return {\\n                    kind: GridCellKind.Text,\\n                    allowOverlay: true,\\n                    data: `${row}`,\\n                    displayData: `${row}`,\\n                };\\n            }\\n\\n            const key = `${col},${row}`;\\n            if (cache.current[key] === undefined) {\\n                cache.current[key] = faker.name.firstName() + \\\" \\\" + faker.name.lastName();\\n            }\\n            const d = cache.current[key];\\n\\n            return {\\n                kind: GridCellKind.Text,\\n                allowOverlay: true,\\n                data: d,\\n                displayData: d,\\n            };\\n        }, []),\\n    });\\n\\n    const [sort, setSort] = React.useState<number>();\\n\\n    const sortArgs = useColumnSort({\\n        columns: moveArgs.columns,\\n        getCellContent: moveArgs.getCellContent,\\n        rows,\\n        sort:\\n            sort === undefined\\n                ? undefined\\n                : {\\n                      column: moveArgs.columns[sort],\\n                      direction: \\\"desc\\\",\\n                      mode: \\\"smart\\\",\\n                  },\\n    });\\n\\n    const collapseArgs = useCollapsingGroups({\\n        columns: moveArgs.columns,\\n        theme: testTheme,\\n        freezeColumns: 0,\\n    });\\n\\n    const onHeaderClick = React.useCallback((index: number) => {\\n        setSort(index);\\n    }, []);\\n\\n    return (\\n        <BeautifulWrapper title=\\\"Custom source extensions\\\" description={<Description>Fixme.</Description>}>\\n            <DataEditor\\n                {...defaultProps}\\n                {...moveArgs}\\n                {...sortArgs}\\n                {...collapseArgs}\\n                rows={rows}\\n                onColumnMoved={moveArgs.onColumnMoved}\\n                onHeaderClicked={onHeaderClick}\\n            />\\n        </BeautifulWrapper>\\n    );\\n};\\n(UseDataSource as any).parameters = {\\n    options: {\\n        showPanel: false,\\n    },\\n};\\n\",\".s1qcunhi{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1qcunhi *,.s1qcunhi *::before,.s1qcunhi *::after{box-sizing:inherit;}\\n.bd6h1gz{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.bd6h1gz > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.bd6h1gz .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.bd6h1gz .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\\n.d8qm2x5{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXFjdW5oaSIsIi5iZDZoMWd6IiwiLmQ4cW0yeDUiXSwibWFwcGluZ3MiOiJBQVNNQTtBQWlDQUM7QUFvRUFDIiwiZmlsZSI6InBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQsIEdyaWRDb2x1bW4sIFRoZW1lIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyB1c2VDb2xsYXBzaW5nR3JvdXBzLCB1c2VDb2x1bW5Tb3J0LCB1c2VNb3ZlYWJsZUNvbHVtbnMgfSBmcm9tIFwiLlwiO1xuXG5mYWtlci5zZWVkKDEzMzcpO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvU291cmNlXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxuICAgICAgICAgICAge2Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXItY2xpcFwiIHJlZj17cmVmfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XG4gICAgKTtcbn07XG5cbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcbmA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcbiAgICBhY2NlbnRDb2xvcjogXCIjNEY1REZGXCIsXG4gICAgYWNjZW50Rmc6IFwiI0ZGRkZGRlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoNjIsIDExNiwgMjUzLCAwLjEpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjMzEzMTM5XCIsXG4gICAgdGV4dE1lZGl1bTogXCIjNzM3MzgzXCIsXG4gICAgdGV4dExpZ2h0OiBcIiNCMkIyQzBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiMzMTMxMzlcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjNzM3MzgzXCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiNGRkZGRkZcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0R3JvdXBIZWFkZXI6IFwiIzMxMzEzOUJCXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnQ2VsbDogXCIjRkZGRkZGXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNGQUZBRkJcIixcbiAgICBiZ0hlYWRlcjogXCIjRjdGN0Y4XCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjRTlFOUVCXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNFRkVGRjFcIixcblxuICAgIGJnQnViYmxlOiBcIiNFREVERjNcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiNmZmY5ZTNcIixcblxuICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMTE1LCAxMTYsIDEzMSwgMC4xNilcIixcbiAgICBob3Jpem9udGFsQm9yZGVyQ29sb3I6IFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVwiLFxuICAgIGRyaWxsZG93bkJvcmRlcjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cbiAgICBsaW5rQ29sb3I6IFwiIzRGNURGRlwiLFxuXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxuICAgIGNlbGxWZXJ0aWNhbFBhZGRpbmc6IDMsXG5cbiAgICBoZWFkZXJGb250U3R5bGU6IFwiNjAwIDEzcHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBlZGl0b3JGb250U2l6ZTogXCIxM3B4XCIsXG4gICAgbGluZUhlaWdodDogMS40LFxuICAgIGZvbnRGYW1pbHk6XG4gICAgICAgIFwiSW50ZXIsIFJvYm90bywgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBhdmVuaXIgbmV4dCwgYXZlbmlyLCBzZWdvZSB1aSwgaGVsdmV0aWNhIG5ldWUsIGhlbHZldGljYSwgVWJ1bnR1LCBub3RvLCBhcmlhbCwgc2Fucy1zZXJpZlwiLFxufTtcblxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQVwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAxXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkJcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogXCJDXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiRFwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAyXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkVcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMlwiLFxuICAgIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgVXNlRGF0YVNvdXJjZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcblxuICAgIGNvbnN0IHJvd3MgPSAxMDBfMDAwO1xuXG4gICAgY29uc3QgbW92ZUFyZ3MgPSB1c2VNb3ZlYWJsZUNvbHVtbnMoe1xuICAgICAgICBjb2x1bW5zOiBjb2xzLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2wgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBgJHtyb3d9YCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2NvbH0sJHtyb3d9YDtcbiAgICAgICAgICAgIGlmIChjYWNoZS5jdXJyZW50W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcIiBcIiArIGZha2VyLm5hbWUubGFzdE5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbXSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBbc29ydCwgc2V0U29ydF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KCk7XG5cbiAgICBjb25zdCBzb3J0QXJncyA9IHVzZUNvbHVtblNvcnQoe1xuICAgICAgICBjb2x1bW5zOiBtb3ZlQXJncy5jb2x1bW5zLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHNvcnQ6XG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZGVzY1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic21hcnRcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb2xsYXBzZUFyZ3MgPSB1c2VDb2xsYXBzaW5nR3JvdXBzKHtcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcbiAgICAgICAgdGhlbWU6IHRlc3RUaGVtZSxcbiAgICAgICAgZnJlZXplQ29sdW1uczogMCxcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRTb3J0KGluZGV4KTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlciB0aXRsZT1cIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1wiIGRlc2NyaXB0aW9uPXs8RGVzY3JpcHRpb24+Rml4bWUuPC9EZXNjcmlwdGlvbj59PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5tb3ZlQXJnc31cbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XG4gICAgICAgICAgICAgICAgey4uLmNvbGxhcHNlQXJnc31cbiAgICAgICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJDbGlja2VkPXtvbkhlYWRlckNsaWNrfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcbiJdfQ==*/\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\\n.d1t1th9s {\\n  position: absolute;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-direction: column;\\n  -ms-flex-direction: column;\\n  flex-direction: column;\\n  overflow: hidden;\\n  box-sizing: border-box;\\n  --overlay-top:var(--d1t1th9s-0);\\n  left: var(--d1t1th9s-1);\\n  top: var(--d1t1th9s-2);\\n  min-width: var(--d1t1th9s-3);\\n  min-height: var(--d1t1th9s-4);\\n  width: -webkit-max-content;\\n  width: -moz-max-content;\\n  width: max-content;\\n  max-width: 400px;\\n  max-height: calc(100vh - var(--d1t1th9s-5));\\n  font-family: var(--gdg-font-family);\\n  font-size: var(--gdg-editor-font-size);\\n  text-align: start;\\n}\\n@-webkit-keyframes glide_fade_in-d1t1th9s {\\n  from {\\n    opacity: 0%;\\n  }\\n  to {\\n    opacity: 100%;\\n  }\\n}\\n@keyframes glide_fade_in-d1t1th9s {\\n  from {\\n    opacity: 0%;\\n  }\\n  to {\\n    opacity: 100%;\\n  }\\n}\\n.d1t1th9s.gdg-style {\\n  border-radius: 2px;\\n  background-color: var(--gdg-bg-cell);\\n  box-shadow:\\n    0 0 0 1px var(--gdg-accent-color),\\n    0px 0px 1px rgba(62, 65, 86, 0.4),\\n    0px 6px 12px rgba(62, 65, 86, 0.15);\\n  -webkit-animation: glide_fade_in-d1t1th9s 60ms 1;\\n  animation: glide_fade_in-d1t1th9s 60ms 1;\\n}\\n.d1t1th9s.pad {\\n  padding: var(--d1t1th9s-6) 8.5px 3px;\\n}\\n.d1t1th9s .clip-region {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-direction: column;\\n  -ms-flex-direction: column;\\n  flex-direction: column;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  border-radius: 2px;\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n}\\n.d1t1th9s .clip-region .gdg-growing-entry {\\n  height: 100%;\\n}\\n.d1t1th9s .clip-region input.gdg-input {\\n  width: 100%;\\n  border: none;\\n  border-width: 0;\\n  outline: none;\\n}\\n.d1t1th9s .clip-region textarea.gdg-input {\\n  border: none;\\n  border-width: 0;\\n  outline: none;\\n}\\n\\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\\n.m15w2ly5 {\\n  position: absolute;\\n  right: 44px;\\n  bottom: 44px;\\n  background-color: var(--gdg-bg-cell);\\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\\n  border-radius: 4px;\\n  z-index: 1;\\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\\n  overflow: hidden;\\n}\\n.m15w2ly5 .header {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  height: 4px;\\n  background-color: var(--gdg-bg-header);\\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\\n}\\n.m15w2ly5 .locationMarker {\\n  position: absolute;\\n  border: 1px solid var(--gdg-accent-color);\\n  background-color: var(--gdg-accent-light);\\n}\\n\\n/* linaria:infinite-scroller_1qseojb.linaria.css */\\n.s1jz82f8 .dvn-scroller {\\n  overflow: var(--s1jz82f8-0);\\n  -webkit-transform: translate3d(0, 0, 0);\\n  -ms-transform: translate3d(0, 0, 0);\\n  transform: translate3d(0, 0, 0);\\n}\\n.s1jz82f8 .hidden {\\n  visibility: hidden;\\n}\\n.s1jz82f8 .dvn-scroll-inner {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  pointer-events: none;\\n}\\n.s1jz82f8 .dvn-scroll-inner > * {\\n  -webkit-flex-shrink: 0;\\n  -ms-flex-negative: 0;\\n  flex-shrink: 0;\\n}\\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n}\\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-direction: column;\\n  -ms-flex-direction: column;\\n  flex-direction: column;\\n}\\n.s1jz82f8 .dvn-underlay > * {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n.s1jz82f8 canvas {\\n  outline: none;\\n}\\n.s1jz82f8 canvas * {\\n  height: 0;\\n}\\n\\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\\n.sxep88s {\\n  position: absolute;\\n  top: 4px;\\n  right: 20px;\\n  background-color: var(--gdg-bg-cell);\\n  color: var(--gdg-text-dark);\\n  padding: 8px;\\n  border: 1px solid var(--gdg-border-color);\\n  border-radius: 6px;\\n  font-size: var(--gdg-editor-font-size);\\n  -webkit-transform: translateX(var(--sxep88s-0));\\n  -ms-transform: translateX(var(--sxep88s-0));\\n  transform: translateX(var(--sxep88s-0));\\n  -webkit-transition: -webkit-transform 0.15s;\\n  -webkit-transition: transform 0.15s;\\n  transition: transform 0.15s;\\n}\\n.sxep88s .search-bar-inner {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n}\\n.sxep88s .search-status {\\n  padding-top: 4px;\\n  font-size: 11px;\\n}\\n.sxep88s .search-progress {\\n  position: absolute;\\n  height: 4px;\\n  left: 0;\\n  bottom: 0;\\n  background-color: var(--gdg-text-light);\\n}\\n.sxep88s input {\\n  width: 220px;\\n  color: var(--gdg-textDark);\\n  background-color: var(--gdg-bg-cell);\\n  border: none;\\n  border-width: 0;\\n  outline: none;\\n}\\n.sxep88s button {\\n  width: 24px;\\n  height: 24px;\\n  padding: 0;\\n  border: none;\\n  outline: none;\\n  background: none;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  cursor: pointer;\\n  color: var(--gdg-text-medium);\\n}\\n.sxep88s button:hover {\\n  color: var(--gdg-text-dark);\\n}\\n.sxep88s button .button-icon {\\n  width: 16px;\\n  height: 16px;\\n}\\n.sxep88s button:disabled {\\n  opacity: 0.4;\\n  pointer-events: none;\\n}\\n\\n/* linaria:group-rename_yc2zuw.linaria.css */\\n.r1kzy40b {\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n  border: none;\\n  outline: none;\\n  background-color: var(--gdg-bg-header-has-focus);\\n  border-radius: 9px;\\n  padding: 0 8px;\\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\\n  color: var(--gdg-text-group-header);\\n  min-height: var(--r1kzy40b-0);\\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\\n}\\n.c1sqdbw3 {\\n  padding: 0 8px;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  background-color: var(--gdg-bg-header);\\n}\\n\\n/* linaria:data-grid-container_gfrgfn.linaria.css */\\n.wzg2m5k {\\n  position: relative;\\n  min-width: 10px;\\n  min-height: 10px;\\n  max-width: 100%;\\n  max-height: 100%;\\n  width: var(--wzg2m5k-0);\\n  height: var(--wzg2m5k-1);\\n  overflow: hidden;\\n  overflow: clip;\\n  contain: strict;\\n}\\n.wzg2m5k > :first-child {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\\n.b1bqsp5z {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-wrap: wrap;\\n  -ms-flex-wrap: wrap;\\n  flex-wrap: wrap;\\n}\\n.b1bqsp5z .boe-bubble {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  border-radius: 100px;\\n  padding: 0 8px;\\n  height: 20px;\\n  background-color: var(--gdg-bg-bubble);\\n  color: var(--gdg-text-dark);\\n  margin: 2px;\\n}\\n.b1bqsp5z textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n\\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\\n.df2kt4a {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-wrap: wrap;\\n  -ms-flex-wrap: wrap;\\n  flex-wrap: wrap;\\n}\\n.df2kt4a .doe-bubble {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  border-radius: 100px;\\n  padding: 0 8px;\\n  height: 24px;\\n  background-color: var(--gdg-bg-cell);\\n  color: var(--gdg-text-dark);\\n  margin: 2px;\\n  border-radius: 6px;\\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\\n}\\n.df2kt4a .doe-bubble img {\\n  height: 16px;\\n  object-fit: contain;\\n  margin-right: 4px;\\n}\\n.df2kt4a textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n\\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\\n.i1eozt10 {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  height: 100%;\\n}\\n.i1eozt10 .centering-container {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  height: 100%;\\n}\\n.i1eozt10 .centering-container img,\\n.i1eozt10 .centering-container canvas {\\n  max-height: calc(100vh - var(--overlay-top) - 20px);\\n  object-fit: contain;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n.i1eozt10 .centering-container canvas {\\n  max-width: 380px;\\n}\\n.i1eozt10 .edit-icon {\\n  position: absolute;\\n  top: 12px;\\n  right: 0;\\n  width: 48px;\\n  height: 48px;\\n  color: var(--gdg-accent-color);\\n  cursor: pointer;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n}\\n.i1eozt10 .edit-icon > * {\\n  width: 24px;\\n  height: 24px;\\n}\\n.i1eozt10 textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n\\n/* linaria:markdown-container_kvmc63.linaria.css */\\n.mlbeo71 {\\n  word-break: break-word;\\n  -webkit-touch-callout: default;\\n  padding-top: 6px;\\n}\\n.mlbeo71 > * {\\n  margin: 0;\\n}\\n.mlbeo71 *:last-child {\\n  margin-bottom: 0;\\n}\\n.mlbeo71 p img {\\n  width: 100%;\\n}\\n\\n/* linaria:growing-entry-style_ycxqui.linaria.css */\\n.ijuk0po {\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  top: 0;\\n  bottom: 0;\\n  width: 100%;\\n  height: 100%;\\n  border-radius: 0px;\\n  resize: none;\\n  white-space: pre-wrap;\\n  min-width: 100%;\\n  overflow: hidden;\\n  border: 0;\\n  background-color: transparent;\\n  font-size: var(--gdg-editor-font-size);\\n  line-height: 16px;\\n  font-family: var(--gdg-font-family);\\n  color: var(--gdg-text-dark);\\n  padding: 0;\\n  margin: 0;\\n}\\n.ijuk0po::-webkit-input-placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.ijuk0po::-moz-placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.ijuk0po:-ms-input-placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.ijuk0po::placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.invalid .ijuk0po {\\n  -webkit-text-decoration: underline;\\n  text-decoration: underline;\\n  -webkit-text-decoration-color: #d60606;\\n  text-decoration-color: #d60606;\\n}\\n.saq3p5l {\\n  visibility: hidden;\\n  white-space: pre-wrap;\\n  word-wrap: break-word;\\n  width: -webkit-max-content;\\n  width: -moz-max-content;\\n  width: max-content;\\n  max-width: 100%;\\n  min-width: 100%;\\n  font-size: var(--gdg-editor-font-size);\\n  line-height: 16px;\\n  font-family: var(--gdg-font-family);\\n  color: var(--gdg-text-dark);\\n  padding: 0;\\n  margin: 0;\\n  padding-bottom: 2px;\\n}\\n.gf8vzix {\\n  position: relative;\\n  margin-top: 6px;\\n}\\n\\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\\n.mdwzdl1 {\\n  min-width: var(--mdwzdl1-0);\\n  width: 100%;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-align-items: flex-start;\\n  -webkit-box-align: flex-start;\\n  -ms-flex-align: flex-start;\\n  align-items: flex-start;\\n  -webkit-box-pack: justify;\\n  -webkit-justify-content: space-between;\\n  -ms-flex-pack: justify;\\n  justify-content: space-between;\\n  position: relative;\\n  color: var(--gdg-text-dark);\\n}\\n.mdwzdl1 .gf8vzix {\\n  -webkit-flex-shrink: 1;\\n  -ms-flex-negative: 1;\\n  flex-shrink: 1;\\n  min-width: 0;\\n}\\n.mdwzdl1 .spacer {\\n  -webkit-flex: 1;\\n  -ms-flex: 1;\\n  flex: 1;\\n}\\n.mdwzdl1 .edit-icon {\\n  position: relative;\\n  cursor: pointer;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  color: var(--gdg-accent-color);\\n  padding: 0;\\n  height: 24px;\\n  width: 24px;\\n  -webkit-flex-shrink: 0;\\n  -ms-flex-negative: 0;\\n  flex-shrink: 0;\\n  -webkit-transition: all \\\"0.125s ease\\\";\\n  transition: all \\\"0.125s ease\\\";\\n  border-radius: 6px;\\n}\\n.mdwzdl1 .edit-icon > * {\\n  width: 16px;\\n  height: 16px;\\n}\\n.mdwzdl1 .edit-hover:hover {\\n  background-color: var(--gdg-accent-light);\\n  -webkit-transition: background-color 150ms;\\n  transition: background-color 150ms;\\n}\\n.mdwzdl1 .checkmark-hover:hover {\\n  color: #ffffff;\\n  background-color: var(--gdg-accent-color);\\n}\\n.mdwzdl1 .md-edit-textarea {\\n  position: relative;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  margin-top: 25px;\\n  opacity: 0;\\n  padding: 0;\\n}\\n.mdwzdl1 .ml-6 {\\n  margin-left: 6px;\\n}\\n\\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\\n.n1czszh3 {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin: 6px 0 3px;\\n  color: var(--gdg-text-dark);\\n}\\n.n1czszh3 > input {\\n  font-size: var(--gdg-editor-font-size);\\n  padding: 0;\\n  font-family: var(--gdg-font-family);\\n  color: var(--gdg-text-dark);\\n  background-color: var(--gdg-bg-cell);\\n}\\n\\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\\n.uf0sjo8 {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  min-height: 21px;\\n}\\n.uf0sjo8 .link-area {\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n  -webkit-flex-shrink: 1;\\n  -ms-flex-negative: 1;\\n  flex-shrink: 1;\\n  cursor: pointer;\\n  margin-right: 8px;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n  color: var(--gdg-link-color);\\n  -webkit-text-decoration: underline !important;\\n  text-decoration: underline !important;\\n}\\n.uf0sjo8 .edit-icon {\\n  -webkit-flex-shrink: 0;\\n  -ms-flex-negative: 0;\\n  flex-shrink: 0;\\n  width: 32px;\\n  color: var(--gdg-accent-color);\\n  cursor: pointer;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n}\\n.uf0sjo8 .edit-icon > * {\\n  width: 24px;\\n  height: 24px;\\n}\\n.uf0sjo8 textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n/*# sourceMappingURL=index.css.map */\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./packages/core/dist/index.css\"],\"names\":[],\"mappings\":\"AAAA,+DAA+D;AAC/D;EACE,kBAAkB;EAClB,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,8BAA8B;EAC9B,0BAA0B;EAC1B,sBAAsB;EACtB,gBAAgB;EAChB,sBAAsB;EACtB,+BAA+B;EAC/B,uBAAuB;EACvB,sBAAsB;EACtB,4BAA4B;EAC5B,6BAA6B;EAC7B,0BAA0B;EAC1B,uBAAuB;EACvB,kBAAkB;EAClB,gBAAgB;EAChB,2CAA2C;EAC3C,mCAAmC;EACnC,sCAAsC;EACtC,iBAAiB;AACnB;AACA;EACE;IACE,WAAW;EACb;EACA;IACE,aAAa;EACf;AACF;AACA;EACE;IACE,WAAW;EACb;EACA;IACE,aAAa;EACf;AACF;AACA;EACE,kBAAkB;EAClB,oCAAoC;EACpC;;;uCAGqC;EACrC,gDAAgD;EAChD,wCAAwC;AAC1C;AACA;EACE,oCAAoC;AACtC;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,8BAA8B;EAC9B,0BAA0B;EAC1B,sBAAsB;EACtB,gBAAgB;EAChB,kBAAkB;EAClB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;AACd;AACA;EACE,YAAY;AACd;AACA;EACE,WAAW;EACX,YAAY;EACZ,eAAe;EACf,aAAa;AACf;AACA;EACE,YAAY;EACZ,eAAe;EACf,aAAa;AACf;;AAEA,mDAAmD;AACnD;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,oCAAoC;EACpC,0EAA0E;EAC1E,kBAAkB;EAClB,UAAU;EACV,4EAA4E;EAC5E,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,WAAW;EACX,WAAW;EACX,sCAAsC;EACtC,6CAA6C;AAC/C;AACA;EACE,kBAAkB;EAClB,yCAAyC;EACzC,yCAAyC;AAC3C;;AAEA,kDAAkD;AAClD;EACE,2BAA2B;EAC3B,uCAAuC;EACvC,mCAAmC;EACnC,+BAA+B;AACjC;AACA;EACE,kBAAkB;AACpB;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,oBAAoB;AACtB;AACA;EACE,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;AAChB;AACA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;AACd;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,8BAA8B;EAC9B,0BAA0B;EAC1B,sBAAsB;AACxB;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;AACR;AACA;EACE,aAAa;AACf;AACA;EACE,SAAS;AACX;;AAEA,sDAAsD;AACtD;EACE,kBAAkB;EAClB,QAAQ;EACR,WAAW;EACX,oCAAoC;EACpC,2BAA2B;EAC3B,YAAY;EACZ,yCAAyC;EACzC,kBAAkB;EAClB,sCAAsC;EACtC,+CAA+C;EAC/C,2CAA2C;EAC3C,uCAAuC;EACvC,2CAA2C;EAC3C,mCAAmC;EACnC,2BAA2B;AAC7B;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;AACf;AACA;EACE,gBAAgB;EAChB,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,OAAO;EACP,SAAS;EACT,uCAAuC;AACzC;AACA;EACE,YAAY;EACZ,0BAA0B;EAC1B,oCAAoC;EACpC,YAAY;EACZ,eAAe;EACf,aAAa;AACf;AACA;EACE,WAAW;EACX,YAAY;EACZ,UAAU;EACV,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,eAAe;EACf,6BAA6B;AAC/B;AACA;EACE,2BAA2B;AAC7B;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,YAAY;EACZ,oBAAoB;AACtB;;AAEA,4CAA4C;AAC5C;EACE,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;EACZ,YAAY;EACZ,aAAa;EACb,gDAAgD;EAChD,kBAAkB;EAClB,cAAc;EACd,6CAA6C;EAC7C,mCAAmC;EACnC,6BAA6B;EAC7B,yDAAyD;AAC3D;AACA;EACE,cAAc;EACd,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,sCAAsC;AACxC;;AAEA,mDAAmD;AACnD;EACE,kBAAkB;EAClB,eAAe;EACf,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,uBAAuB;EACvB,wBAAwB;EACxB,gBAAgB;EAChB,cAAc;EACd,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,WAAW;EACX,YAAY;AACd;;AAEA,6DAA6D;AAC7D;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,eAAe;AACjB;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,oBAAoB;EACpB,cAAc;EACd,YAAY;EACZ,sCAAsC;EACtC,2BAA2B;EAC3B,WAAW;AACb;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;;AAEA,yDAAyD;AACzD;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,eAAe;AACjB;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,oBAAoB;EACpB,cAAc;EACd,YAAY;EACZ,oCAAoC;EACpC,2BAA2B;EAC3B,WAAW;EACX,kBAAkB;EAClB,0EAA0E;AAC5E;AACA;EACE,YAAY;EACZ,mBAAmB;EACnB,iBAAiB;AACnB;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;;AAEA,0DAA0D;AAC1D;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,YAAY;AACd;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,YAAY;AACd;AACA;;EAEE,mDAAmD;EACnD,mBAAmB;EACnB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;AACnB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,WAAW;EACX,YAAY;EACZ,8BAA8B;EAC9B,eAAe;EACf,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;AACrB;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;;AAEA,kDAAkD;AAClD;EACE,sBAAsB;EACtB,8BAA8B;EAC9B,gBAAgB;AAClB;AACA;EACE,SAAS;AACX;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;;AAEA,mDAAmD;AACnD;EACE,kBAAkB;EAClB,OAAO;EACP,QAAQ;EACR,MAAM;EACN,SAAS;EACT,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ,qBAAqB;EACrB,eAAe;EACf,gBAAgB;EAChB,SAAS;EACT,6BAA6B;EAC7B,sCAAsC;EACtC,iBAAiB;EACjB,mCAAmC;EACnC,2BAA2B;EAC3B,UAAU;EACV,SAAS;AACX;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,kCAAkC;EAClC,0BAA0B;EAC1B,sCAAsC;EACtC,8BAA8B;AAChC;AACA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,qBAAqB;EACrB,0BAA0B;EAC1B,uBAAuB;EACvB,kBAAkB;EAClB,eAAe;EACf,eAAe;EACf,sCAAsC;EACtC,iBAAiB;EACjB,mCAAmC;EACnC,2BAA2B;EAC3B,UAAU;EACV,SAAS;EACT,mBAAmB;AACrB;AACA;EACE,kBAAkB;EAClB,eAAe;AACjB;;AAEA,6DAA6D;AAC7D;EACE,2BAA2B;EAC3B,WAAW;EACX,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,+BAA+B;EAC/B,6BAA6B;EAC7B,0BAA0B;EAC1B,uBAAuB;EACvB,yBAAyB;EACzB,sCAAsC;EACtC,sBAAsB;EACtB,8BAA8B;EAC9B,kBAAkB;EAClB,2BAA2B;AAC7B;AACA;EACE,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;EACf,WAAW;EACX,OAAO;AACT;AACA;EACE,kBAAkB;EAClB,eAAe;EACf,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,8BAA8B;EAC9B,UAAU;EACV,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,qCAAqC;EACrC,6BAA6B;EAC7B,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,yCAAyC;EACzC,0CAA0C;EAC1C,kCAAkC;AACpC;AACA;EACE,cAAc;EACd,yCAAyC;AAC3C;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,gBAAgB;EAChB,UAAU;EACV,UAAU;AACZ;AACA;EACE,gBAAgB;AAClB;;AAEA,2DAA2D;AAC3D;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,iBAAiB;EACjB,2BAA2B;AAC7B;AACA;EACE,sCAAsC;EACtC,UAAU;EACV,mCAAmC;EACnC,2BAA2B;EAC3B,oCAAoC;AACtC;;AAEA,wDAAwD;AACxD;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;EACZ,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;EACZ,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,eAAe;EACf,iBAAiB;EACjB,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;EACnB,4BAA4B;EAC5B,6CAA6C;EAC7C,qCAAqC;AACvC;AACA;EACE,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,WAAW;EACX,8BAA8B;EAC9B,eAAe;EACf,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;AACrB;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;AACA,oCAAoC\",\"sourcesContent\":[\"/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\\n.d1t1th9s {\\n  position: absolute;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-direction: column;\\n  -ms-flex-direction: column;\\n  flex-direction: column;\\n  overflow: hidden;\\n  box-sizing: border-box;\\n  --overlay-top:var(--d1t1th9s-0);\\n  left: var(--d1t1th9s-1);\\n  top: var(--d1t1th9s-2);\\n  min-width: var(--d1t1th9s-3);\\n  min-height: var(--d1t1th9s-4);\\n  width: -webkit-max-content;\\n  width: -moz-max-content;\\n  width: max-content;\\n  max-width: 400px;\\n  max-height: calc(100vh - var(--d1t1th9s-5));\\n  font-family: var(--gdg-font-family);\\n  font-size: var(--gdg-editor-font-size);\\n  text-align: start;\\n}\\n@-webkit-keyframes glide_fade_in-d1t1th9s {\\n  from {\\n    opacity: 0%;\\n  }\\n  to {\\n    opacity: 100%;\\n  }\\n}\\n@keyframes glide_fade_in-d1t1th9s {\\n  from {\\n    opacity: 0%;\\n  }\\n  to {\\n    opacity: 100%;\\n  }\\n}\\n.d1t1th9s.gdg-style {\\n  border-radius: 2px;\\n  background-color: var(--gdg-bg-cell);\\n  box-shadow:\\n    0 0 0 1px var(--gdg-accent-color),\\n    0px 0px 1px rgba(62, 65, 86, 0.4),\\n    0px 6px 12px rgba(62, 65, 86, 0.15);\\n  -webkit-animation: glide_fade_in-d1t1th9s 60ms 1;\\n  animation: glide_fade_in-d1t1th9s 60ms 1;\\n}\\n.d1t1th9s.pad {\\n  padding: var(--d1t1th9s-6) 8.5px 3px;\\n}\\n.d1t1th9s .clip-region {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-direction: column;\\n  -ms-flex-direction: column;\\n  flex-direction: column;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  border-radius: 2px;\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n}\\n.d1t1th9s .clip-region .gdg-growing-entry {\\n  height: 100%;\\n}\\n.d1t1th9s .clip-region input.gdg-input {\\n  width: 100%;\\n  border: none;\\n  border-width: 0;\\n  outline: none;\\n}\\n.d1t1th9s .clip-region textarea.gdg-input {\\n  border: none;\\n  border-width: 0;\\n  outline: none;\\n}\\n\\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\\n.m15w2ly5 {\\n  position: absolute;\\n  right: 44px;\\n  bottom: 44px;\\n  background-color: var(--gdg-bg-cell);\\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\\n  border-radius: 4px;\\n  z-index: 1;\\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\\n  overflow: hidden;\\n}\\n.m15w2ly5 .header {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  height: 4px;\\n  background-color: var(--gdg-bg-header);\\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\\n}\\n.m15w2ly5 .locationMarker {\\n  position: absolute;\\n  border: 1px solid var(--gdg-accent-color);\\n  background-color: var(--gdg-accent-light);\\n}\\n\\n/* linaria:infinite-scroller_1qseojb.linaria.css */\\n.s1jz82f8 .dvn-scroller {\\n  overflow: var(--s1jz82f8-0);\\n  -webkit-transform: translate3d(0, 0, 0);\\n  -ms-transform: translate3d(0, 0, 0);\\n  transform: translate3d(0, 0, 0);\\n}\\n.s1jz82f8 .hidden {\\n  visibility: hidden;\\n}\\n.s1jz82f8 .dvn-scroll-inner {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  pointer-events: none;\\n}\\n.s1jz82f8 .dvn-scroll-inner > * {\\n  -webkit-flex-shrink: 0;\\n  -ms-flex-negative: 0;\\n  flex-shrink: 0;\\n}\\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n}\\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-direction: column;\\n  -ms-flex-direction: column;\\n  flex-direction: column;\\n}\\n.s1jz82f8 .dvn-underlay > * {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n.s1jz82f8 canvas {\\n  outline: none;\\n}\\n.s1jz82f8 canvas * {\\n  height: 0;\\n}\\n\\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\\n.sxep88s {\\n  position: absolute;\\n  top: 4px;\\n  right: 20px;\\n  background-color: var(--gdg-bg-cell);\\n  color: var(--gdg-text-dark);\\n  padding: 8px;\\n  border: 1px solid var(--gdg-border-color);\\n  border-radius: 6px;\\n  font-size: var(--gdg-editor-font-size);\\n  -webkit-transform: translateX(var(--sxep88s-0));\\n  -ms-transform: translateX(var(--sxep88s-0));\\n  transform: translateX(var(--sxep88s-0));\\n  -webkit-transition: -webkit-transform 0.15s;\\n  -webkit-transition: transform 0.15s;\\n  transition: transform 0.15s;\\n}\\n.sxep88s .search-bar-inner {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n}\\n.sxep88s .search-status {\\n  padding-top: 4px;\\n  font-size: 11px;\\n}\\n.sxep88s .search-progress {\\n  position: absolute;\\n  height: 4px;\\n  left: 0;\\n  bottom: 0;\\n  background-color: var(--gdg-text-light);\\n}\\n.sxep88s input {\\n  width: 220px;\\n  color: var(--gdg-textDark);\\n  background-color: var(--gdg-bg-cell);\\n  border: none;\\n  border-width: 0;\\n  outline: none;\\n}\\n.sxep88s button {\\n  width: 24px;\\n  height: 24px;\\n  padding: 0;\\n  border: none;\\n  outline: none;\\n  background: none;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  cursor: pointer;\\n  color: var(--gdg-text-medium);\\n}\\n.sxep88s button:hover {\\n  color: var(--gdg-text-dark);\\n}\\n.sxep88s button .button-icon {\\n  width: 16px;\\n  height: 16px;\\n}\\n.sxep88s button:disabled {\\n  opacity: 0.4;\\n  pointer-events: none;\\n}\\n\\n/* linaria:group-rename_yc2zuw.linaria.css */\\n.r1kzy40b {\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n  border: none;\\n  outline: none;\\n  background-color: var(--gdg-bg-header-has-focus);\\n  border-radius: 9px;\\n  padding: 0 8px;\\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\\n  color: var(--gdg-text-group-header);\\n  min-height: var(--r1kzy40b-0);\\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\\n}\\n.c1sqdbw3 {\\n  padding: 0 8px;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  background-color: var(--gdg-bg-header);\\n}\\n\\n/* linaria:data-grid-container_gfrgfn.linaria.css */\\n.wzg2m5k {\\n  position: relative;\\n  min-width: 10px;\\n  min-height: 10px;\\n  max-width: 100%;\\n  max-height: 100%;\\n  width: var(--wzg2m5k-0);\\n  height: var(--wzg2m5k-1);\\n  overflow: hidden;\\n  overflow: clip;\\n  contain: strict;\\n}\\n.wzg2m5k > :first-child {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\\n.b1bqsp5z {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-wrap: wrap;\\n  -ms-flex-wrap: wrap;\\n  flex-wrap: wrap;\\n}\\n.b1bqsp5z .boe-bubble {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  border-radius: 100px;\\n  padding: 0 8px;\\n  height: 20px;\\n  background-color: var(--gdg-bg-bubble);\\n  color: var(--gdg-text-dark);\\n  margin: 2px;\\n}\\n.b1bqsp5z textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n\\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\\n.df2kt4a {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-flex-wrap: wrap;\\n  -ms-flex-wrap: wrap;\\n  flex-wrap: wrap;\\n}\\n.df2kt4a .doe-bubble {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  border-radius: 100px;\\n  padding: 0 8px;\\n  height: 24px;\\n  background-color: var(--gdg-bg-cell);\\n  color: var(--gdg-text-dark);\\n  margin: 2px;\\n  border-radius: 6px;\\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\\n}\\n.df2kt4a .doe-bubble img {\\n  height: 16px;\\n  object-fit: contain;\\n  margin-right: 4px;\\n}\\n.df2kt4a textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n\\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\\n.i1eozt10 {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  height: 100%;\\n}\\n.i1eozt10 .centering-container {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  height: 100%;\\n}\\n.i1eozt10 .centering-container img,\\n.i1eozt10 .centering-container canvas {\\n  max-height: calc(100vh - var(--overlay-top) - 20px);\\n  object-fit: contain;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n.i1eozt10 .centering-container canvas {\\n  max-width: 380px;\\n}\\n.i1eozt10 .edit-icon {\\n  position: absolute;\\n  top: 12px;\\n  right: 0;\\n  width: 48px;\\n  height: 48px;\\n  color: var(--gdg-accent-color);\\n  cursor: pointer;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n}\\n.i1eozt10 .edit-icon > * {\\n  width: 24px;\\n  height: 24px;\\n}\\n.i1eozt10 textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n\\n/* linaria:markdown-container_kvmc63.linaria.css */\\n.mlbeo71 {\\n  word-break: break-word;\\n  -webkit-touch-callout: default;\\n  padding-top: 6px;\\n}\\n.mlbeo71 > * {\\n  margin: 0;\\n}\\n.mlbeo71 *:last-child {\\n  margin-bottom: 0;\\n}\\n.mlbeo71 p img {\\n  width: 100%;\\n}\\n\\n/* linaria:growing-entry-style_ycxqui.linaria.css */\\n.ijuk0po {\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  top: 0;\\n  bottom: 0;\\n  width: 100%;\\n  height: 100%;\\n  border-radius: 0px;\\n  resize: none;\\n  white-space: pre-wrap;\\n  min-width: 100%;\\n  overflow: hidden;\\n  border: 0;\\n  background-color: transparent;\\n  font-size: var(--gdg-editor-font-size);\\n  line-height: 16px;\\n  font-family: var(--gdg-font-family);\\n  color: var(--gdg-text-dark);\\n  padding: 0;\\n  margin: 0;\\n}\\n.ijuk0po::-webkit-input-placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.ijuk0po::-moz-placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.ijuk0po:-ms-input-placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.ijuk0po::placeholder {\\n  color: var(--gdg-text-light);\\n}\\n.invalid .ijuk0po {\\n  -webkit-text-decoration: underline;\\n  text-decoration: underline;\\n  -webkit-text-decoration-color: #d60606;\\n  text-decoration-color: #d60606;\\n}\\n.saq3p5l {\\n  visibility: hidden;\\n  white-space: pre-wrap;\\n  word-wrap: break-word;\\n  width: -webkit-max-content;\\n  width: -moz-max-content;\\n  width: max-content;\\n  max-width: 100%;\\n  min-width: 100%;\\n  font-size: var(--gdg-editor-font-size);\\n  line-height: 16px;\\n  font-family: var(--gdg-font-family);\\n  color: var(--gdg-text-dark);\\n  padding: 0;\\n  margin: 0;\\n  padding-bottom: 2px;\\n}\\n.gf8vzix {\\n  position: relative;\\n  margin-top: 6px;\\n}\\n\\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\\n.mdwzdl1 {\\n  min-width: var(--mdwzdl1-0);\\n  width: 100%;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-align-items: flex-start;\\n  -webkit-box-align: flex-start;\\n  -ms-flex-align: flex-start;\\n  align-items: flex-start;\\n  -webkit-box-pack: justify;\\n  -webkit-justify-content: space-between;\\n  -ms-flex-pack: justify;\\n  justify-content: space-between;\\n  position: relative;\\n  color: var(--gdg-text-dark);\\n}\\n.mdwzdl1 .gf8vzix {\\n  -webkit-flex-shrink: 1;\\n  -ms-flex-negative: 1;\\n  flex-shrink: 1;\\n  min-width: 0;\\n}\\n.mdwzdl1 .spacer {\\n  -webkit-flex: 1;\\n  -ms-flex: 1;\\n  flex: 1;\\n}\\n.mdwzdl1 .edit-icon {\\n  position: relative;\\n  cursor: pointer;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  color: var(--gdg-accent-color);\\n  padding: 0;\\n  height: 24px;\\n  width: 24px;\\n  -webkit-flex-shrink: 0;\\n  -ms-flex-negative: 0;\\n  flex-shrink: 0;\\n  -webkit-transition: all \\\"0.125s ease\\\";\\n  transition: all \\\"0.125s ease\\\";\\n  border-radius: 6px;\\n}\\n.mdwzdl1 .edit-icon > * {\\n  width: 16px;\\n  height: 16px;\\n}\\n.mdwzdl1 .edit-hover:hover {\\n  background-color: var(--gdg-accent-light);\\n  -webkit-transition: background-color 150ms;\\n  transition: background-color 150ms;\\n}\\n.mdwzdl1 .checkmark-hover:hover {\\n  color: #ffffff;\\n  background-color: var(--gdg-accent-color);\\n}\\n.mdwzdl1 .md-edit-textarea {\\n  position: relative;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  margin-top: 25px;\\n  opacity: 0;\\n  padding: 0;\\n}\\n.mdwzdl1 .ml-6 {\\n  margin-left: 6px;\\n}\\n\\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\\n.n1czszh3 {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin: 6px 0 3px;\\n  color: var(--gdg-text-dark);\\n}\\n.n1czszh3 > input {\\n  font-size: var(--gdg-editor-font-size);\\n  padding: 0;\\n  font-family: var(--gdg-font-family);\\n  color: var(--gdg-text-dark);\\n  background-color: var(--gdg-bg-cell);\\n}\\n\\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\\n.uf0sjo8 {\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  min-height: 21px;\\n}\\n.uf0sjo8 .link-area {\\n  -webkit-box-flex: 1;\\n  -webkit-flex-grow: 1;\\n  -ms-flex-positive: 1;\\n  flex-grow: 1;\\n  -webkit-flex-shrink: 1;\\n  -ms-flex-negative: 1;\\n  flex-shrink: 1;\\n  cursor: pointer;\\n  margin-right: 8px;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n  color: var(--gdg-link-color);\\n  -webkit-text-decoration: underline !important;\\n  text-decoration: underline !important;\\n}\\n.uf0sjo8 .edit-icon {\\n  -webkit-flex-shrink: 0;\\n  -ms-flex-negative: 0;\\n  flex-shrink: 0;\\n  width: 32px;\\n  color: var(--gdg-accent-color);\\n  cursor: pointer;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n}\\n.uf0sjo8 .edit-icon > * {\\n  width: 24px;\\n  height: 24px;\\n}\\n.uf0sjo8 textarea {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 0px;\\n  height: 0px;\\n  opacity: 0;\\n}\\n/*# sourceMappingURL=index.css.map */\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","import api from \"!../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./cell.stories.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./dropdown-cell.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./links-cell.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./star-cell.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./tags-cell.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./data-grid-container.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./group-rename.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./data-editor-beautiful.stories.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./data-editor-repros.stories.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./utils.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./data-grid-overlay-editor-style.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./bubbles-overlay-editor-style.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./drilldown-overlay-editor.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./image-overlay-editor-style.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./markdown-overlay-editor-style.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./uri-overlay-editor-style.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./data-grid-search-style.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./doc-wrapper.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./growing-entry-style.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./markdown-container.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./infinite-scroller.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./scrolling-data-grid.stories.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./scrolling-data-grid.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./story-utils.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import api from \"!../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!../../../node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./use-data-source.stories.tsx\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import { addParameters } from \"@storybook/react\";\n\naddParameters({\n    options: {\n        showRoots: true,\n        storySort: (a, b) => {\n            return a[1].name.localeCompare(b[1].name, undefined, { numeric: true });\n        },\n    },\n});\n\nexport const parameters = {\n    layout: \"fullscreen\",\n};\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\nimport { addDecorator, addParameters, addLoader, addArgs, addArgTypes, addArgsEnhancer, addArgTypesEnhancer, setGlobalRender } from '/home/runner/work/glide-data-grid/glide-data-grid/node_modules/@storybook/client-api';\nimport * as config from '/home/runner/work/glide-data-grid/glide-data-grid/.storybook/preview.js';\nObject.keys(config).forEach(function (key) {\n  var value = config[key];\n\n  switch (key) {\n    case 'args':\n      {\n        return addArgs(value);\n      }\n\n    case 'argTypes':\n      {\n        return addArgTypes(value);\n      }\n\n    case 'decorators':\n      {\n        return value.forEach(function (decorator) {\n          return addDecorator(decorator, false);\n        });\n      }\n\n    case 'loaders':\n      {\n        return value.forEach(function (loader) {\n          return addLoader(loader, false);\n        });\n      }\n\n    case 'parameters':\n      {\n        return addParameters(_objectSpread({}, value), false);\n      }\n\n    case 'argTypesEnhancers':\n      {\n        return value.forEach(function (enhancer) {\n          return addArgTypesEnhancer(enhancer);\n        });\n      }\n\n    case 'argsEnhancers':\n      {\n        return value.forEach(function (enhancer) {\n          return addArgsEnhancer(enhancer);\n        });\n      }\n\n    case 'render':\n      {\n        return setGlobalRender(value);\n      }\n\n    case 'globals':\n    case 'globalTypes':\n      {\n        var v = {};\n        v[key] = value;\n        return addParameters(v, false);\n      }\n\n    case '__namedExportsOrder':\n    case 'decorateStory':\n    case 'renderToDOM':\n      {\n        return null; // This key is not handled directly in v6 mode.\n      }\n\n    default:\n      {\n        // eslint-disable-next-line prefer-template\n        return console.log(key + ' was not supported :( !');\n      }\n  }\n});","import { CustomCell, Item, CustomRenderer, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport * as React from \"react\";\nimport { styled } from \"@linaria/react\";\n\ninterface StarCellProps {\n    readonly kind: \"star-cell\";\n    readonly rating: number;\n}\n\nexport type StarCell = CustomCell<StarCellProps>;\n\nconst starPoints = [\n    [50, 5],\n    [61.23, 39.55],\n    [97.55, 39.55],\n    [68.16, 60.9],\n    [79.39, 95.45],\n    [50, 74.1],\n    [20.61, 95.45],\n    [31.84, 60.9],\n    [2.45, 39.55],\n    [38.77, 39.55],\n];\n\nfunction pathStar(ctx: CanvasRenderingContext2D, center: Item, size: number) {\n    let moved = false;\n    for (const p of starPoints) {\n        const x = (p[0] - 50) * (size / 100) + center[0];\n        const y = (p[1] - 50) * (size / 100) + center[1];\n\n        if (moved) {\n            ctx.lineTo(x, y);\n        } else {\n            ctx.moveTo(x, y);\n            moved = true;\n        }\n    }\n\n    ctx.closePath();\n}\n\nconst StarSVG = () => (\n    <svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path\n            d=\"M47.1468 13.7811C48.0449 11.0172 51.9551 11.0172 52.8532 13.7812L60.5522 37.4762C60.9538 38.7123 62.1056 39.5491 63.4053 39.5491H88.3198C91.226 39.5491 92.4343 43.268 90.0831 44.9762L69.9269 59.6205C68.8755 60.3845 68.4355 61.7386 68.8371 62.9746L76.5361 86.6697C77.4342 89.4336 74.2707 91.732 71.9196 90.0238L51.7634 75.3794C50.7119 74.6155 49.2881 74.6155 48.2366 75.3795L28.0804 90.0238C25.7293 91.732 22.5659 89.4336 23.4639 86.6697L31.1629 62.9746C31.5645 61.7386 31.1245 60.3845 30.0731 59.6205L9.91686 44.9762C7.56572 43.268 8.77405 39.5491 11.6802 39.5491H36.5947C37.8944 39.5491 39.0462 38.7123 39.4478 37.4762L47.1468 13.7811Z\"\n            fill=\"currentColor\"\n        />\n    </svg>\n);\n\nconst EditorWrap = styled.div`\n    .active {\n        color: var(--gdg-text-dark);\n    }\n\n    display: flex;\n    align-items: center;\n    padding: 6px 0;\n    color: var(--gdg-text-light);\n\n    > * {\n        position: relative;\n        width: 16px;\n        height: 16px;\n        cursor: pointer;\n        margin-right: 2px;\n\n        svg {\n            width: 100%;\n            height: 100%;\n        }\n    }\n`;\n\nconst renderer: CustomRenderer<StarCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (cell: CustomCell): cell is StarCell => (cell.data as any).kind === \"star-cell\",\n    needsHover: true,\n    draw: (args, cell) => {\n        const { ctx, theme, rect, hoverAmount } = args;\n        const { rating } = cell.data;\n        const padX = theme.cellHorizontalPadding;\n        let drawX = rect.x + padX;\n        const stars = Math.min(5, Math.ceil(rating));\n        drawX += 8;\n        ctx.beginPath();\n        for (let i = 0; i < stars; i++) {\n            pathStar(ctx, [drawX, rect.y + rect.height / 2], 16);\n            drawX += 18;\n        }\n        ctx.fillStyle = theme.textDark;\n        ctx.globalAlpha = 0.6 + 0.4 * hoverAmount;\n        ctx.fill();\n        ctx.globalAlpha = 1;\n        return true;\n    },\n    provideEditor: () => {\n        // eslint-disable-next-line react/display-name\n        return p => (\n            <EditorWrap>\n                {[0, 1, 2, 3, 4].map(index => (\n                    <div\n                        key={index}\n                        className={p.value.data.rating < index + 1 ? \"inactive\" : \"active\"}\n                        onClick={() => {\n                            p.onChange({\n                                ...p.value,\n                                data: {\n                                    ...p.value.data,\n                                    rating: index + 1,\n                                },\n                            });\n                        }}>\n                        <StarSVG />\n                    </div>\n                ))}\n            </EditorWrap>\n        );\n    },\n    onPaste: (val, d) => {\n        const num = Number.parseInt(val);\n        return {\n            ...d,\n            rating: Number.isNaN(num) ? 0 : num,\n        };\n    },\n};\n\nexport default renderer;\n","import { CustomCell, parseToRgba, Item, CustomRenderer, GridCellKind } from \"@glideapps/glide-data-grid\";\n\ninterface SparklineCellProps {\n    readonly kind: \"sparkline-cell\";\n    readonly graphKind?: \"line\" | \"bar\";\n    readonly values: readonly number[];\n    readonly displayValues?: readonly string[];\n    readonly yAxis: Item;\n    readonly color?: string;\n}\n\nexport type SparklineCell = CustomCell<SparklineCellProps>;\n\nconst renderer: CustomRenderer<SparklineCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (cell: CustomCell): cell is SparklineCell => (cell.data as any).kind === \"sparkline-cell\",\n    needsHover: true,\n    needsHoverPosition: true,\n    draw: (args, cell) => {\n        const { ctx, theme, rect, hoverAmount, hoverX } = args;\n        // eslint-disable-next-line prefer-const\n        let { values, yAxis, color, graphKind = \"line\", displayValues } = cell.data;\n        const [minY, maxY] = yAxis;\n        if (values.length === 0) return true;\n\n        values = values.map(x => Math.min(1, Math.max(0, (x - minY) / (maxY - minY))));\n        const padX = theme.cellHorizontalPadding;\n        const drawX = padX + rect.x;\n\n        const y = rect.y + 3;\n        const height = rect.height - 6;\n        const width = rect.width - padX * 2;\n\n        const delta = maxY - minY;\n        const zeroY = maxY <= 0 ? y : minY >= 0 ? y + height : y + height * (maxY / delta);\n        // draw zero\n        if (minY <= 0 && maxY >= 0) {\n            ctx.beginPath();\n            ctx.moveTo(drawX, zeroY);\n            ctx.lineTo(drawX + width, zeroY);\n\n            ctx.globalAlpha = 0.4;\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = theme.textLight;\n            ctx.stroke();\n            ctx.globalAlpha = 1;\n        }\n\n        if (graphKind === \"bar\") {\n            ctx.beginPath();\n            const margin = 2;\n            const spacing = (values.length - 1) * margin;\n            const barWidth = (width - spacing) / values.length;\n\n            let x = drawX;\n            for (const val of values) {\n                const barY = y + height - val * height;\n                ctx.moveTo(x, zeroY);\n                ctx.lineTo(x + barWidth, zeroY);\n                ctx.lineTo(x + barWidth, barY);\n                ctx.lineTo(x, barY);\n\n                x += barWidth + margin;\n            }\n            ctx.fillStyle = cell.data.color ?? theme.accentColor;\n            ctx.fill();\n        } else {\n            if (values.length === 1) values = [values[0], values[0]];\n            // draw line\n            ctx.beginPath();\n\n            const xStep = (rect.width - 16) / (values.length - 1);\n            const points = values.map((val, ind) => {\n                return {\n                    x: drawX + xStep * ind,\n                    y: y + height - val * height,\n                };\n            });\n            ctx.moveTo(points[0].x, points[0].y);\n\n            let i: number;\n            for (i = 1; i < points.length - 2; i++) {\n                const xControl = (points[i].x + points[i + 1].x) / 2;\n                const yControl = (points[i].y + points[i + 1].y) / 2;\n                ctx.quadraticCurveTo(points[i].x, points[i].y, xControl, yControl);\n            }\n            ctx.quadraticCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y);\n\n            ctx.strokeStyle = color ?? theme.accentColor;\n            ctx.lineWidth = 1 + hoverAmount * 0.5;\n            ctx.stroke();\n\n            ctx.lineTo(rect.x + rect.width - padX, zeroY);\n            ctx.lineTo(rect.x + padX, zeroY);\n            ctx.closePath();\n\n            ctx.globalAlpha = 0.2 + 0.2 * hoverAmount;\n            const grad = ctx.createLinearGradient(0, y, 0, y + height * 1.4);\n            grad.addColorStop(0, color ?? theme.accentColor);\n\n            const [r, g, b] = parseToRgba(color ?? theme.accentColor);\n            grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);\n            ctx.fillStyle = grad;\n            ctx.fill();\n            ctx.globalAlpha = 1;\n\n            if (hoverX !== undefined && graphKind === \"line\" && displayValues !== undefined) {\n                ctx.beginPath();\n                const closest = Math.min(values.length - 1, Math.max(0, Math.round((hoverX - padX) / xStep)));\n                ctx.moveTo(drawX + closest * xStep, rect.y);\n                ctx.lineTo(drawX + closest * xStep, rect.y + rect.height);\n\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = theme.textLight;\n                ctx.stroke();\n\n                ctx.save();\n                ctx.font = `8px ${theme.fontFamily}`;\n                ctx.fillStyle = theme.textMedium;\n                ctx.textBaseline = \"top\";\n                ctx.fillText(displayValues[closest], drawX, rect.y + theme.cellVerticalPadding);\n                ctx.restore();\n            }\n        }\n\n        return true;\n    },\n    provideEditor: () => undefined,\n    onPaste: (_v, d) => d,\n};\n\nexport default renderer;\n","interface CornerRadius {\n    tl: number;\n    tr: number;\n    bl: number;\n    br: number;\n}\n\nexport function roundedRect(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number | CornerRadius\n) {\n    if (radius === 0) {\n        ctx.rect(x, y, width, height);\n        return;\n    }\n    if (typeof radius === \"number\") {\n        radius = { tl: radius, tr: radius, br: radius, bl: radius };\n    }\n\n    // restrict radius to a reasonable max\n    radius = {\n        tl: Math.min(radius.tl, height / 2, width / 2),\n        tr: Math.min(radius.tr, height / 2, width / 2),\n        bl: Math.min(radius.bl, height / 2, width / 2),\n        br: Math.min(radius.br, height / 2, width / 2),\n    };\n\n    ctx.moveTo(x + radius.tl, y);\n    ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);\n    ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);\n    ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);\n    ctx.arcTo(x, y, x + radius.tl, y, radius.tl);\n}\n","import {\n    CustomCell,\n    Rectangle,\n    measureTextCached,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { roundedRect } from \"../draw-fns\";\n\ninterface TagsCellProps {\n    readonly kind: \"tags-cell\";\n    readonly tags: readonly string[];\n    readonly readonly?: boolean;\n    readonly possibleTags: readonly {\n        tag: string;\n        color: string;\n    }[];\n}\n\nexport type TagsCell = CustomCell<TagsCellProps>;\n\nconst tagHeight = 20;\nconst innerPad = 6;\n\nconst EditorWrap = styled.div<{ tagHeight: number; innerPad: number }>`\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    padding-top: 6px;\n    color: var(--gdg-text-dark);\n\n    box-sizing: border-box;\n\n    * {\n        box-sizing: border-box;\n    }\n\n    &&&& label {\n        display: flex;\n        cursor: pointer;\n\n        input {\n            cursor: pointer;\n            width: auto;\n        }\n\n        .pill {\n            margin-left: 8px;\n            margin-right: 6px;\n            margin-bottom: 6px;\n\n            border-radius: ${p => p.tagHeight / 2}px;\n            min-height: ${p => p.tagHeight}px;\n            padding: 2px ${p => p.innerPad}px;\n            display: flex;\n            align-items: center;\n\n            font: 12px var(--gdg-font-family);\n\n            background-color: var(--gdg-bg-bubble);\n\n            transition: box-shadow 150ms;\n\n            &.unselected {\n                opacity: 0.8;\n            }\n        }\n    }\n    label:hover .pill {\n        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);\n    }\n\n    &&&&.readonly label {\n        cursor: default;\n\n        .pill {\n            box-shadow: none !important;\n        }\n    }\n`;\n\nconst renderer: CustomRenderer<TagsCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is TagsCell => (c.data as any).kind === \"tags-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { possibleTags, tags } = cell.data;\n\n        const drawArea: Rectangle = {\n            x: rect.x + theme.cellHorizontalPadding,\n            y: rect.y + theme.cellVerticalPadding,\n            width: rect.width - 2 * theme.cellHorizontalPadding,\n            height: rect.height - 2 * theme.cellVerticalPadding,\n        };\n        const rows = Math.max(1, Math.floor(drawArea.height / (tagHeight + innerPad)));\n\n        let x = drawArea.x;\n        let row = 1;\n        let y = drawArea.y + (drawArea.height - rows * tagHeight - (rows - 1) * innerPad) / 2;\n        for (const tag of tags) {\n            const color = possibleTags.find(t => t.tag === tag)?.color ?? theme.bgBubble;\n\n            ctx.font = `12px ${theme.fontFamily}`;\n            const metrics = measureTextCached(tag, ctx);\n            const width = metrics.width + innerPad * 2;\n            const textY = tagHeight / 2;\n\n            if (x !== drawArea.x && x + width > drawArea.x + drawArea.width && row < rows) {\n                row++;\n                y += tagHeight + innerPad;\n                x = drawArea.x;\n            }\n\n            ctx.fillStyle = color;\n            ctx.beginPath();\n            roundedRect(ctx, x, y, width, tagHeight, tagHeight / 2);\n            ctx.fill();\n\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(tag, x + innerPad, y + textY + getMiddleCenterBias(ctx, `12px ${theme.fontFamily}`));\n\n            x += width + 8;\n            if (x > drawArea.x + drawArea.width && row >= rows) break;\n        }\n\n        return true;\n    },\n    provideEditor: () => {\n        // eslint-disable-next-line react/display-name\n        return p => {\n            const { onChange, value } = p;\n            const { possibleTags, tags, readonly = false } = value.data;\n            return (\n                <EditorWrap tagHeight={tagHeight} innerPad={innerPad} className={readonly ? \"readonly\" : \"\"}>\n                    {possibleTags.map(t => {\n                        const selected = tags.indexOf(t.tag) !== -1;\n                        return (\n                            <label key={t.tag}>\n                                {!readonly && (\n                                    <input\n                                        className=\"gdg-input\"\n                                        type=\"checkbox\"\n                                        checked={selected}\n                                        onChange={() => {\n                                            const newTags = selected ? tags.filter(x => x !== t.tag) : [...tags, t.tag];\n                                            onChange({\n                                                ...p.value,\n                                                data: {\n                                                    ...value.data,\n                                                    tags: newTags,\n                                                },\n                                            });\n                                        }}\n                                    />\n                                )}\n                                <div\n                                    className={\"pill \" + (selected ? \"selected\" : \"unselected\")}\n                                    style={{ backgroundColor: selected ? t.color : undefined }}>\n                                    {t.tag}\n                                </div>\n                            </label>\n                        );\n                    })}\n                </EditorWrap>\n            );\n        };\n    },\n    onPaste: (v, d) => ({\n        ...d,\n        tags: d.possibleTags\n            .map(x => x.tag)\n            .filter(x =>\n                v\n                    .split(\",\")\n                    .map(s => s.trim())\n                    .includes(x)\n            ),\n    }),\n};\n\nexport default renderer;\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport {\n    CustomCell,\n    measureTextCached,\n    TextCellEntry,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\n\ninterface UserProfileCellProps {\n    readonly kind: \"user-profile-cell\";\n    readonly image: string;\n    readonly initial: string;\n    readonly tint: string;\n    readonly name?: string;\n}\n\nexport type UserProfileCell = CustomCell<UserProfileCellProps>;\n\nconst renderer: CustomRenderer<UserProfileCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (cell: CustomCell): cell is UserProfileCell => (cell.data as any).kind === \"user-profile-cell\",\n    draw: (args, cell) => {\n        const { ctx, rect, theme, imageLoader, col, row } = args;\n        const { image, name, initial, tint } = cell.data;\n\n        const xPad = theme.cellHorizontalPadding;\n\n        const radius = Math.min(12, rect.height / 2 - theme.cellVerticalPadding);\n\n        const drawX = rect.x + xPad;\n\n        const imageResult = imageLoader.loadOrGetImage(image, col, row);\n\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);\n        ctx.globalAlpha = 0.2;\n        ctx.fillStyle = tint;\n        ctx.fill();\n        ctx.globalAlpha = 1;\n\n        ctx.font = `600 16px ${theme.fontFamily}`;\n        const metrics = measureTextCached(initial[0], ctx);\n        ctx.fillText(\n            initial[0],\n            drawX + radius - metrics.width / 2,\n            rect.y + rect.height / 2 + getMiddleCenterBias(ctx, `600 16px ${theme.fontFamily}`)\n        );\n\n        if (imageResult !== undefined) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);\n            ctx.clip();\n\n            ctx.drawImage(imageResult, drawX, rect.y + rect.height / 2 - radius, radius * 2, radius * 2);\n\n            ctx.restore();\n        }\n\n        if (name !== undefined) {\n            ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(name, drawX + radius * 2 + xPad, rect.y + rect.height / 2 + getMiddleCenterBias(ctx, theme));\n        }\n\n        ctx.restore();\n\n        return true;\n    },\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value } = p;\n        return (\n            <TextCellEntry\n                highlight={isHighlighted}\n                autoFocus={true}\n                value={value.data.name ?? \"\"}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: {\n                            ...value.data,\n                            name: e.target.value,\n                        },\n                    })\n                }\n            />\n        );\n    },\n    onPaste: (v, d) => ({\n        ...d,\n        name: v,\n    }),\n};\n\nexport default renderer;\n","import {\n    CustomCell,\n    ProvideEditorCallback,\n    CustomRenderer,\n    getMiddleCenterBias,\n    useTheme,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport Select, { MenuProps, components } from \"react-select\";\n\ninterface CustomMenuProps extends MenuProps<any> {}\n\nconst CustomMenu: React.FC<CustomMenuProps> = p => {\n    const { Menu } = components;\n    const { children, ...rest } = p;\n    return <Menu {...rest}>{children}</Menu>;\n};\n\ninterface DropdownCellProps {\n    readonly kind: \"dropdown-cell\";\n    readonly value: string;\n    readonly allowedValues: readonly string[];\n    readonly readonly?: boolean;\n}\n\nexport type DropdownCell = CustomCell<DropdownCellProps>;\n\nconst Wrap = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n\n    .glide-select {\n        font-family: var(--gdg-font-family);\n        font-size: var(--gdg-editor-font-size);\n    }\n`;\n\nconst PortalWrap = styled.div`\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n    color: var(--gdg-text-dark);\n\n    > div {\n        border-radius: 4px;\n        border: 1px solid var(--gdg-border-color);\n    }\n`;\n\nconst Editor: ReturnType<ProvideEditorCallback<DropdownCell>> = p => {\n    const { value: cell, onFinishedEditing, initialValue } = p;\n    const { allowedValues, value: valueIn } = cell.data;\n\n    const [value, setValue] = React.useState(valueIn);\n    const [inputValue, setInputValue] = React.useState(initialValue ?? \"\");\n\n    const theme = useTheme();\n\n    const values = React.useMemo(\n        () =>\n            allowedValues.map(x => ({\n                value: x,\n                label: x,\n            })),\n        [allowedValues]\n    );\n\n    return (\n        <Wrap>\n            <Select\n                className=\"glide-select\"\n                inputValue={inputValue}\n                onInputChange={setInputValue}\n                menuPlacement={\"auto\"}\n                value={values.find(x => x.value === value)}\n                styles={{\n                    control: base => ({\n                        ...base,\n                        border: 0,\n                        boxShadow: \"none\",\n                    }),\n                }}\n                theme={t => {\n                    return {\n                        ...t,\n                        colors: {\n                            ...t.colors,\n                            neutral0: theme.bgCell, // this is both the background color AND the fg color of\n                            // the selected item because of course it is.\n                            neutral5: theme.bgCell,\n                            neutral10: theme.bgCell,\n                            neutral20: theme.bgCellMedium,\n                            neutral30: theme.bgCellMedium,\n                            neutral40: theme.bgCellMedium,\n                            neutral50: theme.textLight,\n                            neutral60: theme.textMedium,\n                            neutral70: theme.textMedium,\n                            neutral80: theme.textDark,\n                            neutral90: theme.textDark,\n                            neutral100: theme.textDark,\n                            primary: theme.accentColor,\n                            primary75: theme.accentColor,\n                            primary50: theme.accentColor,\n                            primary25: theme.accentLight, // prelight color\n                        },\n                    };\n                }}\n                menuPortalTarget={document.getElementById(\"portal\")}\n                autoFocus={true}\n                openMenuOnFocus={true}\n                components={{\n                    DropdownIndicator: () => null,\n                    IndicatorSeparator: () => null,\n                    Menu: props => (\n                        <PortalWrap>\n                            <CustomMenu className={\"click-outside-ignore\"} {...props} />\n                        </PortalWrap>\n                    ),\n                }}\n                options={values}\n                onChange={async e => {\n                    if (e === null) return;\n                    setValue(e.value);\n                    await new Promise(r => window.requestAnimationFrame(r));\n                    onFinishedEditing({\n                        ...cell,\n                        data: {\n                            ...cell.data,\n                            value: e.value,\n                        },\n                    });\n                }}\n            />\n        </Wrap>\n    );\n};\n\nconst renderer: CustomRenderer<DropdownCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is DropdownCell => (c.data as any).kind === \"dropdown-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { value } = cell.data;\n        ctx.fillStyle = theme.textDark;\n        ctx.fillText(\n            value,\n            rect.x + theme.cellHorizontalPadding,\n            rect.y + rect.height / 2 + getMiddleCenterBias(ctx, theme)\n        );\n\n        return true;\n    },\n    provideEditor: () => ({\n        editor: Editor,\n        disablePadding: true,\n        deletedValue: v => ({\n            ...v,\n            copyData: \"\",\n            data: {\n                ...v.data,\n                value: \"\",\n            },\n        }),\n    }),\n    onPaste: (v, d) => ({\n        ...d,\n        value: d.allowedValues.includes(v) ? v : d.value,\n    }),\n};\n\nexport default renderer;\n","import type { ArticleCell } from \"./article-cell-types\";\nimport * as React from \"react\";\nimport { CustomRenderer, getMiddleCenterBias, GridCellKind } from \"@glideapps/glide-data-grid\";\n\nconst ArticleCellEditor = React.lazy(async () => await import(\"./article-cell-editor\"));\n\nconst renderer: CustomRenderer<ArticleCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is ArticleCell => (c.data as any).kind === \"article-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { markdown } = cell.data;\n\n        let data = markdown;\n        if (data.includes(\"\\n\")) {\n            // new lines are rare and split is relatively expensive compared to the search\n            // it pays off to not do the split contantly.\n            data = data.split(/\\r?\\n/)[0];\n        }\n        const max = rect.width / 4; // no need to round, slice will just truncate this\n        if (data.length > max) {\n            data = data.slice(0, max);\n        }\n\n        ctx.fillStyle = theme.textDark;\n        ctx.fillText(\n            data,\n            rect.x + theme.cellHorizontalPadding,\n            rect.y + rect.height / 2 + getMiddleCenterBias(ctx, theme)\n        );\n\n        return true;\n    },\n    provideEditor: () => ({\n        editor: p => {\n            return (\n                <React.Suspense fallback={null}>\n                    <ArticleCellEditor {...p} />\n                </React.Suspense>\n            );\n        },\n        styleOverride: {\n            position: \"fixed\",\n            left: \"12.5vw\",\n            top: \"12.5vh\",\n            width: \"75vw\",\n            borderRadius: \"9px\",\n            maxWidth: \"unset\",\n            maxHeight: \"unset\",\n        },\n        disablePadding: true,\n    }),\n    onPaste: (val, d) => ({\n        ...d,\n        markdown: val,\n    }),\n};\n\nexport default renderer;\n","import {\n    CustomCell,\n    measureTextCached,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\nimport * as React from \"react\";\nimport { roundedRect } from \"../draw-fns\";\n\ninterface RangeCellProps {\n    readonly kind: \"range-cell\";\n    readonly value: number;\n    readonly min: number;\n    readonly max: number;\n    readonly step: number;\n    readonly label?: string;\n    readonly measureLabel?: string;\n    readonly readonly?: boolean;\n}\n\nexport type RangeCell = CustomCell<RangeCellProps>;\n\nconst RANGE_HEIGHT = 6;\n\nconst inputStyle: React.CSSProperties = {\n    marginRight: 8,\n};\n\nconst wrapperStyle: React.CSSProperties = {\n    display: \"flex\",\n    alignItems: \"center\",\n    flexGrow: 1,\n};\n\nconst renderer: CustomRenderer<RangeCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is RangeCell => (c.data as any).kind === \"range-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { min, max, value, label, measureLabel } = cell.data;\n\n        const x = rect.x + theme.cellHorizontalPadding;\n        const yMid = rect.y + rect.height / 2;\n\n        const rangeSize = max - min;\n        const fillRatio = (value - min) / rangeSize;\n\n        ctx.save();\n        let labelWidth = 0;\n        if (label !== undefined) {\n            ctx.font = `12px ${theme.fontFamily}`; // fixme this is slow\n            labelWidth =\n                measureTextCached(measureLabel ?? label, ctx, `12px ${theme.fontFamily}`).width +\n                theme.cellHorizontalPadding;\n        }\n\n        const rangeWidth = rect.width - theme.cellHorizontalPadding * 2 - labelWidth;\n\n        const gradient = ctx.createLinearGradient(x, yMid, x + rangeWidth, yMid);\n\n        gradient.addColorStop(0, theme.accentColor);\n        gradient.addColorStop(fillRatio, theme.accentColor);\n        gradient.addColorStop(fillRatio, theme.bgBubble);\n        gradient.addColorStop(1, theme.bgBubble);\n\n        ctx.beginPath();\n        ctx.fillStyle = gradient;\n        roundedRect(ctx, x, yMid - RANGE_HEIGHT / 2, rangeWidth, RANGE_HEIGHT, RANGE_HEIGHT / 2);\n        ctx.fill();\n\n        ctx.beginPath();\n        roundedRect(\n            ctx,\n            x + 0.5,\n            yMid - RANGE_HEIGHT / 2 + 0.5,\n            rangeWidth - 1,\n            RANGE_HEIGHT - 1,\n            (RANGE_HEIGHT - 1) / 2\n        );\n        ctx.strokeStyle = theme.accentLight;\n        ctx.lineWidth = 1;\n        ctx.stroke();\n\n        if (label !== undefined) {\n            ctx.textAlign = \"right\";\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(\n                label,\n                rect.x + rect.width - theme.cellHorizontalPadding,\n                yMid + getMiddleCenterBias(ctx, `12px ${theme.fontFamily}`)\n            );\n        }\n\n        ctx.restore();\n\n        return true;\n    },\n    provideEditor: () => {\n        // eslint-disable-next-line react/display-name\n        return p => {\n            const { data } = p.value;\n\n            const strValue = data.value.toString();\n            const strMin = data.min.toString();\n            const strMax = data.max.toString();\n            const strStep = data.step.toString();\n\n            const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n                p.onChange({\n                    ...p.value,\n                    data: {\n                        ...data,\n                        value: Number(e.target.value),\n                    },\n                });\n            };\n\n            return (\n                <label style={wrapperStyle}>\n                    <input\n                        style={inputStyle}\n                        type=\"range\"\n                        value={strValue}\n                        min={strMin}\n                        max={strMax}\n                        step={strStep}\n                        onChange={onChange}\n                    />\n                    {strValue}\n                </label>\n            );\n        };\n    },\n    onPaste: (v, d) => {\n        let num = Number.parseFloat(v);\n        num = Number.isNaN(num) ? d.value : Math.max(d.min, Math.min(d.max, num));\n        return {\n            ...d,\n            value: num,\n        };\n    },\n};\n\nexport default renderer;\n","import { CustomCell, CustomRenderer, GridCellKind } from \"@glideapps/glide-data-grid\";\n\ninterface SpinnerCellProps {\n    readonly kind: \"spinner-cell\";\n}\n\nexport type SpinnerCell = CustomCell<SpinnerCellProps>;\n\nconst renderer: CustomRenderer<SpinnerCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (cell: CustomCell): cell is SpinnerCell => (cell.data as any).kind === \"spinner-cell\",\n    draw: args => {\n        const { ctx, theme, rect, requestAnimationFrame } = args;\n\n        const progress = (window.performance.now() % 1000) / 1000;\n\n        const x = rect.x + rect.width / 2;\n        const y = rect.y + rect.height / 2;\n        ctx.arc(\n            x,\n            y,\n            Math.min(12, rect.height / 2 - 2),\n            Math.PI * 2 * progress,\n            Math.PI * 2 * progress + Math.PI * 1.5\n        );\n\n        ctx.strokeStyle = theme.textMedium;\n        ctx.lineWidth = 2;\n        ctx.stroke();\n\n        ctx.lineWidth = 1;\n\n        requestAnimationFrame();\n\n        return true;\n    },\n    provideEditor: () => undefined,\n};\n\nexport default renderer;\n","import * as React from \"react\";\nimport { CustomCell, CustomRenderer, drawTextCell, GridCellKind } from \"@glideapps/glide-data-grid\";\n\ninterface DatePickerCellProps {\n    readonly kind: \"date-picker-cell\";\n    readonly date: Date | undefined;\n    readonly displayDate: string;\n    readonly format: \"date\" | \"datetime-local\";\n}\n\nexport type DatePickerCell = CustomCell<DatePickerCellProps>;\n\nconst renderer: CustomRenderer<DatePickerCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (cell: CustomCell): cell is DatePickerCell => (cell.data as any).kind === \"date-picker-cell\",\n    draw: (args, cell) => {\n        const { displayDate } = cell.data;\n        drawTextCell(args, displayDate, cell.contentAlign);\n        return true;\n    },\n    // eslint-disable-next-line react/display-name\n    provideEditor: () => p => {\n        const cellData = p.value.data;\n        const { format, date } = cellData;\n\n        let val = \"\";\n        if (date !== undefined) {\n            val = date.toISOString();\n            if (format === \"date\") {\n                val = val.split(\"T\")[0];\n            }\n        }\n        return (\n            <input\n                style={{ minHeight: 26, border: \"none\", outline: \"none\" }}\n                type={format}\n                autoFocus={true}\n                value={val}\n                onChange={e => {\n                    p.onChange({\n                        ...p.value,\n                        data: {\n                            ...p.value.data,\n                            date: e.target.valueAsDate ?? undefined,\n                        },\n                    });\n                }}\n            />\n        );\n    },\n    onPaste: (v, d) => {\n        let newDate: Date | undefined;\n        try {\n            newDate = new Date(v);\n        } catch {\n            /* do nothing */\n        }\n\n        return {\n            ...d,\n            date: Number.isNaN(newDate) ? undefined : newDate,\n        };\n    },\n};\n\nexport default renderer;\n","import {\n    CustomCell,\n    measureTextCached,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n    blend,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\n\ninterface LinksCellProps {\n    readonly kind: \"links-cell\";\n    /**\n     * Used to hand tune the position of the underline as this is not a native canvas capability, it can need tweaking\n     * for different fonts.\n     */\n    readonly underlineOffset?: number;\n    readonly maxLinks?: number;\n    readonly navigateOn?: \"click\" | \"control-click\";\n    readonly links: readonly {\n        readonly title: string;\n        readonly href?: string;\n        readonly onClick?: () => void;\n    }[];\n}\n\nexport type LinksCell = CustomCell<LinksCellProps>;\n\nfunction onClickSelect(e: Parameters<NonNullable<CustomRenderer<LinksCell>[\"onSelect\"]>>[0]) {\n    const useCtrl = e.cell.data.navigateOn !== \"click\";\n    if (useCtrl !== e.ctrlKey) return undefined;\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\", { alpha: false });\n    if (ctx === null) return;\n\n    const { posX: hoverX, bounds: rect, cell, theme } = e;\n    const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n    ctx.font = font;\n\n    const { links } = cell.data;\n\n    const xPad = theme.cellHorizontalPadding;\n\n    let drawX = rect.x + xPad;\n\n    const rectHoverX = rect.x + hoverX;\n\n    for (const [index, l] of links.entries()) {\n        const needsComma = index < links.length - 1;\n        const metrics = measureTextCached(l.title, ctx);\n        const commaMetrics = needsComma ? measureTextCached(l.title + \",\", ctx, font) : metrics;\n\n        const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\n\n        if (isHovered) {\n            return l;\n        }\n\n        drawX += commaMetrics.width + 4;\n    }\n\n    return undefined;\n}\n\nconst renderer: CustomRenderer<LinksCell> = {\n    kind: GridCellKind.Custom,\n    needsHover: true,\n    needsHoverPosition: true,\n    isMatch: (c): c is LinksCell => (c.data as any).kind === \"links-cell\",\n    onSelect: e => {\n        if (onClickSelect(e) !== undefined) {\n            e.preventDefault();\n        }\n    },\n    onClick: e => {\n        const hovered = onClickSelect(e);\n        if (hovered !== undefined) {\n            hovered.onClick?.();\n            e.preventDefault();\n        }\n        return undefined;\n    },\n    draw: (args, cell) => {\n        const { ctx, rect, theme, hoverX = -100, highlighted } = args;\n        const { links, underlineOffset = 5 } = cell.data;\n\n        const xPad = theme.cellHorizontalPadding;\n\n        let drawX = rect.x + xPad;\n\n        const rectHoverX = rect.x + hoverX;\n\n        const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n\n        const middleCenterBias = getMiddleCenterBias(ctx, font);\n        const drawY = rect.y + rect.height / 2 + middleCenterBias;\n\n        for (const [index, l] of links.entries()) {\n            const needsComma = index < links.length - 1;\n            const metrics = measureTextCached(l.title, ctx);\n            const commaMetrics = needsComma ? measureTextCached(l.title + \",\", ctx, font) : metrics;\n\n            const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\n\n            if (isHovered) {\n                ctx.moveTo(drawX, Math.floor(drawY + underlineOffset) + 0.5);\n                ctx.lineTo(drawX + metrics.width, Math.floor(drawY + underlineOffset) + 0.5);\n\n                // ctx.lineWidth = 1;\n                ctx.strokeStyle = theme.textDark;\n                ctx.stroke();\n\n                ctx.fillStyle = highlighted ? blend(theme.accentLight, theme.bgCell) : theme.bgCell;\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX - 1, drawY);\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX + 1, drawY);\n\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX - 2, drawY);\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX + 2, drawY);\n            }\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX, drawY);\n\n            drawX += commaMetrics.width + 4;\n        }\n\n        return true;\n    },\n    // eslint-disable-next-line react/display-name\n    provideEditor: () => p => {\n        const { value, onChange } = p;\n        const { links, maxLinks = Number.MAX_SAFE_INTEGER } = value.data;\n        return (\n            <LinksCellEditorStyle onKeyDown={ignoreTab}>\n                {links.map((l, i) => (\n                    <LinkTitleEditor\n                        key={i}\n                        link={l.href ?? \"\"}\n                        title={l.title}\n                        focus={i === 0}\n                        onDelete={\n                            links.length > 1\n                                ? () => {\n                                      const newLinks = [...links];\n                                      newLinks.splice(i, 1);\n                                      onChange({\n                                          ...value,\n                                          data: {\n                                              ...value.data,\n                                              links: newLinks,\n                                          },\n                                      });\n                                  }\n                                : undefined\n                        }\n                        onChange={(link, title) => {\n                            const newLinks = [...links];\n                            newLinks[i] = {\n                                href: link,\n                                title,\n                            };\n                            onChange({\n                                ...value,\n                                data: {\n                                    ...value.data,\n                                    links: newLinks,\n                                },\n                            });\n                        }}\n                    />\n                ))}\n                <button\n                    disabled={links.length >= maxLinks}\n                    className=\"add-link\"\n                    onClick={() => {\n                        const newLinks = [...links, { title: \"\" }];\n                        onChange({\n                            ...value,\n                            data: {\n                                ...value.data,\n                                links: newLinks,\n                            },\n                        });\n                    }}>\n                    Add link\n                </button>\n            </LinksCellEditorStyle>\n        );\n    },\n    onPaste: (v, d) => {\n        const split = v.split(\",\");\n        if (d.links.some((l, i) => split[i] !== l.title)) return undefined;\n        return {\n            ...d,\n            links: split.map(l => ({ title: l })),\n        };\n    },\n};\n\nconst LinksCellEditorStyle = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    margin: 4px 0;\n\n    > button {\n        color: var(--gdg-accent-color);\n        font-weight: 600;\n        align-self: flex-end;\n        border: none;\n        outline: none;\n        background-color: transparent;\n\n        transition: background-color 200ms;\n        border-radius: 4px;\n\n        padding: 6px 8px;\n        cursor: pointer;\n\n        :hover,\n        :focus-visible {\n            background-color: var(--gdg-accent-light);\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n\n    .gdg-link-title-editor {\n        display: flex;\n\n        min-width: 250px;\n\n        > input {\n            outline: none;\n            border: 1px solid var(--gdg-border-color);\n            border-radius: 4px;\n            box-shadow: none;\n            padding: 6px 8px;\n            min-width: 0;\n            width: 0;\n            flex-grow: 1;\n\n            &:not(:last-child) {\n                margin-right: 4px;\n            }\n\n            transition: border 200ms;\n\n            &:focus {\n                border: 1px solid var(--gdg-accent-color);\n            }\n        }\n\n        &:not(:last-child) {\n            margin-bottom: 4px;\n        }\n\n        > button {\n            border: none;\n            outline: none;\n            border-radius: 4px;\n\n            background-color: transparent;\n\n            cursor: pointer;\n\n            transition: background-color 200ms, color 200ms;\n\n            color: var(--gdg-text-medium);\n\n            :hover,\n            :focus-visible {\n                background-color: var(--gdg-accent-light);\n                color: var(--gdg-text-dark);\n            }\n        }\n    }\n`;\n\ninterface LinkTitleEditorProps {\n    readonly link: string;\n    readonly title: string;\n    readonly onChange: (link: string, title: string) => void;\n    readonly onDelete?: () => void;\n    readonly focus: boolean;\n}\n\nfunction ignoreTab(e: React.KeyboardEvent) {\n    if (e.key === \"Tab\") {\n        e.stopPropagation();\n    }\n}\n\nconst LinkTitleEditor: React.VFC<LinkTitleEditorProps> = p => {\n    const { link, onChange, title, onDelete, focus } = p;\n    return (\n        <div className=\"gdg-link-title-editor\">\n            <input\n                className=\"gdg-title-input\"\n                value={title}\n                placeholder=\"Title\"\n                autoFocus={focus}\n                onChange={e => {\n                    onChange(link, e.target.value);\n                }}\n            />\n            <input\n                className=\"gdg-link-input\"\n                value={link}\n                placeholder=\"URL\"\n                onChange={e => {\n                    onChange(e.target.value, title);\n                }}\n            />\n            {onDelete !== undefined && (\n                <button onClick={onDelete}>\n                    <svg\n                        width={16}\n                        height={16}\n                        viewBox=\"0 0 24 24\"\n                        fill=\"none\"\n                        id=\"icon-import\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M3 6L5 6L21 6\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M17.9019 6C18.491 6 18.9525 6.50676 18.8975 7.09334L17.67 20.1867C17.5736 21.2144 16.711 22 15.6787 22H8.32127C7.28902 22 6.42635 21.2144 6.33 20.1867L5.1025 7.09334C5.04751 6.50676 5.50898 6 6.09813 6H17.9019Z\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M14.4499 10.211L13.9949 17\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M9.55499 10.211L10.0049 17\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M7.5 2.25H16.5\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                    </svg>\n                </button>\n            )}\n        </div>\n    );\n};\n\nexport default renderer;\n","import {\n    CustomCell,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n    interpolateColors,\n} from \"@glideapps/glide-data-grid\";\nimport { roundedRect } from \"../draw-fns\";\n\ntype PackedColor = string | readonly [normal: string, hover: string];\n\ninterface ButtonCellProps {\n    readonly kind: \"button-cell\";\n    readonly title: string;\n    readonly onClick?: () => void;\n    readonly backgroundColor?: PackedColor;\n    readonly color?: PackedColor;\n    readonly borderColor?: PackedColor;\n    readonly borderRadius?: number;\n}\n\nexport type ButtonCell = CustomCell<ButtonCellProps> & { readonly: true };\n\nfunction unpackColor(color: PackedColor, theme: Record<string, any>, hoverAmount: number): string {\n    if (typeof color === \"string\") {\n        if (theme[color] !== undefined) return theme[color];\n        return color;\n    }\n\n    let [normal, hover] = color;\n    if (theme[normal] !== undefined) normal = theme[normal];\n    if (theme[hover] !== undefined) hover = theme[hover];\n    return interpolateColors(normal, hover, hoverAmount);\n}\n\nconst renderer: CustomRenderer<ButtonCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is ButtonCell => (c.data as any).kind === \"button-cell\",\n    needsHover: true,\n    onSelect: a => a.preventDefault(),\n    onClick: a => {\n        a.cell.data.onClick?.();\n        return undefined;\n    },\n    drawPrep: args => {\n        const { ctx } = args;\n\n        ctx.textAlign = \"center\";\n\n        return {\n            deprep: a => {\n                a.ctx.textAlign = \"start\";\n            },\n        };\n    },\n    draw: (args, cell) => {\n        const { ctx, theme, rect, hoverAmount } = args;\n        const { title, backgroundColor, color, borderColor, borderRadius } = cell.data;\n\n        const x = Math.floor(rect.x + theme.cellHorizontalPadding + 1);\n        const y = Math.floor(rect.y + theme.cellVerticalPadding + 1);\n        const width = Math.ceil(rect.width - theme.cellHorizontalPadding * 2 - 1);\n        const height = Math.ceil(rect.height - theme.cellVerticalPadding * 2 - 1);\n\n        if (backgroundColor !== undefined) {\n            ctx.beginPath();\n            roundedRect(ctx, x, y, width, height, borderRadius ?? 0);\n            ctx.fillStyle = unpackColor(backgroundColor, theme, hoverAmount);\n            ctx.fill();\n        }\n\n        if (borderColor !== undefined) {\n            ctx.beginPath();\n            roundedRect(ctx, x + 0.5, y + 0.5, width - 1, height - 1, borderRadius ?? 0);\n            ctx.strokeStyle = unpackColor(borderColor, theme, hoverAmount);\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        }\n\n        ctx.fillStyle = unpackColor(color ?? theme.accentColor, theme, hoverAmount);\n        ctx.fillText(\n            title,\n            x + width / 2,\n            y + height / 2 + getMiddleCenterBias(ctx, `${theme.baseFontStyle} ${theme.fontFamily}`)\n        );\n        return true;\n    },\n    provideEditor: undefined,\n};\n\nexport default renderer;\n","import { useCustomCells } from \"@glideapps/glide-data-grid\";\nimport StarCellRenderer, { StarCell } from \"./cells/star-cell\";\nimport SparklineCellRenderer, { SparklineCell } from \"./cells/sparkline-cell\";\nimport TagsCellRenderer, { TagsCell } from \"./cells/tags-cell\";\nimport UserProfileCellRenderer, { UserProfileCell } from \"./cells/user-profile-cell\";\nimport DropdownCellRenderer, { DropdownCell } from \"./cells/dropdown-cell\";\nimport ArticleCellRenderer from \"./cells/article-cell\";\nimport type { ArticleCell } from \"./cells/article-cell-types\";\nimport RangeCellRenderer, { RangeCell } from \"./cells/range-cell\";\nimport SpinnerCellRenderer, { SpinnerCell } from \"./cells/spinner-cell\";\nimport DatePickerRenderer, { DatePickerCell } from \"./cells/date-picker-cell\";\nimport LinksCellRenderer, { LinksCell } from \"./cells/links-cell\";\nimport ButtonCellRenderer, { ButtonCell } from \"./cells/button-cell\";\n\nconst cells = [\n    StarCellRenderer,\n    SparklineCellRenderer,\n    TagsCellRenderer,\n    UserProfileCellRenderer,\n    DropdownCellRenderer,\n    ArticleCellRenderer,\n    SpinnerCellRenderer,\n    RangeCellRenderer,\n    DatePickerRenderer,\n    LinksCellRenderer,\n    ButtonCellRenderer,\n];\n\nexport function useExtraCells() {\n    return useCustomCells(cells);\n}\n\nexport {\n    StarCellRenderer as StarCell,\n    SparklineCellRenderer as SparklineCell,\n    TagsCellRenderer as TagsCell,\n    UserProfileCellRenderer as UserProfileCell,\n    DropdownCellRenderer as DropdownCell,\n    ArticleCellRenderer as ArticleCell,\n    RangeCellRenderer as RangeCell,\n    SpinnerCellRenderer as SpinnerCell,\n    DatePickerRenderer as DatePickerCell,\n    LinksCellRenderer as LinksCell,\n    ButtonCellRenderer as ButtonCell,\n    cells as allCells,\n};\n\nexport type {\n    StarCell as StarCellType,\n    SparklineCell as SparklineCellType,\n    TagsCell as TagsCellType,\n    UserProfileCell as UserProfileCellType,\n    DropdownCell as DropdownCellType,\n    ArticleCell as ArticleCellType,\n    RangeCell as RangeCellType,\n    SpinnerCell as SpinnerCellType,\n    DatePickerCell as DatePickerType,\n    LinksCell as LinksCellType,\n    ButtonCell as ButtonCellType,\n};\n","import api from \"!../../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./index.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { DataEditor, DataEditorProps, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \".\";\nimport type { StarCell } from \"./cells/star-cell\";\nimport type { SparklineCell } from \"./cells/sparkline-cell\";\nimport range from \"lodash/range.js\";\nimport uniq from \"lodash/uniq.js\";\nimport type { TagsCell } from \"./cells/tags-cell\";\nimport type { UserProfileCell } from \"./cells/user-profile-cell\";\nimport type { DropdownCell } from \"./cells/dropdown-cell\";\nimport type { ArticleCell } from \"./cells/article-cell-types\";\nimport type { RangeCell } from \"./cells/range-cell\";\nimport type { SpinnerCell } from \"./cells/spinner-cell\";\nimport { useResizeDetector } from \"react-resize-detector\";\n\nimport \"@toast-ui/editor/dist/toastui-editor.css\";\nimport \"@glideapps/glide-data-grid/dist/index.css\";\nimport type { DatePickerCell } from \"./cells/date-picker-cell\";\nimport type { LinksCell } from \"./cells/links-cell\";\nimport type { ButtonCell } from \"./cells/button-cell\";\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Cells\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16807) % 2147483647) / 2147483647;\n}\n\nconst possibleTags = [\n    {\n        tag: \"Bug\",\n        color: \"#ff4d4d35\",\n    },\n    {\n        tag: \"Feature\",\n        color: \"#35f8ff35\",\n    },\n    {\n        tag: \"Enhancement\",\n        color: \"#48ff5735\",\n    },\n    {\n        tag: \"First Issue\",\n        color: \"#436fff35\",\n    },\n    {\n        tag: \"PR\",\n        color: \"#e0ff3235\",\n    },\n    {\n        tag: \"Assigned\",\n        color: \"#ff1eec35\",\n    },\n];\n\nexport const CustomCells: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    return (\n        <BeautifulWrapper title=\"Custom cells\" description={<Description>Some of our extension cells.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                // eslint-disable-next-line no-console\n                onCellEdited={(...args) => console.log(\"Edit Cell\", ...args)}\n                getCellContent={cell => {\n                    const [col, row] = cell;\n                    if (col === 0) {\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"star-cell\",\n                                label: \"Test\",\n                                rating: 4,\n                            },\n                        } as StarCell;\n                    } else if (col === 1) {\n                        num = row + 1;\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values,\n                                displayValues: values.map(x => Math.round(x).toString()),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 2) {\n                        num = row + 1;\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values: range(0, 15).map(() => rand() * 100 - 50),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                graphKind: \"bar\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 3) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"tags-cell\",\n                                possibleTags: possibleTags,\n                                readonly: row % 2 === 0,\n                                tags: uniq([\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                ]),\n                            },\n                        } as TagsCell;\n                    } else if (col === 4) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"user-profile-cell\",\n                                image: row % 2 ? undefined : \"https://i.redd.it/aqc1hwhalsz71.jpg\",\n                                initial: \"B\",\n                                tint: \"#F1D86E\",\n                                name: row % 5 ? undefined : \"Bee bb\",\n                            },\n                        } as UserProfileCell;\n                    } else if (col === 5) {\n                        num = row + 1;\n                        rand();\n                        const d: DropdownCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"dropdown-cell\",\n                                allowedValues: [\"Good\", \"Better\", \"Best\"],\n                                value: \"Good\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 6) {\n                        num = row + 1;\n                        rand();\n                        const v = rand();\n                        const d: RangeCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"range-cell\",\n                                min: 10,\n                                max: 30,\n                                value: 10 + Math.round(v * 20),\n                                step: 1,\n                                label: `${Math.round(v * 100)}%`,\n                                measureLabel: \"100%\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 7) {\n                        num = row + 1;\n                        rand();\n                        const d: ArticleCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"article-cell\",\n                                markdown: \"## This is a test\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 8) {\n                        num = row + 1;\n                        rand();\n                        const d: SpinnerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"spinner-cell\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 9) {\n                        num = row + 1;\n                        rand();\n                        const d: DatePickerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"date-picker-cell\",\n                                date: new Date(),\n                                displayDate: new Date().toISOString(),\n                                format: \"date\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 10) {\n                        num = row + 1;\n                        rand();\n                        const d: LinksCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"links-cell\",\n                                underlineOffset: 6,\n                                links: [\n                                    {\n                                        title: \"Linky phone\",\n                                        onClick: () => alert(\"Click 1\"),\n                                    },\n                                    {\n                                        title: \"Click the linky dinky\",\n                                        onClick: () => alert(\"Click 2\"),\n                                    },\n                                ],\n                            },\n                        };\n                        return d;\n                    } else if (col === 11) {\n                        num = row + 1;\n                        rand();\n                        const d: ButtonCell = {\n                            kind: GridCellKind.Custom,\n                            cursor: \"pointer\",\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            readonly: true,\n                            data: {\n                                kind: \"button-cell\",\n                                backgroundColor: [\"transparent\", \"#6572ffee\"],\n                                color: [\"accentColor\", \"accentFg\"],\n                                borderColor: \"#6572ffa0\",\n                                borderRadius: 9,\n                                title: \"View Details\",\n                                onClick: () => window.alert(\"Button clicked\"),\n                            },\n                            themeOverride: {\n                                baseFontStyle: \"700 12px\",\n                            },\n                        };\n                        return d;\n                    }\n                    throw new Error(\"Fail\");\n                }}\n                columns={[\n                    {\n                        title: \"Stars\",\n                        width: 200,\n                    },\n                    {\n                        title: \"Sparkline\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Sparkline (bars)\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Tags\",\n                        width: 250,\n                    },\n                    {\n                        title: \"Profile\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Dropdown\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Range\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Article\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Spinner\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Date Picker\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Links\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Button\",\n                        width: 120,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CustomCellEditing: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    const data = React.useRef<string[]>([]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Custom cell editing\"\n            description={\n                <Description>\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                onCellEdited={(cell, newVal) => {\n                    if (newVal.kind !== GridCellKind.Custom) return;\n                    if (DropdownRenderer.isMatch(newVal)) {\n                        data.current[cell[1]] = newVal.data.value;\n                    }\n                }}\n                getCellsForSelection={true}\n                getCellContent={cell => {\n                    const [, row] = cell;\n                    const val = data.current[row] ?? \"A\";\n                    return {\n                        kind: GridCellKind.Custom,\n                        allowOverlay: true,\n                        copyData: val,\n                        data: {\n                            kind: \"dropdown-cell\",\n                            allowedValues: [\"A\", \"B\", \"C\"],\n                            value: val,\n                        },\n                    } as DropdownCell;\n                }}\n                columns={[\n                    {\n                        title: \"Dropdown\",\n                        width: 200,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCellEditing as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","class Lazy<T> {\n    private fn: () => T;\n    private val: T | undefined;\n    constructor(fn: () => T) {\n        this.fn = fn;\n    }\n\n    public get value() {\n        return this.val ?? (this.val = this.fn());\n    }\n}\n\nfunction lazy<T>(fn: () => T) {\n    return new Lazy(fn);\n}\n\n// next.js apps don't have window available at import time, so this will fail if its not lazy.\nexport const browserIsFirefox = lazy(() => window.navigator.userAgent.includes(\"Firefox\"));\nexport const browserIsSafari = lazy(\n    () =>\n        window.navigator.userAgent.includes(\"Mac OS\") &&\n        window.navigator.userAgent.includes(\"Safari\") &&\n        !window.navigator.userAgent.includes(\"Chrome\")\n);\nexport const browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith(\"mac\"));\n","import React from \"react\";\n\n// theme variable precidence\n\n/** @category Theme */\nexport function makeCSSStyle(theme: Theme): Record<string, string> {\n    return {\n        \"--gdg-accent-color\": theme.accentColor,\n        \"--gdg-accent-fg\": theme.accentFg,\n        \"--gdg-accent-light\": theme.accentLight,\n        \"--gdg-text-dark\": theme.textDark,\n        \"--gdg-text-medium\": theme.textMedium,\n        \"--gdg-text-light\": theme.textLight,\n        \"--gdg-text-bubble\": theme.textBubble,\n        \"--gdg-bg-icon-header\": theme.bgIconHeader,\n        \"--gdg-fg-icon-header\": theme.fgIconHeader,\n        \"--gdg-text-header\": theme.textHeader,\n        \"--gdg-text-group-header\": theme.textGroupHeader ?? theme.textHeader,\n        \"--gdg-text-header-selected\": theme.textHeaderSelected,\n        \"--gdg-bg-cell\": theme.bgCell,\n        \"--gdg-bg-cell-medium\": theme.bgCellMedium,\n        \"--gdg-bg-header\": theme.bgHeader,\n        \"--gdg-bg-header-has-focus\": theme.bgHeaderHasFocus,\n        \"--gdg-bg-header-hovered\": theme.bgHeaderHovered,\n        \"--gdg-bg-bubble\": theme.bgBubble,\n        \"--gdg-bg-bubble-selected\": theme.bgBubbleSelected,\n        \"--gdg-bg-search-result\": theme.bgSearchResult,\n        \"--gdg-border-color\": theme.borderColor,\n        \"--gdg-horizontal-border-color\": theme.horizontalBorderColor ?? theme.borderColor,\n        \"--gdg-drilldown-border\": theme.drilldownBorder,\n        \"--gdg-link-color\": theme.linkColor,\n        \"--gdg-cell-horizontal-padding\": `${theme.cellHorizontalPadding}px`,\n        \"--gdg-cell-vertical-padding\": `${theme.cellVerticalPadding}px`,\n        \"--gdg-header-font-style\": theme.headerFontStyle,\n        \"--gdg-base-font-style\": theme.baseFontStyle,\n        \"--gdg-font-family\": theme.fontFamily,\n        \"--gdg-editor-font-size\": theme.editorFontSize,\n    };\n}\n\n/** @category Theme */\nexport interface Theme {\n    accentColor: string;\n    accentFg: string;\n    accentLight: string;\n    textDark: string;\n    textMedium: string;\n    textLight: string;\n    textBubble: string;\n    bgIconHeader: string;\n    fgIconHeader: string;\n    textHeader: string;\n    textGroupHeader?: string;\n    textHeaderSelected: string;\n    bgCell: string;\n    bgCellMedium: string;\n    bgHeader: string;\n    bgHeaderHasFocus: string;\n    bgHeaderHovered: string;\n    bgBubble: string;\n    bgBubbleSelected: string;\n    bgSearchResult: string;\n    borderColor: string;\n    horizontalBorderColor?: string;\n    headerBottomBorderColor?: string;\n    drilldownBorder: string;\n    linkColor: string;\n    cellHorizontalPadding: number;\n    cellVerticalPadding: number;\n    headerFontStyle: string;\n    baseFontStyle: string;\n    fontFamily: string;\n    editorFontSize: string;\n    lineHeight: number;\n}\n\nconst dataEditorBaseTheme: Theme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n\n    bgSearchResult: \"#fff9e3\",\n\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n\n    linkColor: \"#4F5DFF\",\n\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4, //unitless scaler depends on your font\n};\n\n/** @category Theme */\nexport function getDataEditorTheme(): Theme {\n    return dataEditorBaseTheme;\n}\n\n/** @category Theme */\nexport const ThemeContext = React.createContext<Theme>(dataEditorBaseTheme);\n/** @category Hooks */\nexport function useTheme(): Theme {\n    return React.useContext(ThemeContext);\n}\n","export function proveType<T>(_val: T) {\n    // do nothing, just prove the compiler thinks the types match\n}\n\nfunction panic(message: string = \"This should not happen\"): never {\n    throw new Error(message);\n}\n\nexport function assert(fact: boolean, message: string = \"Assertion failed\"): asserts fact {\n    if (fact) return;\n    return panic(message);\n}\n\nexport function assertNever(_never: never): never {\n    return panic(\"Hell froze over\");\n}\nexport function maybe<T>(fn: () => T, defaultValue: T) {\n    try {\n        return fn();\n    } catch {\n        return defaultValue;\n    }\n}\n\n// The following code is licensed under the MIT license to Luke Edwards\n// Original license and code can be found here: https://github.com/lukeed/dequal/blob/master/license\n// I have merely \"ported\" it to be TS (any any any) and directly included it for convenience.\nconst has = Object.prototype.hasOwnProperty;\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function deepEqual(foo: any, bar: any): boolean {\n    let ctor: any, len: number;\n    if (foo === bar) return true;\n\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n        if (ctor === Date) return foo.getTime() === bar.getTime();\n        if (ctor === RegExp) return foo.toString() === bar.toString();\n\n        if (ctor === Array) {\n            if ((len = foo.length) === bar.length) {\n                while (len-- && deepEqual(foo[len], bar[len]));\n            }\n            return len === -1;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (!ctor || typeof foo === \"object\") {\n            len = 0;\n            // eslint-disable-next-line guard-for-in\n            for (ctor in foo) {\n                if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n                if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor])) return false;\n            }\n            return Object.keys(bar).length === len;\n        }\n    }\n\n    return foo !== foo && bar !== bar;\n}\n","import * as React from \"react\";\nimport debounce from \"lodash/debounce.js\";\n\nexport function useEventListener<K extends keyof HTMLElementEventMap>(\n    eventName: K,\n    handler: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,\n    element: HTMLElement | Window | null,\n    passive: boolean,\n    capture = false\n) {\n    // Create a ref that stores handler\n    const savedHandler = React.useRef<(this: HTMLElement, ev: HTMLElementEventMap[K]) => any>();\n\n    // Update ref.current value if handler changes.\n    // This allows our effect below to always get latest handler ...\n    // ... without us needing to pass it in effect deps array ...\n    // ... and potentially cause effect to re-run every render.\n    savedHandler.current = handler;\n    React.useEffect(\n        () => {\n            // Make sure element supports addEventListener\n            if (element === null || element.addEventListener === undefined) return;\n            const el = element as HTMLElement;\n\n            // Create event listener that calls handler function stored in ref\n            const eventListener = (event: HTMLElementEventMap[K]) => {\n                savedHandler.current?.call(el, event);\n            };\n\n            el.addEventListener(eventName, eventListener, { passive, capture });\n\n            // Remove event listener on cleanup\n            return () => {\n                el.removeEventListener(eventName, eventListener, { capture });\n            };\n        },\n        [eventName, element, passive, capture] // Re-run if eventName or element changes\n    );\n}\n\nexport function whenDefined<T>(obj: any, result: T) {\n    return obj === undefined ? undefined : result;\n}\n\nconst PI = Math.PI;\nexport function degreesToRadians(degrees: number) {\n    return (degrees * PI) / 180;\n}\n\nexport interface SpriteProps {\n    fgColor: string;\n    bgColor: string;\n}\n\nexport const EditPencil: React.FunctionComponent<Partial<SpriteProps>> = (props: Partial<SpriteProps>) => {\n    const fg = props.fgColor ?? \"currentColor\";\n    return (\n        <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path\n                d=\"M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929\"\n                stroke={fg}\n                strokeWidth=\"1.5\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                fill=\"none\"\n                vectorEffect=\"non-scaling-stroke\"\n            />\n            <path\n                d=\"M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z\"\n                stroke={fg}\n                strokeWidth=\"1.5\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                fill=\"none\"\n                vectorEffect=\"non-scaling-stroke\"\n            />\n        </svg>\n    );\n};\n\nexport const Checkmark: React.FunctionComponent<Partial<SpriteProps>> = (props: Partial<SpriteProps>) => {\n    const fg = props.fgColor ?? \"currentColor\";\n\n    return (\n        <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path\n                d=\"M19 6L10.3802 17L5.34071 11.8758\"\n                vectorEffect=\"non-scaling-stroke\"\n                stroke={fg}\n                strokeWidth=\"1.5\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n            />\n        </svg>\n    );\n};\n\nexport function useDebouncedMemo<T>(factory: () => T, deps: React.DependencyList | undefined, time: number): T {\n    const [state, setState] = React.useState(factory);\n\n    const mountedRef = React.useRef(true);\n    React.useEffect(\n        () => () => {\n            mountedRef.current = false;\n        },\n        []\n    );\n\n    const debouncedSetState = React.useRef<typeof setState>(\n        debounce(x => {\n            if (mountedRef.current) {\n                setState(x);\n            }\n        }, time)\n    );\n\n    React.useLayoutEffect(() => {\n        if (mountedRef.current) {\n            debouncedSetState.current(() => factory());\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n\n    return state;\n}\n\n// Shamelessly inline direction to avoid conflicts with 1.0 and 2.0.\nconst rtlRange = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst ltrRange =\n    \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\" +\n    \"\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C\" +\n    \"\\uFE00-\\uFE6F\\uFEFD-\\uFFFF\";\n\n/* eslint-disable no-misleading-character-class */\nconst rtl = new RegExp(\"^[^\" + ltrRange + \"]*[\" + rtlRange + \"]\");\nconst ltr = new RegExp(\"^[^\" + rtlRange + \"]*[\" + ltrRange + \"]\");\n/* eslint-enable no-misleading-character-class */\n\nexport function direction(value: string): \"rtl\" | \"ltr\" | \"neutral\" {\n    return rtl.test(value) ? \"rtl\" : ltr.test(value) ? \"ltr\" : \"neutral\";\n}\n\nlet scrollbarWidthCache: number | undefined = undefined;\nexport function getScrollBarWidth(): number {\n    if (scrollbarWidthCache !== undefined) return scrollbarWidthCache;\n    const inner = document.createElement(\"p\");\n    inner.style.width = \"100%\";\n    inner.style.height = \"200px\";\n\n    const outer = document.createElement(\"div\");\n    outer.id = \"testScrollbar\";\n\n    outer.style.position = \"absolute\";\n    outer.style.top = \"0px\";\n    outer.style.left = \"0px\";\n    outer.style.visibility = \"hidden\";\n    outer.style.width = \"200px\";\n    outer.style.height = \"150px\";\n    outer.style.overflow = \"hidden\";\n    outer.append(inner);\n\n    document.body.append(outer);\n    const w1 = inner.offsetWidth;\n    outer.style.overflow = \"scroll\";\n    let w2 = inner.offsetWidth;\n    if (w1 === w2) {\n        w2 = outer.clientWidth;\n    }\n\n    outer.remove();\n\n    scrollbarWidthCache = w1 - w2;\n    return scrollbarWidthCache;\n}\n\n// Dear future reader,\n// This dumb hook is to make sure if the inputState changes, that effectively behaves like an instant \"setState\" call.\n// This is useful in a wide variety of situations. I'm too dumb to know if this is a good idea or a really dumb one.\n// I can't tell. It's like poes law but for code.\n//\n// I'm sorry.\nconst empty = Symbol();\nexport function useStateWithReactiveInput<T>(inputState: T): [T, React.Dispatch<React.SetStateAction<T>>, () => void] {\n    // When [0] is not empty we will return it, [1] is always the last value we saw\n    const inputStateRef = React.useRef<[T | typeof empty, T]>([empty, inputState]);\n    if (inputStateRef.current[1] !== inputState) {\n        // it changed, we must use thee!\n        inputStateRef.current[0] = inputState;\n    }\n    inputStateRef.current[1] = inputState;\n\n    const [state, setState] = React.useState(inputState);\n    // crimes against humanity here\n    const [, forceRender] = React.useState<{} | undefined>();\n    const setStateOuter = React.useCallback<typeof setState>(nv => {\n        // this takes care of the case where the inputState was set, then setState gets called again but back to what\n        // the state was before the inputState changed. Since the useState effect wont trigger a render in this case\n        // we need to be very naughty and force it to see the change. Technically this may not be needed some chunk of\n        // the time (in fact most of it) but checking for it is likely to be more expensive than just over-doing it\n        const s = inputStateRef.current[0];\n        if (s !== empty) {\n            nv = typeof nv === \"function\" ? (nv as (pv: T) => T)(s) : nv;\n            if (nv === s) return; // they are setting it to what the inputState is anyway so we can just do nothing\n        }\n        if (s !== empty) forceRender({});\n        setState(pv => {\n            if (typeof nv === \"function\") {\n                return (nv as (pv: T) => T)(s === empty ? pv : s);\n            }\n            return nv;\n        });\n        inputStateRef.current[0] = empty;\n    }, []);\n\n    const onEmpty = React.useCallback(() => {\n        inputStateRef.current[0] = empty;\n        forceRender({});\n    }, []);\n\n    return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];\n}\n","import * as React from \"react\";\ninterface Props extends React.HTMLAttributes<HTMLDivElement> {\n    onClickOutside: () => void;\n}\n\nexport default class ClickOutsideContainer extends React.PureComponent<Props> {\n    private wrapperRef = React.createRef<HTMLDivElement>();\n\n    public componentDidMount() {\n        document.addEventListener(\"mousedown\", this.clickOutside, true);\n        document.addEventListener(\"contextmenu\", this.clickOutside, true);\n    }\n\n    public componentWillUnmount() {\n        document.removeEventListener(\"mousedown\", this.clickOutside);\n        document.removeEventListener(\"contextmenu\", this.clickOutside);\n    }\n\n    private clickOutside = (event: MouseEvent) => {\n        if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target as Node | null)) {\n            let node = event.target as Element | null;\n            while (node !== null) {\n                if (node.classList.contains(\"click-outside-ignore\")) {\n                    return;\n                }\n\n                node = node.parentElement;\n            }\n            this.props.onClickOutside();\n        }\n    };\n\n    public render(): React.ReactNode {\n        const { onClickOutside, ...rest } = this.props;\n        return (\n            <div {...rest} ref={this.wrapperRef}>\n                {this.props.children}\n            </div>\n        );\n    }\n}\n","import { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetX: number;\n    targetY: number;\n    targetWidth: number;\n    targetHeight: number;\n}\nexport const DataGridOverlayEditorStyle = styled.div<Props>`\n    position: absolute;\n\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    box-sizing: border-box;\n\n    --overlay-top: ${p => p.targetY}px;\n\n    left: ${p => p.targetX - 1}px;\n    top: ${p => p.targetY - 1}px;\n    min-width: ${p => p.targetWidth + 2}px;\n    min-height: ${p => p.targetHeight + 2}px;\n    width: max-content;\n    max-width: 400px;\n    max-height: calc(100vh - ${p => p.targetY + 10}px);\n\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n\n    @keyframes glide_fade_in {\n        from {\n            opacity: 0%;\n        }\n\n        to {\n            opacity: 100%;\n        }\n    }\n\n    &.gdg-style {\n        border-radius: 2px;\n        background-color: var(--gdg-bg-cell);\n\n        box-shadow: 0 0 0 1px var(--gdg-accent-color), 0px 0px 1px rgba(62, 65, 86, 0.4),\n            0px 6px 12px rgba(62, 65, 86, 0.15);\n\n        animation: glide_fade_in 60ms 1;\n    }\n\n    &.pad {\n        padding: ${p => Math.max(0, (p.targetHeight - 28) / 2)}px 8.5px 3px;\n    }\n\n    .clip-region {\n        display: flex;\n        flex-direction: column;\n        overflow-y: auto;\n        overflow-x: hidden;\n        border-radius: 2px;\n        flex-grow: 1;\n\n        .gdg-growing-entry {\n            height: 100%;\n        }\n\n        & input.gdg-input {\n            width: 100%;\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n\n        & textarea.gdg-input {\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n    }\n\n    text-align: start;\n`;\n","import * as React from \"react\";\n\nfunction useRefState(): [HTMLElement | undefined, React.RefCallback<HTMLElement | null>] {\n    const [refState, setRefState] = React.useState<HTMLElement | null>();\n    return [refState ?? undefined, setRefState];\n}\n\ninterface StayOnScreen {\n    ref: React.RefCallback<HTMLElement | null>;\n    style: React.CSSProperties;\n}\n\nexport function useStayOnScreen(): StayOnScreen {\n    const [ref, setRef] = useRefState();\n    const [xOffset, setXOffset] = React.useState(0);\n    const [isIntersecting, setIsIntersecting] = React.useState(true);\n\n    React.useLayoutEffect(() => {\n        if (ref === undefined) return;\n        if (!(\"IntersectionObserver\" in window)) return;\n\n        const observer = new IntersectionObserver(\n            ents => {\n                if (ents.length === 0) return;\n                setIsIntersecting(ents[0].isIntersecting);\n            },\n            { threshold: 1 }\n        );\n        observer.observe(ref);\n\n        return () => observer.disconnect();\n    }, [ref]);\n\n    React.useEffect(() => {\n        if (isIntersecting || ref === undefined) return;\n\n        let rafHandle: number | undefined;\n        const fn = () => {\n            const { right: refRight } = ref.getBoundingClientRect();\n\n            setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));\n            rafHandle = requestAnimationFrame(fn);\n        };\n\n        rafHandle = requestAnimationFrame(fn);\n        return () => {\n            if (rafHandle !== undefined) {\n                cancelAnimationFrame(rafHandle);\n            }\n        };\n    }, [ref, isIntersecting]);\n\n    const style = React.useMemo(() => {\n        return { transform: `translateX(${xOffset}px)` };\n    }, [xOffset]);\n\n    return {\n        ref: setRef,\n        style,\n    };\n}\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nimport { makeCSSStyle, Theme, ThemeContext } from \"../common/styles\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport {\n    EditableGridCell,\n    GridCell,\n    isEditableGridCell,\n    isInnerOnlyCell,\n    isObjectEditorCallbackResult,\n    Item,\n    ProvideEditorCallback,\n    ProvideEditorCallbackResult,\n    Rectangle,\n    ValidatedGridCell,\n} from \"../data-grid/data-grid-types\";\nimport { DataGridOverlayEditorStyle } from \"./data-grid-overlay-editor-style\";\nimport type { OverlayImageEditorProps } from \"./private/image-overlay-editor\";\nimport { useStayOnScreen } from \"./use-stay-on-screen\";\n\ntype ImageEditorType = React.ComponentType<OverlayImageEditorProps>;\n\ninterface DataGridOverlayEditorProps {\n    readonly target: Rectangle;\n    readonly cell: Item;\n    readonly content: GridCell;\n    readonly className?: string;\n    readonly id: string;\n    readonly initialValue?: string;\n    readonly theme: Theme;\n    readonly onFinishEditing: (newCell: GridCell | undefined, movement: readonly [-1 | 0 | 1, -1 | 0 | 1]) => void;\n    readonly forceEditMode: boolean;\n    readonly highlight: boolean;\n    readonly imageEditorOverride?: ImageEditorType;\n    readonly getCellRenderer: GetCellRendererCallback;\n    readonly markdownDivCreateNode?: (content: string) => DocumentFragment;\n    readonly provideEditor?: ProvideEditorCallback<GridCell>;\n    readonly validateCell?: (\n        cell: Item,\n        newValue: EditableGridCell,\n        prevValue: GridCell\n    ) => boolean | ValidatedGridCell;\n}\n\nconst DataGridOverlayEditor: React.FunctionComponent<DataGridOverlayEditorProps> = p => {\n    const {\n        target,\n        content,\n        onFinishEditing: onFinishEditingIn,\n        forceEditMode,\n        initialValue,\n        imageEditorOverride,\n        markdownDivCreateNode,\n        highlight,\n        className,\n        theme,\n        id,\n        cell,\n        validateCell,\n        getCellRenderer,\n        provideEditor,\n    } = p;\n\n    const [tempValue, setTempValueRaw] = React.useState<GridCell | undefined>(forceEditMode ? content : undefined);\n    const lastValueRef = React.useRef(tempValue ?? content);\n    lastValueRef.current = tempValue ?? content;\n\n    const [isValid, setIsValid] = React.useState(() => {\n        if (validateCell === undefined) return true;\n        return !(isEditableGridCell(content) && validateCell?.(cell, content, lastValueRef.current) === false);\n    });\n\n    const onFinishEditing = React.useCallback<typeof onFinishEditingIn>(\n        (newCell, movement) => {\n            onFinishEditingIn(isValid ? newCell : undefined, movement);\n        },\n        [isValid, onFinishEditingIn]\n    );\n\n    const setTempValue = React.useCallback(\n        (newVal: GridCell | undefined) => {\n            if (validateCell !== undefined && newVal !== undefined && isEditableGridCell(newVal)) {\n                const validResult = validateCell(cell, newVal, lastValueRef.current);\n                if (validResult === false) {\n                    setIsValid(false);\n                } else if (typeof validResult === \"object\") {\n                    newVal = validResult;\n                    setIsValid(true);\n                } else {\n                    setIsValid(true);\n                }\n            }\n            setTempValueRaw(newVal);\n        },\n        [cell, validateCell]\n    );\n\n    const finished = React.useRef(false);\n    const customMotion = React.useRef<[-1 | 0 | 1, -1 | 0 | 1] | undefined>(undefined);\n\n    const onClickOutside = React.useCallback(() => {\n        onFinishEditing(tempValue, [0, 0]);\n        finished.current = true;\n    }, [tempValue, onFinishEditing]);\n\n    const onEditorFinished = React.useCallback(\n        (newValue: GridCell | undefined) => {\n            onFinishEditing(newValue, customMotion.current ?? [0, 0]);\n            finished.current = true;\n        },\n        [onFinishEditing]\n    );\n\n    const onKeyDown = React.useCallback(\n        async (event: React.KeyboardEvent) => {\n            let save = false;\n            if (event.key === \"Escape\") {\n                event.stopPropagation();\n                event.preventDefault();\n                customMotion.current = [0, 0];\n            } else if (event.key === \"Enter\" && !event.shiftKey) {\n                event.stopPropagation();\n                event.preventDefault();\n                customMotion.current = [0, 1];\n                save = true;\n            } else if (event.key === \"Tab\") {\n                event.stopPropagation();\n                event.preventDefault();\n                customMotion.current = [event.shiftKey ? -1 : 1, 0];\n                save = true;\n            }\n\n            window.setTimeout(() => {\n                if (!finished.current && customMotion.current !== undefined) {\n                    onFinishEditing(save ? tempValue : undefined, customMotion.current);\n                    finished.current = true;\n                }\n            }, 0);\n        },\n        [onFinishEditing, tempValue]\n    );\n\n    const targetValue = tempValue ?? content;\n\n    const [editorProvider, useLabel] = React.useMemo((): [ProvideEditorCallbackResult<GridCell>, boolean] | [] => {\n        if (isInnerOnlyCell(content)) return [];\n        const external = provideEditor?.(content);\n        if (external !== undefined) return [external, false];\n        return [getCellRenderer(content)?.provideEditor?.(content), false];\n    }, [content, getCellRenderer, provideEditor]);\n\n    const { ref, style: stayOnScreenStyle } = useStayOnScreen();\n\n    let pad = true;\n    let editor: React.ReactNode;\n    let style = true;\n    let styleOverride: React.CSSProperties | undefined;\n\n    if (editorProvider !== undefined) {\n        pad = editorProvider.disablePadding !== true;\n        style = editorProvider.disableStyling !== true;\n        const isObjectEditor = isObjectEditorCallbackResult(editorProvider);\n        if (isObjectEditor) {\n            styleOverride = editorProvider.styleOverride;\n        }\n        const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;\n        editor = (\n            <CustomEditor\n                isHighlighted={highlight}\n                onChange={setTempValue}\n                value={targetValue}\n                initialValue={initialValue}\n                onFinishedEditing={onEditorFinished}\n                validatedSelection={isEditableGridCell(targetValue) ? targetValue.selectionRange : undefined}\n                forceEditMode={forceEditMode}\n                target={target}\n                imageEditorOverride={imageEditorOverride}\n                markdownDivCreateNode={markdownDivCreateNode}\n                isValid={isValid}\n            />\n        );\n    }\n\n    styleOverride = { ...styleOverride, ...stayOnScreenStyle };\n\n    // Consider imperatively creating and adding the element to the dom?\n    const portalElement = document.getElementById(\"portal\");\n    if (portalElement === null) {\n        // eslint-disable-next-line no-console\n        console.error(\n            'Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id=\"portal\" />` as the last child of your `<body>`.'\n        );\n        return null;\n    }\n\n    let classWrap = style ? \"gdg-style\" : \"gdg-unstyle\";\n    if (!isValid) {\n        classWrap += \" invalid\";\n    }\n\n    if (pad) {\n        classWrap += \" pad\";\n    }\n\n    return createPortal(\n        <ThemeContext.Provider value={theme}>\n            <ClickOutsideContainer style={makeCSSStyle(theme)} className={className} onClickOutside={onClickOutside}>\n                <DataGridOverlayEditorStyle\n                    ref={ref}\n                    id={id}\n                    className={classWrap}\n                    style={styleOverride}\n                    as={useLabel === true ? \"label\" : undefined}\n                    targetX={target.x}\n                    targetY={target.y}\n                    targetWidth={target.width}\n                    targetHeight={target.height}>\n                    <div className=\"clip-region\" onKeyDown={onKeyDown}>\n                        {editor}\n                    </div>\n                </DataGridOverlayEditorStyle>\n            </ClickOutsideContainer>\n        </ThemeContext.Provider>,\n        portalElement\n    );\n};\n\nexport default DataGridOverlayEditor;\n","import { styled } from \"@linaria/react\";\n\nexport const SearchWrapper = styled.div<{ showSearch: boolean }>`\n    position: absolute;\n    top: 4px;\n    right: 20px;\n\n    background-color: var(--gdg-bg-cell);\n    color: var(--gdg-text-dark);\n\n    padding: 8px;\n    border: 1px solid var(--gdg-border-color);\n    border-radius: 6px;\n\n    font-size: var(--gdg-editor-font-size);\n\n    transform: translateX(${p => (p.showSearch ? 0 : 400)}px);\n    transition: transform 0.15s;\n\n    .search-bar-inner {\n        display: flex;\n    }\n\n    .search-status {\n        padding-top: 4px;\n        font-size: 11px;\n    }\n\n    .search-progress {\n        position: absolute;\n        height: 4px;\n        left: 0;\n        bottom: 0;\n\n        background-color: var(--gdg-text-light);\n    }\n\n    input {\n        width: 220px;\n        color: var(--gdg-textDark);\n        background-color: var(--gdg-bg-cell);\n        border: none;\n        border-width: 0;\n        outline: none;\n    }\n\n    button {\n        width: 24px;\n        height: 24px;\n        padding: 0;\n\n        border: none;\n        outline: none;\n        background: none;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        cursor: pointer;\n        color: var(--gdg-text-medium);\n\n        :hover {\n            color: var(--gdg-text-dark);\n        }\n\n        .button-icon {\n            width: 16px;\n            height: 16px;\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n`;\n","/* eslint-disable unicorn/consistent-destructuring */\nimport * as React from \"react\";\nimport { CellArray, GetCellsThunk, GridCellKind, Item, Rectangle } from \"../data-grid/data-grid-types\";\nimport ScrollingDataGrid, { ScrollingDataGridProps } from \"../scrolling-data-grid/scrolling-data-grid\";\nimport { SearchWrapper } from \"./data-grid-search-style\";\nimport { assert } from \"../common/support\";\n\n// icons\nconst upArrow = (\n    <svg className=\"button-icon\" viewBox=\"0 0 512 512\">\n        <path\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"48\"\n            d=\"M112 244l144-144 144 144M256 120v292\"\n        />\n    </svg>\n);\nconst downArrow = (\n    <svg className=\"button-icon\" viewBox=\"0 0 512 512\">\n        <path\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"48\"\n            d=\"M112 268l144 144 144-144M256 392V100\"\n        />\n    </svg>\n);\n\nconst closeX = (\n    <svg className=\"button-icon\" viewBox=\"0 0 512 512\">\n        <path\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"32\"\n            d=\"M368 368L144 144M368 144L144 368\"\n        />\n    </svg>\n);\n\nexport interface DataGridSearchProps extends Omit<ScrollingDataGridProps, \"prelightCells\"> {\n    readonly getCellsForSelection?: (selection: Rectangle, abortSignal: AbortSignal) => GetCellsThunk | CellArray;\n    readonly onSearchResultsChanged?: (results: readonly Item[], navIndex: number) => void;\n    /**\n     * Controls the visibility of the search overlay.\n     * @group Search\n     */\n    readonly showSearch?: boolean;\n    /**\n     * Emitted when the search window close event is triggered.\n     * @group Search\n     */\n    readonly onSearchClose?: () => void;\n    readonly searchInputRef: React.MutableRefObject<HTMLInputElement | null>;\n}\n\nconst targetSearchTimeMS = 10;\n\nconst DataGridSearch: React.FunctionComponent<DataGridSearchProps> = p => {\n    const {\n        canvasRef,\n        cellYOffset,\n        rows,\n        columns,\n        searchInputRef,\n        getCellsForSelection,\n        onSearchResultsChanged,\n        showSearch = false,\n        onSearchClose,\n    } = p;\n\n    const [searchID] = React.useState(() => \"search-box-\" + Math.round(Math.random() * 1000));\n\n    const [searchString, setSearchString] = React.useState(\"\");\n    const [searchStatus, setSearchStatus] =\n        React.useState<{\n            rowsSearched: number;\n            results: number;\n            selectedIndex: number;\n        }>();\n\n    const searchStatusRef = React.useRef(searchStatus);\n    searchStatusRef.current = searchStatus;\n\n    const abortControllerRef = React.useRef(new AbortController());\n    const searchHandle = React.useRef<number>();\n    const [searchResults, setSearchResults] = React.useState<readonly Item[]>([]);\n\n    const cancelSearch = React.useCallback(() => {\n        if (searchHandle.current !== undefined) {\n            window.cancelAnimationFrame(searchHandle.current);\n            searchHandle.current = undefined;\n            abortControllerRef.current.abort();\n        }\n    }, []);\n\n    const cellYOffsetRef = React.useRef(cellYOffset);\n    cellYOffsetRef.current = cellYOffset;\n    const beginSearch = React.useCallback(\n        (str: string) => {\n            const regex = new RegExp(str.replace(/([$()*+.?[\\\\\\]^{|}-])/g, \"\\\\$1\"), \"i\");\n\n            let startY = cellYOffsetRef.current;\n\n            // Lets assume we can do 10 rows at a time\n            // This is usually very safe and limits the damage for bad\n            // performing sheets.\n            let searchStride = Math.min(10, rows);\n\n            let rowsSearched = 0;\n\n            setSearchStatus(undefined);\n            setSearchResults([]);\n\n            const runningResult: [number, number][] = [];\n\n            const tick = async () => {\n                if (getCellsForSelection === undefined) return;\n                const tStart = performance.now();\n                const rowsLeft = rows - rowsSearched;\n                let data = getCellsForSelection(\n                    {\n                        x: 0,\n                        y: startY,\n                        width: columns.length,\n                        height: Math.min(searchStride, rowsLeft, rows - startY),\n                    },\n                    abortControllerRef.current.signal\n                );\n\n                if (typeof data === \"function\") {\n                    data = await data();\n                }\n\n                let added = false;\n                for (const [row, d] of data.entries()) {\n                    for (const [col, cell] of d.entries()) {\n                        let testString: string | undefined;\n                        switch (cell.kind) {\n                            case GridCellKind.Text:\n                            case GridCellKind.Number:\n                                testString = cell.displayData;\n                                break;\n                            case GridCellKind.Uri:\n                            case GridCellKind.Markdown:\n                                testString = cell.data;\n                                break;\n                            case GridCellKind.Boolean:\n                                testString = typeof cell.data === \"boolean\" ? cell.data.toString() : undefined;\n                                break;\n                            case GridCellKind.Image:\n                            case GridCellKind.Bubble:\n                                // I know its lazy, but unless someone is actually\n                                // searching for the whale emoji, this is pretty side effect\n                                // free. And ya know... it's nice and easy to do...\n                                testString = cell.data.join(\"\");\n                                break;\n                            case GridCellKind.Custom:\n                                testString = cell.copyData;\n                                break;\n                        }\n\n                        if (testString !== undefined && regex.test(testString)) {\n                            runningResult.push([col, row + startY]);\n                            added = true;\n                        }\n                    }\n                }\n\n                const tEnd = performance.now();\n\n                if (added) {\n                    setSearchResults([...runningResult]);\n                }\n\n                rowsSearched += data.length;\n                assert(rowsSearched <= rows);\n\n                const selectedIndex = searchStatusRef.current?.selectedIndex ?? -1;\n                setSearchStatus({\n                    results: runningResult.length,\n                    rowsSearched,\n                    selectedIndex,\n                });\n                onSearchResultsChanged?.(runningResult, selectedIndex);\n\n                if (startY + searchStride >= rows) {\n                    startY = 0;\n                } else {\n                    startY += searchStride;\n                }\n\n                const tElapsed = tEnd - tStart;\n                const rounded = Math.max(tElapsed, 1);\n\n                const scalar = targetSearchTimeMS / rounded;\n                searchStride = Math.ceil(searchStride * scalar);\n\n                if (rowsSearched < rows && runningResult.length < 1000) {\n                    searchHandle.current = window.requestAnimationFrame(tick);\n                }\n            };\n\n            cancelSearch();\n            searchHandle.current = window.requestAnimationFrame(tick);\n        },\n        [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]\n    );\n\n    const onClose = React.useCallback(() => {\n        onSearchClose?.();\n        setSearchStatus(undefined);\n        setSearchResults([]);\n        onSearchResultsChanged?.([], -1);\n        cancelSearch();\n        canvasRef?.current?.focus();\n    }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);\n\n    const onSearchChange = React.useCallback(\n        (event: React.ChangeEvent<HTMLInputElement>) => {\n            setSearchString(event.target.value);\n            if (event.target.value === \"\") {\n                setSearchStatus(undefined);\n                setSearchResults([]);\n                cancelSearch();\n            } else {\n                beginSearch(event.target.value);\n            }\n        },\n        [beginSearch, cancelSearch]\n    );\n\n    React.useEffect(() => {\n        if (showSearch && searchInputRef.current !== null) {\n            setSearchString(\"\");\n            searchInputRef.current.focus({ preventScroll: true });\n        }\n    }, [showSearch, searchInputRef]);\n\n    const onNext = React.useCallback(\n        (ev?: React.MouseEvent) => {\n            ev?.stopPropagation?.();\n            if (searchStatus === undefined) return;\n            const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;\n            setSearchStatus({\n                ...searchStatus,\n                selectedIndex: newIndex,\n            });\n            onSearchResultsChanged?.(searchResults, newIndex);\n        },\n        [searchStatus, onSearchResultsChanged, searchResults]\n    );\n\n    const onPrev = React.useCallback(\n        (ev?: React.MouseEvent) => {\n            ev?.stopPropagation?.();\n            if (searchStatus === undefined) return;\n            let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;\n            if (newIndex < 0) newIndex += searchStatus.results;\n            setSearchStatus({\n                ...searchStatus,\n                selectedIndex: newIndex,\n            });\n            onSearchResultsChanged?.(searchResults, newIndex);\n        },\n        [onSearchResultsChanged, searchResults, searchStatus]\n    );\n\n    const onSearchKeyDown = React.useCallback(\n        (event: React.KeyboardEvent<HTMLInputElement>) => {\n            if (((event.ctrlKey || event.metaKey) && event.nativeEvent.code === \"KeyF\") || event.key === \"Escape\") {\n                onClose();\n                event.stopPropagation();\n                event.preventDefault();\n            } else if (event.key === \"Enter\") {\n                if (event.shiftKey) {\n                    onPrev();\n                } else {\n                    onNext();\n                }\n            }\n        },\n        [onClose, onNext, onPrev]\n    );\n\n    // cancel search if the component is unmounted\n    React.useEffect(() => {\n        return () => {\n            cancelSearch();\n        };\n    }, [cancelSearch]);\n\n    const searchbox = React.useMemo(() => {\n        let resultString: string | undefined;\n        if (searchStatus !== undefined) {\n            resultString =\n                searchStatus.results >= 1000\n                    ? `over 1000`\n                    : `${searchStatus.results} result${searchStatus.results !== 1 ? \"s\" : \"\"}`;\n            if (searchStatus.selectedIndex >= 0) {\n                resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;\n            }\n        }\n\n        const cancelEvent = (ev: React.MouseEvent) => {\n            ev.stopPropagation();\n        };\n\n        const rowsSearchedProgress = Math.floor(((searchStatus?.rowsSearched ?? 0) / rows) * 100);\n        const progressStyle: React.CSSProperties = {\n            width: `${rowsSearchedProgress}%`,\n        };\n\n        return (\n            <SearchWrapper\n                showSearch={showSearch}\n                onMouseDown={cancelEvent}\n                onMouseMove={cancelEvent}\n                onMouseUp={cancelEvent}\n                onClick={cancelEvent}>\n                <div className=\"search-bar-inner\">\n                    <input\n                        id={searchID}\n                        aria-hidden={!showSearch}\n                        data-testid=\"search-input\"\n                        ref={searchInputRef}\n                        onChange={onSearchChange}\n                        value={searchString}\n                        tabIndex={showSearch ? undefined : -1}\n                        onKeyDownCapture={onSearchKeyDown}\n                    />\n                    <button\n                        aria-label=\"Previous Result\"\n                        aria-hidden={!showSearch}\n                        tabIndex={showSearch ? undefined : -1}\n                        onClick={onPrev}\n                        disabled={(searchStatus?.results ?? 0) === 0}>\n                        {upArrow}\n                    </button>\n                    <button\n                        aria-label=\"Next Result\"\n                        aria-hidden={!showSearch}\n                        tabIndex={showSearch ? undefined : -1}\n                        onClick={onNext}\n                        disabled={(searchStatus?.results ?? 0) === 0}>\n                        {downArrow}\n                    </button>\n                    {onSearchClose !== undefined && (\n                        <button\n                            aria-label=\"Close Search\"\n                            aria-hidden={!showSearch}\n                            data-testid=\"search-close-button\"\n                            tabIndex={showSearch ? undefined : -1}\n                            onClick={onClose}>\n                            {closeX}\n                        </button>\n                    )}\n                </div>\n                {searchStatus !== undefined ? (\n                    <>\n                        <div className=\"search-status\">\n                            <div data-testid=\"search-result-area\">{resultString}</div>\n                        </div>\n                        <div className=\"search-progress\" style={progressStyle} />\n                    </>\n                ) : (\n                    <div className=\"search-status\">\n                        <label htmlFor={searchID}>Type to search</label>\n                    </div>\n                )}\n            </SearchWrapper>\n        );\n    }, [\n        onClose,\n        onNext,\n        onPrev,\n        onSearchChange,\n        onSearchClose,\n        onSearchKeyDown,\n        rows,\n        searchStatus,\n        searchString,\n        showSearch,\n        searchID,\n        searchInputRef,\n    ]);\n\n    return (\n        <>\n            <ScrollingDataGrid\n                prelightCells={searchResults}\n                accessibilityHeight={p.accessibilityHeight}\n                canvasRef={p.canvasRef}\n                cellXOffset={p.cellXOffset}\n                cellYOffset={p.cellYOffset}\n                className={p.className}\n                clientSize={p.clientSize}\n                columns={p.columns}\n                disabledRows={p.disabledRows}\n                enableGroups={p.enableGroups}\n                fillHandle={p.fillHandle}\n                firstColAccessible={p.firstColAccessible}\n                fixedShadowX={p.fixedShadowX}\n                fixedShadowY={p.fixedShadowY}\n                freezeColumns={p.freezeColumns}\n                getCellContent={p.getCellContent}\n                getCellRenderer={p.getCellRenderer}\n                getGroupDetails={p.getGroupDetails}\n                getRowThemeOverride={p.getRowThemeOverride}\n                groupHeaderHeight={p.groupHeaderHeight}\n                headerHeight={p.headerHeight}\n                highlightRegions={p.highlightRegions}\n                imageWindowLoader={p.imageWindowLoader}\n                initialSize={p.initialSize}\n                isFilling={p.isFilling}\n                isFocused={p.isFocused}\n                lockColumns={p.lockColumns}\n                maxColumnWidth={p.maxColumnWidth}\n                minColumnWidth={p.minColumnWidth}\n                onHeaderMenuClick={p.onHeaderMenuClick}\n                onMouseMove={p.onMouseMove}\n                onVisibleRegionChanged={p.onVisibleRegionChanged}\n                overscrollX={p.overscrollX}\n                overscrollY={p.overscrollY}\n                preventDiagonalScrolling={p.preventDiagonalScrolling}\n                rightElement={p.rightElement}\n                rightElementProps={p.rightElementProps}\n                rowHeight={p.rowHeight}\n                rows={p.rows}\n                scrollRef={p.scrollRef}\n                selection={p.selection}\n                showMinimap={p.showMinimap}\n                theme={p.theme}\n                trailingRowType={p.trailingRowType}\n                translateX={p.translateX}\n                translateY={p.translateY}\n                verticalBorder={p.verticalBorder}\n                drawCustomCell={p.drawCustomCell}\n                drawFocusRing={p.drawFocusRing}\n                drawHeader={p.drawHeader}\n                experimental={p.experimental}\n                gridRef={p.gridRef}\n                headerIcons={p.headerIcons}\n                isDraggable={p.isDraggable}\n                onCanvasBlur={p.onCanvasBlur}\n                onCanvasFocused={p.onCanvasFocused}\n                onCellFocused={p.onCellFocused}\n                onColumnMoved={p.onColumnMoved}\n                onColumnResize={p.onColumnResize}\n                onColumnResizeEnd={p.onColumnResizeEnd}\n                onColumnResizeStart={p.onColumnResizeStart}\n                onContextMenu={p.onContextMenu}\n                onDragEnd={p.onDragEnd}\n                onDragLeave={p.onDragLeave}\n                onDragOverCell={p.onDragOverCell}\n                onDragStart={p.onDragStart}\n                onDrop={p.onDrop}\n                onItemHovered={p.onItemHovered}\n                onKeyDown={p.onKeyDown}\n                onKeyUp={p.onKeyUp}\n                onMouseDown={p.onMouseDown}\n                onMouseUp={p.onMouseUp}\n                onRowMoved={p.onRowMoved}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n                scrollToEnd={p.scrollToEnd}\n            />\n            {searchbox}\n        </>\n    );\n};\n\nexport default DataGridSearch;\n","import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { css } from \"@linaria/core\";\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly bounds: Rectangle;\n    readonly group: string;\n    readonly onClose: () => void;\n    readonly onFinish: (newVal: string) => void;\n    readonly canvasBounds: DOMRect;\n}\n\nconst RenameInput = styled.input<{ targetHeight: number }>`\n    flex-grow: 1;\n    border: none;\n    outline: none;\n    background-color: var(--gdg-bg-header-has-focus);\n    border-radius: 9px;\n    padding: 0 8px;\n    box-shadow: 0 0 0 1px var(--gdg-border-color);\n    color: var(--gdg-text-group-header);\n    min-height: ${p => Math.max(16, p.targetHeight - 10)}px;\n    font: var(--gdg-header-font-style) var(--gdg-font-family);\n`;\n\nexport const GroupRename: React.VFC<Props> = p => {\n    const { bounds, group, onClose, canvasBounds, onFinish } = p;\n\n    const [value, setValue] = React.useState(group);\n\n    return (\n        <ClickOutsideContainer\n            style={{\n                position: \"absolute\",\n                left: bounds.x - canvasBounds.left + 1,\n                top: bounds.y - canvasBounds.top,\n                width: bounds.width - 2,\n                height: bounds.height,\n            }}\n            className={css`\n                padding: 0 8px;\n                display: flex;\n                align-items: center;\n                background-color: var(--gdg-bg-header);\n            `}\n            onClickOutside={onClose}>\n            <RenameInput\n                targetHeight={bounds.height}\n                data-testid=\"group-rename-input\"\n                value={value}\n                onBlur={onClose}\n                onFocus={e => e.target.setSelectionRange(0, value.length)}\n                onChange={e => setValue(e.target.value)}\n                onKeyDown={e => {\n                    if (e.key === \"Enter\") {\n                        onFinish(value);\n                    } else if (e.key === \"Escape\") {\n                        onClose();\n                    }\n                }}\n                autoFocus={true}\n            />\n        </ClickOutsideContainer>\n    );\n};\n","import * as React from \"react\";\nimport type { Theme } from \"../common/styles\";\nimport type { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport {\n    CellArray,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    InnerGridColumn,\n    isSizedGridColumn,\n    resolveCellsThunk,\n    SizedGridColumn,\n} from \"../data-grid/data-grid-types\";\n\nconst defaultSize = 150;\n\nfunction measureCell(\n    ctx: CanvasRenderingContext2D,\n    cell: GridCell,\n    theme: Theme,\n    getCellRenderer: GetCellRendererCallback\n): number {\n    if (cell.kind === GridCellKind.Custom) return defaultSize;\n\n    const r = getCellRenderer(cell);\n    return r?.measure?.(ctx, cell, theme) ?? defaultSize;\n}\n\nexport function measureColumn(\n    ctx: CanvasRenderingContext2D,\n    theme: Theme,\n    c: GridColumn,\n    colIndex: number,\n    selectedData: CellArray,\n    minColumnWidth: number,\n    maxColumnWidth: number,\n    removeOutliers: boolean,\n    getCellRenderer: GetCellRendererCallback\n): SizedGridColumn {\n    let sizes: number[] = [];\n    if (selectedData !== undefined) {\n        sizes.push(\n            ...selectedData.map(row => row[colIndex]).map(cell => measureCell(ctx, cell, theme, getCellRenderer))\n        );\n    }\n    if (sizes.length > 5 && removeOutliers) {\n        // Filter out outliers\n        const average = sizes.reduce((a, b) => a + b) / sizes.length;\n        sizes = sizes.filter(a => a < average * 2);\n    }\n    sizes.push(ctx.measureText(c.title).width + 16 + (c.icon === undefined ? 0 : 28));\n    const biggest = Math.max(...sizes);\n    const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(biggest)));\n\n    return {\n        ...c,\n        width: final,\n    };\n}\n\n/** @category Hooks */\nexport function useColumnSizer(\n    columns: readonly GridColumn[],\n    rows: number,\n    getCellsForSelection: DataGridSearchProps[\"getCellsForSelection\"],\n    clientWidth: number,\n    minColumnWidth: number,\n    maxColumnWidth: number,\n    theme: Theme,\n    getCellRenderer: GetCellRendererCallback,\n    abortController: AbortController\n): readonly InnerGridColumn[] {\n    const rowsRef = React.useRef(rows);\n    const getCellsForSelectionRef = React.useRef(getCellsForSelection);\n    const themeRef = React.useRef(theme);\n    rowsRef.current = rows;\n    getCellsForSelectionRef.current = getCellsForSelection;\n    themeRef.current = theme;\n\n    const [ctx] = React.useState(() => {\n        const offscreen = document.createElement(\"canvas\");\n        return offscreen.getContext(\"2d\", { alpha: false });\n    });\n\n    const memoMap = React.useRef<Record<string, number>>({});\n\n    const lastColumns = React.useRef<typeof columns>();\n    const [selectedData, setSelectionData] = React.useState<CellArray | undefined>();\n\n    React.useLayoutEffect(() => {\n        const getCells = getCellsForSelectionRef.current;\n        if (getCells === undefined || columns.every(isSizedGridColumn)) return;\n        let computeRows = Math.max(1, 10 - Math.floor(columns.length / 10_000));\n        let tailRows = 0;\n        if (computeRows < rowsRef.current && computeRows > 1) {\n            computeRows--;\n            tailRows = 1;\n        }\n\n        const computeArea = {\n            x: 0,\n            y: 0,\n            width: columns.length,\n            height: Math.min(rowsRef.current, computeRows),\n        };\n\n        const tailComputeArea = {\n            x: 0,\n            y: rowsRef.current - 1,\n            width: columns.length,\n            height: 1,\n        };\n        const fn = async () => {\n            const getResult = getCells(computeArea, abortController.signal);\n            const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : undefined;\n            let toSet: CellArray;\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (typeof getResult === \"object\") {\n                toSet = getResult;\n            } else {\n                toSet = await resolveCellsThunk(getResult);\n            }\n            if (tailGetResult !== undefined) {\n                // eslint-disable-next-line unicorn/prefer-ternary\n                if (typeof tailGetResult === \"object\") {\n                    toSet = [...toSet, ...tailGetResult];\n                } else {\n                    toSet = [...toSet, ...(await resolveCellsThunk(tailGetResult))];\n                }\n            }\n            lastColumns.current = columns;\n            setSelectionData(toSet);\n        };\n        void fn();\n    }, [abortController.signal, columns]);\n\n    return React.useMemo(() => {\n        const getRaw = () => {\n            if (columns.every(isSizedGridColumn)) {\n                return columns;\n            }\n\n            if (ctx === null) {\n                return columns.map(c => {\n                    if (isSizedGridColumn(c)) return c;\n\n                    return {\n                        ...c,\n                        width: defaultSize,\n                    };\n                });\n            }\n\n            ctx.font = `${themeRef.current.baseFontStyle} ${themeRef.current.fontFamily}`;\n\n            return columns.map((c, colIndex) => {\n                if (isSizedGridColumn(c)) return c;\n\n                if (memoMap.current[c.id] !== undefined) {\n                    return {\n                        ...c,\n                        width: memoMap.current[c.id],\n                    };\n                }\n\n                if (selectedData === undefined || lastColumns.current !== columns || c.id === undefined) {\n                    return {\n                        ...c,\n                        width: defaultSize,\n                    };\n                }\n\n                const r = measureColumn(\n                    ctx,\n                    theme,\n                    c,\n                    colIndex,\n                    selectedData,\n                    minColumnWidth,\n                    maxColumnWidth,\n                    true,\n                    getCellRenderer\n                );\n                memoMap.current[c.id] = r.width;\n                return r;\n            });\n        };\n\n        let result: readonly InnerGridColumn[] = getRaw();\n        let totalWidth = 0;\n        let totalGrow = 0;\n        const distribute: number[] = [];\n        for (const [i, c] of result.entries()) {\n            totalWidth += c.width;\n            if (c.grow !== undefined && c.grow > 0) {\n                totalGrow += c.grow;\n                distribute.push(i);\n            }\n        }\n        if (totalWidth < clientWidth && distribute.length > 0) {\n            const writeable = [...result];\n            const extra = clientWidth - totalWidth;\n            let remaining = extra;\n            for (let di = 0; di < distribute.length; di++) {\n                const i = distribute[di];\n                const weighted = (result[i].grow ?? 0) / totalGrow;\n                const toAdd =\n                    di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));\n                writeable[i] = {\n                    ...result[i],\n                    growOffset: toAdd,\n                    width: result[i].width + toAdd,\n                };\n                remaining -= toAdd;\n            }\n            result = writeable;\n        }\n        return result;\n    }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);\n}\n","import type { GridKeyEventArgs } from \"../data-grid/data-grid-types\";\nimport { browserIsOSX } from \"./browser-detect\";\n\n// brain dead syntax, find your deps, and make buggy replacements with 5 times the effort\n// all lower case\n// ctrl+shift+alt+d or ctrl+x or shift+c or shift+Backspace or alt+_53\n// you get it, last one is always event.key, nothing fancy\n// special: primary === ctrl on windows, meta on mac\n// no to lower, its a waste, we're the only consumer, don't use caps\n\n// and before you ask, yes space is \" \", e.g. \"ctrl+alt+ \", whatacountry.gif\n// load bearing whitespace, it's basically python\n// if the char starts with a _ it is the event.keycode instead\nfunction checkKey(key: string | undefined, args: GridKeyEventArgs): boolean {\n    if (key === undefined) return false;\n    if (key.length > 1 && key.startsWith(\"_\")) {\n        const keycode = Number.parseInt(key.slice(1));\n        if (keycode !== args.keyCode) return false;\n    } else {\n        if (key !== args.key) return false;\n    }\n    return true;\n}\nexport function isHotkey(hotkey: string, args: GridKeyEventArgs): boolean {\n    if (hotkey.length === 0) return false;\n    let wantCtrl = false;\n    let wantShift = false;\n    let wantAlt = false;\n    let wantMeta = false;\n    const split = hotkey.split(\"+\");\n    const key = split.pop();\n    if (!checkKey(key, args)) return false;\n    for (const accel of split) {\n        switch (accel) {\n            case \"ctrl\":\n                wantCtrl = true;\n                break;\n            case \"shift\":\n                wantShift = true;\n                break;\n            case \"alt\":\n                wantAlt = true;\n                break;\n            case \"meta\":\n                wantMeta = true;\n                break;\n            case \"primary\":\n                if (browserIsOSX.value) {\n                    wantMeta = true;\n                } else {\n                    wantCtrl = true;\n                }\n                break;\n        }\n    }\n\n    return (\n        args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta\n    );\n}\n","import React from \"react\";\nimport { CompactSelection, GridSelection, Slice } from \"./data-grid-types\";\n\ntype SetCallback = (newVal: GridSelection, expand: boolean) => void;\n\nexport type SelectionBlending = \"exclusive\" | \"mixed\";\n\ntype SelectionTrigger = \"click\" | \"drag\" | \"keyboard-nav\" | \"keyboard-select\" | \"edit\";\n\nexport function useSelectionBehavior(\n    gridSelection: GridSelection,\n    setGridSelection: SetCallback,\n    rangeBehavior: SelectionBlending,\n    columnBehavior: SelectionBlending,\n    rowBehavior: SelectionBlending,\n    rangeSelect: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\"\n) {\n    // if append is true, the current range will be added to the rangeStack\n    const setCurrent = React.useCallback(\n        (\n            value: Pick<NonNullable<GridSelection[\"current\"]>, \"cell\" | \"range\"> | undefined,\n            expand: boolean,\n            append: boolean,\n            trigger: SelectionTrigger\n        ) => {\n            if ((rangeSelect === \"cell\" || rangeSelect === \"multi-cell\") && value !== undefined) {\n                value = {\n                    ...value,\n                    range: {\n                        x: value.cell[0],\n                        y: value.cell[1],\n                        width: 1,\n                        height: 1,\n                    },\n                };\n            }\n            const rangeMixable = rangeBehavior === \"mixed\" && (append || trigger === \"drag\");\n            const allowColumnCoSelect = columnBehavior === \"mixed\" && rangeMixable;\n            const allowRowCoSelect = rowBehavior === \"mixed\" && rangeMixable;\n            let newVal: GridSelection = {\n                current:\n                    value === undefined\n                        ? undefined\n                        : {\n                              ...value,\n                              rangeStack: trigger === \"drag\" ? gridSelection.current?.rangeStack ?? [] : [],\n                          },\n                columns: allowColumnCoSelect ? gridSelection.columns : CompactSelection.empty(),\n                rows: allowRowCoSelect ? gridSelection.rows : CompactSelection.empty(),\n            };\n\n            const addLastRange = append && (rangeSelect === \"multi-rect\" || rangeSelect === \"multi-cell\");\n            if (addLastRange && newVal.current !== undefined && gridSelection.current !== undefined) {\n                newVal = {\n                    ...newVal,\n                    current: {\n                        ...newVal.current,\n                        rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range],\n                    },\n                };\n            }\n            setGridSelection(newVal, expand);\n        },\n        [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]\n    );\n\n    const setSelectedRows = React.useCallback(\n        (newRows: CompactSelection | undefined, append: Slice | number | undefined, allowMixed: boolean): void => {\n            newRows = newRows ?? gridSelection.rows;\n            if (append !== undefined) {\n                newRows = newRows.add(append);\n            }\n            let newVal: GridSelection;\n            if (rowBehavior === \"exclusive\" && newRows.length > 0) {\n                newVal = {\n                    current: undefined,\n                    columns: CompactSelection.empty(),\n                    rows: newRows,\n                };\n            } else {\n                const rangeMixed = allowMixed && rangeBehavior === \"mixed\";\n                const columnMixed = allowMixed && columnBehavior === \"mixed\";\n                const current = !rangeMixed ? undefined : gridSelection.current;\n                newVal = {\n                    current,\n                    columns: columnMixed ? gridSelection.columns : CompactSelection.empty(),\n                    rows: newRows,\n                };\n            }\n            setGridSelection(newVal, false);\n        },\n        [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]\n    );\n\n    const setSelectedColumns = React.useCallback(\n        (newCols: CompactSelection | undefined, append: number | Slice | undefined, allowMixed: boolean): void => {\n            newCols = newCols ?? gridSelection.columns;\n            if (append !== undefined) {\n                newCols = newCols.add(append);\n            }\n            let newVal: GridSelection;\n            if (columnBehavior === \"exclusive\" && newCols.length > 0) {\n                newVal = {\n                    current: undefined,\n                    rows: CompactSelection.empty(),\n                    columns: newCols,\n                };\n            } else {\n                const rangeMixed = allowMixed && rangeBehavior === \"mixed\";\n                const rowMixed = allowMixed && rowBehavior === \"mixed\";\n                const current = !rangeMixed ? undefined : gridSelection.current;\n                newVal = {\n                    current,\n                    rows: rowMixed ? gridSelection.rows : CompactSelection.empty(),\n                    columns: newCols,\n                };\n            }\n            setGridSelection(newVal, false);\n        },\n        [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]\n    );\n\n    return [setCurrent, setSelectedRows, setSelectedColumns] as const;\n}\n","import * as React from \"react\";\nimport type { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport { CellArray, GridCell, GridCellKind } from \"../data-grid/data-grid-types\";\nimport type { DataEditorProps } from \"./data-editor\";\n\ntype CellsForSelectionCallback = NonNullable<DataGridSearchProps[\"getCellsForSelection\"]>;\nexport function useCellsForSelection(\n    getCellsForSelectionIn: CellsForSelectionCallback | true | undefined,\n    getCellContent: DataEditorProps[\"getCellContent\"],\n    rowMarkerOffset: number,\n    abortController: AbortController\n) {\n    const getCellsForSelectionDirectWhenValid = React.useCallback<CellsForSelectionCallback>(\n        rect => {\n            if (getCellsForSelectionIn === true) {\n                const result: GridCell[][] = [];\n\n                for (let y = rect.y; y < rect.y + rect.height; y++) {\n                    const row: GridCell[] = [];\n                    for (let x = rect.x; x < rect.x + rect.width; x++) {\n                        if (x < 0) {\n                            row.push({\n                                kind: GridCellKind.Loading,\n                                allowOverlay: false,\n                            });\n                        } else {\n                            row.push(getCellContent([x, y]));\n                        }\n                    }\n                    result.push(row);\n                }\n\n                return result;\n            }\n            return getCellsForSelectionIn?.(rect, abortController.signal) ?? [];\n        },\n        [abortController.signal, getCellContent, getCellsForSelectionIn]\n    );\n    const getCellsForSelectionDirect =\n        getCellsForSelectionIn !== undefined ? getCellsForSelectionDirectWhenValid : undefined;\n    const getCellsForSelectionMangled = React.useCallback<CellsForSelectionCallback>(\n        rect => {\n            if (getCellsForSelectionDirect === undefined) return [];\n            const newRect = {\n                ...rect,\n                x: rect.x - rowMarkerOffset,\n            };\n            if (newRect.x < 0) {\n                newRect.x = 0;\n                newRect.width--;\n                const r = getCellsForSelectionDirect(newRect, abortController.signal);\n\n                if (typeof r === \"function\") {\n                    return async () =>\n                        // eslint-disable-next-line unicorn/no-await-expression-member\n                        (await r()).map<CellArray[0]>(row => [\n                            { kind: GridCellKind.Loading, allowOverlay: false },\n                            ...row,\n                        ]);\n                }\n                return r.map(row => [{ kind: GridCellKind.Loading, allowOverlay: false }, ...row]);\n            }\n            return getCellsForSelectionDirect(newRect, abortController.signal);\n        },\n        [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]\n    );\n\n    const getCellsForSelection = getCellsForSelectionIn !== undefined ? getCellsForSelectionMangled : undefined;\n\n    return [getCellsForSelection, getCellsForSelectionDirect] as const;\n}\n","import { assertNever } from \"../common/support\";\nimport type { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport {\n    BooleanEmpty,\n    BooleanIndeterminate,\n    GridCell,\n    GridCellKind,\n    GridSelection,\n    Rectangle,\n} from \"../data-grid/data-grid-types\";\n\nexport function expandSelection(\n    newVal: GridSelection,\n    getCellsForSelection: DataGridSearchProps[\"getCellsForSelection\"],\n    rowMarkerOffset: number,\n    spanRangeBehavior: \"allowPartial\" | \"default\",\n    abortController: AbortController\n): GridSelection {\n    const origVal = newVal;\n    if (spanRangeBehavior === \"allowPartial\" || newVal.current === undefined) return newVal;\n    if (getCellsForSelection !== undefined) {\n        let isFilled = false;\n        do {\n            if (newVal?.current === undefined) break;\n            const r: Rectangle = newVal.current?.range;\n            const cells: (readonly GridCell[])[] = [];\n            if (r.width > 2) {\n                const leftCells = getCellsForSelection(\n                    {\n                        x: r.x,\n                        y: r.y,\n                        width: 1,\n                        height: r.height,\n                    },\n                    abortController.signal\n                );\n\n                if (typeof leftCells === \"function\") {\n                    return origVal;\n                }\n\n                cells.push(...leftCells);\n\n                const rightCells = getCellsForSelection(\n                    {\n                        x: r.x + r.width - 1,\n                        y: r.y,\n                        width: 1,\n                        height: r.height,\n                    },\n                    abortController.signal\n                );\n\n                if (typeof rightCells === \"function\") {\n                    return origVal;\n                }\n\n                cells.push(...rightCells);\n            } else {\n                const rCells = getCellsForSelection(\n                    {\n                        x: r.x,\n                        y: r.y,\n                        width: r.width,\n                        height: r.height,\n                    },\n                    abortController.signal\n                );\n                if (typeof rCells === \"function\") {\n                    return origVal;\n                }\n                cells.push(...rCells);\n            }\n\n            let left = r.x - rowMarkerOffset;\n            let right = r.x + r.width - 1 - rowMarkerOffset;\n            for (const row of cells) {\n                for (const cell of row) {\n                    if (cell.span === undefined) continue;\n                    left = Math.min(cell.span[0], left);\n                    right = Math.max(cell.span[1], right);\n                }\n            }\n\n            if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {\n                isFilled = true;\n            } else {\n                newVal = {\n                    current: {\n                        cell: newVal.current.cell ?? [0, 0],\n                        range: {\n                            x: left + rowMarkerOffset,\n                            y: r.y,\n                            width: right - left + 1,\n                            height: r.height,\n                        },\n                        rangeStack: newVal.current.rangeStack,\n                    },\n                    columns: newVal.columns,\n                    rows: newVal.rows,\n                };\n            }\n        } while (!isFilled);\n    }\n    return newVal;\n}\n\nfunction descape(s: string): string {\n    if (s.startsWith('\"') && s.endsWith('\"')) {\n        s = s.slice(1, -1).replace(/\"\"/g, '\"');\n    }\n    return s;\n}\n\nexport function unquote(str: string): string[][] {\n    const enum State {\n        None,\n        inString,\n        inStringPostQuote,\n    }\n\n    const result: string[][] = [];\n    let current: string[] = [];\n\n    let start = 0;\n    let state = State.None;\n    str = str.replace(/\\r\\n/g, \"\\n\");\n    let index = 0;\n    for (const char of str) {\n        switch (state) {\n            case State.None:\n                if (char === \"\\t\" || char === \"\\n\") {\n                    current.push(str.slice(start, index));\n                    start = index + 1;\n\n                    if (char === \"\\n\") {\n                        result.push(current);\n                        current = [];\n                    }\n                } else if (char === `\"`) {\n                    state = State.inString;\n                }\n                break;\n            case State.inString:\n                if (char === `\"`) {\n                    state = State.inStringPostQuote;\n                }\n                break;\n            case State.inStringPostQuote:\n                if (char === '\"') {\n                    state = State.inString;\n                } else if (char === \"\\t\" || char === \"\\n\") {\n                    current.push(descape(str.slice(start, index)));\n                    start = index + 1;\n\n                    if (char === \"\\n\") {\n                        result.push(current);\n                        current = [];\n                    }\n                    state = State.None;\n                } else {\n                    state = State.None;\n                }\n                break;\n        }\n\n        index++;\n    }\n    if (start < str.length) {\n        current.push(descape(str.slice(start, str.length)));\n    }\n    result.push(current);\n    return result;\n}\n\nexport function decodeHTML(tableEl: HTMLTableElement): string[][] | undefined {\n    const walkEl: Element[] = [tableEl];\n    const result: string[][] = [];\n    let current: string[] | undefined;\n\n    while (walkEl.length > 0) {\n        const el = walkEl.pop();\n\n        if (el === undefined) break;\n\n        if (el instanceof HTMLTableElement || el.nodeName === \"TBODY\") {\n            walkEl.push(...[...el.children].reverse());\n        } else if (el instanceof HTMLTableRowElement) {\n            if (current !== undefined) {\n                result.push(current);\n            }\n            current = [];\n            walkEl.push(...[...el.children].reverse());\n        } else if (el instanceof HTMLTableCellElement) {\n            current?.push(el.innerText ?? el.textContent ?? \"\");\n        }\n    }\n\n    if (current !== undefined) {\n        result.push(current);\n    }\n\n    return result;\n}\n\nfunction escape(str: string): string {\n    if (/[\\t\\n\"]/.test(str)) {\n        str = `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n}\n\nconst formatBoolean = (val: boolean | BooleanEmpty | BooleanIndeterminate): string => {\n    switch (val) {\n        case true:\n            return \"TRUE\";\n\n        case false:\n            return \"FALSE\";\n\n        case BooleanIndeterminate:\n            return \"INDETERMINATE\";\n\n        case BooleanEmpty:\n            return \"\";\n\n        default:\n            assertNever(val);\n    }\n};\n\nexport function copyToClipboard(\n    cells: readonly (readonly GridCell[])[],\n    columnIndexes: readonly number[],\n    e?: ClipboardEvent\n) {\n    const formatCell = (cell: GridCell, index: number, raw: boolean): string => {\n        const colIndex = columnIndexes[index];\n        if (cell.span !== undefined && cell.span[0] !== colIndex) return \"\";\n        switch (cell.kind) {\n            case GridCellKind.Text:\n            case GridCellKind.Number:\n                return escape(raw ? cell.data?.toString() ?? \"\" : cell.displayData);\n            case GridCellKind.Markdown:\n            case GridCellKind.RowID:\n            case GridCellKind.Uri:\n                return escape(cell.data);\n            case GridCellKind.Image:\n            case GridCellKind.Bubble:\n                return cell.data.reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);\n            case GridCellKind.Boolean:\n                return formatBoolean(cell.data);\n            case GridCellKind.Loading:\n                return raw ? \"\" : \"#LOADING\";\n            case GridCellKind.Protected:\n                return raw ? \"\" : \"************\";\n            case GridCellKind.Drilldown:\n                return cell.data.map(i => i.text).reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);\n            case GridCellKind.Custom:\n                return escape(cell.copyData);\n            default:\n                assertNever(cell);\n        }\n    };\n\n    const str = cells.map(row => row.map((a, b) => formatCell(a, b, false)).join(\"\\t\")).join(\"\\n\");\n\n    if (window.navigator.clipboard?.write !== undefined || e !== undefined) {\n        const rootEl = document.createElement(\"tbody\");\n\n        for (const row of cells) {\n            const rowEl = document.createElement(\"tr\");\n\n            for (const [i, cell] of row.entries()) {\n                const cellEl = document.createElement(\"td\");\n                if (cell.kind === GridCellKind.Uri) {\n                    const link = document.createElement(\"a\");\n                    link.href = cell.data;\n                    link.innerText = cell.data;\n                    cellEl.append(link);\n                } else {\n                    cellEl.innerText = formatCell(cell, i, true);\n                }\n                rowEl.append(cellEl);\n            }\n\n            rootEl.append(rowEl);\n        }\n        if (window.navigator.clipboard?.write !== undefined) {\n            void window.navigator.clipboard.write([\n                new ClipboardItem({\n                    \"text/plain\": new Blob([str], { type: \"text/plain\" }),\n                    \"text/html\": new Blob([`<table>${rootEl.outerHTML}</table>`], { type: \"text/html\" }),\n                }),\n            ]);\n        } else if (e !== undefined && e?.clipboardData !== null) {\n            try {\n                // This might fail if we had to await the thunk\n                e.clipboardData.setData(\"text/plain\", str);\n                e.clipboardData.setData(\"text/html\", `<table>${rootEl.outerHTML}</table>`);\n            } catch {\n                void window.navigator.clipboard?.writeText(str);\n            }\n        }\n    } else {\n        void window.navigator.clipboard?.writeText(str);\n    }\n\n    e?.preventDefault();\n}\n","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\n\ninterface WrapperProps {\n    inWidth: number | string;\n    inHeight: number | string;\n}\n\nfunction toCss(x: number | string) {\n    if (typeof x === \"string\") return x;\n    return `${x}px`;\n}\n\nconst Wrapper = styled.div<{ innerWidth: string; innerHeight: string }>`\n    position: relative;\n\n    min-width: 10px;\n    min-height: 10px;\n    max-width: 100%;\n    max-height: 100%;\n\n    width: ${p => p.innerWidth};\n    height: ${p => p.innerHeight};\n\n    overflow: hidden;\n    overflow: clip;\n\n    contain: strict;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\ninterface Props extends WrapperProps, React.HTMLAttributes<HTMLDivElement> {}\n\nexport const DataEditorContainer: React.FunctionComponent<React.PropsWithChildren<Props>> = p => {\n    const { inWidth, inHeight, children, ...rest } = p;\n    return (\n        <Wrapper innerHeight={toCss(inHeight)} innerWidth={toCss(inWidth)} {...rest}>\n            {children}\n        </Wrapper>\n    );\n};\n","import React from \"react\";\nimport type { GridMouseCellEventArgs } from \"../data-grid/data-grid-types\";\n\nconst maxPxPerMs = 2;\nconst msToFullSpeed = 1300;\n\nexport function useAutoscroll(\n    scrollDirection: GridMouseCellEventArgs[\"scrollEdge\"] | undefined,\n    scrollRef: React.MutableRefObject<HTMLDivElement | null>\n) {\n    const speedScalar = React.useRef(0);\n    const [xDir, yDir] = scrollDirection ?? [0, 0];\n    React.useEffect(() => {\n        if (xDir === 0 && yDir === 0) {\n            speedScalar.current = 0;\n            return;\n        }\n\n        let lastTime = 0;\n        const scrollFn = (curTime: number) => {\n            if (lastTime === 0) {\n                lastTime = curTime;\n            } else {\n                const step = curTime - lastTime;\n                speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);\n                const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;\n                scrollRef.current?.scrollBy(xDir * motion, yDir * motion);\n                lastTime = curTime;\n            }\n            t = window.requestAnimationFrame(scrollFn);\n        };\n        let t = window.requestAnimationFrame(scrollFn);\n        return () => window.cancelAnimationFrame(t);\n    }, [scrollRef, xDir, yDir]);\n}\n","/* eslint-disable sonarjs/no-duplicate-string */\nimport * as React from \"react\";\nimport { assert, assertNever, maybe } from \"../common/support\";\nimport clamp from \"lodash/clamp.js\";\nimport uniq from \"lodash/uniq.js\";\nimport flatten from \"lodash/flatten.js\";\nimport range from \"lodash/range.js\";\nimport debounce from \"lodash/debounce.js\";\nimport DataGridOverlayEditor from \"../data-grid-overlay-editor/data-grid-overlay-editor\";\nimport {\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridDragEventArgs,\n    GridKeyEventArgs,\n    GridMouseEventArgs,\n    GridSelection,\n    isEditableGridCell,\n    Rectangle,\n    isReadWriteCell,\n    InnerGridCell,\n    InnerGridCellKind,\n    CompactSelection,\n    Slice,\n    isInnerOnlyCell,\n    ProvideEditorCallback,\n    DrawCustomCellCallback,\n    GridMouseCellEventArgs,\n    GridColumn,\n    isObjectEditorCallbackResult,\n    GroupHeaderClickedEventArgs,\n    HeaderClickedEventArgs,\n    CellClickedEventArgs,\n    Item,\n    MarkerCell,\n    headerCellUnheckedMarker,\n    headerCellCheckedMarker,\n    headerCellIndeterminateMarker,\n    groupHeaderKind,\n    outOfBoundsKind,\n    ValidatedGridCell,\n    ImageEditorType,\n    CustomCell,\n} from \"../data-grid/data-grid-types\";\nimport DataGridSearch, { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport { browserIsOSX } from \"../common/browser-detect\";\nimport { getDataEditorTheme, makeCSSStyle, Theme, ThemeContext } from \"../common/styles\";\nimport type { DataGridRef } from \"../data-grid/data-grid\";\nimport { getScrollBarWidth, useEventListener, useStateWithReactiveInput, whenDefined } from \"../common/utils\";\nimport { isGroupEqual } from \"../data-grid/data-grid-lib\";\nimport { GroupRename } from \"./group-rename\";\nimport { measureColumn, useColumnSizer } from \"./use-column-sizer\";\nimport { isHotkey } from \"../common/is-hotkey\";\nimport { SelectionBlending, useSelectionBehavior } from \"../data-grid/use-selection-behavior\";\nimport { useCellsForSelection } from \"./use-cells-for-selection\";\nimport { unquote, expandSelection, copyToClipboard, decodeHTML } from \"./data-editor-fns\";\nimport { DataEditorContainer } from \"../data-editor-container/data-grid-container\";\nimport { toggleBoolean } from \"../data-grid/cells/boolean-cell\";\nimport { useAutoscroll } from \"./use-autoscroll\";\nimport type { CustomRenderer, CellRenderer } from \"../data-grid/cells/cell-types\";\nimport { CellRenderers } from \"../data-grid/cells\";\n\nlet idCounter = 0;\n\ninterface MouseState {\n    readonly previousSelection?: GridSelection;\n    readonly fillHandle?: boolean;\n}\n\ntype Props = Partial<\n    Omit<\n        DataGridSearchProps,\n        | \"accessibilityHeight\"\n        | \"canvasRef\"\n        | \"cellXOffset\"\n        | \"cellYOffset\"\n        | \"className\"\n        | \"clientSize\"\n        | \"columns\"\n        | \"disabledRows\"\n        | \"drawCustomCell\"\n        | \"enableGroups\"\n        | \"firstColAccessible\"\n        | \"firstColSticky\"\n        | \"freezeColumns\"\n        | \"getCellContent\"\n        | \"getCellRenderer\"\n        | \"getCellsForSelection\"\n        | \"gridRef\"\n        | \"groupHeaderHeight\"\n        | \"headerHeight\"\n        | \"isFilling\"\n        | \"isFocused\"\n        | \"lockColumns\"\n        | \"maxColumnWidth\"\n        | \"minColumnWidth\"\n        | \"onCanvasBlur\"\n        | \"onCanvasFocused\"\n        | \"onCellFocused\"\n        | \"onContextMenu\"\n        | \"onDragEnd\"\n        | \"onMouseDown\"\n        | \"onMouseMove\"\n        | \"onMouseUp\"\n        | \"onSearchResultsChanged\"\n        | \"onVisibleRegionChanged\"\n        | \"rowHeight\"\n        | \"rows\"\n        | \"scrollRef\"\n        | \"searchColOffset\"\n        | \"searchInputRef\"\n        | \"selectedColumns\"\n        | \"selection\"\n        | \"theme\"\n        | \"trailingRowType\"\n        | \"translateX\"\n        | \"translateY\"\n        | \"verticalBorder\"\n    >\n>;\n\ntype EditListItem = { location: Item; value: EditableGridCell };\n\ntype EmitEvents = \"copy\" | \"paste\" | \"delete\" | \"fill-right\" | \"fill-down\";\n\nfunction getSpanStops(cells: readonly (readonly GridCell[])[]): number[] {\n    return uniq(\n        flatten(\n            flatten(cells)\n                .filter(c => c.span !== undefined)\n                .map(c => range((c.span?.[0] ?? 0) + 1, (c.span?.[1] ?? 0) + 1))\n        )\n    );\n}\n\nfunction shiftSelection(input: GridSelection, offset: number): GridSelection {\n    if (input === undefined || offset === 0 || (input.columns.length === 0 && input.current === undefined))\n        return input;\n\n    return {\n        current:\n            input.current === undefined\n                ? undefined\n                : {\n                      cell: [input.current.cell[0] + offset, input.current.cell[1]],\n                      range: {\n                          ...input.current.range,\n                          x: input.current.range.x + offset,\n                      },\n                      rangeStack: input.current.rangeStack.map(r => ({\n                          ...r,\n                          x: r.x + offset,\n                      })),\n                  },\n        rows: input.rows,\n        columns: input.columns.offset(offset),\n    };\n}\n\ninterface Keybinds {\n    readonly selectAll: boolean;\n    readonly selectRow: boolean;\n    readonly selectColumn: boolean;\n    readonly downFill: boolean;\n    readonly rightFill: boolean;\n    readonly pageUp: boolean;\n    readonly pageDown: boolean;\n    readonly clear: boolean;\n    readonly copy: boolean;\n    readonly paste: boolean;\n    readonly search: boolean;\n    readonly first: boolean;\n    readonly last: boolean;\n}\n\nconst keybindingDefaults: Keybinds = {\n    selectAll: true,\n    selectRow: true,\n    selectColumn: true,\n    downFill: false,\n    rightFill: false,\n    pageUp: false,\n    pageDown: false,\n    clear: true,\n    copy: true,\n    paste: true,\n    search: false,\n    first: true,\n    last: true,\n};\n\n/**\n * @category DataEditor\n */\nexport interface DataEditorProps extends Props {\n    /** Emitted whenever the user has requested the deletion of the selection.\n     * @group Editing\n     */\n    readonly onDelete?: (selection: GridSelection) => boolean | GridSelection;\n    /** Emitted whenever a cell edit is completed.\n     * @group Editing\n     */\n    readonly onCellEdited?: (cell: Item, newValue: EditableGridCell) => void;\n    /** Emitted whenever a cell mutation is completed and provides all edits inbound as a single batch.\n     * @group Editing\n     */\n    readonly onCellsEdited?: (newValues: readonly EditListItem[]) => boolean | void;\n    /** Emitted whenever a row append operation is requested. Append location can be set in callback.\n     * @group Editing\n     */\n    readonly onRowAppended?: () => Promise<\"top\" | \"bottom\" | number | undefined> | void;\n    /** Emitted when a column header should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onHeaderClicked?: (colIndex: number, event: HeaderClickedEventArgs) => void;\n    /** Emitted when a group header is clicked.\n     * @group Events\n     */\n    readonly onGroupHeaderClicked?: (colIndex: number, event: GroupHeaderClickedEventArgs) => void;\n    /** Emitted whe the user wishes to rename a group.\n     * @group Events\n     */\n    readonly onGroupHeaderRenamed?: (groupName: string, newVal: string) => void;\n    /** Emitted when a cell is clicked.\n     * @group Events\n     */\n    readonly onCellClicked?: (cell: Item, event: CellClickedEventArgs) => void;\n    /** Emitted when a cell is activated, by pressing Enter, Space or double clicking it.\n     * @group Events\n     */\n    readonly onCellActivated?: (cell: Item) => void;\n    /** Emitted when editing has finished, regardless of data changing or not.\n     * @group Editing\n     */\n    readonly onFinishedEditing?: (newValue: GridCell | undefined, movement: Item) => void;\n    /** Emitted when a column header should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onHeaderContextMenu?: (colIndex: number, event: HeaderClickedEventArgs) => void;\n    /** Emitted when a group header should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onGroupHeaderContextMenu?: (colIndex: number, event: GroupHeaderClickedEventArgs) => void;\n    /** Emitted when a cell should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onCellContextMenu?: (cell: Item, event: CellClickedEventArgs) => void;\n    /** Used for validating cell values during editing.\n     * @group Editing\n     * @param cell The cell which is being validated.\n     * @param newValue The new value being proposed.\n     * @param prevValue The previous value before the edit.\n     * @returns A return of false indicates the value will not be accepted. A value of\n     * true indicates the value will be accepted. Returning a new GridCell will immediately coerce the value to match.\n     */\n    readonly validateCell?: (\n        cell: Item,\n        newValue: EditableGridCell,\n        prevValue: GridCell\n    ) => boolean | ValidatedGridCell;\n\n    /** The columns to display in the data grid.\n     * @group Data\n     */\n    readonly columns: readonly GridColumn[];\n\n    /** Controls the trailing row used to insert new data into the grid.\n     * @group Editing\n     */\n    readonly trailingRowOptions?: {\n        /** If the trailing row should be tinted */\n        readonly tint?: boolean;\n        /** A hint string displayed on hover. Usually something like \"New row\" */\n        readonly hint?: string;\n        /** When set to true, the trailing row is always visible. */\n        readonly sticky?: boolean;\n        /** The icon to use for the cell. Either a GridColumnIcon or a member of the passed headerIcons */\n        readonly addIcon?: string;\n        /** Overrides the column to focus when a new row is created. */\n        readonly targetColumn?: number | GridColumn;\n    };\n    /** Controls the height of the header row\n     * @defaultValue 36\n     * @group Style\n     */\n    readonly headerHeight?: number;\n    /** Controls the header of the group header row\n     * @defaultValue `headerHeight`\n     * @group Style\n     */\n    readonly groupHeaderHeight?: number;\n\n    /**\n     * The number of rows in the grid.\n     * @group Data\n     */\n    readonly rows: number;\n\n    /** Determins if row markers should be automatically added to the grid.\n     * @defaultValue `none`\n     * @group Style\n     */\n    readonly rowMarkers?: \"checkbox\" | \"number\" | \"clickable-number\" | \"both\" | \"none\";\n    /**\n     * Sets the width of row markers in pixels, if unset row markers will automatically size.\n     * @group Style\n     */\n    readonly rowMarkerWidth?: number;\n    /** Changes the starting index for row markers.\n     * @defaultValue 1\n     * @group Style\n     */\n    readonly rowMarkerStartIndex?: number;\n\n    /** Sets the width of the data grid.\n     * @group Style\n     */\n    readonly width?: number | string;\n    /** Sets the height of the data grid.\n     * @group Style\n     */\n    readonly height?: number | string;\n    /** Custom classname for data grid wrapper.\n     * @group Style\n     */\n    readonly className?: string;\n\n    /** If set to `default`, `gridSelection` will be coerced to always include full spans.\n     * @group Selection\n     * @defaultValue `default`\n     */\n    readonly spanRangeBehavior?: \"default\" | \"allowPartial\";\n\n    /** Controls which types of selections can exist at the same time in the grid. If selection blending is set to\n     * exclusive, the grid will clear other types of selections when the exclusive selection is made. By default row,\n     * column, and range selections are exclusive.\n     * @group Selection\n     * @defaultValue `exclusive`\n     * */\n    readonly rangeSelectionBlending?: SelectionBlending;\n    /** {@inheritDoc rangeSelectionBlending}\n     * @group Selection\n     */\n    readonly columnSelectionBlending?: SelectionBlending;\n    /** {@inheritDoc rangeSelectionBlending}\n     * @group Selection\n     */\n    readonly rowSelectionBlending?: SelectionBlending;\n    /** Controls if multi-selection is allowed. If disabled, shift/ctrl/command clicking will work as if no modifiers\n     * are pressed.\n     *\n     * When range select is set to cell, only one cell may be selected at a time. When set to rect one one rect at a\n     * time. The multi variants allow for multiples of the rect or cell to be selected.\n     * @group Selection\n     * @defaultValue `rect`\n     */\n    readonly rangeSelect?: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\";\n    /** {@inheritDoc rangeSelect}\n     * @group Selection\n     * @defaultValue `multi`\n     */\n    readonly columnSelect?: \"none\" | \"single\" | \"multi\";\n    /** {@inheritDoc rangeSelect}\n     * @group Selection\n     * @defaultValue `multi`\n     */\n    readonly rowSelect?: \"none\" | \"single\" | \"multi\";\n\n    /** Sets the initial scroll Y offset.\n     * @see {@link scrollOffsetX}\n     * @group Advanced\n     */\n    readonly scrollOffsetY?: number;\n    /** Sets the initial scroll X offset\n     * @see {@link scrollOffsetY}\n     * @group Advanced\n     */\n    readonly scrollOffsetX?: number;\n\n    /** Determins the height of each row.\n     * @group Style\n     * @defaultValue 34\n     */\n    readonly rowHeight?: DataGridSearchProps[\"rowHeight\"];\n    /** Fires whenever the mouse moves\n     * @group Events\n     * @param args\n     */\n    readonly onMouseMove?: DataGridSearchProps[\"onMouseMove\"];\n\n    /**\n     * The minimum width a column can be resized to.\n     * @defaultValue 50\n     * @group Style\n     */\n    readonly minColumnWidth?: DataGridSearchProps[\"minColumnWidth\"];\n    /**\n     * The maximum width a column can be resized to.\n     * @defaultValue 500\n     * @group Style\n     */\n    readonly maxColumnWidth?: DataGridSearchProps[\"maxColumnWidth\"];\n    /**\n     * The maximum width a column can be automatically sized to.\n     * @defaultValue `maxColumnWidth`\n     * @group Style\n     */\n    readonly maxColumnAutoWidth?: number;\n\n    /**\n     * Used to provide an override to the default image editor for the data grid. `provideEditor` may be a better\n     * choice for most people.\n     * @group Advanced\n     * */\n    readonly imageEditorOverride?: ImageEditorType;\n    /**\n     * If specified, it will be used to render Markdown, instead of the default Markdown renderer used by the Grid.\n     * You'll want to use this if you need to process your Markdown for security purposes, or if you want to use a\n     * renderer with different Markdown features.\n     * @group Advanced\n     */\n    readonly markdownDivCreateNode?: (content: string) => DocumentFragment;\n\n    /** Callback for providing a custom editor for a cell.\n     * @group Editing\n     */\n    readonly provideEditor?: ProvideEditorCallback<GridCell>;\n    /**\n     * Allows coercion of pasted values.\n     * @group Editing\n     * @param val The pasted value\n     * @param cell The cell being pasted into\n     * @returns `undefined` to accept default behavior or a `GridCell` which should be used to represent the pasted value.\n     */\n    readonly coercePasteValue?: (val: string, cell: GridCell) => GridCell | undefined;\n\n    /**\n     * Emitted when the grid selection is cleared.\n     * @group Selection\n     */\n    readonly onSelectionCleared?: () => void;\n\n    /**\n     * Callback used to override the rendering of any cell.\n     * @group Drawing\n     */\n    readonly drawCell?: DrawCustomCellCallback;\n\n    /**\n     * The current selection of the data grid. Contains all selected cells, ranges, rows, and columns.\n     * @group Selection\n     */\n    readonly gridSelection?: GridSelection;\n    /**\n     * Emitted whenever the grid selection changes.\n     * @param newSelection The new gridSelection as created by user input.\n     * @group Selection\n     */\n    readonly onGridSelectionChange?: (newSelection: GridSelection) => void;\n    /**\n     * Emitted whenever the visible cells change, usually due to scrolling.\n     * @group Events\n     * @param range An inclusive range of all visible cells. May include cells obscured by UI elements such\n     * as headers.\n     * @param tx The x transform of the cell region.\n     * @param ty The y transform of the cell region.\n     * @param extras Contains information about the selected cell and\n     * any visible freeze columns.\n     */\n    readonly onVisibleRegionChanged?: (\n        range: Rectangle,\n        tx?: number,\n        ty?: number,\n        extras?: {\n            /** The selected item if visible */\n            selected?: Item;\n            /** A selection of visible freeze columns */\n            freezeRegion?: Rectangle;\n        }\n    ) => void;\n\n    /**\n     * The primary callback for getting cell data into the data grid.\n     * @group Data\n     * @param cell The location of the cell being requested.\n     * @returns A valid GridCell to be rendered by the Grid.\n     */\n    readonly getCellContent: (cell: Item) => GridCell;\n    /**\n     * Determines if row selection requires a modifier key to enable multi-selection or not. In auto mode it adapts to\n     * touch or mouse environments automatically, in multi-mode it always acts as if the multi key (Ctrl) is pressed.\n     * @group Editing\n     * @defaultValue `auto`\n     */\n    readonly rowSelectionMode?: \"auto\" | \"multi\";\n\n    /**\n     * Determins which keybindings are enabled.\n     * @group Editing\n     * @defaultValue is\n     \n            {  \n                selectAll: true,\n                selectRow: true,\n                selectColumn: true,\n                downFill: false,\n                rightFill: false,\n                pageUp: false,\n                pageDown: false,\n                clear: true,\n                copy: true,\n                paste: true,\n                search: false,\n                first: true,\n                last: true,\n            }\n     */\n    readonly keybindings?: Partial<Keybinds>;\n\n    /**\n     * Used to fetch large amounts of cells at once. Used for copy/paste, if unset copy will not work.\n     *\n     * `getCellsForSelection` is called when the user copies a selection to the clipboard or the data editor needs to\n     * inspect data which may be outside the curently visible range. It must return a two-dimensional array (an array of\n     * rows, where each row is an array of cells) of the cells in the selection's rectangle. Note that the rectangle can\n     * include cells that are not currently visible.\n     *\n     * If `true` is passed instead of a callback, the data grid will internally use the `getCellContent` callback to\n     * provide a basic implementation of `getCellsForSelection`. This can make it easier to light up more data grid\n     * functionality, but may have negative side effects if your data source is not able to handle being queried for\n     * data outside the normal window.\n     *\n     * If `getCellsForSelection` returns a thunk, the data may be loaded asynchronously, however the data grid may be\n     * unable to properly react to column spans when performing range selections. Copying large amounts of data out of\n     * the grid will depend on the performance of the thunk as well.\n     * @group Data\n     * @param {Rectangle} selection The range of requested cells\n     * @param {AbortSignal} abortSignal A signal indicating the requested cells are no longer needed\n     * @returns A row-major collection of cells or an async thunk which returns a row-major collection.\n     */\n    readonly getCellsForSelection?: DataGridSearchProps[\"getCellsForSelection\"] | true;\n\n    /** The number of columns which should remain in place when scrolling horizontally. The row marker column, if\n     * enabled is always frozen and is not included in this count.\n     * @defaultValue 0\n     * @group Style\n     */\n    readonly freezeColumns?: DataGridSearchProps[\"freezeColumns\"];\n\n    /**\n     * Controls the drawing of the left hand vertical border of a column. If set to a boolean value it controls all\n     * borders.\n     * @defaultValue `true`\n     * @group Style\n     */\n    readonly verticalBorder?: DataGridSearchProps[\"verticalBorder\"] | boolean;\n\n    /**\n     * Called when data is pasted into the grid. If left undefined, the `DataEditor` will operate in a\n     * fallback mode and attempt to paste the text buffer into the current cell assuming the current cell is not\n     * readonly and can accept the data type. If `onPaste` is set to false or the function returns false, the grid will\n     * simply ignore paste. If `onPaste` evaluates to true the grid will attempt to split the data by tabs and newlines\n     * and paste into available cells.\n     *\n     * The grid will not attempt to add additional rows if more data is pasted then can fit. In that case it is\n     * advisable to simply return false from onPaste and handle the paste manually.\n     * @group Editing\n     */\n    readonly onPaste?: ((target: Item, values: readonly (readonly string[])[]) => boolean) | boolean;\n\n    /**\n     * The theme used by the data grid to get all color and font information\n     * @group Style\n     */\n    readonly theme?: Partial<Theme>;\n\n    /**\n     * An array of custom renderers which can be used to extend the data grid.\n     * @group Advanced\n     */\n    readonly customRenderers?: readonly CustomRenderer<CustomCell<any>>[];\n}\n\ntype ScrollToFn = (\n    col: number | { amount: number; unit: \"cell\" | \"px\" },\n    row: number | { amount: number; unit: \"cell\" | \"px\" },\n    dir?: \"horizontal\" | \"vertical\" | \"both\",\n    paddingX?: number,\n    paddingY?: number,\n    options?: {\n        hAlign?: \"start\" | \"center\" | \"end\";\n        vAlign?: \"start\" | \"center\" | \"end\";\n    }\n) => void;\n\n/** @category DataEditor */\nexport interface DataEditorRef {\n    /**\n     * Programatically appends a row.\n     * @param col The column index to focus in the new row.\n     * @returns A promise which waits for the append to complete.\n     */\n    appendRow: (col: number) => Promise<void>;\n    /**\n     * Triggers cells to redraw.\n     */\n    updateCells: DataGridRef[\"damage\"];\n    /**\n     * Gets the screen space bounds of the requested item.\n     */\n    getBounds: DataGridRef[\"getBounds\"];\n    /**\n     * Triggers the data grid to focus itself or the correct accessibility element.\n     */\n    focus: DataGridRef[\"focus\"];\n    /**\n     * Generic API for emitting events as if they had been triggered via user interaction.\n     */\n    emit: (eventName: EmitEvents) => Promise<void>;\n    /**\n     * Scrolls to the desired cell or location in the grid.\n     */\n    scrollTo: ScrollToFn;\n}\n\nconst loadingCell: GridCell = {\n    kind: GridCellKind.Loading,\n    allowOverlay: false,\n};\n\nconst emptyGridSelection: GridSelection = {\n    columns: CompactSelection.empty(),\n    rows: CompactSelection.empty(),\n    current: undefined,\n};\n\nconst DataEditorImpl: React.ForwardRefRenderFunction<DataEditorRef, DataEditorProps> = (p, forwardedRef) => {\n    const [gridSelectionInner, setGridSelectionInner] = React.useState<GridSelection>(emptyGridSelection);\n    const [overlay, setOverlay] =\n        React.useState<{\n            target: Rectangle;\n            content: GridCell;\n            theme: Theme;\n            initialValue: string | undefined;\n            cell: Item;\n            highlight: boolean;\n            forceEditMode: boolean;\n        }>();\n    const searchInputRef = React.useRef<HTMLInputElement | null>(null);\n    const canvasRef = React.useRef<HTMLCanvasElement | null>(null);\n    const [mouseState, setMouseState] = React.useState<MouseState>();\n    const scrollRef = React.useRef<HTMLDivElement | null>(null);\n    const lastSent = React.useRef<[number, number]>();\n\n    const {\n        rowMarkers = \"none\",\n        rowHeight = 34,\n        headerHeight = 36,\n        rowMarkerWidth: rowMarkerWidthRaw,\n        imageEditorOverride,\n        getRowThemeOverride,\n        markdownDivCreateNode,\n    } = p;\n\n    const {\n        width,\n        height,\n        columns: columnsIn,\n        rows,\n        getCellContent,\n        onCellClicked,\n        onCellActivated,\n        onFinishedEditing,\n        coercePasteValue,\n        drawHeader: drawHeaderIn,\n        onHeaderClicked,\n        spanRangeBehavior = \"default\",\n        onGroupHeaderClicked,\n        onCellContextMenu,\n        className,\n        theme,\n        onHeaderContextMenu,\n        getCellsForSelection: getCellsForSelectionIn,\n        onGroupHeaderContextMenu,\n        onGroupHeaderRenamed,\n        onCellEdited,\n        onCellsEdited,\n        onKeyDown: onKeyDownIn,\n        onKeyUp: onKeyUpIn,\n        keybindings: keybindingsIn,\n        onRowAppended,\n        onColumnMoved,\n        validateCell: validateCellIn,\n        highlightRegions: highlightRegionsIn,\n        drawCell,\n        rangeSelect = \"rect\",\n        columnSelect = \"multi\",\n        rowSelect = \"multi\",\n        rangeSelectionBlending = \"exclusive\",\n        columnSelectionBlending = \"exclusive\",\n        rowSelectionBlending = \"exclusive\",\n        onDelete: onDeleteIn,\n        onDragStart,\n        onMouseMove,\n        onPaste,\n        groupHeaderHeight = headerHeight,\n        freezeColumns = 0,\n        rowSelectionMode = \"auto\",\n        rowMarkerStartIndex = 1,\n        onHeaderMenuClick,\n        getGroupDetails,\n        onSearchClose: onSearchCloseIn,\n        onItemHovered,\n        onSelectionCleared,\n        showSearch: showSearchIn,\n        onVisibleRegionChanged,\n        gridSelection: gridSelectionOuter,\n        onGridSelectionChange,\n        minColumnWidth: minColumnWidthIn = 50,\n        maxColumnWidth: maxColumnWidthIn = 500,\n        maxColumnAutoWidth: maxColumnAutoWidthIn,\n        provideEditor,\n        trailingRowOptions,\n        scrollOffsetX,\n        scrollOffsetY,\n        verticalBorder,\n        onDragOverCell,\n        onDrop,\n        onColumnResize: onColumnResizeIn,\n        onColumnResizeEnd: onColumnResizeEndIn,\n        onColumnResizeStart: onColumnResizeStartIn,\n        customRenderers: additionalRenderers,\n        fillHandle,\n        drawFocusRing,\n        experimental,\n        fixedShadowX,\n        fixedShadowY,\n        headerIcons,\n        imageWindowLoader,\n        initialSize,\n        isDraggable,\n        onDragLeave,\n        onRowMoved,\n        overscrollX,\n        overscrollY,\n        preventDiagonalScrolling,\n        rightElement,\n        rightElementProps,\n        showMinimap,\n        smoothScrollX,\n        smoothScrollY,\n        scrollToEnd,\n    } = p;\n\n    const minColumnWidth = Math.max(minColumnWidthIn, 20);\n    const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);\n    const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn ?? maxColumnWidth, minColumnWidth);\n\n    const keybindings = React.useMemo(() => {\n        return keybindingsIn === undefined\n            ? keybindingDefaults\n            : {\n                  ...keybindingDefaults,\n                  ...keybindingsIn,\n              };\n    }, [keybindingsIn]);\n\n    const rowMarkerWidth = rowMarkerWidthRaw ?? (rows > 10_000 ? 48 : rows > 1000 ? 44 : rows > 100 ? 36 : 32);\n    const hasRowMarkers = rowMarkers !== \"none\";\n    const rowMarkerOffset = hasRowMarkers ? 1 : 0;\n    const showTrailingBlankRow = onRowAppended !== undefined;\n    const lastRowSticky = trailingRowOptions?.sticky === true;\n\n    const [showSearchInner, setShowSearchInner] = React.useState(false);\n    const showSearch = showSearchIn ?? showSearchInner;\n\n    const onSearchClose = React.useCallback(() => {\n        if (onSearchCloseIn !== undefined) {\n            onSearchCloseIn();\n        } else {\n            setShowSearchInner(false);\n        }\n    }, [onSearchCloseIn]);\n\n    const gridSelectionOuterMangled: GridSelection | undefined = React.useMemo((): GridSelection | undefined => {\n        return gridSelectionOuter === undefined ? undefined : shiftSelection(gridSelectionOuter, rowMarkerOffset);\n    }, [gridSelectionOuter, rowMarkerOffset]);\n    const gridSelection = gridSelectionOuterMangled ?? gridSelectionInner;\n\n    const abortControllerRef = React.useRef(new AbortController());\n    React.useEffect(() => {\n        return () => {\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            abortControllerRef?.current.abort();\n        };\n    }, []);\n\n    const [getCellsForSelection, getCellsForSeletionDirect] = useCellsForSelection(\n        getCellsForSelectionIn,\n        getCellContent,\n        rowMarkerOffset,\n        abortControllerRef.current\n    );\n\n    const validateCell = React.useCallback<NonNullable<typeof validateCellIn>>(\n        (cell, newValue, prevValue) => {\n            if (validateCellIn === undefined) return true;\n            const item: Item = [cell[0] - rowMarkerOffset, cell[1]];\n            return validateCellIn?.(item, newValue, prevValue);\n        },\n        [rowMarkerOffset, validateCellIn]\n    );\n\n    const expectedExternalGridSelection = React.useRef<GridSelection | undefined>(gridSelectionOuter);\n    const setGridSelection = React.useCallback(\n        (newVal: GridSelection, expand: boolean): void => {\n            if (expand) {\n                newVal = expandSelection(\n                    newVal,\n                    getCellsForSelection,\n                    rowMarkerOffset,\n                    spanRangeBehavior,\n                    abortControllerRef.current\n                );\n            }\n            if (onGridSelectionChange !== undefined) {\n                expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);\n                onGridSelectionChange(expectedExternalGridSelection.current);\n            } else {\n                setGridSelectionInner(newVal);\n            }\n        },\n        [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]\n    );\n\n    const onColumnResize = whenDefined(\n        onColumnResizeIn,\n        React.useCallback<NonNullable<typeof onColumnResizeIn>>(\n            (_, w, ind, wg) => {\n                onColumnResizeIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n            },\n            [onColumnResizeIn, rowMarkerOffset, columnsIn]\n        )\n    );\n\n    const onColumnResizeEnd = whenDefined(\n        onColumnResizeEndIn,\n        React.useCallback<NonNullable<typeof onColumnResizeEndIn>>(\n            (_, w, ind, wg) => {\n                onColumnResizeEndIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n            },\n            [onColumnResizeEndIn, rowMarkerOffset, columnsIn]\n        )\n    );\n\n    const onColumnResizeStart = whenDefined(\n        onColumnResizeStartIn,\n        React.useCallback<NonNullable<typeof onColumnResizeStartIn>>(\n            (_, w, ind, wg) => {\n                onColumnResizeStartIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n            },\n            [onColumnResizeStartIn, rowMarkerOffset, columnsIn]\n        )\n    );\n\n    const drawHeader = whenDefined(\n        drawHeaderIn,\n        React.useCallback<NonNullable<typeof drawHeaderIn>>(\n            args => {\n                return drawHeaderIn?.({ ...args, columnIndex: args.columnIndex - rowMarkerOffset }) ?? false;\n            },\n            [drawHeaderIn, rowMarkerOffset]\n        )\n    );\n\n    const onDelete = React.useCallback<NonNullable<DataEditorProps[\"onDelete\"]>>(\n        sel => {\n            if (onDeleteIn !== undefined) {\n                const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));\n                if (typeof result === \"boolean\") {\n                    return result;\n                }\n                return shiftSelection(result, rowMarkerOffset);\n            }\n            return true;\n        },\n        [onDeleteIn, rowMarkerOffset]\n    );\n\n    const [setCurrent, setSelectedRows, setSelectedColumns] = useSelectionBehavior(\n        gridSelection,\n        setGridSelection,\n        rangeSelectionBlending,\n        columnSelectionBlending,\n        rowSelectionBlending,\n        rangeSelect\n    );\n\n    const mergedTheme = React.useMemo(() => {\n        return { ...getDataEditorTheme(), ...theme };\n    }, [theme]);\n\n    const [clientSize, setClientSize] = React.useState<readonly [number, number, number]>([10, 10, 0]);\n\n    const getCellRenderer: <T extends InnerGridCell>(cell: T) => CellRenderer<T> | undefined = React.useCallback(\n        <T extends InnerGridCell>(cell: T) => {\n            if (cell.kind !== GridCellKind.Custom) {\n                return CellRenderers[cell.kind] as unknown as CellRenderer<T>;\n            }\n            return additionalRenderers?.find(x => x.isMatch(cell)) as CellRenderer<T>;\n        },\n        [additionalRenderers]\n    );\n\n    const columns = useColumnSizer(\n        columnsIn,\n        rows,\n        getCellsForSeletionDirect,\n        clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2],\n        minColumnWidth,\n        maxColumnAutoWidth,\n        mergedTheme,\n        getCellRenderer,\n        abortControllerRef.current\n    );\n\n    const enableGroups = React.useMemo(() => {\n        return columns.some(c => c.group !== undefined);\n    }, [columns]);\n\n    const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n\n    const numSelectedRows = gridSelection.rows.length;\n    const rowMarkerHeader =\n        rowMarkers === \"none\"\n            ? \"\"\n            : numSelectedRows === 0\n            ? headerCellUnheckedMarker\n            : numSelectedRows === rows\n            ? headerCellCheckedMarker\n            : headerCellIndeterminateMarker;\n\n    const mangledCols = React.useMemo(() => {\n        if (rowMarkers === \"none\") return columns;\n        return [\n            {\n                title: rowMarkerHeader,\n                width: rowMarkerWidth,\n                icon: undefined,\n                hasMenu: false,\n                style: \"normal\" as const,\n            },\n            ...columns,\n        ];\n    }, [columns, rowMarkerWidth, rowMarkers, rowMarkerHeader]);\n\n    const [visibleRegionY, visibleRegionTy] = React.useMemo(() => {\n        return [\n            scrollOffsetY !== undefined && typeof rowHeight === \"number\" ? Math.floor(scrollOffsetY / rowHeight) : 0,\n            scrollOffsetY !== undefined && typeof rowHeight === \"number\" ? -(scrollOffsetY % rowHeight) : 0,\n        ];\n    }, [scrollOffsetY, rowHeight]);\n\n    type VisibleRegion = Rectangle & {\n        /** value in px */\n        tx?: number;\n        /** value in px */\n        ty?: number;\n        extras?: {\n            selected?: Item;\n            freezeRegion?: Rectangle;\n        };\n    };\n\n    const visibleRegionRef = React.useRef<VisibleRegion>({\n        height: 1,\n        width: 1,\n        x: 0,\n        y: 0,\n    });\n    const visibleRegionInput = React.useMemo<VisibleRegion>(\n        () => ({\n            x: visibleRegionRef.current.x,\n            y: visibleRegionY,\n            width: visibleRegionRef.current.width ?? 1,\n            height: visibleRegionRef.current.height ?? 1,\n            // tx: 'TODO',\n            ty: visibleRegionTy,\n        }),\n        [visibleRegionTy, visibleRegionY]\n    );\n\n    const hasJustScrolled = React.useRef(false);\n\n    const [visibleRegion, setVisibleRegion, empty] = useStateWithReactiveInput<VisibleRegion>(visibleRegionInput);\n    visibleRegionRef.current = visibleRegion;\n\n    const vScrollReady = (visibleRegion.height ?? 1) > 1;\n    React.useLayoutEffect(() => {\n        if (scrollOffsetY !== undefined && scrollRef.current !== null && vScrollReady) {\n            scrollRef.current.scrollTop = scrollOffsetY;\n            if (scrollRef.current.scrollTop !== scrollOffsetY) {\n                empty();\n            }\n            hasJustScrolled.current = true;\n        }\n    }, [scrollOffsetY, vScrollReady, empty]);\n\n    const hScrollReady = (visibleRegion.width ?? 1) > 1;\n    React.useLayoutEffect(() => {\n        if (scrollOffsetX !== undefined && scrollRef.current !== null && hScrollReady) {\n            scrollRef.current.scrollLeft = scrollOffsetX;\n            if (scrollRef.current.scrollLeft !== scrollOffsetX) {\n                empty();\n            }\n            hasJustScrolled.current = true;\n        }\n    }, [scrollOffsetX, hScrollReady, empty]);\n\n    const cellXOffset = visibleRegion.x + rowMarkerOffset;\n    const cellYOffset = visibleRegion.y;\n\n    const gridRef = React.useRef<DataGridRef | null>(null);\n\n    const focus = React.useCallback((immediate?: boolean) => {\n        if (immediate === true) {\n            gridRef.current?.focus();\n        } else {\n            window.requestAnimationFrame(() => {\n                gridRef.current?.focus();\n            });\n        }\n    }, []);\n\n    const mangledRows = showTrailingBlankRow ? rows + 1 : rows;\n\n    const mangledOnCellsEdited = React.useCallback<NonNullable<typeof onCellsEdited>>(\n        (items: readonly EditListItem[]) => {\n            const mangledItems =\n                rowMarkerOffset === 0\n                    ? items\n                    : items.map(x => ({\n                          ...x,\n                          location: [x.location[0] - rowMarkerOffset, x.location[1]] as const,\n                      }));\n            const r = onCellsEdited?.(mangledItems);\n\n            if (r !== true) {\n                for (const i of mangledItems) onCellEdited?.(i.location, i.value);\n            }\n\n            return r;\n        },\n        [onCellEdited, onCellsEdited, rowMarkerOffset]\n    );\n\n    const highlightRegions = React.useMemo(() => {\n        if (highlightRegionsIn === undefined) return undefined;\n        if (rowMarkerOffset === 0) return highlightRegionsIn;\n\n        return highlightRegionsIn\n            .map(r => {\n                const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;\n                if (maxWidth <= 0) return undefined;\n                return {\n                    color: r.color,\n                    range: {\n                        ...r.range,\n                        x: r.range.x + rowMarkerOffset,\n                        width: Math.min(maxWidth, r.range.width),\n                    },\n                    style: r.style,\n                };\n            })\n            .filter(x => x !== undefined) as typeof highlightRegionsIn;\n    }, [highlightRegionsIn, mangledCols.length, rowMarkerOffset]);\n\n    const mangledColsRef = React.useRef(mangledCols);\n    mangledColsRef.current = mangledCols;\n    const getMangledCellContent = React.useCallback(\n        ([col, row]: Item): InnerGridCell => {\n            const isTrailing = showTrailingBlankRow && row === mangledRows - 1;\n            const isRowMarkerCol = col === 0 && hasRowMarkers;\n            if (isRowMarkerCol) {\n                if (isTrailing) {\n                    return loadingCell;\n                }\n                return {\n                    kind: InnerGridCellKind.Marker,\n                    allowOverlay: false,\n                    checked: gridSelection?.rows.hasIndex(row) === true,\n                    markerKind: rowMarkers === \"clickable-number\" ? \"number\" : rowMarkers,\n                    row: rowMarkerStartIndex + row,\n                    drawHandle: onRowMoved !== undefined,\n                };\n            } else if (isTrailing) {\n                //If the grid is empty, we will return text\n                const isFirst = col === rowMarkerOffset;\n\n                const maybeFirstColumnHint = isFirst ? trailingRowOptions?.hint ?? \"\" : \"\";\n                const c = mangledColsRef.current[col];\n\n                if (c?.trailingRowOptions?.disabled === true) {\n                    return loadingCell;\n                } else {\n                    const hint = c?.trailingRowOptions?.hint ?? maybeFirstColumnHint;\n                    const icon = c?.trailingRowOptions?.addIcon ?? trailingRowOptions?.addIcon;\n                    return {\n                        kind: InnerGridCellKind.NewRow,\n                        hint,\n                        allowOverlay: false,\n                        icon,\n                    };\n                }\n            } else {\n                const outerCol = col - rowMarkerOffset;\n                if (experimental?.strict === true) {\n                    const vr = visibleRegionRef.current;\n                    const isOutsideMainArea =\n                        vr.x > outerCol || outerCol > vr.x + vr.width || vr.y > row || row > vr.y + vr.height;\n                    const isSelected = outerCol === vr.extras?.selected?.[0] && row === vr.extras?.selected[1];\n                    const isOutsideFreezeArea =\n                        vr.extras?.freezeRegion === undefined ||\n                        vr.extras.freezeRegion.x > outerCol ||\n                        outerCol > vr.extras.freezeRegion.x + vr.extras.freezeRegion.width ||\n                        vr.extras.freezeRegion.y > row ||\n                        row > vr.extras.freezeRegion.y + vr.extras.freezeRegion.height;\n                    if (isOutsideMainArea && !isSelected && isOutsideFreezeArea) {\n                        return {\n                            kind: GridCellKind.Loading,\n                            allowOverlay: false,\n                        };\n                    }\n                }\n                let result = getCellContent([outerCol, row]);\n                if (rowMarkerOffset !== 0 && result.span !== undefined) {\n                    result = {\n                        ...result,\n                        span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset],\n                    };\n                }\n                return result;\n            }\n        },\n        [\n            showTrailingBlankRow,\n            mangledRows,\n            hasRowMarkers,\n            gridSelection?.rows,\n            onRowMoved,\n            rowMarkers,\n            rowMarkerOffset,\n            trailingRowOptions?.hint,\n            trailingRowOptions?.addIcon,\n            experimental?.strict,\n            getCellContent,\n            rowMarkerStartIndex,\n        ]\n    );\n\n    const mangledGetGroupDetails = React.useCallback<NonNullable<DataEditorProps[\"getGroupDetails\"]>>(\n        group => {\n            let result = getGroupDetails?.(group) ?? { name: group };\n            if (onGroupHeaderRenamed !== undefined && group !== \"\") {\n                result = {\n                    icon: result.icon,\n                    name: result.name,\n                    overrideTheme: result.overrideTheme,\n                    actions: [\n                        ...(result.actions ?? []),\n                        {\n                            title: \"Rename\",\n                            icon: \"renameIcon\",\n                            onClick: e =>\n                                setRenameGroup({\n                                    group: result.name,\n                                    bounds: e.bounds,\n                                }),\n                        },\n                    ],\n                };\n            }\n            return result;\n        },\n        [getGroupDetails, onGroupHeaderRenamed]\n    );\n\n    const setOverlaySimple = React.useCallback(\n        (val: Omit<NonNullable<typeof overlay>, \"theme\">) => {\n            const [col, row] = val.cell;\n            const column = mangledCols[col];\n            const groupTheme =\n                column?.group !== undefined ? mangledGetGroupDetails(column.group)?.overrideTheme : undefined;\n            const colTheme = column?.themeOverride;\n            const rowTheme = getRowThemeOverride?.(row);\n\n            setOverlay({\n                ...val,\n                theme: { ...mergedTheme, ...groupTheme, ...colTheme, ...rowTheme, ...val.content.themeOverride },\n            });\n        },\n        [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]\n    );\n\n    const reselect = React.useCallback(\n        (bounds: Rectangle, fromKeyboard: boolean, initialValue?: string) => {\n            if (gridSelection.current === undefined) return;\n\n            const [col, row] = gridSelection.current.cell;\n            const c = getMangledCellContent([col, row]);\n            if (c.kind !== GridCellKind.Boolean && c.allowOverlay) {\n                let content = c;\n                if (initialValue !== undefined) {\n                    switch (content.kind) {\n                        case GridCellKind.Number: {\n                            const d = maybe(() => (initialValue === \"-\" ? -0 : Number.parseFloat(initialValue)), 0);\n                            content = {\n                                ...content,\n                                data: Number.isNaN(d) ? 0 : d,\n                            };\n                            break;\n                        }\n                        case GridCellKind.Text:\n                        case GridCellKind.Markdown:\n                        case GridCellKind.Uri:\n                            content = {\n                                ...content,\n                                data: initialValue,\n                            };\n                            break;\n                    }\n                }\n\n                setOverlaySimple({\n                    target: bounds,\n                    content,\n                    initialValue,\n                    cell: [col, row],\n                    highlight: initialValue === undefined,\n                    forceEditMode: initialValue !== undefined,\n                });\n            } else if (c.kind === GridCellKind.Boolean && fromKeyboard && c.readonly !== true) {\n                mangledOnCellsEdited([\n                    {\n                        location: gridSelection.current.cell,\n                        value: {\n                            ...c,\n                            data: toggleBoolean(c.data),\n                        },\n                    },\n                ]);\n                gridRef.current?.damage([{ cell: gridSelection.current.cell }]);\n            }\n        },\n        [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]\n    );\n\n    const focusOnRowFromTrailingBlankRow = React.useCallback(\n        (col: number, row: number) => {\n            const bounds = gridRef.current?.getBounds(col, row);\n            if (bounds === undefined || scrollRef.current === null) {\n                return;\n            }\n\n            const content = getMangledCellContent([col, row]);\n            if (!content.allowOverlay) {\n                return;\n            }\n\n            setOverlaySimple({\n                target: bounds,\n                content,\n                initialValue: undefined,\n                highlight: true,\n                cell: [col, row],\n                forceEditMode: true,\n            });\n        },\n        [getMangledCellContent, setOverlaySimple]\n    );\n\n    const scrollTo = React.useCallback<ScrollToFn>(\n        (col, row, dir = \"both\", paddingX = 0, paddingY = 0, options = undefined): void => {\n            if (scrollRef.current !== null) {\n                const grid = gridRef.current;\n                const canvas = canvasRef.current;\n\n                const trueCol = typeof col !== \"number\" ? (col.unit === \"cell\" ? col.amount : undefined) : col;\n                const trueRow = typeof row !== \"number\" ? (row.unit === \"cell\" ? row.amount : undefined) : row;\n                const desiredX = typeof col !== \"number\" && col.unit === \"px\" ? col.amount : undefined;\n                const desiredY = typeof row !== \"number\" && row.unit === \"px\" ? row.amount : undefined;\n                if (grid !== null && canvas !== null) {\n                    let targetRect: Rectangle = {\n                        x: 0,\n                        y: 0,\n                        width: 0,\n                        height: 0,\n                    };\n\n                    let scrollX = 0;\n                    let scrollY = 0;\n\n                    if (trueCol !== undefined || trueRow !== undefined) {\n                        targetRect = grid.getBounds((trueCol ?? 0) + rowMarkerOffset, trueRow ?? 0) ?? targetRect;\n                        if (targetRect.width === 0 || targetRect.height === 0) return;\n                    }\n\n                    const scrollBounds = canvas.getBoundingClientRect();\n\n                    if (desiredX !== undefined) {\n                        targetRect = {\n                            ...targetRect,\n                            x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,\n                            width: 1,\n                        };\n                    }\n                    if (desiredY !== undefined) {\n                        targetRect = {\n                            ...targetRect,\n                            y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,\n                            height: 1,\n                        };\n                    }\n\n                    if (targetRect !== undefined) {\n                        const bounds = {\n                            x: targetRect.x - paddingX,\n                            y: targetRect.y - paddingY,\n                            width: targetRect.width + 2 * paddingX,\n                            height: targetRect.height + 2 * paddingY,\n                        };\n\n                        let frozenWidth = 0;\n                        for (let i = 0; i < freezeColumns; i++) {\n                            frozenWidth += columns[i].width;\n                        }\n                        let trailingRowHeight = 0;\n                        if (lastRowSticky) {\n                            trailingRowHeight = typeof rowHeight === \"number\" ? rowHeight : rowHeight(rows);\n                        }\n\n                        let sLeft = frozenWidth + scrollBounds.left + rowMarkerOffset * rowMarkerWidth;\n                        let sRight = scrollBounds.right;\n                        let sTop = scrollBounds.top + totalHeaderHeight;\n                        let sBottom = scrollBounds.bottom - trailingRowHeight;\n\n                        const minx = targetRect.width + paddingX * 2;\n                        switch (options?.hAlign) {\n                            case \"start\":\n                                sRight = sLeft + minx;\n                                break;\n                            case \"end\":\n                                sLeft = sRight - minx;\n                                break;\n                            case \"center\":\n                                sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;\n                                sRight = sLeft + minx;\n                                break;\n                        }\n\n                        const miny = targetRect.height + paddingY * 2;\n                        switch (options?.vAlign) {\n                            case \"start\":\n                                sBottom = sTop + miny;\n                                break;\n                            case \"end\":\n                                sTop = sBottom - miny;\n                                break;\n                            case \"center\":\n                                sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;\n                                sBottom = sTop + miny;\n                                break;\n                        }\n\n                        if (sLeft > bounds.x) {\n                            scrollX = bounds.x - sLeft;\n                        } else if (sRight < bounds.x + bounds.width) {\n                            scrollX = bounds.x + bounds.width - sRight;\n                        }\n\n                        if (sTop > bounds.y) {\n                            scrollY = bounds.y - sTop;\n                        } else if (sBottom < bounds.y + bounds.height) {\n                            scrollY = bounds.y + bounds.height - sBottom;\n                        }\n\n                        if (dir === \"vertical\" || col < freezeColumns) {\n                            scrollX = 0;\n                        } else if (dir === \"horizontal\") {\n                            scrollY = 0;\n                        }\n\n                        if (scrollX !== 0 || scrollY !== 0) {\n                            scrollRef.current.scrollTo(\n                                scrollX + scrollRef.current.scrollLeft,\n                                scrollY + scrollRef.current.scrollTop\n                            );\n                        }\n                    }\n                }\n            }\n        },\n        [rowMarkerOffset, rowMarkerWidth, totalHeaderHeight, lastRowSticky, freezeColumns, columns, rowHeight, rows]\n    );\n\n    const focusCallback = React.useRef(focusOnRowFromTrailingBlankRow);\n    const getCellContentRef = React.useRef(getCellContent);\n    const rowsRef = React.useRef(rows);\n    focusCallback.current = focusOnRowFromTrailingBlankRow;\n    getCellContentRef.current = getCellContent;\n    rowsRef.current = rows;\n    const appendRow = React.useCallback(\n        async (col: number): Promise<void> => {\n            const c = mangledCols[col];\n            if (c?.trailingRowOptions?.disabled === true) {\n                return;\n            }\n            const appendResult = onRowAppended?.();\n\n            let r: \"top\" | \"bottom\" | number | undefined = undefined;\n            let bottom = true;\n            if (appendResult !== undefined) {\n                r = await appendResult;\n                if (r === \"top\") bottom = false;\n                if (typeof r === \"number\") bottom = false;\n            }\n\n            let backoff = 0;\n            const doFocus = () => {\n                if (rowsRef.current <= rows) {\n                    if (backoff < 500) {\n                        window.setTimeout(doFocus, backoff);\n                    }\n                    backoff = 50 + backoff * 2;\n                    return;\n                }\n\n                const row = typeof r === \"number\" ? r : bottom ? rows : 0;\n                scrollTo(col - rowMarkerOffset, row);\n                setCurrent(\n                    {\n                        cell: [col, row],\n                        range: {\n                            x: col,\n                            y: row,\n                            width: 1,\n                            height: 1,\n                        },\n                    },\n                    false,\n                    false,\n                    \"edit\"\n                );\n\n                const cell = getCellContentRef.current([col - rowMarkerOffset, row]);\n                if (cell.allowOverlay && isReadWriteCell(cell) && cell.readonly !== true) {\n                    // wait for scroll to have a chance to process\n                    window.setTimeout(() => {\n                        focusCallback.current(col, row);\n                    }, 0);\n                }\n            };\n            // Queue up to allow the consumer to react to the event and let us check if they did\n            doFocus();\n        },\n        [mangledCols, onRowAppended, rowMarkerOffset, rows, scrollTo, setCurrent]\n    );\n\n    const getCustomNewRowTargetColumn = React.useCallback(\n        (col: number): number | undefined => {\n            const customTargetColumn =\n                columns[col]?.trailingRowOptions?.targetColumn ?? trailingRowOptions?.targetColumn;\n\n            if (typeof customTargetColumn === \"number\") {\n                const customTargetOffset = hasRowMarkers ? 1 : 0;\n                return customTargetColumn + customTargetOffset;\n            }\n\n            if (typeof customTargetColumn === \"object\") {\n                const maybeIndex = columnsIn.indexOf(customTargetColumn);\n                if (maybeIndex >= 0) {\n                    const customTargetOffset = hasRowMarkers ? 1 : 0;\n                    return maybeIndex + customTargetOffset;\n                }\n            }\n\n            return undefined;\n        },\n        [columns, columnsIn, hasRowMarkers, trailingRowOptions?.targetColumn]\n    );\n\n    const lastSelectedRowRef = React.useRef<number>();\n    const lastSelectedColRef = React.useRef<number>();\n\n    const themeForCell = React.useCallback(\n        (cell: InnerGridCell, pos: Item): Theme => {\n            const [col, row] = pos;\n            return {\n                ...mergedTheme,\n                ...mangledCols[col]?.themeOverride,\n                ...getRowThemeOverride?.(row),\n                ...cell.themeOverride,\n            };\n        },\n        [getRowThemeOverride, mangledCols, mergedTheme]\n    );\n\n    const handleSelect = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;\n            const isMultiRow = isMultiKey && rowSelect === \"multi\";\n            const isMultiCol = isMultiKey && columnSelect === \"multi\";\n            const [col, row] = args.location;\n            const selectedColumns = gridSelection.columns;\n            const selectedRows = gridSelection.rows;\n            const [cellCol, cellRow] = gridSelection.current?.cell ?? [];\n            // eslint-disable-next-line unicorn/prefer-switch\n            if (args.kind === \"cell\") {\n                lastSelectedColRef.current = undefined;\n\n                lastMouseSelectLocation.current = [col, row];\n\n                if (col === 0 && hasRowMarkers) {\n                    if (\n                        (showTrailingBlankRow === true && row === rows) ||\n                        rowMarkers === \"number\" ||\n                        rowSelect === \"none\"\n                    )\n                        return;\n\n                    const markerCell = getMangledCellContent(args.location);\n                    if (markerCell.kind !== InnerGridCellKind.Marker) {\n                        return;\n                    }\n\n                    if (onRowMoved !== undefined) {\n                        const renderer = getCellRenderer(markerCell);\n                        assert(renderer?.kind === InnerGridCellKind.Marker);\n                        const postClick = renderer?.onClick?.({\n                            ...args,\n                            cell: markerCell,\n                            posX: args.localEventX,\n                            posY: args.localEventY,\n                            bounds: args.bounds,\n                            theme: themeForCell(markerCell, args.location),\n                            preventDefault: () => undefined,\n                        }) as MarkerCell | undefined;\n                        if (postClick === undefined || postClick.checked === markerCell.checked) return;\n                    }\n\n                    setOverlay(undefined);\n                    focus();\n                    const isSelected = selectedRows.hasIndex(row);\n\n                    const lastHighlighted = lastSelectedRowRef.current;\n                    if (\n                        rowSelect === \"multi\" &&\n                        (args.shiftKey || args.isLongTouch === true) &&\n                        lastHighlighted !== undefined &&\n                        selectedRows.hasIndex(lastHighlighted)\n                    ) {\n                        const newSlice: Slice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];\n\n                        if (isMultiRow || rowSelectionMode === \"multi\") {\n                            setSelectedRows(undefined, newSlice, true);\n                        } else {\n                            setSelectedRows(CompactSelection.fromSingleSelection(newSlice), undefined, isMultiRow);\n                        }\n                    } else if (isMultiRow || args.isTouch || rowSelectionMode === \"multi\") {\n                        if (isSelected) {\n                            setSelectedRows(selectedRows.remove(row), undefined, true);\n                        } else {\n                            setSelectedRows(undefined, row, true);\n                            lastSelectedRowRef.current = row;\n                        }\n                    } else if (isSelected && selectedRows.length === 1) {\n                        setSelectedRows(CompactSelection.empty(), undefined, isMultiKey);\n                    } else {\n                        setSelectedRows(CompactSelection.fromSingleSelection(row), undefined, isMultiKey);\n                        lastSelectedRowRef.current = row;\n                    }\n                } else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {\n                    const customTargetColumn = getCustomNewRowTargetColumn(col);\n                    void appendRow(customTargetColumn ?? col);\n                } else {\n                    if (cellCol !== col || cellRow !== row) {\n                        const cell = getMangledCellContent(args.location);\n                        const renderer = getCellRenderer(cell);\n\n                        if (renderer?.onSelect !== undefined) {\n                            let prevented = false;\n                            renderer.onSelect({\n                                ...args,\n                                cell,\n                                posX: args.localEventX,\n                                posY: args.localEventY,\n                                bounds: args.bounds,\n                                preventDefault: () => (prevented = true),\n                                theme: themeForCell(cell, args.location),\n                            });\n                            if (prevented) {\n                                return;\n                            }\n                        }\n                        const isLastStickyRow = lastRowSticky && row === rows;\n\n                        const startedFromLastSticky =\n                            lastRowSticky && gridSelection !== undefined && gridSelection.current?.cell[1] === rows;\n\n                        if (\n                            (args.shiftKey || args.isLongTouch === true) &&\n                            cellCol !== undefined &&\n                            cellRow !== undefined &&\n                            gridSelection.current !== undefined &&\n                            !startedFromLastSticky\n                        ) {\n                            if (isLastStickyRow) {\n                                // If we're making a selection and shift click in to the last sticky row,\n                                // just drop the event. Don't kill the selection.\n                                return;\n                            }\n\n                            const left = Math.min(col, cellCol);\n                            const right = Math.max(col, cellCol);\n                            const top = Math.min(row, cellRow);\n                            const bottom = Math.max(row, cellRow);\n                            setCurrent(\n                                {\n                                    ...gridSelection.current,\n                                    range: {\n                                        x: left,\n                                        y: top,\n                                        width: right - left + 1,\n                                        height: bottom - top + 1,\n                                    },\n                                },\n                                true,\n                                isMultiKey,\n                                \"click\"\n                            );\n                            lastSelectedRowRef.current = undefined;\n                            focus();\n                        } else {\n                            setCurrent(\n                                {\n                                    cell: [col, row],\n                                    range: { x: col, y: row, width: 1, height: 1 },\n                                },\n                                true,\n                                isMultiKey,\n                                \"click\"\n                            );\n                            lastSelectedRowRef.current = undefined;\n                            setOverlay(undefined);\n                            focus();\n                        }\n                    }\n                }\n            } else if (args.kind === \"header\") {\n                lastMouseSelectLocation.current = [col, row];\n                setOverlay(undefined);\n                if (hasRowMarkers && col === 0) {\n                    lastSelectedRowRef.current = undefined;\n                    lastSelectedColRef.current = undefined;\n                    if (rowSelect === \"multi\") {\n                        if (selectedRows.length !== rows) {\n                            setSelectedRows(CompactSelection.fromSingleSelection([0, rows]), undefined, isMultiKey);\n                        } else {\n                            setSelectedRows(CompactSelection.empty(), undefined, isMultiKey);\n                        }\n                        focus();\n                    }\n                } else {\n                    const lastCol = lastSelectedColRef.current;\n                    if (\n                        columnSelect === \"multi\" &&\n                        (args.shiftKey || args.isLongTouch === true) &&\n                        lastCol !== undefined &&\n                        selectedColumns.hasIndex(lastCol)\n                    ) {\n                        const newSlice: Slice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];\n\n                        if (isMultiCol) {\n                            setSelectedColumns(undefined, newSlice, isMultiKey);\n                        } else {\n                            setSelectedColumns(CompactSelection.fromSingleSelection(newSlice), undefined, isMultiKey);\n                        }\n                    } else if (isMultiCol) {\n                        if (selectedColumns.hasIndex(col)) {\n                            setSelectedColumns(selectedColumns.remove(col), undefined, isMultiKey);\n                        } else {\n                            setSelectedColumns(undefined, col, isMultiKey);\n                        }\n                        lastSelectedColRef.current = col;\n                    } else if (columnSelect !== \"none\") {\n                        setSelectedColumns(CompactSelection.fromSingleSelection(col), undefined, isMultiKey);\n                        lastSelectedColRef.current = col;\n                    }\n                    lastSelectedRowRef.current = undefined;\n                    focus();\n                }\n            } else if (args.kind === groupHeaderKind) {\n                lastMouseSelectLocation.current = [col, row];\n            } else if (args.kind === outOfBoundsKind) {\n                setGridSelection(emptyGridSelection, false);\n                setOverlay(undefined);\n                focus();\n                onSelectionCleared?.();\n                lastSelectedRowRef.current = undefined;\n                lastSelectedColRef.current = undefined;\n            }\n        },\n        [\n            appendRow,\n            columnSelect,\n            focus,\n            getCellRenderer,\n            getCustomNewRowTargetColumn,\n            getMangledCellContent,\n            gridSelection,\n            hasRowMarkers,\n            lastRowSticky,\n            onSelectionCleared,\n            onRowMoved,\n            rowMarkerOffset,\n            rowMarkers,\n            rowSelect,\n            rowSelectionMode,\n            rows,\n            setCurrent,\n            setGridSelection,\n            setSelectedColumns,\n            setSelectedRows,\n            showTrailingBlankRow,\n            themeForCell,\n        ]\n    );\n\n    const lastMouseSelectLocation = React.useRef<[number, number]>();\n    const touchDownArgs = React.useRef(visibleRegion);\n    const mouseDownData =\n        React.useRef<{\n            wasDoubleClick: boolean;\n            time: number;\n            location: Item;\n        }>();\n    const onMouseDown = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            isPrevented.current = false;\n            touchDownArgs.current = visibleRegionRef.current;\n            if (args.button !== 0) {\n                mouseDownData.current = undefined;\n                return;\n            }\n\n            const time = performance.now();\n            const wasDoubleClick = time - (mouseDownData.current?.time ?? -1000) < 250;\n            mouseDownData.current = {\n                wasDoubleClick,\n                time,\n                location: args.location,\n            };\n\n            const fh = args.kind === \"cell\" && args.isFillHandle;\n\n            if (!fh && args.kind !== \"cell\" && args.isEdge) return;\n\n            setMouseState({\n                previousSelection: gridSelection,\n                fillHandle: fh,\n            });\n            lastMouseSelectLocation.current = undefined;\n\n            if (!args.isTouch) {\n                handleSelect(args);\n            }\n        },\n        [gridSelection, handleSelect]\n    );\n\n    const [renameGroup, setRenameGroup] =\n        React.useState<{\n            group: string;\n            bounds: Rectangle;\n        }>();\n\n    const handleGroupHeaderSelection = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            if (args.kind !== groupHeaderKind || columnSelect !== \"multi\") {\n                return;\n            }\n            const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;\n            const [col] = args.location;\n            const selectedColumns = gridSelection.columns;\n\n            if (col < rowMarkerOffset) return;\n\n            const needle = mangledCols[col];\n            let start = col;\n            let end = col;\n            for (let i = col - 1; i >= rowMarkerOffset; i--) {\n                if (!isGroupEqual(needle.group, mangledCols[i].group)) break;\n                start--;\n            }\n\n            for (let i = col + 1; i < mangledCols.length; i++) {\n                if (!isGroupEqual(needle.group, mangledCols[i].group)) break;\n                end++;\n            }\n\n            focus();\n\n            if (isMultiKey) {\n                if (selectedColumns.hasAll([start, end + 1])) {\n                    let newVal = selectedColumns;\n                    for (let index = start; index <= end; index++) {\n                        newVal = newVal.remove(index);\n                    }\n                    setSelectedColumns(newVal, undefined, isMultiKey);\n                } else {\n                    setSelectedColumns(undefined, [start, end + 1], isMultiKey);\n                }\n            } else {\n                setSelectedColumns(CompactSelection.fromSingleSelection([start, end + 1]), undefined, isMultiKey);\n            }\n        },\n        [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]\n    );\n\n    const fillDown = React.useCallback(\n        (reverse: boolean) => {\n            if (gridSelection.current === undefined) return;\n            const v: EditListItem[] = [];\n            const r = gridSelection.current.range;\n            for (let x = 0; x < r.width; x++) {\n                const fillCol = x + r.x;\n                const fillVal = getMangledCellContent([fillCol, reverse ? r.y + r.height - 1 : r.y]);\n                if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;\n                for (let y = 1; y < r.height; y++) {\n                    const fillRow = reverse ? r.y + r.height - (y + 1) : y + r.y;\n                    const target = [fillCol, fillRow] as const;\n                    v.push({\n                        location: target,\n                        value: { ...fillVal },\n                    });\n                }\n            }\n\n            mangledOnCellsEdited(v);\n\n            gridRef.current?.damage(\n                v.map(c => ({\n                    cell: c.location,\n                }))\n            );\n        },\n        [getMangledCellContent, gridSelection, mangledOnCellsEdited]\n    );\n\n    const isPrevented = React.useRef(false);\n    const onContextMenu = React.useCallback(\n        (args: GridMouseEventArgs, preventDefault: () => void) => {\n            const clickLocation = args.location[0] - rowMarkerOffset;\n            if (args.kind === \"header\") {\n                onHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n            }\n\n            if (args.kind === groupHeaderKind) {\n                if (clickLocation < 0) {\n                    return;\n                }\n                onGroupHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n            }\n\n            if (args.kind === \"cell\") {\n                onCellContextMenu?.([clickLocation, args.location[1]], {\n                    ...args,\n                    preventDefault,\n                });\n            }\n        },\n        [onCellContextMenu, onGroupHeaderContextMenu, onHeaderContextMenu, rowMarkerOffset]\n    );\n\n    const normalSizeColumn = React.useCallback(\n        async (col: number): Promise<void> => {\n            if (\n                mouseDownData.current?.wasDoubleClick === true &&\n                getCellsForSelection !== undefined &&\n                onColumnResize !== undefined\n            ) {\n                const start = visibleRegionRef.current.y;\n                const end = visibleRegionRef.current.height;\n                let cells = getCellsForSelection(\n                    {\n                        x: col,\n                        y: start,\n                        width: 1,\n                        height: Math.min(end, rows - start),\n                    },\n                    abortControllerRef.current.signal\n                );\n                if (typeof cells !== \"object\") {\n                    cells = await cells();\n                }\n                const inputCol = columns[col - rowMarkerOffset];\n                const offscreen = document.createElement(\"canvas\");\n                const ctx = offscreen.getContext(\"2d\", { alpha: false });\n                if (ctx !== null) {\n                    ctx.font = `${mergedTheme.baseFontStyle} ${mergedTheme.fontFamily}`;\n                    const newCol = measureColumn(\n                        ctx,\n                        mergedTheme,\n                        inputCol,\n                        0,\n                        cells,\n                        minColumnWidth,\n                        maxColumnWidth,\n                        false,\n                        getCellRenderer\n                    );\n                    onColumnResize?.(inputCol, newCol.width, col, newCol.width);\n                }\n            }\n        },\n        [\n            columns,\n            getCellsForSelection,\n            maxColumnWidth,\n            mergedTheme,\n            minColumnWidth,\n            onColumnResize,\n            rowMarkerOffset,\n            rows,\n            getCellRenderer,\n        ]\n    );\n\n    const [scrollDir, setScrollDir] = React.useState<GridMouseEventArgs[\"scrollEdge\"]>();\n\n    const onMouseUp = React.useCallback(\n        (args: GridMouseEventArgs, isOutside: boolean) => {\n            const mouse = mouseState;\n            setMouseState(undefined);\n            setScrollDir(undefined);\n\n            if (isOutside) return;\n\n            const [col, row] = args.location;\n            const [lastMouseDownCol, lastMouseDownRow] = lastMouseSelectLocation.current ?? [];\n\n            const preventDefault = () => {\n                isPrevented.current = true;\n            };\n\n            const handleMaybeClick = (a: GridMouseCellEventArgs): boolean => {\n                if (lastMouseDownCol === col && lastMouseDownRow === row) {\n                    onCellClicked?.([col - rowMarkerOffset, row], {\n                        ...a,\n                        preventDefault,\n                    });\n                }\n                if (mouse?.fillHandle === true && gridSelection.current !== undefined) {\n                    fillDown(gridSelection.current.cell[1] !== gridSelection.current.range.y);\n                } else if (!isPrevented.current) {\n                    const c = getMangledCellContent(args.location);\n                    const r = getCellRenderer(c);\n                    if (r !== undefined && r.onClick !== undefined) {\n                        const newVal = r.onClick({\n                            ...a,\n                            cell: c,\n                            posX: a.localEventX,\n                            posY: a.localEventY,\n                            bounds: a.bounds,\n                            theme: themeForCell(c, args.location),\n                            preventDefault,\n                        });\n                        if (newVal !== undefined && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {\n                            mangledOnCellsEdited([{ location: a.location, value: newVal }]);\n                            gridRef.current?.damage([\n                                {\n                                    cell: a.location,\n                                },\n                            ]);\n                        }\n                    }\n                    if (\n                        !isPrevented.current &&\n                        mouse?.previousSelection?.current?.cell !== undefined &&\n                        gridSelection.current !== undefined\n                    ) {\n                        const [selectedCol, selectedRow] = gridSelection.current.cell;\n                        const [prevCol, prevRow] = mouse.previousSelection.current.cell;\n                        if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {\n                            onCellActivated?.([col - rowMarkerOffset, row]);\n                            reselect(a.bounds, false);\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            };\n\n            const clickLocation = args.location[0] - rowMarkerOffset;\n            if (args.isTouch) {\n                const vr = visibleRegionRef.current;\n                const touchVr = touchDownArgs.current;\n                if (vr.x !== touchVr.x || vr.y !== touchVr.y) {\n                    // we scrolled, abort\n                    return;\n                }\n                // take care of context menus first if long pressed item is already selected\n                if (args.isLongTouch === true) {\n                    if (\n                        args.kind === \"cell\" &&\n                        gridSelection?.current?.cell[0] === col &&\n                        gridSelection?.current?.cell[1] === row\n                    ) {\n                        onCellContextMenu?.([clickLocation, args.location[1]], {\n                            ...args,\n                            preventDefault,\n                        });\n                        return;\n                    } else if (args.kind === \"header\" && gridSelection.columns.hasIndex(col)) {\n                        onHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n                        return;\n                    } else if (args.kind === groupHeaderKind) {\n                        if (clickLocation < 0) {\n                            return;\n                        }\n\n                        onGroupHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n                        return;\n                    }\n                }\n                if (args.kind === \"cell\") {\n                    // click that cell\n                    if (!handleMaybeClick(args)) {\n                        handleSelect(args);\n                    }\n                } else if (args.kind === groupHeaderKind) {\n                    onGroupHeaderClicked?.(clickLocation, { ...args, preventDefault });\n                } else {\n                    handleSelect(args);\n                }\n                return;\n            }\n\n            if (args.kind === \"header\") {\n                if (clickLocation < 0) {\n                    return;\n                }\n\n                if (args.isEdge) {\n                    void normalSizeColumn(col);\n                } else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {\n                    onHeaderClicked?.(clickLocation, { ...args, preventDefault });\n                }\n            }\n\n            if (args.kind === groupHeaderKind) {\n                if (clickLocation < 0) {\n                    return;\n                }\n\n                if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {\n                    onGroupHeaderClicked?.(clickLocation, { ...args, preventDefault });\n                    if (!isPrevented.current) {\n                        handleGroupHeaderSelection(args);\n                    }\n                }\n            }\n\n            if (args.kind === \"cell\" && args.button === 0) {\n                handleMaybeClick(args);\n            }\n\n            lastMouseSelectLocation.current = undefined;\n        },\n        [\n            mouseState,\n            rowMarkerOffset,\n            gridSelection,\n            onCellClicked,\n            fillDown,\n            getMangledCellContent,\n            getCellRenderer,\n            themeForCell,\n            mangledOnCellsEdited,\n            onCellActivated,\n            reselect,\n            onCellContextMenu,\n            onHeaderContextMenu,\n            onGroupHeaderContextMenu,\n            handleSelect,\n            onGroupHeaderClicked,\n            normalSizeColumn,\n            onHeaderClicked,\n            handleGroupHeaderSelection,\n        ]\n    );\n\n    const onMouseMoveImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            const a: GridMouseEventArgs = {\n                ...args,\n                location: [args.location[0] - rowMarkerOffset, args.location[1]] as any,\n            };\n            onMouseMove?.(a);\n            setScrollDir(cv => {\n                if (args.scrollEdge[0] === cv?.[0] && args.scrollEdge[1] === cv[1]) return cv;\n                return mouseState === undefined || (mouseDownData.current?.location[0] ?? 0) < rowMarkerOffset\n                    ? undefined\n                    : args.scrollEdge;\n            });\n        },\n        [mouseState, onMouseMove, rowMarkerOffset]\n    );\n\n    useAutoscroll(scrollDir, scrollRef);\n\n    const onHeaderMenuClickInner = React.useCallback(\n        (col: number, screenPosition: Rectangle) => {\n            onHeaderMenuClick?.(col - rowMarkerOffset, screenPosition);\n        },\n        [onHeaderMenuClick, rowMarkerOffset]\n    );\n\n    const currentCell = gridSelection?.current?.cell;\n    const onVisibleRegionChangedImpl = React.useCallback(\n        (\n            region: Rectangle,\n            clientWidth: number,\n            clientHeight: number,\n            rightElWidth: number,\n            tx?: number,\n            ty?: number\n        ) => {\n            let selected = currentCell;\n            if (selected !== undefined) {\n                selected = [selected[0] - rowMarkerOffset, selected[1]];\n            }\n            const newRegion = {\n                x: region.x - rowMarkerOffset,\n                y: region.y,\n                width: region.width,\n                height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,\n                tx,\n                ty,\n                extras: {\n                    selected,\n                    freezeRegion:\n                        freezeColumns === 0\n                            ? undefined\n                            : {\n                                  x: 0,\n                                  y: region.y,\n                                  width: freezeColumns,\n                                  height: region.height,\n                              },\n                },\n            };\n            setClientSize([clientWidth, clientHeight, rightElWidth]);\n            setVisibleRegion(newRegion);\n            onVisibleRegionChanged?.(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);\n        },\n        [\n            currentCell,\n            rowMarkerOffset,\n            showTrailingBlankRow,\n            rows,\n            freezeColumns,\n            setVisibleRegion,\n            onVisibleRegionChanged,\n        ]\n    );\n\n    const onColumnMovedImpl = whenDefined(\n        onColumnMoved,\n        React.useCallback(\n            (startIndex: number, endIndex: number) => {\n                onColumnMoved?.(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);\n                if (columnSelect !== \"none\") {\n                    setSelectedColumns(CompactSelection.fromSingleSelection(endIndex), undefined, true);\n                }\n            },\n            [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]\n        )\n    );\n\n    const isActivelyDragging = React.useRef(false);\n    const onDragStartImpl = React.useCallback(\n        (args: GridDragEventArgs) => {\n            if (args.location[0] === 0 && rowMarkerOffset > 0) {\n                args.preventDefault();\n                return;\n            }\n            onDragStart?.({\n                ...args,\n                location: [args.location[0] - rowMarkerOffset, args.location[1]] as any,\n            });\n\n            if (!args.defaultPrevented()) {\n                isActivelyDragging.current = true;\n            }\n            setMouseState(undefined);\n        },\n        [onDragStart, rowMarkerOffset]\n    );\n\n    const onDragEnd = React.useCallback(() => {\n        isActivelyDragging.current = false;\n    }, []);\n\n    const onItemHoveredImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            if (\n                mouseState !== undefined &&\n                gridSelection.current !== undefined &&\n                !isActivelyDragging.current &&\n                (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")\n            ) {\n                const [selectedCol, selectedRow] = gridSelection.current.cell;\n                // eslint-disable-next-line prefer-const\n                let [col, row] = args.location;\n\n                if (row < 0) {\n                    row = visibleRegionRef.current.y;\n                }\n\n                const landedOnLastStickyRow = lastRowSticky && row === rows;\n                const startedFromLastStickyRow = lastRowSticky && selectedRow === rows;\n                if (landedOnLastStickyRow || startedFromLastStickyRow) return;\n\n                col = Math.max(col, rowMarkerOffset);\n\n                const deltaX = col - selectedCol;\n                const deltaY = row - selectedRow;\n\n                const newRange: Rectangle = {\n                    x: deltaX >= 0 ? selectedCol : col,\n                    y: deltaY >= 0 ? selectedRow : row,\n                    width: Math.abs(deltaX) + 1,\n                    height: Math.abs(deltaY) + 1,\n                };\n\n                setCurrent(\n                    {\n                        ...gridSelection.current,\n                        range: newRange,\n                    },\n                    true,\n                    false,\n                    \"drag\"\n                );\n            }\n\n            onItemHovered?.({ ...args, location: [args.location[0] - rowMarkerOffset, args.location[1]] as any });\n        },\n        [mouseState, gridSelection, rangeSelect, onItemHovered, rowMarkerOffset, lastRowSticky, rows, setCurrent]\n    );\n\n    // 1 === move one\n    // 2 === move to end\n    const adjustSelection = React.useCallback(\n        (direction: [0 | 1 | -1 | 2 | -2, 0 | 1 | -1 | 2 | -2]) => {\n            if (gridSelection.current === undefined) return;\n\n            const [x, y] = direction;\n            const [col, row] = gridSelection.current.cell;\n            const old = gridSelection.current.range;\n            let left = old.x;\n            let right = old.x + old.width;\n            let top = old.y;\n            let bottom = old.y + old.height;\n\n            // take care of vertical first in case new spans come in\n            if (y !== 0) {\n                switch (y) {\n                    case 2: {\n                        // go to end\n                        bottom = rows;\n                        top = row;\n                        scrollTo(0, bottom, \"vertical\");\n\n                        break;\n                    }\n                    case -2: {\n                        // go to start\n                        top = 0;\n                        bottom = row + 1;\n                        scrollTo(0, top, \"vertical\");\n\n                        break;\n                    }\n                    case 1: {\n                        // motion down\n                        if (top < row) {\n                            top++;\n                            scrollTo(0, top, \"vertical\");\n                        } else {\n                            bottom = Math.min(rows, bottom + 1);\n                            scrollTo(0, bottom, \"vertical\");\n                        }\n\n                        break;\n                    }\n                    case -1: {\n                        // motion up\n                        if (bottom > row + 1) {\n                            bottom--;\n                            scrollTo(0, bottom, \"vertical\");\n                        } else {\n                            top = Math.max(0, top - 1);\n                            scrollTo(0, top, \"vertical\");\n                        }\n\n                        break;\n                    }\n                    default: {\n                        assertNever(y);\n                    }\n                }\n            }\n\n            if (x !== 0) {\n                if (x === 2) {\n                    right = mangledCols.length;\n                    left = col;\n                    scrollTo(right - 1 - rowMarkerOffset, 0, \"horizontal\");\n                } else if (x === -2) {\n                    left = rowMarkerOffset;\n                    right = col + 1;\n                    scrollTo(left - rowMarkerOffset, 0, \"horizontal\");\n                } else {\n                    let disallowed: number[] = [];\n                    if (getCellsForSelection !== undefined) {\n                        const cells = getCellsForSelection(\n                            {\n                                x: left,\n                                y: top,\n                                width: right - left - rowMarkerOffset,\n                                height: bottom - top,\n                            },\n                            abortControllerRef.current.signal\n                        );\n\n                        if (typeof cells === \"object\") {\n                            disallowed = getSpanStops(cells);\n                        }\n                    }\n                    if (x === 1) {\n                        // motion right\n                        let done = false;\n                        if (left < col) {\n                            if (disallowed.length > 0) {\n                                const target = range(left + 1, col + 1).find(\n                                    n => !disallowed.includes(n - rowMarkerOffset)\n                                );\n                                if (target !== undefined) {\n                                    left = target;\n                                    done = true;\n                                }\n                            } else {\n                                left++;\n                                done = true;\n                            }\n                            if (done) scrollTo(left, 0, \"horizontal\");\n                        }\n                        if (!done) {\n                            right = Math.min(mangledCols.length, right + 1);\n                            scrollTo(right - 1 - rowMarkerOffset, 0, \"horizontal\");\n                        }\n                    } else if (x === -1) {\n                        // motion left\n                        let done = false;\n                        if (right > col + 1) {\n                            if (disallowed.length > 0) {\n                                const target = range(right - 1, col, -1).find(\n                                    n => !disallowed.includes(n - rowMarkerOffset)\n                                );\n                                if (target !== undefined) {\n                                    right = target;\n                                    done = true;\n                                }\n                            } else {\n                                right--;\n                                done = true;\n                            }\n                            if (done) scrollTo(right - rowMarkerOffset, 0, \"horizontal\");\n                        }\n                        if (!done) {\n                            left = Math.max(rowMarkerOffset, left - 1);\n                            scrollTo(left - rowMarkerOffset, 0, \"horizontal\");\n                        }\n                    } else {\n                        assertNever(x);\n                    }\n                }\n            }\n\n            setCurrent(\n                {\n                    cell: gridSelection.current.cell,\n                    range: {\n                        x: left,\n                        y: top,\n                        width: right - left,\n                        height: bottom - top,\n                    },\n                },\n                true,\n                false,\n                \"keyboard-select\"\n            );\n        },\n        [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]\n    );\n\n    const updateSelectedCell = React.useCallback(\n        (col: number, row: number, fromEditingTrailingRow: boolean, freeMove: boolean): boolean => {\n            const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);\n            col = clamp(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);\n            row = clamp(row, 0, rowMax);\n\n            if (col === currentCell?.[0] && row === currentCell?.[1]) return false;\n            if (freeMove && gridSelection.current !== undefined) {\n                const newStack = [...gridSelection.current.rangeStack];\n                if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {\n                    newStack.push(gridSelection.current.range);\n                }\n                setGridSelection(\n                    {\n                        ...gridSelection,\n                        current: {\n                            cell: [col, row],\n                            range: { x: col, y: row, width: 1, height: 1 },\n                            rangeStack: newStack,\n                        },\n                    },\n                    true\n                );\n            } else {\n                setCurrent(\n                    {\n                        cell: [col, row],\n                        range: { x: col, y: row, width: 1, height: 1 },\n                    },\n                    true,\n                    false,\n                    \"keyboard-nav\"\n                );\n            }\n\n            if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {\n                lastSent.current = undefined;\n            }\n\n            scrollTo(col - rowMarkerOffset, row);\n\n            return true;\n        },\n        [\n            mangledRows,\n            rowMarkerOffset,\n            columns.length,\n            currentCell,\n            gridSelection,\n            scrollTo,\n            setGridSelection,\n            setCurrent,\n        ]\n    );\n\n    const onFinishEditing = React.useCallback(\n        (newValue: GridCell | undefined, movement: readonly [-1 | 0 | 1, -1 | 0 | 1]) => {\n            if (overlay?.cell !== undefined && newValue !== undefined && isEditableGridCell(newValue)) {\n                mangledOnCellsEdited([{ location: overlay.cell, value: newValue }]);\n                window.requestAnimationFrame(() => {\n                    gridRef.current?.damage([\n                        {\n                            cell: overlay.cell,\n                        },\n                    ]);\n                });\n            }\n            focus(true);\n            setOverlay(undefined);\n\n            const [movX, movY] = movement;\n            if (gridSelection.current !== undefined && (movX !== 0 || movY !== 0)) {\n                const isEditingTrailingRow =\n                    gridSelection.current.cell[1] === mangledRows - 1 && newValue !== undefined;\n                updateSelectedCell(\n                    clamp(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1),\n                    clamp(gridSelection.current.cell[1] + movY, 0, mangledRows - 1),\n                    isEditingTrailingRow,\n                    false\n                );\n            }\n            onFinishedEditing?.(newValue, movement);\n        },\n        [\n            overlay?.cell,\n            focus,\n            gridSelection,\n            onFinishedEditing,\n            mangledOnCellsEdited,\n            mangledRows,\n            updateSelectedCell,\n            mangledCols.length,\n        ]\n    );\n\n    const overlayID = React.useMemo(() => {\n        return `gdg-overlay-${idCounter++}`;\n    }, []);\n\n    const onKeyDown = React.useCallback(\n        (event: GridKeyEventArgs) => {\n            const fn = async () => {\n                let cancelled = false;\n                if (onKeyDownIn !== undefined) {\n                    onKeyDownIn({\n                        ...event,\n                        cancel: () => {\n                            cancelled = true;\n                        },\n                    });\n                }\n\n                if (cancelled) return;\n\n                const cancel = () => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                };\n\n                const overlayOpen = overlay !== undefined;\n                const { altKey, shiftKey, metaKey, ctrlKey, key, bounds } = event;\n                const isOSX = browserIsOSX.value;\n                const isPrimaryKey = isOSX ? metaKey : ctrlKey;\n                const isDeleteKey = key === \"Delete\" || (isOSX && key === \"Backspace\");\n                const vr = visibleRegionRef.current;\n                const selectedColumns = gridSelection.columns;\n                const selectedRows = gridSelection.rows;\n\n                if (key === \"Escape\") {\n                    if (overlayOpen) {\n                        setOverlay(undefined);\n                    } else if (keybindings.clear) {\n                        setGridSelection(emptyGridSelection, false);\n                        onSelectionCleared?.();\n                    }\n                    return;\n                } else if (isHotkey(\"primary+a\", event) && keybindings.selectAll) {\n                    if (!overlayOpen) {\n                        setGridSelection(\n                            {\n                                columns: CompactSelection.empty(),\n                                rows: CompactSelection.empty(),\n                                current: {\n                                    cell: gridSelection.current?.cell ?? [rowMarkerOffset, 0],\n                                    range: {\n                                        x: rowMarkerOffset,\n                                        y: 0,\n                                        width: columnsIn.length,\n                                        height: rows,\n                                    },\n                                    rangeStack: [],\n                                },\n                            },\n                            false\n                        );\n                    } else {\n                        const el = document.getElementById(overlayID);\n                        if (el !== null) {\n                            const s = window.getSelection();\n                            const r = document.createRange();\n                            r.selectNodeContents(el);\n                            s?.removeAllRanges();\n                            s?.addRange(r);\n                        }\n                    }\n                    cancel();\n                    return;\n                } else if (isHotkey(\"primary+f\", event) && keybindings.search) {\n                    cancel();\n                    searchInputRef?.current?.focus({ preventScroll: true });\n                    setShowSearchInner(true);\n                }\n\n                function deleteRange(r: Rectangle) {\n                    focus();\n                    const editList: EditListItem[] = [];\n                    for (let x = r.x; x < r.x + r.width; x++) {\n                        for (let y = r.y; y < r.y + r.height; y++) {\n                            const cellValue = getCellContent([x - rowMarkerOffset, y]);\n                            if (!cellValue.allowOverlay && cellValue.kind !== GridCellKind.Boolean) continue;\n                            let newVal: InnerGridCell | undefined = undefined;\n                            if (cellValue.kind === GridCellKind.Custom) {\n                                const editor = provideEditor?.(cellValue);\n                                if (isObjectEditorCallbackResult(editor)) {\n                                    newVal = editor?.deletedValue?.(cellValue);\n                                }\n                            } else if (\n                                (isEditableGridCell(cellValue) && cellValue.allowOverlay) ||\n                                cellValue.kind === GridCellKind.Boolean\n                            ) {\n                                const toDelete = getCellRenderer(cellValue);\n                                newVal = toDelete?.onDelete?.(cellValue);\n                            }\n                            if (newVal !== undefined && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {\n                                editList.push({ location: [x, y], value: newVal });\n                            }\n                        }\n                    }\n                    mangledOnCellsEdited(editList);\n                    gridRef.current?.damage(editList.map(x => ({ cell: x.location })));\n                }\n\n                if (isDeleteKey) {\n                    const callbackResult = onDelete?.(gridSelection) ?? true;\n                    cancel();\n                    if (callbackResult !== false) {\n                        const toDelete = callbackResult === true ? gridSelection : callbackResult;\n\n                        // delete order:\n                        // 1) primary range\n                        // 2) secondary ranges\n                        // 3) columns\n                        // 4) rows\n\n                        if (toDelete.current !== undefined) {\n                            deleteRange(toDelete.current.range);\n                            for (const r of toDelete.current.rangeStack) {\n                                deleteRange(r);\n                            }\n                        }\n\n                        for (const r of toDelete.rows) {\n                            deleteRange({\n                                x: rowMarkerOffset,\n                                y: r,\n                                width: mangledCols.length - rowMarkerOffset,\n                                height: 1,\n                            });\n                        }\n\n                        for (const col of toDelete.columns) {\n                            deleteRange({\n                                x: col,\n                                y: 0,\n                                width: 1,\n                                height: rows,\n                            });\n                        }\n                    }\n                    return;\n                }\n\n                if (gridSelection.current === undefined) return;\n                let [col, row] = gridSelection.current.cell;\n                let freeMove = false;\n\n                if (keybindings.selectColumn && isHotkey(\"ctrl+ \", event) && columnSelect !== \"none\") {\n                    if (selectedColumns.hasIndex(col)) {\n                        setSelectedColumns(selectedColumns.remove(col), undefined, true);\n                    } else {\n                        if (columnSelect === \"single\") {\n                            setSelectedColumns(CompactSelection.fromSingleSelection(col), undefined, true);\n                        } else {\n                            setSelectedColumns(undefined, col, true);\n                        }\n                    }\n                } else if (keybindings.selectRow && isHotkey(\"shift+ \", event) && rowSelect !== \"none\") {\n                    if (selectedRows.hasIndex(row)) {\n                        setSelectedRows(selectedRows.remove(row), undefined, true);\n                    } else {\n                        if (rowSelect === \"single\") {\n                            setSelectedRows(CompactSelection.fromSingleSelection(row), undefined, true);\n                        } else {\n                            setSelectedRows(undefined, row, true);\n                        }\n                    }\n                } else if (\n                    (isHotkey(\"Enter\", event) || isHotkey(\" \", event) || isHotkey(\"shift+Enter\", event)) &&\n                    bounds !== undefined\n                ) {\n                    if (overlayOpen) {\n                        setOverlay(undefined);\n                        if (isHotkey(\"Enter\", event)) {\n                            row++;\n                        } else if (isHotkey(\"shift+Enter\", event)) {\n                            row--;\n                        }\n                    } else if (row === rows && showTrailingBlankRow) {\n                        window.setTimeout(() => {\n                            const customTargetColumn = getCustomNewRowTargetColumn(col);\n                            void appendRow(customTargetColumn ?? col);\n                        }, 0);\n                    } else {\n                        onCellActivated?.([col - rowMarkerOffset, row]);\n                        reselect(bounds, true);\n                        cancel();\n                    }\n                } else if (\n                    keybindings.downFill &&\n                    isHotkey(\"primary+_68\", event) &&\n                    gridSelection.current.range.height > 1\n                ) {\n                    // ctrl/cmd + d\n                    fillDown(false);\n                    cancel();\n                } else if (\n                    keybindings.rightFill &&\n                    isHotkey(\"primary+_82\", event) &&\n                    gridSelection.current.range.width > 1\n                ) {\n                    // ctrl/cmd + r\n                    const editList: EditListItem[] = [];\n                    const r = gridSelection.current.range;\n                    for (let y = 0; y < r.height; y++) {\n                        const fillRow = y + r.y;\n                        const fillVal = getMangledCellContent([r.x, fillRow]);\n                        if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;\n                        for (let x = 1; x < r.width; x++) {\n                            const fillCol = x + r.x;\n                            const target = [fillCol, fillRow] as const;\n                            editList.push({\n                                location: target,\n                                value: { ...fillVal },\n                            });\n                        }\n                    }\n                    mangledOnCellsEdited(editList);\n                    gridRef.current?.damage(\n                        editList.map(c => ({\n                            cell: c.location,\n                        }))\n                    );\n                    cancel();\n                } else if (keybindings.pageDown && isHotkey(\"PageDown\", event)) {\n                    row += Math.max(1, visibleRegionRef.current.height - 4); // partial cell accounting\n                    cancel();\n                } else if (keybindings.pageUp && isHotkey(\"PageUp\", event)) {\n                    row -= Math.max(1, visibleRegionRef.current.height - 4); // partial cell accounting\n                    cancel();\n                } else if (keybindings.first && isHotkey(\"primary+Home\", event)) {\n                    setOverlay(undefined);\n                    row = 0;\n                    col = 0;\n                } else if (keybindings.last && isHotkey(\"primary+End\", event)) {\n                    setOverlay(undefined);\n                    row = Number.MAX_SAFE_INTEGER;\n                    col = Number.MAX_SAFE_INTEGER;\n                } else if (keybindings.first && isHotkey(\"primary+shift+Home\", event)) {\n                    setOverlay(undefined);\n                    adjustSelection([-2, -2]);\n                } else if (keybindings.last && isHotkey(\"primary+shift+End\", event)) {\n                    setOverlay(undefined);\n                    adjustSelection([2, 2]);\n                    // eslint-disable-next-line unicorn/prefer-switch\n                } else if (key === \"ArrowDown\") {\n                    if (ctrlKey && altKey) {\n                        return;\n                    }\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([0, isPrimaryKey && !altKey ? 2 : 1]);\n                    } else {\n                        if (altKey && !isPrimaryKey) {\n                            freeMove = true;\n                        }\n                        if (isPrimaryKey && !altKey) {\n                            row = rows - 1;\n                        } else {\n                            row += 1;\n                        }\n                    }\n                } else if (key === \"ArrowUp\" || key === \"Home\") {\n                    const asPrimary = key === \"Home\" || isPrimaryKey;\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([0, asPrimary && !altKey ? -2 : -1]);\n                    } else {\n                        if (altKey && !asPrimary) {\n                            freeMove = true;\n                        }\n                        row += asPrimary && !altKey ? Number.MIN_SAFE_INTEGER : -1;\n                    }\n                } else if (key === \"ArrowRight\" || key === \"End\") {\n                    const asPrimary = key === \"End\" || isPrimaryKey;\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([asPrimary && !altKey ? 2 : 1, 0]);\n                    } else {\n                        if (altKey && !asPrimary) {\n                            freeMove = true;\n                        }\n                        col += asPrimary && !altKey ? Number.MAX_SAFE_INTEGER : 1;\n                    }\n                } else if (key === \"ArrowLeft\") {\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([isPrimaryKey && !altKey ? -2 : -1, 0]);\n                    } else {\n                        if (altKey && !isPrimaryKey) {\n                            freeMove = true;\n                        }\n                        col += isPrimaryKey && !altKey ? Number.MIN_SAFE_INTEGER : -1;\n                    }\n                } else if (key === \"Tab\") {\n                    setOverlay(undefined);\n                    if (shiftKey) {\n                        col--;\n                    } else {\n                        col++;\n                    }\n                } else if (\n                    !metaKey &&\n                    !ctrlKey &&\n                    gridSelection.current !== undefined &&\n                    key.length === 1 &&\n                    /[ -~]/g.test(key) &&\n                    bounds !== undefined &&\n                    isReadWriteCell(getCellContent([col - rowMarkerOffset, Math.max(0, row - 1)]))\n                ) {\n                    if (\n                        (!lastRowSticky || row !== rows) &&\n                        (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)\n                    ) {\n                        return;\n                    }\n                    reselect(bounds, true, key);\n                    cancel();\n                }\n\n                const moved = updateSelectedCell(col, row, false, freeMove);\n                if (moved) {\n                    cancel();\n                }\n            };\n            void fn();\n        },\n        [\n            onKeyDownIn,\n            overlay,\n            gridSelection,\n            keybindings.selectAll,\n            keybindings.search,\n            keybindings.selectColumn,\n            keybindings.selectRow,\n            keybindings.downFill,\n            keybindings.rightFill,\n            keybindings.pageDown,\n            keybindings.pageUp,\n            keybindings.first,\n            keybindings.last,\n            keybindings.clear,\n            columnSelect,\n            rowSelect,\n            getCellContent,\n            rowMarkerOffset,\n            updateSelectedCell,\n            setGridSelection,\n            onSelectionCleared,\n            columnsIn.length,\n            rows,\n            overlayID,\n            focus,\n            mangledOnCellsEdited,\n            provideEditor,\n            getCellRenderer,\n            onDelete,\n            mangledCols.length,\n            setSelectedColumns,\n            setSelectedRows,\n            showTrailingBlankRow,\n            getCustomNewRowTargetColumn,\n            appendRow,\n            onCellActivated,\n            reselect,\n            fillDown,\n            getMangledCellContent,\n            adjustSelection,\n            rangeSelect,\n            lastRowSticky,\n        ]\n    );\n\n    const onPasteInternal = React.useCallback(\n        async (e?: ClipboardEvent) => {\n            if (!keybindings.paste) return;\n            function pasteToCell(inner: InnerGridCell, target: Item, toPaste: string): EditListItem | undefined {\n                if (!isInnerOnlyCell(inner) && isReadWriteCell(inner) && inner.readonly !== true) {\n                    const coerced = coercePasteValue?.(toPaste, inner);\n                    if (coerced !== undefined && isEditableGridCell(coerced)) {\n                        if (process.env.NODE_ENV !== \"production\" && coerced.kind !== inner.kind) {\n                            // eslint-disable-next-line no-console\n                            console.warn(\"Coercion should not change cell kind.\");\n                        }\n                        return {\n                            location: target,\n                            value: coerced,\n                        };\n                    }\n                    const r = getCellRenderer(inner);\n                    if (r === undefined) return undefined;\n                    if (r.kind === GridCellKind.Custom) {\n                        assert(inner.kind === GridCellKind.Custom);\n                        const newVal = r.onPaste?.(toPaste, inner);\n                        if (newVal === undefined) return undefined;\n                        return {\n                            location: target,\n                            value: {\n                                ...inner,\n                                data: newVal,\n                            },\n                        };\n                    } else {\n                        const newVal = r.onPaste?.(toPaste, inner);\n                        if (newVal === undefined) return undefined;\n                        assert(newVal.kind === inner.kind);\n                        return {\n                            location: target,\n                            value: newVal,\n                        };\n                    }\n                }\n                return undefined;\n            }\n\n            const selectedColumns = gridSelection.columns;\n            const selectedRows = gridSelection.rows;\n            const focused =\n                scrollRef.current?.contains(document.activeElement) === true ||\n                canvasRef.current?.contains(document.activeElement) === true;\n\n            let target = gridSelection.current?.cell;\n            if (target === undefined && selectedColumns.length === 1) {\n                target = [selectedColumns.first() ?? 0, 0];\n            }\n            if (target === undefined && selectedRows.length === 1) {\n                target = [rowMarkerOffset, selectedRows.first() ?? 0];\n            }\n\n            if (focused && target !== undefined) {\n                let data: string[][] | undefined;\n                let text: string | undefined;\n\n                const textPlain = \"text/plain\";\n                const textHtml = \"text/html\";\n\n                if (navigator.clipboard.read !== undefined) {\n                    const clipboardContent = await navigator.clipboard.read();\n\n                    for (const item of clipboardContent) {\n                        if (item.types.includes(textHtml)) {\n                            const htmlBlob = await item.getType(textHtml);\n                            const html = await htmlBlob.text();\n                            const fragment = document.createElement(\"html\");\n                            fragment.innerHTML = html;\n                            const el = fragment.querySelector(\"table\");\n                            if (el !== null) {\n                                data = decodeHTML(el);\n                                break;\n                            }\n                        }\n                        if (item.types.includes(textPlain)) {\n                            // eslint-disable-next-line unicorn/no-await-expression-member\n                            text = await (await item.getType(textPlain)).text();\n                        }\n                    }\n                } else if (navigator.clipboard.readText !== undefined) {\n                    text = await navigator.clipboard.readText();\n                } else if (e !== undefined && e?.clipboardData !== null) {\n                    if (e.clipboardData.types.includes(textHtml)) {\n                        const html = e.clipboardData.getData(textHtml);\n                        const fragment = document.createElement(\"html\");\n                        fragment.innerHTML = html;\n                        const el = fragment.querySelector(\"table\");\n                        if (el !== null) {\n                            data = decodeHTML(el);\n                        }\n                    }\n                    if (data === undefined && e.clipboardData.types.includes(textPlain)) {\n                        text = e.clipboardData.getData(textPlain);\n                    }\n                } else {\n                    return; // I didn't want to read that paste value anyway\n                }\n\n                const [gridCol, gridRow] = target;\n\n                const editList: EditListItem[] = [];\n                do {\n                    if (onPaste === undefined) {\n                        const cellData = getMangledCellContent(target);\n                        const newVal = pasteToCell(\n                            cellData,\n                            target,\n                            text ?? data?.map(r => r.join(\"\\t\")).join(\"\\t\") ?? \"\"\n                        );\n                        if (newVal !== undefined) {\n                            editList.push(newVal);\n                        }\n                        break;\n                    }\n\n                    if (data === undefined) {\n                        if (text === undefined) return;\n                        data = unquote(text);\n                    }\n\n                    if (\n                        onPaste === false ||\n                        (typeof onPaste === \"function\" &&\n                            onPaste?.([target[0] - rowMarkerOffset, target[1]], data) !== true)\n                    ) {\n                        return;\n                    }\n\n                    for (const [row, dataRow] of data.entries()) {\n                        if (row + gridRow >= rows) break;\n                        for (const [col, dataItem] of dataRow.entries()) {\n                            const index = [col + gridCol, row + gridRow] as const;\n                            const cellData = getMangledCellContent(index);\n                            const newVal = pasteToCell(cellData, index, dataItem);\n                            if (newVal !== undefined) {\n                                editList.push(newVal);\n                            }\n                        }\n                    }\n                    // eslint-disable-next-line no-constant-condition\n                } while (false);\n\n                mangledOnCellsEdited(editList);\n\n                gridRef.current?.damage(\n                    editList.map(c => ({\n                        cell: c.location,\n                    }))\n                );\n            }\n        },\n        [\n            coercePasteValue,\n            getCellRenderer,\n            getMangledCellContent,\n            gridSelection,\n            keybindings.paste,\n            mangledOnCellsEdited,\n            onPaste,\n            rowMarkerOffset,\n            rows,\n        ]\n    );\n\n    useEventListener(\"paste\", onPasteInternal, window, false, true);\n\n    // While this function is async, we deeply prefer not to await if we don't have to. This will lead to unpacking\n    // promises in rather awkward ways when possible to avoid awaiting. We have to use fallback copy mechanisms when\n    // an await has happened.\n    const onCopy = React.useCallback(\n        async (e?: ClipboardEvent, ignoreFocus?: boolean) => {\n            if (!keybindings.copy) return;\n            const focused =\n                ignoreFocus === true ||\n                scrollRef.current?.contains(document.activeElement) === true ||\n                canvasRef.current?.contains(document.activeElement) === true;\n\n            const selectedColumns = gridSelection.columns;\n            const selectedRows = gridSelection.rows;\n\n            if (focused && getCellsForSelection !== undefined) {\n                if (gridSelection.current !== undefined) {\n                    let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);\n                    if (typeof thunk !== \"object\") {\n                        thunk = await thunk();\n                    }\n                    copyToClipboard(\n                        thunk,\n                        range(\n                            gridSelection.current.range.x - rowMarkerOffset,\n                            gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset\n                        ),\n                        e\n                    );\n                } else if (selectedRows !== undefined && selectedRows.length > 0) {\n                    const toCopy = [...selectedRows];\n                    const cells = toCopy.map(rowIndex => {\n                        const thunk = getCellsForSelection(\n                            {\n                                x: rowMarkerOffset,\n                                y: rowIndex,\n                                width: columnsIn.length - rowMarkerOffset,\n                                height: 1,\n                            },\n                            abortControllerRef.current.signal\n                        );\n                        if (typeof thunk === \"object\") {\n                            return thunk[0];\n                        }\n                        return thunk().then(v => v[0]);\n                    });\n                    if (cells.some(x => x instanceof Promise)) {\n                        const settled = await Promise.all(cells);\n                        copyToClipboard(settled, range(columnsIn.length), e);\n                    } else {\n                        copyToClipboard(cells as (readonly GridCell[])[], range(columnsIn.length), e);\n                    }\n                } else if (selectedColumns.length > 0) {\n                    const results: (readonly (readonly GridCell[])[])[] = [];\n                    const cols: number[] = [];\n                    for (const col of selectedColumns) {\n                        let thunk = getCellsForSelection(\n                            {\n                                x: col,\n                                y: 0,\n                                width: 1,\n                                height: rows,\n                            },\n                            abortControllerRef.current.signal\n                        );\n                        if (typeof thunk !== \"object\") {\n                            thunk = await thunk();\n                        }\n                        results.push(thunk);\n                        cols.push(col - rowMarkerOffset);\n                    }\n                    if (results.length === 1) {\n                        copyToClipboard(results[0], cols, e);\n                    } else {\n                        // FIXME: this is dumb\n                        const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));\n                        copyToClipboard(toCopy, cols, e);\n                    }\n                }\n            }\n        },\n        [columnsIn.length, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows]\n    );\n\n    useEventListener(\"copy\", onCopy, window, false, false);\n\n    const onSearchResultsChanged = React.useCallback(\n        (results: readonly Item[], navIndex: number) => {\n            if (results.length === 0 || navIndex === -1) return;\n\n            const [col, row] = results[navIndex];\n            if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {\n                return;\n            }\n            lastSent.current = [col, row];\n            updateSelectedCell(col, row, false, false);\n        },\n        [updateSelectedCell]\n    );\n\n    // this effects purpose in life is to scroll the newly selected cell into view when and ONLY when that cell\n    // is from an external gridSelection change. Also note we want the unmangled out selection because scrollTo\n    // expects unmangled indexes\n    const [outCol, outRow] = gridSelectionOuter?.current?.cell ?? [];\n    const scrollToRef = React.useRef(scrollTo);\n    scrollToRef.current = scrollTo;\n    React.useEffect(() => {\n        if (\n            outCol !== undefined &&\n            outRow !== undefined &&\n            (outCol !== expectedExternalGridSelection.current?.current?.cell[0] ||\n                outRow !== expectedExternalGridSelection.current?.current?.cell[1])\n        ) {\n            scrollToRef.current(outCol, outRow);\n        }\n    }, [outCol, outRow]);\n\n    const disabledRows = React.useMemo(() => {\n        if (showTrailingBlankRow === true && trailingRowOptions?.tint === true) {\n            return CompactSelection.fromSingleSelection(mangledRows - 1);\n        }\n        return CompactSelection.empty();\n    }, [mangledRows, showTrailingBlankRow, trailingRowOptions?.tint]);\n\n    const mangledVerticalBorder = React.useCallback(\n        (col: number) => {\n            return typeof verticalBorder === \"boolean\"\n                ? verticalBorder\n                : verticalBorder?.(col - rowMarkerOffset) ?? true;\n        },\n        [rowMarkerOffset, verticalBorder]\n    );\n\n    const renameGroupNode = React.useMemo(() => {\n        if (renameGroup === undefined || canvasRef.current === null) return null;\n        const { bounds, group } = renameGroup;\n        const canvasBounds = canvasRef.current.getBoundingClientRect();\n        return (\n            <GroupRename\n                bounds={bounds}\n                group={group}\n                canvasBounds={canvasBounds}\n                onClose={() => setRenameGroup(undefined)}\n                onFinish={newVal => {\n                    setRenameGroup(undefined);\n                    onGroupHeaderRenamed?.(group, newVal);\n                }}\n            />\n        );\n    }, [onGroupHeaderRenamed, renameGroup]);\n\n    const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));\n\n    React.useImperativeHandle(\n        forwardedRef,\n        () => ({\n            appendRow: (col: number) => appendRow(col + rowMarkerOffset),\n            updateCells: damageList => {\n                if (rowMarkerOffset !== 0) {\n                    damageList = damageList.map(x => ({ cell: [x.cell[0] + rowMarkerOffset, x.cell[1]] }));\n                }\n                return gridRef.current?.damage(damageList);\n            },\n            getBounds: (col, row) => {\n                return gridRef.current?.getBounds(col + rowMarkerOffset, row);\n            },\n            focus: () => gridRef.current?.focus(),\n            emit: async e => {\n                switch (e) {\n                    case \"delete\":\n                        onKeyDown({\n                            bounds: undefined,\n                            cancel: () => undefined,\n                            stopPropagation: () => undefined,\n                            preventDefault: () => undefined,\n                            ctrlKey: false,\n                            key: \"Delete\",\n                            keyCode: 46,\n                            metaKey: false,\n                            shiftKey: false,\n                            altKey: false,\n                            rawEvent: undefined,\n                        });\n                        break;\n                    case \"fill-right\":\n                        onKeyDown({\n                            bounds: undefined,\n                            cancel: () => undefined,\n                            stopPropagation: () => undefined,\n                            preventDefault: () => undefined,\n                            ctrlKey: true,\n                            key: \"r\",\n                            keyCode: 82,\n                            metaKey: false,\n                            shiftKey: false,\n                            altKey: false,\n                            rawEvent: undefined,\n                        });\n                        break;\n                    case \"fill-down\":\n                        onKeyDown({\n                            bounds: undefined,\n                            cancel: () => undefined,\n                            stopPropagation: () => undefined,\n                            preventDefault: () => undefined,\n                            ctrlKey: true,\n                            key: \"d\",\n                            keyCode: 68,\n                            metaKey: false,\n                            shiftKey: false,\n                            altKey: false,\n                            rawEvent: undefined,\n                        });\n                        break;\n                    case \"copy\":\n                        await onCopy(undefined, true);\n                        break;\n                    case \"paste\":\n                        await onPasteInternal();\n                        break;\n                }\n            },\n            scrollTo,\n        }),\n        [appendRow, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]\n    );\n\n    const [selCol, selRow] = currentCell ?? [];\n    const onCellFocused = React.useCallback(\n        (cell: Item) => {\n            const [col, row] = cell;\n\n            if (row === -1) {\n                if (columnSelect !== \"none\") {\n                    setSelectedColumns(CompactSelection.fromSingleSelection(col), undefined, false);\n                    focus();\n                }\n                return;\n            }\n\n            if (selCol === col && selRow === row) return;\n            setCurrent(\n                {\n                    cell,\n                    range: { x: col, y: row, width: 1, height: 1 },\n                },\n                true,\n                false,\n                \"keyboard-nav\"\n            );\n            scrollTo(col, row);\n        },\n        [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]\n    );\n\n    const [isFocused, setIsFocused] = React.useState(false);\n    const setIsFocusedDebounced = React.useRef(\n        debounce((val: boolean) => {\n            setIsFocused(val);\n        }, 5)\n    );\n\n    const onCanvasFocused = React.useCallback(() => {\n        setIsFocusedDebounced.current(true);\n\n        // check for mouse state, don't do anything if the user is clicked to focus.\n        if (\n            gridSelection.current === undefined &&\n            gridSelection.columns.length === 0 &&\n            gridSelection.rows.length === 0 &&\n            mouseState === undefined\n        ) {\n            setCurrent(\n                {\n                    cell: [rowMarkerOffset, cellYOffset],\n                    range: {\n                        x: rowMarkerOffset,\n                        y: cellYOffset,\n                        width: 1,\n                        height: 1,\n                    },\n                },\n                true,\n                false,\n                \"keyboard-select\"\n            );\n        }\n    }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);\n\n    const onFocusOut = React.useCallback(() => {\n        setIsFocusedDebounced.current(false);\n    }, []);\n\n    const [idealWidth, idealHeight] = React.useMemo(() => {\n        let h: number;\n        const scrollbarWidth = experimental?.scrollbarWidthOverride ?? getScrollBarWidth();\n        const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);\n        if (typeof rowHeight === \"number\") {\n            h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;\n        } else {\n            let avg = 0;\n            const toAverage = Math.min(rowsCountWithTrailingRow, 10);\n            for (let i = 0; i < toAverage; i++) {\n                avg += rowHeight(i);\n            }\n            avg = Math.floor(avg / toAverage);\n\n            h = totalHeaderHeight + rowsCountWithTrailingRow * avg;\n        }\n        h += scrollbarWidth;\n\n        const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;\n\n        // We need to set a reasonable cap here as some browsers will just ignore huge values\n        // rather than treat them as huge values.\n        return [`${Math.min(100_000, w)}px`, `${Math.min(100_000, h)}px`];\n    }, [mangledCols, experimental?.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);\n\n    return (\n        <ThemeContext.Provider value={mergedTheme}>\n            <DataEditorContainer\n                style={makeCSSStyle(mergedTheme)}\n                className={className}\n                inWidth={width ?? idealWidth}\n                inHeight={height ?? idealHeight}>\n                <DataGridSearch\n                    fillHandle={fillHandle}\n                    drawFocusRing={drawFocusRing}\n                    experimental={experimental}\n                    fixedShadowX={fixedShadowX}\n                    fixedShadowY={fixedShadowY}\n                    getRowThemeOverride={p.getRowThemeOverride}\n                    headerIcons={headerIcons}\n                    imageWindowLoader={imageWindowLoader}\n                    initialSize={initialSize}\n                    isDraggable={isDraggable}\n                    onDragLeave={onDragLeave}\n                    onRowMoved={onRowMoved}\n                    overscrollX={overscrollX}\n                    overscrollY={overscrollY}\n                    preventDiagonalScrolling={preventDiagonalScrolling}\n                    rightElement={rightElement}\n                    rightElementProps={rightElementProps}\n                    showMinimap={showMinimap}\n                    smoothScrollX={smoothScrollX}\n                    smoothScrollY={smoothScrollY}\n                    className={className}\n                    enableGroups={enableGroups}\n                    onCanvasFocused={onCanvasFocused}\n                    onCanvasBlur={onFocusOut}\n                    canvasRef={canvasRef}\n                    onContextMenu={onContextMenu}\n                    theme={mergedTheme}\n                    cellXOffset={cellXOffset}\n                    cellYOffset={cellYOffset}\n                    accessibilityHeight={visibleRegion.height}\n                    onDragEnd={onDragEnd}\n                    columns={mangledCols}\n                    drawCustomCell={drawCell}\n                    drawHeader={drawHeader}\n                    disabledRows={disabledRows}\n                    freezeColumns={mangledFreezeColumns}\n                    lockColumns={rowMarkerOffset}\n                    firstColAccessible={rowMarkerOffset === 0}\n                    getCellContent={getMangledCellContent}\n                    minColumnWidth={minColumnWidth}\n                    maxColumnWidth={maxColumnWidth}\n                    searchInputRef={searchInputRef}\n                    showSearch={showSearch}\n                    onSearchClose={onSearchClose}\n                    highlightRegions={highlightRegions}\n                    getCellsForSelection={getCellsForSelection}\n                    getGroupDetails={mangledGetGroupDetails}\n                    headerHeight={headerHeight}\n                    isFocused={isFocused}\n                    groupHeaderHeight={enableGroups ? groupHeaderHeight : 0}\n                    trailingRowType={\n                        !showTrailingBlankRow ? \"none\" : trailingRowOptions?.sticky === true ? \"sticky\" : \"appended\"\n                    }\n                    onColumnResize={onColumnResize}\n                    onColumnResizeEnd={onColumnResizeEnd}\n                    onColumnResizeStart={onColumnResizeStart}\n                    onCellFocused={onCellFocused}\n                    onColumnMoved={onColumnMovedImpl}\n                    onDragStart={onDragStartImpl}\n                    onHeaderMenuClick={onHeaderMenuClickInner}\n                    onItemHovered={onItemHoveredImpl}\n                    isFilling={mouseState?.fillHandle === true}\n                    onMouseMove={onMouseMoveImpl}\n                    onKeyDown={onKeyDown}\n                    onKeyUp={onKeyUpIn}\n                    onMouseDown={onMouseDown}\n                    onMouseUp={onMouseUp}\n                    onDragOverCell={onDragOverCell}\n                    onDrop={onDrop}\n                    onSearchResultsChanged={onSearchResultsChanged}\n                    onVisibleRegionChanged={onVisibleRegionChangedImpl}\n                    clientSize={[clientSize[0], clientSize[1]]}\n                    rowHeight={rowHeight}\n                    rows={mangledRows}\n                    scrollRef={scrollRef}\n                    selection={gridSelection}\n                    translateX={visibleRegion.tx}\n                    translateY={visibleRegion.ty}\n                    verticalBorder={mangledVerticalBorder}\n                    gridRef={gridRef}\n                    getCellRenderer={getCellRenderer}\n                    scrollToEnd={scrollToEnd}\n                />\n                {renameGroupNode}\n                {overlay !== undefined && (\n                    <DataGridOverlayEditor\n                        {...overlay}\n                        validateCell={validateCell}\n                        id={overlayID}\n                        getCellRenderer={getCellRenderer}\n                        className={experimental?.isSubGrid === true ? \"click-outside-ignore\" : undefined}\n                        provideEditor={provideEditor}\n                        imageEditorOverride={imageEditorOverride}\n                        onFinishEditing={onFinishEditing}\n                        markdownDivCreateNode={markdownDivCreateNode}\n                    />\n                )}\n            </DataEditorContainer>\n        </ThemeContext.Provider>\n    );\n};\n\n/**\n * The primary component of Glide Data Grid.\n * @category DataEditor\n * @param {DataEditorProps} props\n */\nexport const DataEditor = React.forwardRef(DataEditorImpl);\n","import React from \"react\";\nimport {\n    CompactSelection,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    Rectangle,\n    Item,\n    CellArray,\n} from \"../../data-grid/data-grid-types\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\nimport { DataEditor, DataEditorProps, DataEditorRef } from \"../data-editor\";\nimport { BeautifulWrapper, Description } from \"./utils\";\nimport range from \"lodash/range.js\";\nimport chunk from \"lodash/chunk.js\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ntype RowCallback<T> = (range: Item) => Promise<readonly T[]>;\ntype RowToCell<T> = (row: T, col: number) => GridCell;\ntype RowEditedCallback<T> = (cell: Item, newVal: EditableGridCell, rowData: T) => T | undefined;\nfunction useAsyncData<TRowType>(\n    pageSize: number,\n    maxConcurrency: number,\n    getRowData: RowCallback<TRowType>,\n    toCell: RowToCell<TRowType>,\n    onEdited: RowEditedCallback<TRowType>,\n    gridRef: React.MutableRefObject<DataEditorRef | null>\n): Pick<DataEditorProps, \"getCellContent\" | \"onVisibleRegionChanged\" | \"onCellEdited\" | \"getCellsForSelection\"> {\n    pageSize = Math.max(pageSize, 1);\n    const loadingRef = React.useRef(CompactSelection.empty());\n    const dataRef = React.useRef<TRowType[]>([]);\n\n    const [visiblePages, setVisiblePages] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\n    const visiblePagesRef = React.useRef(visiblePages);\n    visiblePagesRef.current = visiblePages;\n\n    const onVisibleRegionChanged: NonNullable<DataEditorProps[\"onVisibleRegionChanged\"]> = React.useCallback(r => {\n        setVisiblePages(cv => {\n            if (r.x === cv.x && r.y === cv.y && r.width === cv.width && r.height === cv.height) return cv;\n            return r;\n        });\n    }, []);\n\n    const getCellContent = React.useCallback<DataEditorProps[\"getCellContent\"]>(\n        cell => {\n            const [col, row] = cell;\n            const rowData: TRowType | undefined = dataRef.current[row];\n            if (rowData !== undefined) {\n                return toCell(rowData, col);\n            }\n            return {\n                kind: GridCellKind.Loading,\n                allowOverlay: false,\n            };\n        },\n        [toCell]\n    );\n\n    const loadPage = React.useCallback(\n        async (page: number) => {\n            loadingRef.current = loadingRef.current.add(page);\n            const startIndex = page * pageSize;\n            const d = await getRowData([startIndex, (page + 1) * pageSize]);\n\n            const vr = visiblePagesRef.current;\n\n            const damageList: { cell: [number, number] }[] = [];\n            const data = dataRef.current;\n            for (const [i, element] of d.entries()) {\n                data[i + startIndex] = element;\n                for (let col = vr.x; col <= vr.x + vr.width; col++) {\n                    damageList.push({\n                        cell: [col, i + startIndex],\n                    });\n                }\n            }\n            gridRef.current?.updateCells(damageList);\n        },\n        [getRowData, gridRef, pageSize]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (r: Rectangle): (() => Promise<CellArray>) => {\n            return async () => {\n                const firstPage = Math.max(0, Math.floor(r.y / pageSize));\n                const lastPage = Math.floor((r.y + r.height) / pageSize);\n\n                for (const pageChunk of chunk(\n                    range(firstPage, lastPage + 1).filter(i => !loadingRef.current.hasIndex(i)),\n                    maxConcurrency\n                )) {\n                    await Promise.allSettled(pageChunk.map(loadPage));\n                }\n\n                const result: GridCell[][] = [];\n\n                for (let y = r.y; y < r.y + r.height; y++) {\n                    const row: GridCell[] = [];\n                    for (let x = r.x; x < r.x + r.width; x++) {\n                        row.push(getCellContent([x, y]));\n                    }\n                    result.push(row);\n                }\n\n                return result;\n            };\n        },\n        [getCellContent, loadPage, maxConcurrency, pageSize]\n    );\n\n    React.useEffect(() => {\n        const r = visiblePages;\n        const firstPage = Math.max(0, Math.floor((r.y - pageSize / 2) / pageSize));\n        const lastPage = Math.floor((r.y + r.height + pageSize / 2) / pageSize);\n        for (const page of range(firstPage, lastPage + 1)) {\n            if (loadingRef.current.hasIndex(page)) continue;\n            void loadPage(page);\n        }\n    }, [loadPage, pageSize, visiblePages]);\n\n    const onCellEdited = React.useCallback(\n        (cell: Item, newVal: EditableGridCell) => {\n            const [, row] = cell;\n            const current = dataRef.current[row];\n            if (current === undefined) return;\n\n            const result = onEdited(cell, newVal, current);\n            if (result !== undefined) {\n                dataRef.current[row] = result;\n            }\n        },\n        [onEdited]\n    );\n\n    return {\n        getCellContent,\n        onVisibleRegionChanged,\n        onCellEdited,\n        getCellsForSelection,\n    };\n}\n\nexport const ServerSideData: React.VFC = () => {\n    const ref = React.useRef<DataEditorRef | null>(null);\n\n    const getRowData = React.useCallback(async (r: Item) => {\n        await new Promise(res => setTimeout(res, 300));\n        return range(r[0], r[1]).map(rowIndex => [`1, ${rowIndex}`, `2, ${rowIndex}`]);\n    }, []);\n\n    const columns = React.useMemo<readonly GridColumn[]>(() => {\n        return [\n            {\n                title: \"A\",\n                width: 150,\n            },\n            {\n                title: \"B\",\n                width: 200,\n            },\n        ];\n    }, []);\n\n    const args = useAsyncData<string[]>(\n        50,\n        5,\n        getRowData,\n        React.useCallback(\n            (rowData, col) => ({\n                kind: GridCellKind.Text,\n                data: rowData[col],\n                allowOverlay: true,\n                displayData: rowData[col],\n            }),\n            []\n        ),\n        React.useCallback((cell, newVal, rowData) => {\n            const [col] = cell;\n            if (newVal.kind !== GridCellKind.Text) return undefined;\n            const newRow: string[] = [...rowData];\n            newRow[col] = newVal.data;\n            return newRow;\n        }, []),\n        ref\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Server Side Data\"\n            description={\n                <Description>\n                    Glide data grid is fully ready to handle your server side data needs. This example condenses the\n                    implementation into a single custom hook and loads in pages of 50. We are using 300ms sleeps, but\n                    network transactions should work the same.\n                </Description>\n            }>\n            <DataEditor ref={ref} {...args} width=\"100%\" columns={columns} rows={3000} rowMarkers=\"both\" />\n        </BeautifulWrapper>\n    );\n};\n(ServerSideData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","/* eslint-disable sonarjs/no-identical-functions */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport * as React from \"react\";\n\nimport {\n    CellArray,\n    CompactSelection,\n    DrawHeaderCallback,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridColumnIcon,\n    GridMouseEventArgs,\n    GridSelection,\n    GroupHeaderClickedEventArgs,\n    isEditableGridCell,\n    Item,\n    Rectangle,\n} from \"../../data-grid/data-grid-types\";\nimport { DataEditor, DataEditorProps } from \"../data-editor\";\n\nimport faker from \"faker\";\nimport { styled } from \"@linaria/react\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\nimport { useEventListener } from \"../../common/utils\";\nimport { IBounds, useLayer } from \"react-laag\";\nimport type { SpriteMap } from \"../../data-grid/data-grid-sprites\";\nimport type { DataEditorRef, Theme } from \"../..\";\nimport range from \"lodash/range.js\";\nimport {\n    useMockDataGenerator,\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    lossyCopyData,\n    getGridColumn,\n    GridColumnWithMockingInfo,\n    ContentCache,\n    BeautifulStyle,\n    ColumnAddButton,\n} from \"./utils\";\nimport noop from \"lodash/noop.js\";\nimport type { GetRowThemeCallback } from \"../../data-grid/data-grid-render\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    getCellsForSelection: true,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nexport const ResizableColumns: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, getCellsForSelection } = useMockDataGenerator(60);\n\n    return (\n        <BeautifulWrapper\n            title=\"Resizable columns\"\n            description={\n                <>\n                    <Description>\n                        You can resize columns by dragging their edges, as long as you respond to the{\" \"}\n                        <PropName>onColumnResize</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        By setting the <PropName>overscrollX</PropName> property extra space can be allocated at the end\n                        of the grid to allow for easier resizing of the final column. You can highlight multiple columns\n                        to resize them all at once.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                overscrollX={200}\n                overscrollY={200}\n                maxColumnAutoWidth={500}\n                maxColumnWidth={2000}\n                rows={50}\n                onColumnResize={onColumnResize}\n                getCellsForSelection={getCellsForSelection}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ResizableColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface OverscrollProps {\n    overscrollX: number;\n    overscrollY: number;\n}\n\nexport const Overscroll: React.VFC<OverscrollProps> = p => {\n    const { overscrollX, overscrollY } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <BeautifulWrapper\n            title=\"Overscroll\"\n            description={\n                <>\n                    <Description>\n                        You can allocate extra space at the ends of the grid by setting the{\" \"}\n                        <PropName>overscrollX</PropName> and <PropName>overscrollY</PropName> props\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                overscrollX={overscrollX}\n                overscrollY={overscrollY}\n                rows={50}\n            />\n        </BeautifulWrapper>\n    );\n};\n(Overscroll as any).argTypes = {\n    overscrollX: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    overscrollY: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Overscroll as any).args = {\n    overscrollX: 200,\n    overscrollY: 200,\n};\n(Overscroll as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nfunction clearCell(cell: GridCell): GridCell {\n    switch (cell.kind) {\n        case GridCellKind.Boolean: {\n            return {\n                ...cell,\n                data: false,\n            };\n        }\n        case GridCellKind.Image: {\n            return {\n                ...cell,\n                data: [],\n                displayData: [],\n            };\n        }\n        case GridCellKind.Drilldown:\n        case GridCellKind.Bubble: {\n            return {\n                ...cell,\n                data: [],\n            };\n        }\n        case GridCellKind.Uri:\n        case GridCellKind.Markdown: {\n            return {\n                ...cell,\n                data: \"\",\n            };\n        }\n        case GridCellKind.Text: {\n            return {\n                ...cell,\n                data: \"\",\n                displayData: \"\",\n            };\n        }\n        case GridCellKind.Number: {\n            return {\n                ...cell,\n                data: 0,\n                displayData: \"\",\n            };\n        }\n    }\n    return cell;\n}\n\nexport const AddData: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        60,\n        false\n    );\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add data\"\n            description={\n                <>\n                    <Description>Data can be added by clicking on the trailing row.</Description>\n                    <MoreInfo>\n                        Keyboard is also supported, just navigate past the last row and press <KeyName>Enter</KeyName>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    sticky: true,\n                    tint: true,\n                    hint: \"New row...\",\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const RightToLeft: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, onColumnResize } = useMockDataGenerator(60, false);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        item => {\n            const [col, _row] = item;\n            if (col !== 0) return getCellContent(item);\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: \" ,   .\",\n                displayData: \" ,   .\",\n                allowWrapping: true,\n            };\n        },\n        [getCellContent]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Right \"\n            description={\n                <>\n                    <Description>The data editor automatically detects RTL in text cells and respects it.</Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContentMangled}\n                columns={cols}\n                onColumnResize={onColumnResize}\n                getCellsForSelection={true}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                onCellEdited={setCellValue}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RightToLeft as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ValidateData: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, getCellsForSelection } = useMockDataGenerator(60, false);\n\n    return (\n        <BeautifulWrapper\n            title=\"Validate data\"\n            description={\n                <>\n                    <Description>\n                        Data can be validated using the <PropName>validateCell</PropName> callback\n                    </Description>\n                    <MoreInfo>This example only allows the word &quot;Valid&quot; inside text cells.</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                onCellEdited={setCellValue}\n                rows={100}\n                validateCell={(_cell, newValue) => {\n                    if (newValue.kind !== GridCellKind.Text) return true;\n                    if (newValue.data === \"Valid\") return true;\n                    if (newValue.data.toLowerCase() === \"valid\") {\n                        return {\n                            ...newValue,\n                            data: \"Valid\",\n                            selectionRange: [0, 3],\n                        };\n                    }\n                    return false;\n                }}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ValidateData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const FillHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        60,\n        false\n    );\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        i => {\n            let val = getCellContent(i);\n            if (i[0] === 1 && val.kind === GridCellKind.Text) {\n                val = {\n                    ...val,\n                    readonly: true,\n                };\n            }\n\n            return val;\n        },\n        [getCellContent]\n    );\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Fill handle\"\n            description={\n                <>\n                    <Description>Fill handles can be used to downfill data with the mouse.</Description>\n                    <MoreInfo>\n                        Just click and drag, the top row will be copied down. Enable using the{\" \"}\n                        <PropName>fillHandle</PropName> prop.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContentMangled}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                fillHandle={true}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    sticky: true,\n                    tint: true,\n                    hint: \"New row...\",\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(FillHandle as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nconst trailingRowOptionsColumnIndexesHint: Record<number, string> = {\n    2: \"Smol text\",\n    3: \"Add\",\n    5: \"New\",\n};\n\nconst trailingRowOptionsColumnIndexesIcon: Record<number, string> = {\n    2: GridColumnIcon.HeaderArray,\n    3: GridColumnIcon.HeaderEmoji,\n    5: GridColumnIcon.HeaderNumber,\n};\n\nconst trailingRowOptionsColumnIndexesTarget: Record<number, number> = {\n    2: 0,\n    3: 0,\n    5: 0,\n};\n\nconst trailingRowOptionsColumnIndexesDisabled: Record<number, boolean> = {\n    3: true,\n};\n\nconst trailingRowOptionsColumnIndexesTheme: Record<number, Partial<Theme>> = {\n    2: {\n        baseFontStyle: \"10px\",\n    },\n};\n\nexport const TrailingRowOptions: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    const columnsWithRowOptions: GridColumn[] = React.useMemo(() => {\n        return cols.map((c, idx) => ({\n            ...c,\n            trailingRowOptions: {\n                hint: trailingRowOptionsColumnIndexesHint[idx],\n                addIcon: trailingRowOptionsColumnIndexesIcon[idx],\n                targetColumn: trailingRowOptionsColumnIndexesTarget[idx],\n                disabled: trailingRowOptionsColumnIndexesDisabled[idx],\n                themeOverride: trailingRowOptionsColumnIndexesTheme[idx],\n            },\n        }));\n    }, [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Trailing row options\"\n            description={\n                <Description>\n                    You can customize the trailing row in each column by setting a{\" \"}\n                    <PropName>trailingRowOptions</PropName> in your columns.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columnsWithRowOptions}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    tint: true,\n                    sticky: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(TrailingRowOptions as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const AddDataToTop: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(async () => {\n        // shift all of the existing cells down\n        for (let y = numRows; y > 0; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, 0]);\n            setCellValueRaw([c, 0], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return \"top\" as const;\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add data\"\n            description={\n                <>\n                    <Description>\n                        You can return a different location to have the new row append take place.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddDataToTop as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface AddDataToMiddleProps {\n    insertIndex: number;\n}\nexport const AddDataToMiddle: React.FC<AddDataToMiddleProps> = p => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const index = p.insertIndex;\n    const onRowAppended = React.useCallback(async () => {\n        // shift rows below index down\n        for (let y = numRows; y > index; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, index]);\n            setCellValueRaw([c, index], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return index;\n    }, [getCellContent, numRows, setCellValueRaw, index]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add data to middle\"\n            description={\n                <>\n                    <Description>\n                        You can return a different location to have the new row append take place.\n                    </Description>\n                    <MoreInfo>\n                        Note that <KeyName>insertIndex</KeyName> is zero-based while the number column on the left side\n                        of the grid is one-based, so inserting at index &quot;4&quot; creates a new row at &quot;5&quot;\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddDataToMiddle as any).args = {\n    insertIndex: 10,\n};\n(AddDataToMiddle as any).argTypes = {\n    insertIndex: {\n        control: {\n            type: \"range\",\n            min: 1,\n            max: 48,\n        },\n    },\n};\n(AddDataToMiddle as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const AppendRowHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = React.useCallback(() => {\n        void ref.current?.appendRow(3);\n    }, [ref]);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"appendRow Ref\"\n            description={\n                <>\n                    <Description>\n                        Adding data can also be triggered from outside of <PropName>DataEditor</PropName>\n                    </Description>\n                    <MoreInfo>\n                        By calling <PropName>appendRow</PropName> on a <PropName>ref</PropName> to your grid, you can\n                        trigger the append elsewhere, like this <KeyName onClick={onClick}>Append</KeyName> button\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AppendRowHandle as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const SmallEditableGrid = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(6, false);\n\n    return (\n        <BeautifulWrapper\n            title=\"Editable Grid\"\n            description={\n                <Description>\n                    Data grid supports overlay editors for changing values. There are bespoke editors for numbers,\n                    strings, images, booleans, markdown, and uri.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                rowMarkers=\"both\"\n                columns={cols}\n                rows={20}\n                onCellEdited={setCellValue}\n            />\n        </BeautifulWrapper>\n    );\n};\n(SmallEditableGrid as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const OneMillionRows: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"One Million Rows\"\n            description={<Description>Data grid supports over 1 million rows. Your limit is mostly RAM.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                rowHeight={31}\n                rows={1_000_000}\n                rowMarkers=\"number\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(OneMillionRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const SillyNumbers: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"100 Million Rows\"\n            description={\n                <Description>\n                    100 million rows is silly. Once we cross about 33 million pixels in height we can no longer trust\n                    the browser to scroll accurately.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                rowHeight={31}\n                rows={100_000_000}\n                rowMarkers=\"number\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(SillyNumbers as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ObserveVisibleRegion: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    const [visibleRegion, setVisibleRegion] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\n\n    return (\n        <BeautifulWrapper\n            title=\"Observe Visible Region\"\n            description={\n                <>\n                    <Description>\n                        The visible region can be observed using <PropName>onVisibleRegionChanged</PropName>\n                    </Description>\n                    <MoreInfo>\n                        Then current visible region is x:<KeyName>{visibleRegion.x}</KeyName> y:\n                        <KeyName>{visibleRegion.y}</KeyName> width:\n                        <KeyName>{visibleRegion.width}</KeyName> height:<KeyName>{visibleRegion.height}</KeyName>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n                onVisibleRegionChanged={setVisibleRegion}\n            />\n        </BeautifulWrapper>\n    );\n};\n(OneMillionRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const OneHundredThousandCols: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100_000);\n\n    return (\n        <BeautifulWrapper\n            title=\"One Hundred Thousand Columns\"\n            description={\n                <Description>\n                    Data grid supports way more columns than you will ever need. Also this is rendering 10 million cells\n                    but that&apos;s not important.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellsForSelection={getCellsForSelection}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(OneHundredThousandCols as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const TenMillionCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <BeautifulWrapper\n            title=\"Ten Million Cells\"\n            description={<Description>Data grid supports over 10 million cells. Go nuts with it.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"number\"\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={100_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(TenMillionCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface SmoothScrollingGridProps {\n    smoothScrollX: boolean;\n    smoothScrollY: boolean;\n}\n\nexport const SmoothScrollingGrid: React.FC<SmoothScrollingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <BeautifulWrapper\n            title=\"Smooth scrolling\"\n            description={\n                <Description>\n                    You can enable smooth scrolling with the <PropName>smoothScrollX</PropName> and{\" \"}\n                    <PropName>smoothScrollY</PropName> props. Disabling smooth scrolling can dramatically increase\n                    performance and improve visual stability during rapid scrolling.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(SmoothScrollingGrid as any).args = {\n    smoothScrollX: false,\n    smoothScrollY: false,\n};\n(SmoothScrollingGrid as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\ninterface InputBlendingGridProps {\n    rangeBlending: \"mixed\" | \"exclusive\";\n    columnBlending: \"mixed\" | \"exclusive\";\n    rowBlending: \"mixed\" | \"exclusive\";\n    rangeMultiSelect: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\";\n    columnMultiSelect: \"none\" | \"single\" | \"multi\";\n    rowMultiSelect: \"none\" | \"single\" | \"multi\";\n}\n\nexport const InputBlending: React.FC<InputBlendingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <BeautifulWrapper\n            title=\"Input blending\"\n            description={\n                <Description>\n                    Input blending can be enabled or disable between row, column, and range selections. Multi-selections\n                    can also be enabled or disabled with the same level of granularity.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={p.rowMultiSelect === \"none\" ? \"number\" : \"both\"}\n                keybindings={{\n                    clear: true,\n                    copy: true,\n                    downFill: true,\n                    rightFill: true,\n                    pageDown: true,\n                    pageUp: true,\n                    paste: true,\n                    search: true,\n                    selectAll: true,\n                    selectColumn: true,\n                    selectRow: true,\n                }}\n                getCellsForSelection={true}\n                rangeSelect={p.rangeMultiSelect}\n                columnSelect={p.columnMultiSelect}\n                rowSelect={p.rowMultiSelect}\n                rangeSelectionBlending={p.rangeBlending}\n                columnSelectionBlending={p.columnBlending}\n                rowSelectionBlending={p.rowBlending}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(InputBlending as any).args = {\n    rangeBlending: \"mixed\",\n    columnBlending: \"mixed\",\n    rowBlending: \"mixed\",\n    rangeMultiSelect: \"rect\",\n    columnMultiSelect: \"multi\",\n    rowMultiSelect: \"multi\",\n};\n(InputBlending as any).argTypes = {\n    rangeBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    columnBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rowBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rangeMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"cell\", \"rect\", \"multi-cell\", \"multi-rect\"] },\n    },\n    columnMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n    rowMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n};\n(InputBlending as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\ninterface AddColumnsProps {\n    columnsCount: number;\n}\n\nexport const AddColumns: React.FC<AddColumnsProps> = p => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(p.columnsCount);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add and remove columns\"\n            description={\n                <>\n                    <Description>You can add and remove columns at your disposal</Description>\n                    <MoreInfo>Use the story&apos;s controls to change the number of columns</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"number\"\n                getCellsForSelection={getCellsForSelection}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddColumns as any).args = {\n    columnsCount: 10,\n};\n(AddColumns as any).argTypes = {\n    columnsCount: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n(AddColumns as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const ScrollShadows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    const onSelectionChange = React.useCallback((newSel: GridSelection) => {\n        let newRows = CompactSelection.empty();\n        if (newSel.current !== undefined) {\n            newRows = newRows.add([newSel.current.range.y, newSel.current.range.y + newSel.current.range.height]);\n        }\n        for (const b of newSel.current?.rangeStack ?? []) {\n            newRows = newRows.add([b.y, b.y + b.height]);\n        }\n        setSelection({\n            ...newSel,\n            rows: newRows,\n        });\n    }, []);\n\n    const theme = React.useMemo<Partial<Theme>>(\n        () => ({\n            accentLight: \"#b1f6ff\",\n            horizontalBorderColor: \"transparent\",\n            headerBottomBorderColor: \"rgba(115, 116, 131, 0.16)\",\n        }),\n        []\n    );\n\n    const getRowThemeOverride = React.useCallback(row => (row % 2 === 0 ? undefined : { bgCell: \"#f5f5f6\" }), []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Automatic Row Markers\"\n            description={\n                <>\n                    <Description>You can enable and disable the horizontal/vertical scroll shadows.</Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={\"number\"}\n                gridSelection={selection}\n                onGridSelectionChange={onSelectionChange}\n                fixedShadowX={false}\n                headerHeight={26}\n                drawFocusRing={false}\n                rowHeight={22}\n                fixedShadowY={false}\n                getRowThemeOverride={getRowThemeOverride}\n                verticalBorder={false}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n                theme={theme}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ScrollShadows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const AutomaticRowMarkers: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Automatic Row Markers\"\n            description={\n                <>\n                    <Description>\n                        You can enable row markers with rich selection behavior using the{\" \"}\n                        <PropName>rowMarkers</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        Use <KeyName></KeyName> + click to make range selections, and <KeyName>Ctrl</KeyName> (\n                        <KeyName></KeyName> on Mac) + click to add/remove individual rows.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={\"both\"}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AutomaticRowMarkers as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const WrappingText: React.VFC<{\n    alignment: \"left\" | \"center\" | \"right\";\n    length: number;\n    hyperWrapping: boolean;\n}> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(6);\n\n    const suffix = React.useMemo(() => {\n        return range(0, 100).map(() => faker.lorem.sentence(p.length));\n    }, [p.length]);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        i => {\n            const [col, row] = i;\n\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    displayData: `${row},\\n${suffix[row % suffix.length]}`,\n                    data: `${row}, ${suffix}`,\n                    allowWrapping: true,\n                    contentAlign: p.alignment,\n                };\n            }\n            return getCellContent(i);\n        },\n        [getCellContent, p.alignment, suffix]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Wrapping Text\"\n            description={\n                <Description>\n                    Text cells can have wrapping text by setting the <PropName>allowWrapping</PropName> prop to true.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowHeight={80}\n                getCellContent={mangledGetCellContent}\n                columns={cols}\n                rows={1000}\n                onColumnResize={onColumnResize}\n                experimental={{\n                    hyperWrapping: p.hyperWrapping,\n                }}\n            />\n        </BeautifulWrapper>\n    );\n};\n(WrappingText as any).args = {\n    alignment: \"left\",\n    length: 20,\n    hyperWrapping: false,\n};\n(WrappingText as any).argTypes = {\n    alignment: {\n        control: { type: \"select\", options: [\"left\", \"center\", \"right\"] },\n    },\n    length: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n(WrappingText as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const UnevenRows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Uneven Rows\"\n            description={\n                <Description>\n                    Rows can be made uneven by passing a callback to the <PropName>rowHeight</PropName> prop\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowHeight={r => (r % 3 === 0 ? 30 : r % 2 ? 50 : 60)}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UnevenRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const DrawCustomCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Draw custom cells\"\n            description={\n                <Description>\n                    You can draw custom cell contents however you want using the <PropName>drawCustomCell</PropName>{\" \"}\n                    prop\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                drawCell={args => {\n                    const { cell, rect, ctx } = args;\n                    if (cell.kind !== GridCellKind.Text) return false;\n\n                    const hasX = cell.displayData.toLowerCase().includes(\"x\"); // all my x's live in texas\n\n                    ctx.save();\n                    const { x, y, width, height } = rect;\n                    const data = cell.displayData;\n\n                    ctx.fillStyle = hasX ? \"#bfffcd\" : \"#ffe6e6\";\n                    ctx.fillRect(x + 1, y + 1, width - 1, height - 1);\n\n                    ctx.fillStyle = hasX ? \"#0fc035\" : \"#e01e1e\";\n                    ctx.font = \"bold 14px sans-serif\";\n                    ctx.fillText(data, x + 8 + 0.5, y + height / 2 + 4.5);\n                    ctx.restore();\n\n                    return true;\n                }}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(DrawCustomCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const RearrangeColumns: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(60);\n\n    // This is a dirty hack because the mock generator doesn't really support changing this. In a real data source\n    // you should track indexes properly\n    const [sortableCols, setSortableCols] = React.useState(cols);\n\n    const onColMoved = React.useCallback((startIndex: number, endIndex: number): void => {\n        setSortableCols(old => {\n            const newCols = [...old];\n            const [toMove] = newCols.splice(startIndex, 1);\n            newCols.splice(endIndex, 0, toMove);\n            return newCols;\n        });\n    }, []);\n\n    const getCellContentMangled = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            const remappedCol = cols.findIndex(c => c.title === sortableCols[col].title);\n            return getCellContent([remappedCol, row]);\n        },\n        [cols, getCellContent, sortableCols]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Rearrange Columns\"\n            description={\n                <Description>\n                    Columns can be rearranged by drag and dropping, as long as you respond to the{\" \"}\n                    <PropName>onColumnMoved</PropName> callback.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                freezeColumns={1}\n                rowMarkers=\"both\"\n                getCellContent={getCellContentMangled}\n                getCellsForSelection={getCellsForSelection}\n                columns={sortableCols}\n                onColumnMoved={onColMoved}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RearrangeColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface RowAndHeaderSizesProps {\n    rowHeight: number;\n    headerHeight: number;\n}\nexport const RowAndHeaderSizes: React.VFC<RowAndHeaderSizesProps> = p => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Row and Header sizes\"\n            description={\n                <>\n                    <Description>\n                        The row size can be controlled with <PropName>rowHeight</PropName> and the header size with{\" \"}\n                        <PropName>headerHeight</PropName>.\n                    </Description>\n                    <MoreInfo>Use the story&apos;s controls to resize them</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowHeight={p.rowHeight}\n                headerHeight={p.headerHeight}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"number\"}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RowAndHeaderSizes as any).args = {\n    rowHeight: 34,\n    headerHeight: 34,\n};\n(RowAndHeaderSizes as any).argTypes = {\n    rowHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n    headerHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n};\n(RowAndHeaderSizes as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nconst KeyName = styled.kbd`\n    background-color: #f4f4f4;\n    color: #2b2b2b;\n    padding: 2px 6px;\n    font-family: monospace;\n    font-size: 14px;\n    border-radius: 4px;\n    box-shadow: 0px 1px 2px #00000040;\n    margin: 0 0.1em;\n`;\n\nexport const MultiSelectColumns: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\n\n    return (\n        <BeautifulWrapper\n            title=\"Multi select columns\"\n            description={\n                <>\n                    <Description>\n                        You can select multiple columns by using the <PropName>selectedColumns</PropName> and{\" \"}\n                        <PropName>onSelectedColumnsChange</PropName> props\n                    </Description>\n                    <MoreInfo>\n                        Here you can multi select columns by using <KeyName>Ctrl</KeyName> (on Windows) or{\" \"}\n                        <KeyName></KeyName> (on Mac)\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers=\"both\"\n                columns={cols}\n                rows={100_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(MultiSelectColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nfunction getColumnsForCellTypes(): GridColumnWithMockingInfo[] {\n    return [\n        {\n            title: \"Row ID\",\n            width: 120,\n            icon: GridColumnIcon.HeaderRowID,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.RowID,\n                    data: faker.datatype.uuid(),\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Protected\",\n            width: 120,\n            icon: GridColumnIcon.HeaderCode,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Protected,\n                    data: faker.finance.bitcoinAddress(),\n                    allowOverlay: false,\n                };\n            },\n        },\n        {\n            title: \"Loading\",\n            width: 120,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Loading,\n                    allowOverlay: false,\n                };\n            },\n        },\n        {\n            title: \"Text\",\n            width: 120,\n            icon: GridColumnIcon.HeaderCode,\n            hasMenu: false,\n            getContent: () => {\n                const name = faker.name.firstName();\n                return {\n                    kind: GridCellKind.Text,\n                    data: name,\n                    displayData: name,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Number\",\n            width: 120,\n            icon: GridColumnIcon.HeaderNumber,\n            hasMenu: false,\n            getContent: () => {\n                const age = faker.datatype.number(100);\n                return {\n                    kind: GridCellKind.Number,\n                    data: age,\n                    displayData: `${age}`,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Boolean\",\n            width: 120,\n            icon: GridColumnIcon.HeaderBoolean,\n            hasMenu: false,\n            getContent: () => {\n                const roll = Math.random();\n                const checked = roll < 0.1 ? undefined : roll < 0.2 ? null : roll < 0.6;\n                // TODO: Make editable. UX looks bad by default.\n                return {\n                    kind: GridCellKind.Boolean,\n                    data: checked,\n                    allowOverlay: false,\n                    readonly: false,\n                };\n            },\n        },\n        {\n            title: \"Image\",\n            width: 120,\n            icon: GridColumnIcon.HeaderImage,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Image,\n                    data: [`${faker.image.animals(40, 40)}?random=${faker.datatype.number(100_000)}`],\n                    allowOverlay: true,\n                    allowAdd: false,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Uri\",\n            width: 120,\n            icon: GridColumnIcon.HeaderUri,\n            hasMenu: false,\n            getContent: () => {\n                const url = faker.internet.url();\n                return {\n                    kind: GridCellKind.Uri,\n                    data: url,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Markdown\",\n            width: 120,\n            icon: GridColumnIcon.HeaderMarkdown,\n            hasMenu: false,\n            getContent: () => {\n                const markdown = `# Title\nHello my name is *${faker.name.firstName()}*\n\n## TODO:\nTry out [Glide](https://www.glideapps.com/)\n`;\n                return {\n                    kind: GridCellKind.Markdown,\n                    data: markdown,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Bubble\",\n            width: 120,\n            icon: GridColumnIcon.HeaderArray,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Bubble,\n                    data: [faker.lorem.word(), faker.lorem.word(), faker.lorem.word()],\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Drilldown\",\n            width: 120,\n            icon: GridColumnIcon.HeaderArray,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Drilldown,\n                    data: [\n                        {\n                            text: faker.address.cityName(),\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\n                        },\n                        {\n                            text: faker.address.cityName(),\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\n                        },\n                    ],\n                    allowOverlay: true,\n                };\n            },\n        },\n    ];\n}\n\nfunction useAllMockedKinds() {\n    const cache = React.useRef<ContentCache>(new ContentCache());\n\n    const [colsMap, setColsMap] = React.useState(getColumnsForCellTypes);\n\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\n        setColsMap(prevColsMap => {\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\n            const newArray = [...prevColsMap];\n            newArray.splice(index, 1, {\n                ...prevColsMap[index],\n                width: newSize,\n            });\n            return newArray;\n        });\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return colsMap.map(getGridColumn);\n    }, [colsMap]);\n\n    const [updateVersion, setUpdateVersion] = React.useState(0);\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            // Terrible hack to force update when setCellValue requests it\n            noop(updateVersion);\n            let val = cache.current.get(col, row);\n            if (val === undefined) {\n                val = colsMap[col].getContent();\n                cache.current.set(col, row, val);\n            }\n\n            return val;\n        },\n        [colsMap, updateVersion]\n    );\n\n    const setCellValue = React.useCallback(\n        ([col, row]: Item, val: GridCell, noDisplay?: boolean, forceUpdate?: boolean): void => {\n            let current = cache.current.get(col, row);\n            if (current === undefined) {\n                current = colsMap[col].getContent();\n            }\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\n                const copied = lossyCopyData(val, current);\n                cache.current.set(col, row, {\n                    ...copied,\n                    displayData: noDisplay === true ? undefined : copied.data?.toString() ?? \"\",\n                } as any);\n\n                if (forceUpdate === true) {\n                    setUpdateVersion(v => v + 1);\n                }\n            }\n        },\n        [colsMap]\n    );\n\n    return { cols, getCellContent, onColumnResize, setCellValue };\n}\n\nexport const AllCellKinds: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    return (\n        <BeautifulWrapper\n            title=\"Lotsa cell kinds\"\n            description={\n                <Description>\n                    Data grid supports plenty cell kinds. Anything under <PropName>GridCellKind</PropName>.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                highlightRegions={[\n                    {\n                        color: \"#ff00ff33\",\n                        range: {\n                            x: 1,\n                            y: 1,\n                            width: 3,\n                            height: 3,\n                        },\n                    },\n                ]}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AllCellKinds as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nconst darkTheme = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"#b8b8b8\",\n    textLight: \"#a0a0a0\",\n    textBubble: \"#ffffff\",\n\n    bgIconHeader: \"#b8b8b8\",\n    fgIconHeader: \"#000000\",\n    textHeader: \"#a1a1a1\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#16161b\",\n    bgCellMedium: \"#202027\",\n    bgHeader: \"#212121\",\n    bgHeaderHasFocus: \"#474747\",\n    bgHeaderHovered: \"#404040\",\n\n    bgBubble: \"#212121\",\n    bgBubbleSelected: \"#000000\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"rgba(225,225,225,0.2)\",\n    drilldownBorder: \"rgba(225,225,225,0.4)\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst hotdogStand = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"rgba(255, 255, 255, 0.9)\",\n    textLight: \"rgba(255, 255, 255, 0.7)\",\n    textBubble: \"#000000\",\n\n    bgIconHeader: \"#880000\",\n    fgIconHeader: \"#ff5555\",\n    textHeader: \"rgba(0, 0, 0, 0.9)\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#ff0000\",\n    bgCellMedium: \"#ff4d4d\",\n    bgHeader: \"#f3f300\",\n    bgHeaderHasFocus: \"#eeee00\",\n    bgHeaderHovered: \"#e0e000\",\n\n    bgBubble: \"#ffff00\",\n    bgBubbleSelected: \"#ffff00\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"#ffff00\",\n    drilldownBorder: \"#ffff00\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nexport const ThemeSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [theme, setTheme] = React.useState<Partial<Theme>>({});\n\n    const [numRows, setNumRows] = React.useState(1000);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme support\"\n            description={\n                <>\n                    <Description>\n                        DataGrid respects the theme provided by the <PropName>theme</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        <button onClick={() => setTheme({})}>Light</button> or{\" \"}\n                        <button onClick={() => setTheme(darkTheme)}>Dark</button> even{\" \"}\n                        <button onClick={() => setTheme(hotdogStand)}>Hotdog Stand</button>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                theme={theme}\n                getCellContent={getCellContent}\n                columns={cols}\n                onRowAppended={onRowAppended}\n                trailingRowOptions={{\n                    tint: true,\n                    sticky: true,\n                }}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={numRows}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ThemeSupport as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ThemePerColumn: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[4] = {\n            ...c[4],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[9] = {\n            ...c[9],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        c[10] = {\n            ...c[10],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        return c;\n    }, [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme per column\"\n            description={\n                <>\n                    <Description>Each column can provide theme overrides for rendering that column.</Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={realCols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ThemePerColumn as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ThemePerRow: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(5);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme per row\"\n            description={\n                <>\n                    <Description>\n                        Each row can provide theme overrides for rendering that row using the{\" \"}\n                        <PropName>getRowThemeOverride</PropName> callback.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                trailingRowOptions={{\n                    sticky: true,\n                    tint: true,\n                }}\n                onRowAppended={() => undefined}\n                getCellsForSelection={getCellsForSelection}\n                getRowThemeOverride={i =>\n                    i % 2 === 0\n                        ? undefined\n                        : {\n                              bgCell: \"#f0f8ff\",\n                              borderColor: \"#3f90e0\",\n                          }\n                }\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1_000_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ThemePerRow as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CellActivatedEvent: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [lastActivated, setLastActivated] = React.useState<Item | undefined>(undefined);\n\n    const onCellActivated = React.useCallback((cell: Item) => {\n        setLastActivated(cell);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Cell Activated event\"\n            description={\n                <>\n                    <Description>\n                        When you tap <KeyName>Enter</KeyName>, <KeyName>Space</KeyName> or double click a cell, that\n                        cell is activated. You can track this with <PropName>onCellActivated</PropName>.\n                    </Description>\n                    <MoreInfo>\n                        Last activated cell:{\" \"}\n                        {lastActivated === undefined ? \"none\" : `(${lastActivated[0]}, ${lastActivated[1]})`}\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={true}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                onCellActivated={onCellActivated}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CellActivatedEvent as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const BuiltInSearch: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [showSearch, setShowSearch] = React.useState(false);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    useEventListener(\n        \"keydown\",\n        React.useCallback(event => {\n            if ((event.ctrlKey || event.metaKey) && event.code === \"KeyF\") {\n                setShowSearch(cv => !cv);\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        }, []),\n        window,\n        false,\n        true\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Search is easy\"\n            description={\n                <>\n                    <Description>\n                        Search for any data in your grid by setting <PropName>showSearch</PropName>.\n                    </Description>\n                    <MoreInfo>\n                        In this story, <KeyName>Ctrl</KeyName> (<KeyName></KeyName> on Mac) + <KeyName>f</KeyName>{\" \"}\n                        toggles the search bar. Make sure you&apos;re focused on the Data Grid!\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={true}\n                gridSelection={selection}\n                onGridSelectionChange={setSelection}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                showSearch={showSearch}\n                onSearchClose={() => setShowSearch(false)}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(BuiltInSearch as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface ImperativeScrollProps {\n    paddingY: number;\n    paddingX: number;\n    vAlign?: \"start\" | \"center\" | \"end\";\n    hAlign?: \"start\" | \"center\" | \"end\";\n}\n\nexport const ImperativeScroll: React.VFC<ImperativeScrollProps> = p => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = () => {\n        ref.current?.scrollTo(4, 99, \"both\", p.paddingX, p.paddingY, {\n            vAlign: p.vAlign,\n            hAlign: p.hAlign,\n        });\n    };\n\n    return (\n        <BeautifulWrapper\n            title=\"Imperative scrolling\"\n            description={\n                <>\n                    <Description>\n                        You can imperatively scroll to a cell by calling <PropName>scrollTo</PropName> on a DataEditor\n                        ref.\n                    </Description>\n                    <MoreInfo>\n                        Click <button onClick={onClick}>Here</button> to scroll to column 4 row 100\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                rowMarkers=\"clickable-number\"\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ImperativeScroll as any).args = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: \"start\",\n    hAlign: \"start\",\n};\n(ImperativeScroll as any).argTypes = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n    hAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n};\n(ImperativeScroll as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nconst SimpleMenu = styled.div`\n    width: 175px;\n    padding: 8px 0;\n    border-radius: 6px;\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\n\n    display: flex;\n    flex-direction: column;\n\n    background-color: white;\n    font-size: 13px;\n    font-weight: 600;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\",\n        \"Helvetica Neue\", sans-serif;\n\n    .danger {\n        color: rgba(255, 40, 40, 0.8);\n        :hover {\n            color: rgba(255, 40, 40, 1);\n        }\n    }\n\n    > div {\n        padding: 6px 8px;\n        color: rgba(0, 0, 0, 0.7);\n        :hover {\n            background-color: rgba(0, 0, 0, 0.05);\n            color: rgba(0, 0, 0, 0.9);\n        }\n        transition: background-color 100ms;\n        cursor: pointer;\n    }\n`;\n\nexport const HeaderMenus: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        return cols.map(c => ({\n            ...c,\n            hasMenu: true,\n        }));\n    }, [cols]);\n\n    const [menu, setMenu] =\n        React.useState<{\n            col: number;\n            bounds: Rectangle;\n        }>();\n\n    const isOpen = menu !== undefined;\n\n    const { layerProps, renderLayer } = useLayer({\n        isOpen,\n        auto: true,\n        placement: \"bottom-end\",\n        triggerOffset: 2,\n        onOutsideClick: () => setMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                left: menu?.bounds.x ?? 0,\n                top: menu?.bounds.y ?? 0,\n                width: menu?.bounds.width ?? 0,\n                height: menu?.bounds.height ?? 0,\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\n            }),\n        },\n    });\n\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n        setMenu({ col, bounds });\n    }, []);\n\n    const onHeaderClicked = React.useCallback(() => {\n        // eslint-disable-next-line no-console\n        console.log(\"Header clicked\");\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Header menus\"\n            description={\n                <>\n                    <Description>\n                        Headers on the data grid can be configured to support menus. We provide the events and the\n                        triangle, you provide the menu.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                onHeaderMenuClick={onHeaderMenuClick}\n                onHeaderClicked={onHeaderClicked}\n                columns={realCols}\n                onCellContextMenu={(_, e) => e.preventDefault()}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n            />\n            {isOpen &&\n                renderLayer(\n                    <SimpleMenu {...layerProps}>\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\n                        <div className=\"danger\" onClick={() => setMenu(undefined)}>\n                            Delete\n                        </div>\n                    </SimpleMenu>\n                )}\n        </BeautifulWrapper>\n    );\n};\n(HeaderMenus as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CustomHeaderIcons: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            title: \"CUSTOM ICON\",\n            icon: \"custom\",\n            width: 200,\n        };\n        return c;\n    }, [cols]);\n\n    const headerIcons = React.useMemo<SpriteMap>(() => {\n        return {\n            custom: p => `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <rect x=\"2.00015\" y=\"2\" width=\"16\" height=\"16\" rx=\"4\" fill=\"${p.bgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.69759 6.00977C4.23735 6.00977 3.86426 6.38286 3.86426 6.8431C3.86426 7.30334 4.23735 7.67643 4.69759 7.67643H8.86426C9.3245 7.67643 9.69759 7.30334 9.69759 6.8431C9.69759 6.38286 9.32449 6.00977 8.86426 6.00977H4.69759Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.61426 4.76009C7.61426 4.29985 7.24116 3.92676 6.78092 3.92676C6.32069 3.92676 5.94759 4.29985 5.94759 4.76009L5.94759 8.92676C5.94759 9.387 6.32069 9.76009 6.78092 9.76009C7.24116 9.76009 7.61426 9.38699 7.61426 8.92676L7.61426 4.76009Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M11.0336 6.00977C10.5734 6.00977 10.2003 6.38286 10.2003 6.8431C10.2003 7.30334 10.5734 7.67643 11.0336 7.67643H15.2003C15.6605 7.67643 16.0336 7.30334 16.0336 6.8431C16.0336 6.38286 15.6605 6.00977 15.2003 6.00977H11.0336Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.89704 10.9916C5.5716 10.6662 5.04397 10.6662 4.71853 10.9916C4.39309 11.317 4.39309 11.8447 4.71853 12.1701L7.66481 15.1164C7.99024 15.4418 8.51788 15.4418 8.84332 15.1164C9.16876 14.791 9.16876 14.2633 8.84332 13.9379L5.89704 10.9916Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.84332 12.1703C9.16875 11.8449 9.16875 11.3172 8.84332 10.9918C8.51788 10.6664 7.99024 10.6664 7.6648 10.9918L4.71853 13.9381C4.39309 14.2635 4.39309 14.7912 4.71853 15.1166C5.04396 15.442 5.5716 15.442 5.89704 15.1166L8.84332 12.1703Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 11.804C10.2003 11.3438 10.5734 10.9707 11.0336 10.9707H15.2003C15.6605 10.9707 16.0336 11.3438 16.0336 11.804C16.0336 12.2643 15.6605 12.6374 15.2003 12.6374H11.0336C10.5734 12.6374 10.2003 12.2643 10.2003 11.804Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 14.304C10.2003 13.8438 10.5734 13.4707 11.0336 13.4707H15.2003C15.6605 13.4707 16.0336 13.8438 16.0336 14.304C16.0336 14.7643 15.6605 15.1374 15.2003 15.1374H11.0336C10.5734 15.1374 10.2003 14.7643 10.2003 14.304Z\" fill=\"${p.fgColor}\"/>\n            </svg>`,\n        };\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Custom header icons\"\n            description={\n                <>\n                    <Description>\n                        You can provide overrides for the default icons by passing the <PropName>headerIcons</PropName>{\" \"}\n                        prop.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={realCols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                headerIcons={headerIcons}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomHeaderIcons as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const RightElement: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, getCellsForSelection } = useMockDataGenerator(8, false);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    const [numRows, setNumRows] = React.useState(300);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Right Element\"\n            description={\n                <Description>\n                    A DOM element may be added as a trailer to the grid by using the <PropName>rightElement</PropName>{\" \"}\n                    prop.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columns}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n                rightElementProps={{ sticky: true }}\n                rightElement={\n                    <div\n                        style={{\n                            height: \"100%\",\n                            padding: \"20px 20px 40px 20px\",\n                            width: 200,\n                            color: \"black\",\n                            whiteSpace: \"pre-wrap\",\n                            backgroundColor: \"rgba(240, 240, 250, 0.2)\",\n                            display: \"flex\",\n                            justifyContent: \"center\",\n                            alignItems: \"center\",\n                            boxShadow: \"0 0 10px rgba(0, 0, 0, 0.15)\",\n                            backdropFilter: \"blur(12px)\",\n                        }}>\n                        This is a real DOM element. You can put whatever you want here. You can also size it as big as\n                        you want. {\"\\n\\n\"}It also does not have to be sticky.\n                    </div>\n                }\n            />\n        </BeautifulWrapper>\n    );\n};\n(RightElement as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16_807) % 2_147_483_647);\n}\n\nexport const RapidUpdates: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, getCellsForSelection } = useMockDataGenerator(100);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const countRef = React.useRef(0);\n    const displayCountRef = React.useRef<HTMLElement>(null);\n\n    React.useEffect(() => {\n        let rafID = 0;\n\n        const sendUpdate = () => {\n            const cells: {\n                cell: Item;\n            }[] = [];\n            const now = performance.now();\n            for (let x = 0; x < 5000; x++) {\n                const col = Math.max(10, rand() % 100);\n                const row = rand() % 10_000;\n\n                setCellValueRaw([col, row], {\n                    kind: GridCellKind.Text,\n                    data: x.toString(),\n                    displayData: `${x}k`,\n                    themeOverride:\n                        x % 5 !== 0\n                            ? {\n                                  bgCell: \"#f2fff4\",\n                                  textDark: \"#00d41c\",\n                              }\n                            : {\n                                  bgCell: \"#fff6f6\",\n                                  textDark: \"#d40000\",\n                              },\n                    allowOverlay: true,\n                    lastUpdated: now,\n                });\n                cells.push({ cell: [col, row] });\n            }\n            countRef.current += 5000;\n            if (displayCountRef.current !== null) {\n                displayCountRef.current.textContent = `${countRef.current}`;\n            }\n\n            ref.current?.updateCells(cells);\n\n            rafID = window.requestAnimationFrame(sendUpdate);\n        };\n\n        sendUpdate();\n\n        return () => {\n            cancelAnimationFrame(rafID);\n        };\n    }, [setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Rapid updating\"\n            description={\n                <>\n                    <Description>\n                        Data grid can support many thousands of updates per seconds. The data grid can easily update\n                        data faster than a human can read it, more importantly the faster the data grid can update, the\n                        more time your code can spend doing more valuable work.\n                    </Description>\n                    <MoreInfo>\n                        Updates processed: <KeyName ref={displayCountRef} /> We could do this faster but we wrote a\n                        really crappy data store for this demo which is actually slowing down the data grid.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RapidUpdates as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CopySupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        10,\n        false\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Copy support\"\n            description={\n                <>\n                    <Description>\n                        Large amounts of data can be copied and customized using{\" \"}\n                        <PropName>getCellsForSelection</PropName>.\n                    </Description>\n                    <MoreInfo>The data is copied into a format ready to be pasted into Excel or Google Sheets</MoreInfo>\n                    <textarea\n                        placeholder=\"Copy something below and paste it here...\"\n                        style={{ width: \"100%\", marginBottom: 20, borderRadius: 9, minHeight: 200, padding: 10 }}\n                    />\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                rowMarkers=\"both\"\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={400}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CopySupport as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const PasteSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        50,\n        false\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Paste support\"\n            description={\n                <>\n                    <Description>\n                        The data grid can handle paste automatically by returning true from <PropName>onPaste</PropName>\n                        . You can also return false and handle paste yourself. If paste is undefined the DataEditor will\n                        do its best to paste to the current cell.\n                    </Description>\n                    <MoreInfo>\n                        Paste supports the copy format of Google Sheets and Excel. Below is an example of data copied\n                        from excel with some escaped text.\n                    </MoreInfo>\n                    <textarea\n                        value={`Sunday\tDogs\thttps://google.com\nMonday\tCats\thttps://google.com\nTuesday\tTurtles\thttps://google.com\nWednesday\tBears\thttps://google.com\nThursday\t\"L  ions\"\thttps://google.com\nFriday\tPigs\thttps://google.com\nSaturday\t\"Turkeys and some \"\"quotes\"\" and\na new line char \"\"more quotes\"\" plus a tab  .\"\thttps://google.com`}\n                        style={{ width: \"100%\", marginBottom: 20, borderRadius: 9, minHeight: 200, padding: 10 }}\n                    />\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                rowMarkers=\"both\"\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                onPaste={true}\n                rows={400}\n            />\n        </BeautifulWrapper>\n    );\n};\n(PasteSupport as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const FreezeColumns: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\n\n    return (\n        <BeautifulWrapper\n            title=\"Freeze columns\"\n            description={\n                <Description>\n                    Columns at the start of your grid can be frozen in place by settings{\" \"}\n                    <PropName>freezeColumns</PropName> to a number greater than 0.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"both\"\n                freezeColumns={1}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                verticalBorder={c => c > 0}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(FreezeColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ReorderRows: React.VFC = () => {\n    const cols = React.useMemo<GridColumn[]>(\n        () => [\n            {\n                title: \"Col A\",\n                width: 150,\n            },\n            {\n                title: \"Col B\",\n                width: 150,\n            },\n        ],\n        []\n    );\n\n    const [rowData, setRowData] = React.useState(() => {\n        return range(0, 50).map(x => [`A: ${x}`, `B: ${x}`]);\n    });\n\n    const getCellContent = React.useCallback<DataEditorProps[\"getCellContent\"]>(\n        ([col, row]) => {\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: false,\n                data: rowData[row][col],\n                displayData: rowData[row][col],\n            };\n        },\n        [rowData]\n    );\n\n    const reorderRows = React.useCallback((from: number, to: number) => {\n        setRowData(cv => {\n            const d = [...cv];\n            const removed = d.splice(from, 1);\n            d.splice(to, 0, ...removed);\n            return d;\n        });\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Reorder Rows\"\n            description={\n                <>\n                    <Description>\n                        Rows can be re-arranged by using the <PropName>onRowMoved</PropName> callback. When set the\n                        first row can be used to drag and drop.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={\"both\"}\n                onRowMoved={reorderRows}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={50}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ReorderRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ColumnGroups: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(20, true, true);\n\n    return (\n        <BeautifulWrapper\n            title=\"Column Grouping\"\n            description={\n                <Description>\n                    Columns in the data grid may be grouped by setting their <PropName>group</PropName> property.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                onGroupHeaderRenamed={(x, y) => window.alert(`Please rename group ${x} to ${y}`)}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rows={1000}\n                getGroupDetails={g => ({\n                    name: g,\n                    icon: g === \"\" ? undefined : GridColumnIcon.HeaderCode,\n                })}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(ColumnGroups as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const StretchColumnSize: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection, onColumnResize } = useMockDataGenerator(5, true, true);\n\n    const hasResized = React.useRef(new Set<number>());\n\n    const columns = React.useMemo(() => {\n        return cols.map((x, i) => ({ ...x, grow: hasResized.current.has(i) ? undefined : (5 + i) / 5 }));\n    }, [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Column Grow\"\n            description={\n                <Description>\n                    Columns in the data grid may be set to grow to fill space by setting the <PropName>grow</PropName>{\" \"}\n                    prop.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columns}\n                getCellsForSelection={getCellsForSelection}\n                rows={1000}\n                onColumnResize={(col, _newSize, colIndex, newSizeWithGrow) => {\n                    hasResized.current.add(colIndex);\n                    onColumnResize(col, newSizeWithGrow);\n                }}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(StretchColumnSize as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nfunction useCollapsableColumnGroups(cols: readonly GridColumn[]) {\n    const [collapsed, setCollapsed] = React.useState<readonly string[]>([]);\n\n    const onGroupHeaderClicked = React.useCallback(\n        (colIndex: number, args: GroupHeaderClickedEventArgs) => {\n            const group = cols[colIndex].group ?? \"\";\n            setCollapsed(cv => (cv.includes(group) ? cv.filter(g => g !== group) : [...cv, group]));\n            args.preventDefault();\n        },\n        [cols]\n    );\n\n    const [selectedColumns, setSelectedColumns] = React.useState<CompactSelection>(CompactSelection.empty());\n\n    const setCols = React.useCallback((newVal: CompactSelection, trigger: string) => {\n        if (trigger === \"group\") return;\n\n        setSelectedColumns(newVal);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        return cols.map(c => {\n            if (!collapsed.includes(c.group ?? \"\"))\n                return {\n                    ...c,\n                    hasMenu: true,\n                };\n            return {\n                ...c,\n                width: 8,\n                hasMenu: true,\n            };\n        });\n    }, [collapsed, cols]);\n\n    return {\n        columns,\n        onGroupHeaderClicked,\n        selectedColumns,\n        onSelectedColumnsChange: setCols,\n    };\n}\n\nexport const ColumnGroupCollapse: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const groupHeaderArgs = useCollapsableColumnGroups(cols);\n\n    return (\n        <BeautifulWrapper\n            title=\"Group collapse\"\n            description={\n                <>\n                    <Description>\n                        Through clever usage of <PropName>onGroupHeaderClicked</PropName> you can implement group\n                        collapsing. This is a very basic version however it is possible to go much further.\n                    </Description>\n                    <MoreInfo>Cells under a certain size will not attempt to render to save some frames.</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                {...groupHeaderArgs}\n                getCellContent={getCellContent}\n                groupHeaderHeight={24}\n                rows={1000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(ColumnGroupCollapse as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const Minimap: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <BeautifulWrapper\n            title=\"Minimap\"\n            description={\n                <Description>\n                    A minimap can be enabled by setting the <PropName>showMinimap</PropName> property.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                showMinimap={true}\n                rows={3000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(Minimap as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ContentAlignment: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, _row] = cell;\n            if (col === 3) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"center\",\n                };\n            }\n            if (col === 4) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"right\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Content Alignment\"\n            description={\n                <Description>\n                    You can customize the content alignment by setting <PropName>contentAlign</PropName> of a cell to{\" \"}\n                    <PropName>left</PropName>, <PropName>right</PropName> or <PropName>center</PropName>.\n                </Description>\n            }>\n            <DataEditor {...defaultProps} getCellContent={mangledGetCellContent} columns={cols} rows={300} />\n        </BeautifulWrapper>\n    );\n};\n\nexport const RowHover: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const [hoverRow, setHoverRow] = React.useState<number | undefined>(undefined);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        const [_, row] = args.location;\n        setHoverRow(args.kind !== \"cell\" ? undefined : row);\n    }, []);\n\n    const getRowThemeOverride = React.useCallback<GetRowThemeCallback>(\n        row => {\n            if (row !== hoverRow) return undefined;\n            return {\n                bgCell: \"#f7f7f7\",\n                bgCellMedium: \"#f0f0f0\",\n            };\n        },\n        [hoverRow]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Row Hover Effect\"\n            description={\n                <Description>\n                    Through careful usage of the <PropName>onItemHovered</PropName> callback it is possible to easily\n                    create a row hover effect.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"both\"\n                onItemHovered={onItemHovered}\n                getCellContent={getCellContent}\n                getRowThemeOverride={getRowThemeOverride}\n                columns={cols}\n                rows={300}\n            />\n        </BeautifulWrapper>\n    );\n};\n\nexport const SpanCell: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, row] = cell;\n            if (row === 6 && col >= 3 && col <= 4) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [3, 4],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            if (row === 5) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [0, 99],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (selection: Rectangle): CellArray => {\n            const result: GridCell[][] = [];\n\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\n                const row: GridCell[] = [];\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\n                    row.push(mangledGetCellContent([x, y]));\n                }\n                result.push(row);\n            }\n\n            return result;\n        },\n        [mangledGetCellContent]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Spans\"\n            description={\n                <Description>\n                    By setting the <PropName>span</PropName> of a cell you can create spans in your grid. All cells\n                    within a span must return consistent data for defined behavior.\n                    <MoreInfo>\n                        Spans will always be split if they span frozen and non-frozen columns. By default selections are\n                        always expanded to include a span. This can be disabled using the{\" \"}\n                        <PropName>spanRangeBehavior</PropName> prop.\n                    </MoreInfo>\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={mangledGetCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                freezeColumns={2}\n                rows={300}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(SpanCell as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nconst zeroBounds = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n};\n\nexport const Tooltips: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [tooltip, setTooltip] = React.useState<{ val: string; bounds: IBounds } | undefined>();\n\n    const timeoutRef = React.useRef(0);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        if (args.kind === \"cell\") {\n            window.clearTimeout(timeoutRef.current);\n            setTooltip(undefined);\n            timeoutRef.current = window.setTimeout(() => {\n                setTooltip({\n                    val: `Tooltip for ${args.location[0]}, ${args.location[1]}`,\n                    bounds: {\n                        // translate to react-laag types\n                        left: args.bounds.x,\n                        top: args.bounds.y,\n                        width: args.bounds.width,\n                        height: args.bounds.height,\n                        right: args.bounds.x + args.bounds.width,\n                        bottom: args.bounds.y + args.bounds.height,\n                    },\n                });\n            }, 1000);\n        } else {\n            window.clearTimeout(timeoutRef.current);\n            timeoutRef.current = 0;\n            setTooltip(undefined);\n        }\n    }, []);\n\n    React.useEffect(() => () => window.clearTimeout(timeoutRef.current), []);\n\n    const isOpen = tooltip !== undefined;\n    const { renderLayer, layerProps } = useLayer({\n        isOpen,\n        triggerOffset: 4,\n        auto: true,\n        container: \"portal\",\n        trigger: {\n            getBounds: () => tooltip?.bounds ?? zeroBounds,\n        },\n    });\n\n    return (\n        <>\n            <BeautifulWrapper\n                title=\"Tooltips\"\n                className=\"double\"\n                description={\n                    <Description>\n                        Using the <PropName>onItemHovered</PropName> event makes it easy to create tooltips. This story\n                        is intentionally forced to scroll vertically so layout in scrolling documents can be confirmed.\n                    </Description>\n                }>\n                <DataEditor\n                    {...defaultProps}\n                    onItemHovered={onItemHovered}\n                    getCellContent={getCellContent}\n                    columns={cols}\n                    rows={1000}\n                />\n            </BeautifulWrapper>\n            {isOpen &&\n                renderLayer(\n                    <div\n                        {...layerProps}\n                        style={{\n                            ...layerProps.style,\n                            padding: \"8px 12px\",\n                            color: \"white\",\n                            font: \"500 13px Inter\",\n                            backgroundColor: \"rgba(0, 0, 0, 0.85)\",\n                            borderRadius: 9,\n                        }}>\n                        {tooltip.val}\n                    </div>\n                )}\n        </>\n    );\n};\n(Tooltips as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ControlledSelection: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(30, true, true);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    return (\n        <BeautifulWrapper\n            title=\"Controlled Selection\"\n            description={\n                <Description>\n                    The selection of the grid can be controlled via <PropName>GridSelection</PropName> and{\" \"}\n                    <PropName>onGridSelectionChange</PropName>.\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={29}\n                        value={selection.current?.cell[0] ?? 0}\n                        onChange={e => {\n                            const newCol = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [newCol, cv.current?.cell[1] ?? 0],\n                                    range: {\n                                        x: newCol,\n                                        y: cv.current?.cell[1] ?? 0,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={99}\n                        value={selection.current?.cell[1] ?? 0}\n                        onChange={e => {\n                            const newRow = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [cv.current?.cell[0] ?? 0, newRow],\n                                    range: {\n                                        x: cv.current?.cell[0] ?? 0,\n                                        y: newRow,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                gridSelection={selection}\n                onGridSelectionChange={setSelection}\n                columns={cols}\n                rows={100}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n\nexport const NewColumnButton: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(10, true);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"New column button\"\n            description={\n                <Description>\n                    A new column button can be created using the <PropName>rightElement</PropName>.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columns}\n                rightElement={\n                    <ColumnAddButton>\n                        <button onClick={() => window.alert(\"Add a column!\")}>+</button>\n                    </ColumnAddButton>\n                }\n                rightElementProps={{\n                    fill: false,\n                    sticky: false,\n                }}\n                rows={3000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n\nexport const CustomHeader: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    const drawHeader: DrawHeaderCallback = React.useCallback(args => {\n        const { ctx, rect } = args;\n        ctx.rect(rect.x, rect.y, rect.width, rect.height);\n        const lg = ctx.createLinearGradient(0, rect.y, 0, rect.y + rect.height);\n        lg.addColorStop(0, \"#ff00d934\");\n        lg.addColorStop(1, \"#00a2ff34\");\n        ctx.fillStyle = lg;\n        ctx.fill();\n        return false;\n    }, []);\n\n    return (\n        <BeautifulWrapper title=\"Custom Header\" description={<Description>Make it as fancy as you like.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                drawHeader={drawHeader}\n                rows={3000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomHeader as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface PaddingProps {\n    paddingRight: number;\n    paddingBottom: number;\n}\n\nexport const Padding: React.VFC<PaddingProps> = p => {\n    const { paddingRight, paddingBottom } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <BeautifulWrapper\n            title=\"Padding\"\n            description={\n                <>\n                    <Description>\n                        You can add padding at the ends of the grid by setting the <PropName>paddingRight</PropName> and{\" \"}\n                        <PropName>paddingBottom</PropName> props\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                experimental={{ paddingRight, paddingBottom }}\n                rows={50}\n            />\n        </BeautifulWrapper>\n    );\n};\n(Padding as any).argTypes = {\n    paddingRight: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    paddingBottom: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Padding as any).args = {\n    paddingRight: 200,\n    paddingBottom: 200,\n};\n(Padding as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const HighlightCells: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\n\n    const [gridSelection, setGridSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const highlights = React.useMemo<DataEditorProps[\"highlightRegions\"]>(() => {\n        if (gridSelection.current === undefined) return undefined;\n        const [col, row] = gridSelection.current.cell;\n        return [\n            {\n                color: \"#44BB0022\",\n                range: {\n                    x: col + 2,\n                    y: row,\n                    width: 10,\n                    height: 10,\n                },\n                style: \"solid\",\n            },\n            {\n                color: \"#b000b021\",\n                range: {\n                    x: col,\n                    y: row + 2,\n                    width: 1,\n                    height: 1,\n                },\n            },\n        ];\n    }, [gridSelection]);\n\n    return (\n        <BeautifulWrapper\n            title=\"HighlightCells\"\n            description={\n                <Description>\n                    The <PropName>highlightRegions</PropName> prop can be set to provide additional hinting or context\n                    for the current selection.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"both\"\n                freezeColumns={1}\n                highlightRegions={highlights}\n                gridSelection={gridSelection}\n                onGridSelectionChange={setGridSelection}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                verticalBorder={c => c > 0}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(HighlightCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const LayoutIntegration: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <BeautifulStyle>\n            <h1>Layout Integration</h1>\n            <Description>Trying the grid in different situations</Description>\n            <DataEditor\n                {...defaultProps}\n                className=\"white\"\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10}\n                rowMarkers=\"both\"\n                height={200}\n            />\n            <DataEditor\n                {...defaultProps}\n                className=\"white\"\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10}\n                rowMarkers=\"both\"\n            />\n            <div style={{ display: \"flex\", height: \"300px\" }}>\n                <DataEditor\n                    {...defaultProps}\n                    className=\"white\"\n                    getCellContent={getCellContent}\n                    columns={cols}\n                    rows={10}\n                    rowMarkers=\"both\"\n                />\n                <div style={{ flexShrink: 0 }}>This is some text what happens here?</div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n(LayoutIntegration as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const DragSource: React.VFC<{ isDraggable: boolean | \"header\" | \"cell\" }> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(200);\n\n    return (\n        <BeautifulWrapper\n            title=\"Drag source\"\n            description={\n                <>\n                    <Description>\n                        Setting the <PropName>isDraggable</PropName> prop can allow for more granular control over what\n                        is draggable in the grid via HTML drag and drop.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers=\"both\"\n                rows={5000}\n                onRowMoved={(s, e) => window.alert(`Moved row ${s} to ${e}`)}\n                onColumnMoved={(s, e) => window.alert(`Moved col ${s} to ${e}`)}\n                onColumnResize={onColumnResize}\n                isDraggable={p.isDraggable}\n                onDragStart={e => {\n                    e.setData(\"text/plain\", \"Drag data here!\");\n                }}\n            />\n        </BeautifulWrapper>\n    );\n};\n(DragSource as any).argTypes = {\n    isDraggable: {\n        control: { type: \"select\", options: [true, false, \"cell\", \"header\"] },\n    },\n};\n(DragSource as any).args = {\n    isDraggable: false,\n};\n(DragSource as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const PreventDiagonalScroll: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(200);\n\n    return (\n        <BeautifulWrapper\n            title=\"Prevent Diagonal Scroll\"\n            description={\n                <>\n                    <Description>\n                        Diagonal scrolling can be prevented by setting <PropName>preventDiagonalScrolling</PropName>.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                preventDiagonalScrolling={true}\n                rows={5000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(PreventDiagonalScroll as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\n// A few supported mime types for drag and drop into cells.\nconst SUPPORTED_IMAGE_TYPES = new Set([\"image/png\", \"image/gif\", \"image/bmp\", \"image/jpeg\"]);\n\nexport const DropEvents: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [highlights, setHighlights] = React.useState<DataEditorProps[\"highlightRegions\"]>([]);\n\n    const [lastDropCell, setLastDropCell] = React.useState<Item | undefined>();\n\n    const onDrop = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            setHighlights([]);\n\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { files } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (files.length !== 1) {\n                return;\n            }\n\n            const [file] = files;\n            if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {\n                return;\n            }\n\n            const imgUrl = URL.createObjectURL(file);\n\n            setCellValue(\n                cell,\n                {\n                    kind: GridCellKind.Image,\n                    data: [imgUrl],\n                    allowOverlay: true,\n                    allowAdd: false,\n                },\n                true,\n                true\n            );\n\n            setLastDropCell(cell);\n        },\n        [setCellValue]\n    );\n\n    const onDragOverCell = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { items } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (items.length !== 1) {\n                return;\n            }\n\n            const [item] = items;\n            if (!SUPPORTED_IMAGE_TYPES.has(item.type)) {\n                return;\n            }\n\n            const [col, row] = cell;\n            if (getCellContent(cell).kind === GridCellKind.Image) {\n                setHighlights([\n                    {\n                        color: \"#44BB0022\",\n                        range: {\n                            x: col,\n                            y: row,\n                            width: 1,\n                            height: 1,\n                        },\n                    },\n                ]);\n            } else {\n                setHighlights([]);\n            }\n        },\n        [getCellContent]\n    );\n\n    const onDragLeave = React.useCallback(() => {\n        setHighlights([]);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Drop events\"\n            description={\n                <>\n                    <Description>\n                        You can drag and drop into cells by using <PropName>onDragOverCell</PropName> and{\" \"}\n                        <PropName>onDrop</PropName>.\n                    </Description>\n\n                    <div>\n                        {lastDropCell === undefined ? (\n                            <MoreInfo>Nothing dropped, yet</MoreInfo>\n                        ) : (\n                            <>\n                                <MoreInfo>\n                                    You last dropped in cell <PropName>{JSON.stringify(lastDropCell)}</PropName>\n                                </MoreInfo>\n                            </>\n                        )}\n                    </div>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n                onDrop={onDrop}\n                onDragOverCell={onDragOverCell}\n                onDragLeave={onDragLeave}\n                highlightRegions={highlights}\n                rowMarkers=\"none\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(DropEvents as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { useState, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport { GridCell, GridCellKind, Item } from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\nimport { styled } from \"@linaria/react\";\n\nexport default {\n    title: \"Tests/TestCases/Bugs\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nconst bug70Gen = ([, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Number,\n    data: row,\n    displayData: row.toString(),\n});\n\nconst ignore = () => undefined;\n\nconst Bug70Style = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    > a {\n        margin-bottom: 20px;\n    }\n`;\n\nexport function Bug70() {\n    const cols = [\n        { title: \"Col1\", width: 100 },\n        { title: \"Col2\", width: 100 },\n    ];\n\n    return (\n        <Bug70Style className=\"App\">\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\n            <a href=\"https://github.com/glideapps/glide-data-grid/issues/70\" target=\"_blank\" rel=\"noreferrer\">\n                Original report\n            </a>\n            <DataEditor\n                width={500}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={bug70Gen}\n                onCellEdited={ignore}\n            />\n        </Bug70Style>\n    );\n}\n\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Text,\n    data: `${col} - ${row}`,\n    displayData: `${col} - ${row}`,\n});\n\nconst filteringColumns = [\n    { title: \"Col AAAA\", width: 120 },\n    { title: \"Col AAA\", width: 120 },\n    { title: \"Col AA\", width: 120 },\n    { title: \"Col A\", width: 120 },\n    { title: \"Col\", width: 120 },\n];\n\nexport function FilterColumns() {\n    const [searchText, setSearchText] = useState(\"\");\n\n    const cols = useMemo(() => {\n        if (searchText === \"\") {\n            return filteringColumns;\n        }\n\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\n    }, [searchText]);\n\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setSearchText(e.target.value);\n    };\n\n    return (\n        <div>\n            <input value={searchText} onChange={onInputChange} />\n            <DataEditor\n                width={1000}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={filterColumnsGen}\n                smoothScrollX={true}\n                smoothScrollY={true}\n            />\n        </div>\n    );\n}\n","/* eslint-disable sonarjs/no-identical-functions */\nimport * as React from \"react\";\n\nimport { useState, useCallback, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport {\n    CompactSelection,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridSelection,\n    Item,\n} from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\n\nexport default {\n    title: \"Tests/TestCases\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nfunction getDummyData([col, row]: Item): GridCell {\n    if (col === 0) {\n        return {\n            kind: GridCellKind.RowID,\n            data: `RowID ${col}, ${row}`,\n            allowOverlay: false,\n        };\n    }\n    if (col === 1) {\n        return {\n            kind: GridCellKind.Bubble,\n            data: [\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n                `Bub ${col}`,\n                `Bub ${row}`,\n            ],\n            allowOverlay: true,\n        };\n    }\n    if (col === 2) {\n        return {\n            kind: GridCellKind.Image,\n            data: [\n                \"https://i.imgur.com/5J0BftG.jpg\",\n                \"https://preview.redd.it/7jlqkp2cyap51.jpg?width=575&auto=webp&s=26fa9ed15b16fb450ee08ed1f2f0ccb5e0223581\",\n            ],\n            allowOverlay: true,\n            allowAdd: true,\n        };\n    }\n    if (col === 3) {\n        return {\n            kind: GridCellKind.Markdown,\n            data: `## Markdown has titles\n\nAnd supports newline chars and automatic wrapping text that just needs to be long enough to trigger it.\n\n\n[Google](https://google.com)\n\n- with\n- lists\n- that\n- can\n- be\n- pretty\n- long\n                    `,\n            allowOverlay: true,\n        };\n    }\n    if (col === 4) {\n        return {\n            kind: GridCellKind.Number,\n            displayData: \"$10,352\",\n            allowOverlay: true,\n            data: 10_352,\n            readonly: true,\n        };\n    }\n    if (col === 5) {\n        return {\n            kind: GridCellKind.Uri,\n            data: \"https://www.google.com\",\n            allowOverlay: true,\n        };\n    }\n    if (col === 6) {\n        return {\n            kind: GridCellKind.Boolean,\n            data: row % 3 === 0 || row % 5 === 0,\n            readonly: true,\n            allowOverlay: false,\n        };\n    }\n    if (col === 7) {\n        return {\n            kind: GridCellKind.Text,\n            // RTL test\n            displayData: ` `,\n            data: ` `,\n            allowOverlay: true,\n            readonly: true,\n        };\n    }\n    if (col === 8) {\n        return {\n            kind: GridCellKind.Drilldown,\n            data: [\n                {\n                    text: \"Test\",\n                    img: \"https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg\",\n                },\n                { text: \"No Image\" },\n            ],\n            allowOverlay: true,\n        };\n    }\n    return {\n        kind: GridCellKind.Text,\n        displayData: `${col}, ${row} `,\n        data: `${col}, ${row} `,\n        allowOverlay: true,\n    };\n}\n\nfunction getDummyCols() {\n    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].map(\n        i =>\n            ({\n                title: i.toString() + \" is the longest header in the world\",\n                width: 120 + (i % 4) * 10,\n                icon: \"headerString\",\n                hasMenu: true,\n            } as GridColumn)\n    );\n}\n\nexport function Simplenotest() {\n    const [cols, setColumns] = useState(getDummyCols);\n\n    const onColumnResize = useCallback(\n        (col: GridColumn, newSize: number) => {\n            const index = cols.indexOf(col);\n            const newCols = [...cols];\n            newCols[index] = {\n                ...newCols[index],\n                width: newSize,\n            };\n            setColumns(newCols);\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            getCellsForSelection={true}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n        />\n    );\n}\n\nfunction getDummyRelationColumn(): GridColumn[] {\n    return [\n        {\n            title: \"Relation\",\n            width: 360,\n            icon: \"headerString\",\n            hasMenu: true,\n        },\n    ];\n}\n\nfunction getDummyRelationData([col, row]: Item): GridCell {\n    return {\n        kind: GridCellKind.Drilldown,\n        data: [\n            {\n                text: `Image ${col}-${row}`,\n                img: \"https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg\",\n            },\n            { text: `Text ${col}-${row}` },\n            { text: `More text ${col}-${row}` },\n        ],\n        allowOverlay: true,\n    };\n}\n\nexport function RelationColumn() {\n    const [cols, setColumns] = useState(getDummyRelationColumn);\n\n    const onColumnResize = useCallback(\n        (col: GridColumn, newSize: number) => {\n            const index = cols.indexOf(col);\n            const newCols = [...cols];\n            newCols[index] = {\n                ...newCols[index],\n                width: newSize,\n            };\n            setColumns(newCols);\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyRelationData}\n            columns={cols}\n            rows={1000}\n            onColumnResize={onColumnResize}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n}\n\nconst columns: GridColumn[] = [\n    { title: \"Number\", width: 100, icon: \"headerArray\", overlayIcon: \"rowOwnerOverlay\" },\n    { title: \"Square\", width: 100 },\n];\n\nfunction getData([col, row]: Item): GridCell {\n    const n = Math.pow(row, col + 1);\n\n    return {\n        kind: GridCellKind.Number,\n        data: n,\n        displayData: n.toString(),\n        allowOverlay: false,\n    };\n}\n\nexport function Minimal() {\n    return <DataEditor width=\"100%\" getCellContent={getData} columns={columns} rows={1000} />;\n}\n\nexport function Smooth() {\n    const [cols, setCols] = useState(getDummyCols);\n\n    const onColumnResize = useCallback(\n        (column: GridColumn, newSize: number) => {\n            const index = cols.indexOf(column);\n            if (index !== -1) {\n                const newCol: GridColumn = {\n                    ...column,\n                    width: newSize,\n                };\n\n                const newCols = [...cols];\n                newCols.splice(index, 1, newCol);\n\n                setCols(newCols);\n            }\n        },\n        [cols]\n    );\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            onColumnResize={onColumnResize}\n            columns={cols}\n            rows={1000}\n            smoothScrollY={true}\n            smoothScrollX={true}\n        />\n    );\n}\n\nexport function ManualControl() {\n    const [gridSelection, setGridSelection] = useState<GridSelection | undefined>(undefined);\n\n    const cb = (newVal: GridSelection) => {\n        if ((newVal.current?.cell[0] ?? 0) % 2 === 0) {\n            setGridSelection(newVal);\n        }\n    };\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            gridSelection={gridSelection}\n            onGridSelectionChange={cb}\n            getCellContent={getData}\n            columns={columns}\n            rows={1000}\n        />\n    );\n}\n\nexport function Draggable() {\n    return (\n        <DataEditor\n            width=\"100%\"\n            isDraggable={true}\n            onDragStart={args => {\n                args.setData(\"text\", \"testing\");\n            }}\n            getCellContent={getData}\n            columns={columns}\n            rows={1000}\n        />\n    );\n}\n\nexport function IdealSize() {\n    // trying to be 500x500\n    const cols: GridColumn[] = [\n        { title: \"Number\", width: 250 },\n        { title: \"Square\", width: 250 },\n    ];\n    return (\n        <div style={{ width: 500, height: 500, position: \"relative\" }}>\n            <DataEditor\n                width={500}\n                height={500}\n                isDraggable={true}\n                onDragStart={args => {\n                    args.setData(\"text\", \"testing\");\n                }}\n                getCellContent={getData}\n                columns={cols}\n                smoothScrollX={true}\n                smoothScrollY={true}\n                rowHeight={50}\n                headerHeight={50}\n                rows={9}\n            />\n        </div>\n    );\n}\n\nexport function DynamicAddRemoveColumns({ columnCount }: { columnCount: number }) {\n    // trying to be 500x500\n    const cols: GridColumn[] = [\n        { title: \"Number\", width: 250 },\n        { title: \"Square\", width: 250 },\n    ];\n\n    for (let i = 2; i < columnCount; i++) {\n        cols.push({\n            title: \"Foo\",\n            width: 250,\n        });\n    }\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            isDraggable={true}\n            getCellContent={getData}\n            columns={cols}\n            smoothScrollX={true}\n            smoothScrollY={true}\n            rowHeight={50}\n            headerHeight={50}\n            rows={9}\n        />\n    );\n}\nDynamicAddRemoveColumns.args = {\n    columnCount: 2,\n};\n\nexport function GridSelectionOutOfRangeNoColumns() {\n    const dummyCols = useMemo(\n        () => getDummyCols().map(v => ({ ...v, width: 300, title: \"Making column smaller used to crash!\" })),\n        []\n    );\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const [cols, setCols] = useState(dummyCols);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n            onColumnResize={(_col, newSize) => {\n                if (newSize > 300) {\n                    setCols(dummyCols);\n                } else {\n                    setCols([]);\n                }\n            }}\n        />\n    );\n}\n\ntype ResizableColumnsSizeMap = Record<string, number>;\n\nfunction getResizableColumnsInitSize(): ResizableColumnsSizeMap {\n    return {\n        \"resize me 0\": 120,\n        \"resize me 1\": 120,\n        \"resize me 2\": 120,\n        \"resize me 3\": 120,\n        \"resize me 4\": 120,\n        \"resize me 5\": 120,\n        \"resize me 6\": 120,\n        \"resize me 7\": 120,\n    };\n}\n\nfunction getResizableColumns(sizeMap: ResizableColumnsSizeMap): GridColumn[] {\n    return Object.entries(sizeMap).map(([title, width]) => ({\n        title,\n        width,\n        icon: \"headerString\",\n        hasMenu: true,\n    }));\n}\n\nexport function ResizableColumns() {\n    const [colSizes, setColSizes] = useState(getResizableColumnsInitSize);\n\n    const cols = useMemo(() => {\n        return getResizableColumns(colSizes);\n    }, [colSizes]);\n\n    const onColumnResize = useCallback((column: GridColumn, newSize: number) => {\n        setColSizes(prevColSizes => {\n            return {\n                ...prevColSizes,\n                [column.title]: newSize,\n            };\n        });\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={20}\n            isDraggable={false}\n            smoothScrollX={true}\n            smoothScrollY={true}\n            onColumnResize={onColumnResize}\n        />\n    );\n}\n\nexport function GridSelectionOutOfRangeLessColumnsThanSelection() {\n    const dummyCols = useMemo(\n        () => getDummyCols().map(v => ({ ...v, width: 300, title: \"Making column smaller used to crash!\" })),\n        []\n    );\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const [cols, setCols] = useState(dummyCols);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n            onColumnResize={(_col, newSize) => {\n                if (newSize > 300) {\n                    setCols(dummyCols);\n                } else {\n                    setCols([dummyCols[0]]);\n                }\n            }}\n        />\n    );\n}\n\nexport function GridAddNewRows() {\n    const cols = useMemo(getDummyCols, []);\n\n    const [rowsCount, setRowsCount] = useState(10);\n\n    const onRowAppended = useCallback(() => {\n        setRowsCount(r => r + 1);\n    }, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>(undefined);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={rowsCount}\n            onRowAppended={onRowAppended}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport function GridNoTrailingBlankRow() {\n    const cols = useMemo(getDummyCols, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>(undefined);\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={getDummyData}\n            columns={cols}\n            rows={100}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport function MarkdownEdits() {\n    const dummyCols: GridColumn[] = useMemo(() => {\n        return [\n            {\n                title: \"MD short\",\n                width: 50,\n            },\n            {\n                title: \"MD long\",\n                width: 50,\n            },\n        ];\n    }, []);\n\n    const dummyCells = useCallback(([col, _row]: Item) => {\n        if (col === 0) {\n            const editable: EditableGridCell = {\n                data: \"text\",\n                allowOverlay: true,\n                kind: GridCellKind.Markdown,\n            };\n            return editable;\n        } else if (col === 1) {\n            const editable: EditableGridCell = {\n                data: `text really really really long\n## H1\n\n- this\n- is\n- a\n- longer\n- example\n- to\n- test\n- scroll\n- of\n- preview\n                `,\n                allowOverlay: true,\n                kind: GridCellKind.Markdown,\n            };\n            return editable;\n        }\n        const editable: EditableGridCell = {\n            data: \"text\",\n            allowOverlay: true,\n            kind: GridCellKind.Markdown,\n        };\n        return editable;\n    }, []);\n\n    const [selected, setSelected] = useState<GridSelection | undefined>({\n        current: { cell: [2, 8], range: { width: 1, height: 1, x: 2, y: 8 }, rangeStack: [] },\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const onSelected = useCallback((newSel?: GridSelection) => {\n        setSelected(newSel);\n    }, []);\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            getCellContent={dummyCells}\n            columns={dummyCols}\n            rows={1000}\n            onGridSelectionChange={onSelected}\n            gridSelection={selected}\n        />\n    );\n}\n\nexport const CanEditBoolean = () => {\n    const [vals, setVals] = useState<[boolean | null | undefined, boolean | null | undefined]>([false, false]);\n    return (\n        <DataEditor\n            width=\"100%\"\n            columns={[\n                {\n                    title: \"Editable\",\n                    width: 100,\n                },\n                {\n                    title: \"Readonly\",\n                    width: 100,\n                },\n            ]}\n            rows={1}\n            getCellContent={([col]) => {\n                return {\n                    kind: GridCellKind.Boolean,\n                    readonly: col !== 0,\n                    allowOverlay: false,\n                    data: vals[col],\n                };\n            }}\n            onCellEdited={([col], newVal) => {\n                if (newVal.kind === GridCellKind.Boolean) {\n                    setVals(cv => {\n                        const f = [...cv];\n                        f.splice(col, 1, newVal.data);\n                        return f as [boolean, boolean];\n                    });\n                }\n            }}\n        />\n    );\n};\n\nexport const SimpleEditable = () => {\n    const [vals, setVals] = useState<[string, string][]>(() => {\n        const result: [string, string][] = [];\n        for (let i = 0; i < 2000; i++) {\n            result.push([\"Edit\", \"Me\"]);\n        }\n        return result;\n    });\n\n    return (\n        <DataEditor\n            width=\"100%\"\n            columns={[\n                {\n                    title: \"Column A\",\n                    width: 250,\n                },\n                {\n                    title: \"Column B\",\n                    width: 250,\n                },\n            ]}\n            rows={vals.length}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: vals[row][col],\n                displayData: vals[row][col],\n            })}\n            onCellEdited={([col, row], newVal) => {\n                const newVals = [...vals];\n                const newRow: [string, string] = [...newVals[row]];\n                if (typeof newVal.data === \"string\") {\n                    newRow[col] = newVal.data;\n                }\n                newVals[row] = newRow;\n                setVals(newVals);\n            }}\n        />\n    );\n};\n","import * as React from \"react\";\n\nimport {\n    CellArray,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridColumnIcon,\n    isEditableGridCell,\n    isTextEditableGridCell,\n    Item,\n    Rectangle,\n} from \"../../data-grid/data-grid-types\";\n\nimport faker from \"faker\";\nimport { styled } from \"@linaria/react\";\nimport isArray from \"lodash/isArray.js\";\nimport { assertNever } from \"../../common/support\";\nimport { browserIsFirefox } from \"../../common/browser-detect\";\nimport { useResizeDetector } from \"react-resize-detector\";\n\nfaker.seed(1337);\n\nfunction isTruthy(x: any): boolean {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    return x ? true : false;\n}\n\n/**\n * Attempts to copy data between grid cells of any kind.\n */\nexport function lossyCopyData<T extends EditableGridCell>(source: EditableGridCell, target: T): EditableGridCell {\n    const sourceData = source.data;\n    if (typeof sourceData === typeof target.data) {\n        return {\n            ...target,\n            data: sourceData as any,\n        };\n    } else\n        switch (target.kind) {\n            case GridCellKind.Uri: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0],\n                    };\n                }\n                return {\n                    ...target,\n                    data: sourceData?.toString() ?? \"\",\n                };\n            }\n            case GridCellKind.Boolean: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0] !== undefined,\n                    };\n                } else if (source.kind === GridCellKind.Boolean) {\n                    return {\n                        ...target,\n                        data: source.data,\n                    };\n                }\n                return {\n                    ...target,\n                    data: isTruthy(sourceData) ? true : false,\n                };\n            }\n            case GridCellKind.Image: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: [sourceData[0]],\n                    };\n                }\n                return {\n                    ...target,\n                    data: [sourceData?.toString() ?? \"\"],\n                };\n            }\n            case GridCellKind.Number: {\n                return {\n                    ...target,\n                    data: 0,\n                };\n            }\n            case GridCellKind.Text:\n            case GridCellKind.Markdown: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0].toString() ?? \"\",\n                    };\n                }\n\n                return {\n                    ...target,\n                    data: source.data?.toString() ?? \"\",\n                };\n            }\n            case GridCellKind.Custom: {\n                return target;\n            }\n            // No default\n        }\n    assertNever(target);\n}\n\nexport type GridColumnWithMockingInfo = GridColumn & {\n    getContent(): GridCell;\n};\n\nexport function getGridColumn(columnWithMock: GridColumnWithMockingInfo): GridColumn {\n    const { getContent, ...rest } = columnWithMock;\n\n    return rest;\n}\n\nexport const ColumnAddButton = styled.div`\n    width: 120px;\n    display: flex;\n    flex-direction: column;\n    background-color: #f1f1f1;\n    height: 100%;\n    button {\n        border: none;\n        outline: none;\n        height: 37px;\n        width: 120px;\n        font-size: 20px;\n        background-color: #f7f7f8;\n        color: #000000dd;\n        border-bottom: 1px solid #e1e2e5;\n\n        transition: background-color 200ms;\n\n        cursor: pointer;\n        :hover {\n            background-color: #efeff1;\n        }\n    }\n`;\n\nexport const BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    &.double {\n        height: 200vh;\n    }\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n\n    &.firefox .sizer {\n        border-radius: 0;\n        box-shadow: unset;\n\n        .sizer-clip {\n            border-radius: 0;\n        }\n    }\n\n    .white {\n        background-color: white;\n    }\n`;\n\nexport const PropName = styled.span`\n    font-family: monospace;\n    font-weight: 500;\n    color: #ffe394;\n`;\n\nexport const Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n    className?: string;\n}\n\nexport const BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description, className } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle className={className + (browserIsFirefox.value ? \" firefox\" : \"\")}>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nfunction createTextColumnInfo(index: number, group: boolean): GridColumnWithMockingInfo {\n    return {\n        title: `Column ${index}`,\n        id: `Column ${index}`,\n        group: group ? `Group ${Math.round(index / 3)}` : undefined,\n        icon: GridColumnIcon.HeaderString,\n        hasMenu: false,\n        getContent: () => {\n            const text = faker.lorem.word();\n\n            return {\n                kind: GridCellKind.Text,\n                data: text,\n                displayData: text,\n                allowOverlay: true,\n                readonly: true,\n            };\n        },\n    };\n}\n\nfunction getResizableColumns(amount: number, group: boolean): GridColumnWithMockingInfo[] {\n    const defaultColumns: GridColumnWithMockingInfo[] = [\n        {\n            title: \"First name\",\n            id: \"First name\",\n            group: group ? \"Name\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const firstName = faker.name.firstName();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: firstName,\n                    data: firstName,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Last name\",\n            id: \"Last name\",\n            group: group ? \"Name\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const lastName = faker.name.lastName();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: lastName,\n                    data: lastName,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Avatar\",\n            id: \"Avatar\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderImage,\n            hasMenu: false,\n            getContent: () => {\n                const n = Math.round(Math.random() * 100);\n                return {\n                    kind: GridCellKind.Image,\n                    data: [`https://picsum.photos/id/${n}/900/900`],\n                    displayData: [`https://picsum.photos/id/${n}/40/40`],\n                    allowOverlay: true,\n                    allowAdd: false,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Email\",\n            id: \"Email\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const email = faker.internet.email();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: email,\n                    data: email,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Title\",\n            id: \"Title\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const company = faker.name.jobTitle();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: company,\n                    data: company,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"More Info\",\n            id: \"More Info\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderUri,\n            hasMenu: false,\n            getContent: () => {\n                const url = faker.internet.url();\n                return {\n                    kind: GridCellKind.Uri,\n                    displayData: url,\n                    data: url,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n    ];\n\n    if (amount < defaultColumns.length) {\n        return defaultColumns.slice(0, amount);\n    }\n\n    const extraColumnsAmount = amount - defaultColumns.length;\n\n    // eslint-disable-next-line unicorn/no-new-array\n    const extraColumns = [...new Array(extraColumnsAmount)].map((_, index) =>\n        createTextColumnInfo(index + defaultColumns.length, group)\n    );\n\n    return [...defaultColumns, ...extraColumns];\n}\n\nexport class ContentCache {\n    // column -> row -> value\n    private cachedContent: Map<number, Map<number, GridCell>> = new Map();\n\n    get(col: number, row: number) {\n        const colCache = this.cachedContent.get(col);\n\n        if (colCache === undefined) {\n            return undefined;\n        }\n\n        return colCache.get(row);\n    }\n\n    set(col: number, row: number, value: GridCell) {\n        if (this.cachedContent.get(col) === undefined) {\n            this.cachedContent.set(col, new Map());\n        }\n\n        const rowCache = this.cachedContent.get(col) as Map<number, GridCell>;\n        rowCache.set(row, value);\n    }\n}\n\nexport function useMockDataGenerator(numCols: number, readonly: boolean = true, group: boolean = false) {\n    const cache = React.useRef<ContentCache>(new ContentCache());\n\n    const [colsMap, setColsMap] = React.useState(() => getResizableColumns(numCols, group));\n\n    React.useEffect(() => {\n        setColsMap(getResizableColumns(numCols, group));\n    }, [group, numCols]);\n\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\n        setColsMap(prevColsMap => {\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\n            const newArray = [...prevColsMap];\n            newArray.splice(index, 1, {\n                ...prevColsMap[index],\n                width: newSize,\n            });\n            return newArray;\n        });\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return colsMap.map(getGridColumn);\n    }, [colsMap]);\n\n    const colsMapRef = React.useRef(colsMap);\n    colsMapRef.current = colsMap;\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            let val = cache.current.get(col, row);\n            if (val === undefined) {\n                val = colsMapRef.current[col].getContent();\n                if (!readonly && isTextEditableGridCell(val)) {\n                    val = { ...val, readonly };\n                }\n                cache.current.set(col, row, val);\n            }\n            return val;\n        },\n        [readonly]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (selection: Rectangle): CellArray => {\n            const result: GridCell[][] = [];\n\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\n                const row: GridCell[] = [];\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\n                    row.push(getCellContent([x, y]));\n                }\n                result.push(row);\n            }\n\n            return result;\n        },\n        [getCellContent]\n    );\n\n    const setCellValueRaw = React.useCallback(([col, row]: Item, val: GridCell): void => {\n        cache.current.set(col, row, val);\n    }, []);\n\n    const setCellValue = React.useCallback(\n        ([col, row]: Item, val: GridCell): void => {\n            let current = cache.current.get(col, row);\n            if (current === undefined) {\n                current = colsMap[col].getContent();\n            }\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\n                const copied = lossyCopyData(val, current);\n                cache.current.set(col, row, {\n                    ...copied,\n                    displayData: typeof copied.data === \"string\" ? copied.data : (copied as any).displayData,\n                    lastUpdated: performance.now(),\n                } as any);\n            }\n        },\n        [colsMap]\n    );\n\n    return { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection, setCellValueRaw };\n}\n","import { drawBoolean } from \"../data-grid-lib\";\nimport {\n    GridCellKind,\n    BooleanCell,\n    booleanCellIsEditable,\n    BooleanEmpty,\n    BooleanIndeterminate,\n} from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\n/**\n * Checkbox behavior:\n *\n * true + click -> unchecked\n * false + click -> checked\n * indeterminate + click -> checked\n * empty + click -> checked\n */\nexport function toggleBoolean(data: boolean | null | undefined): boolean | null | undefined {\n    return data !== true;\n}\n\nexport const booleanCellRenderer: InternalCellRenderer<BooleanCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"false\",\n    kind: GridCellKind.Boolean,\n    needsHover: true,\n    useLabel: false,\n    needsHoverPosition: true,\n    measure: () => 50,\n    draw: a => drawBoolean(a, a.cell.data, booleanCellIsEditable(a.cell)),\n    onDelete: c => ({\n        ...c,\n        data: false,\n    }),\n    onClick: e => {\n        const { cell, posX: x, posY: y, bounds } = e;\n        if (\n            booleanCellIsEditable(cell) &&\n            Math.abs(x - bounds.width / 2) <= 10 &&\n            Math.abs(y - bounds.height / 2) <= 10\n        ) {\n            return {\n                ...cell,\n                data: toggleBoolean(cell.data),\n            };\n        }\n        return undefined;\n    },\n    onPaste: (toPaste, cell) => {\n        let newVal: boolean | BooleanEmpty | BooleanIndeterminate = BooleanEmpty;\n        if (toPaste.toLowerCase() === \"true\") {\n            newVal = true;\n        } else if (toPaste.toLowerCase() === \"false\") {\n            newVal = false;\n        } else if (toPaste.toLowerCase() === \"indeterminate\") {\n            newVal = BooleanIndeterminate;\n        }\n        return newVal === cell.data\n            ? undefined\n            : {\n                  ...cell,\n                  data: newVal,\n              };\n    },\n};\n","import { styled } from \"@linaria/react\";\n\nexport const BubblesOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .boe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 20px;\n\n        background-color: var(--gdg-bg-bubble);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n","import * as React from \"react\";\nimport { BubblesOverlayEditorStyle } from \"./bubbles-overlay-editor-style\";\n\ninterface Props {\n    readonly bubbles: readonly string[];\n}\n\nconst BubblesOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { bubbles } = p;\n    return (\n        <BubblesOverlayEditorStyle>\n            {bubbles.map((b, i) => (\n                <div key={i} className=\"boe-bubble\">\n                    {b}\n                </div>\n            ))}\n            <textarea className=\"gdg-input\" autoFocus={true} />\n        </BubblesOverlayEditorStyle>\n    );\n};\nexport default BubblesOverlayEditor;\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport BubblesOverlayEditor from \"../../data-grid-overlay-editor/private/bubbles-overlay-editor\";\nimport { drawBubbles } from \"../data-grid-lib\";\nimport { GridCellKind, BubbleCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const bubbleCellRenderer: InternalCellRenderer<BubbleCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Bubble,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: (ctx, cell, t) =>\n        cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,\n    draw: a => drawBubbles(a, a.cell.data),\n    provideEditor: () => p => {\n        const { value } = p;\n        return <BubblesOverlayEditor bubbles={value.data} />;\n    },\n    onPaste: () => undefined,\n};\n","import type { DrilldownCellData } from \"../../data-grid/data-grid-types\";\nimport * as React from \"react\";\nimport { styled } from \"@linaria/react\";\n\nconst DrilldownOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .doe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 24px;\n\n        background-color: var(--gdg-bg-cell);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n\n        border-radius: 6px;\n\n        box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n\n        img {\n            height: 16px;\n            object-fit: contain;\n\n            margin-right: 4px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n\ninterface Props {\n    readonly drilldowns: readonly DrilldownCellData[];\n}\n\nconst DrilldownOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { drilldowns } = p;\n    return (\n        <DrilldownOverlayEditorStyle>\n            {drilldowns.map((d, i) => (\n                <div key={i} className=\"doe-bubble\">\n                    {d.img !== undefined && <img src={d.img} />}\n                    <div>{d.text}</div>\n                </div>\n            ))}\n        </DrilldownOverlayEditorStyle>\n    );\n};\nexport default DrilldownOverlayEditor;\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport DrilldownOverlayEditor from \"../../data-grid-overlay-editor/private/drilldown-overlay-editor\";\nimport { drawDrilldownCell } from \"../data-grid-lib\";\nimport { GridCellKind, DrilldownCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const drilldownCellRenderer: InternalCellRenderer<DrilldownCell> = {\n    getAccessibilityString: c => c.data.map(d => d.text).join(\", \"),\n    kind: GridCellKind.Drilldown,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: (ctx, cell, t) =>\n        cell.data.reduce(\n            (acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== undefined ? 18 : 0),\n            0\n        ) +\n        2 * t.cellHorizontalPadding -\n        4,\n    draw: a => drawDrilldownCell(a, a.cell.data),\n    provideEditor: () => p => {\n        const { value } = p;\n        return <DrilldownOverlayEditor drilldowns={value.data} />;\n    },\n    onPaste: () => undefined,\n};\n","import { styled } from \"@linaria/react\";\n\nexport const ImageOverlayEditorStyle = styled.div`\n    display: flex;\n\n    height: 100%;\n\n    .centering-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        height: 100%;\n\n        img,\n        canvas {\n            max-height: calc(100vh - var(--overlay-top) - 20px);\n            object-fit: contain;\n            user-select: none;\n        }\n\n        canvas {\n            max-width: 380px;\n        }\n    }\n\n    .edit-icon {\n        position: absolute;\n        top: 12px;\n        right: 0;\n        width: 48px;\n        height: 48px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n","import * as React from \"react\";\nimport { ImageOverlayEditorStyle } from \"./image-overlay-editor-style\";\nimport { Carousel } from \"react-responsive-carousel\";\nimport { EditPencil } from \"../../common/utils\";\n\n/** @category Types */\nexport interface OverlayImageEditorProps {\n    readonly urls: readonly string[];\n    readonly canWrite: boolean;\n    readonly onCancel: () => void;\n    readonly onChange: (newImage: string) => void;\n    readonly onEditClick?: () => void;\n    readonly renderImage?: (url: string) => React.ReactNode;\n}\n\n/** @category Renderers */\nexport const ImageOverlayEditor: React.FunctionComponent<OverlayImageEditorProps> = p => {\n    const { urls, canWrite, onEditClick, renderImage } = p;\n\n    const filtered = urls.filter(u => u !== \"\");\n\n    if (filtered.length === 0) {\n        return null;\n    }\n\n    const allowMove = filtered.length > 1;\n    return (\n        <ImageOverlayEditorStyle data-testid=\"GDG-default-image-overlay-editor\">\n            <Carousel\n                showArrows={allowMove}\n                showThumbs={false}\n                swipeable={allowMove}\n                emulateTouch={allowMove}\n                infiniteLoop={allowMove}>\n                {filtered.map(url => {\n                    const innerContent = renderImage?.(url) ?? <img draggable={false} src={url} />;\n                    return (\n                        <div className=\"centering-container\" key={url}>\n                            {innerContent}\n                        </div>\n                    );\n                })}\n            </Carousel>\n            {canWrite && onEditClick && (\n                <button className=\"edit-icon\" onClick={onEditClick}>\n                    <EditPencil />\n                </button>\n            )}\n        </ImageOverlayEditorStyle>\n    );\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { ImageOverlayEditor } from \"../../data-grid-overlay-editor/private/image-overlay-editor\";\nimport { drawImage } from \"../data-grid-lib\";\nimport { GridCellKind, ImageCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const imageCellRenderer: InternalCellRenderer<ImageCell> = {\n    getAccessibilityString: c => c.data.join(\", \"),\n    kind: GridCellKind.Image,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    draw: a => drawImage(a, a.cell.displayData ?? a.cell.data, a.cell.rounding),\n    measure: (_ctx, cell) => cell.data.length * 50,\n    onDelete: c => ({\n        ...c,\n        data: [],\n    }),\n    provideEditor: () => p => {\n        const { value, onFinishedEditing, imageEditorOverride } = p;\n\n        const ImageEditor = imageEditorOverride ?? ImageOverlayEditor;\n\n        return (\n            <ImageEditor\n                urls={value.data}\n                canWrite={value.allowAdd}\n                onCancel={onFinishedEditing}\n                onChange={newImage => {\n                    onFinishedEditing({\n                        ...value,\n                        data: [newImage],\n                    });\n                }}\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => {\n        toPaste = toPaste.trim();\n        const fragments = toPaste.split(\",\");\n        const uris = fragments\n            .map(f => {\n                try {\n                    new URL(f);\n                    return f;\n                } catch {\n                    return undefined;\n                }\n            })\n            .filter(x => x !== undefined) as string[];\n\n        if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i])) return undefined;\n        return {\n            ...cell,\n            data: uris,\n        };\n    },\n};\n","import { GridCellKind, LoadingCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const loadingCellRenderer: InternalCellRenderer<LoadingCell> = {\n    getAccessibilityString: () => \"\",\n    kind: GridCellKind.Loading,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: () => 120,\n    draw: () => undefined,\n    onPaste: () => undefined,\n};\n","import { styled } from \"@linaria/react\";\n\nexport const MarkdownContainer = styled.div`\n    word-break: break-word;\n    -webkit-touch-callout: default;\n    padding-top: 6px;\n\n    > * {\n        margin: 0;\n    }\n\n    & *:last-child {\n        margin-bottom: 0;\n    }\n\n    & p img {\n        width: 100%;\n    }\n`;\n","import React from \"react\";\nimport { marked } from \"marked\";\n\nimport { MarkdownContainer } from \"./private/markdown-container\";\n\n/** @category Renderers */\nexport interface MarkdownDivProps {\n    contents: string;\n    createNode?: (content: string) => DocumentFragment;\n}\n\n/** @category Renderers */\nexport default class MarkdownDiv<TProps extends MarkdownDivProps, TState> extends React.PureComponent<TProps, TState> {\n    private targetElement: HTMLElement | null = null;\n\n    private renderMarkdownIntoDiv() {\n        const { targetElement, props } = this;\n        if (targetElement === null) return;\n\n        const { contents, createNode } = props;\n\n        const innerHTML: string = (marked as any)(contents);\n\n        const childRange = document.createRange();\n        childRange.selectNodeContents(targetElement);\n        childRange.deleteContents();\n\n        let newChild: DocumentFragment | undefined = createNode?.(innerHTML);\n        if (newChild === undefined) {\n            const childDoc = document.createElement(\"template\");\n            childDoc.innerHTML = innerHTML;\n            newChild = childDoc.content;\n        }\n        targetElement.append(newChild);\n\n        const tags = targetElement.getElementsByTagName(\"a\");\n        for (const tag of tags) {\n            tag.target = \"_blank\";\n            tag.rel = \"noreferrer noopener\";\n        }\n    }\n\n    private containerRefHook = (element: HTMLElement | null) => {\n        this.targetElement = element;\n        this.renderMarkdownIntoDiv();\n    };\n\n    public render() {\n        // Doing this in the ref hook works great when we first render, but never again.\n        // This only works great after the first render, but not in the first render.\n        // Putting the two together makes the full solution.\n        this.renderMarkdownIntoDiv();\n        return <MarkdownContainer ref={this.containerRefHook as any} />;\n    }\n}\n","import { styled } from \"@linaria/react\";\n\nexport const InputBox = styled.textarea`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n\n    border-radius: 0px;\n\n    resize: none;\n    white-space: pre-wrap;\n    min-width: 100%;\n    overflow: hidden;\n    border: 0;\n    background-color: transparent;\n\n    ::placeholder {\n        color: var(--gdg-text-light);\n    }\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    .invalid & {\n        text-decoration: underline;\n        text-decoration-color: #d60606;\n    }\n`;\n\nexport const ShadowBox = styled.div`\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n\n    width: max-content;\n    max-width: 100%;\n\n    min-width: 100%;\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    padding-bottom: 2px;\n`;\n\nexport const GrowingEntryStyle = styled.div`\n    position: relative;\n    margin-top: 6px;\n`;\n","import * as React from \"react\";\n\nimport { GrowingEntryStyle, ShadowBox, InputBox } from \"./growing-entry-style\";\nimport { assert } from \"../common/support\";\nimport type { SelectionRange } from \"../data-grid/data-grid-types\";\n\ninterface Props\n    extends React.DetailedHTMLProps<React.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement> {\n    readonly placeholder?: string;\n    readonly highlight: boolean;\n    readonly altNewline?: boolean;\n    readonly validatedSelection?: SelectionRange;\n}\n\n/** @category Renderers */\nexport const GrowingEntry: React.FunctionComponent<Props> = (props: Props) => {\n    const { placeholder, value, onKeyDown, highlight, altNewline, validatedSelection, ...rest } = props;\n    const { onChange, className } = rest;\n\n    const inputRef = React.useRef<HTMLTextAreaElement | null>(null);\n\n    const useText = value ?? \"\";\n\n    assert(onChange !== undefined, \"GrowingEntry must be a controlled input area\");\n\n    React.useEffect(() => {\n        const ta = inputRef.current;\n        if (ta === null) return;\n\n        if (ta.disabled) return;\n        const length = useText.toString().length;\n        ta.focus();\n        ta.setSelectionRange(highlight ? 0 : length, length);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    React.useLayoutEffect(() => {\n        if (validatedSelection !== undefined) {\n            const range = typeof validatedSelection === \"number\" ? [validatedSelection, null] : validatedSelection;\n            inputRef.current?.setSelectionRange(range[0], range[1]);\n        }\n    }, [validatedSelection]);\n\n    const onKeyDownInner = React.useCallback<NonNullable<typeof onKeyDown>>(\n        e => {\n            if (e.key === \"Enter\" && e.shiftKey && altNewline === true) {\n                return;\n            }\n            onKeyDown?.(e);\n        },\n        [altNewline, onKeyDown]\n    );\n\n    return (\n        <GrowingEntryStyle className=\"gdg-growing-entry\">\n            <ShadowBox className={className}>{useText + \"\\n\"}</ShadowBox>\n            <InputBox\n                {...rest}\n                className={(className ?? \"\") + \" gdg-input\"}\n                ref={inputRef}\n                onKeyDown={onKeyDownInner}\n                value={useText}\n                placeholder={placeholder}\n                dir=\"auto\"\n            />\n        </GrowingEntryStyle>\n    );\n};\n","import { GrowingEntryStyle } from \"../../growing-entry/growing-entry-style\";\nimport { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetWidth: number;\n}\n\nexport const MarkdownOverlayEditorStyle = styled.div<Props>`\n    min-width: ${p => p.targetWidth}px;\n    width: 100%;\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    position: relative;\n    color: var(--gdg-text-dark);\n\n    ${GrowingEntryStyle} {\n        flex-shrink: 1;\n        min-width: 0;\n    }\n\n    .spacer {\n        flex: 1;\n    }\n\n    .edit-icon {\n        position: relative;\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        color: var(--gdg-accent-color);\n\n        padding: 0;\n\n        height: 24px;\n        width: 24px;\n        flex-shrink: 0;\n\n        transition: all \"0.125s ease\";\n\n        border-radius: 6px;\n\n        > * {\n            width: 16px;\n            height: 16px;\n        }\n    }\n\n    .edit-hover {\n        :hover {\n            background-color: var(--gdg-accent-light);\n            transition: background-color 150ms;\n        }\n    }\n\n    .checkmark-hover {\n        :hover {\n            color: #ffffff;\n            background-color: var(--gdg-accent-color);\n        }\n    }\n\n    .md-edit-textarea {\n        position: relative;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n        margin-top: 25px;\n        opacity: 0;\n        padding: 0;\n    }\n\n    .ml-6 {\n        margin-left: 6px;\n    }\n`;\n","import * as React from \"react\";\nimport MarkdownDiv from \"../../markdown-div/markdown-div\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { MarkdownOverlayEditorStyle } from \"./markdown-overlay-editor-style\";\nimport { EditPencil, Checkmark } from \"../../common/utils\";\nimport type { Rectangle, SelectionRange } from \"../../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly targetRect: Rectangle;\n    readonly markdown: string;\n    readonly onChange: (ev: React.ChangeEvent<HTMLTextAreaElement>) => void;\n    readonly forceEditMode: boolean;\n    readonly onFinish: () => void;\n    readonly validatedSelection?: SelectionRange;\n\n    readonly readonly: boolean;\n\n    createNode?: (content: string) => DocumentFragment;\n}\n\nexport const MarkdownOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { markdown, onChange, forceEditMode, createNode, targetRect, readonly, onFinish, validatedSelection } = p;\n\n    const [editMode, setEditMode] = React.useState<boolean>(markdown === \"\" || forceEditMode);\n    const onEditClick = React.useCallback(() => {\n        setEditMode(e => !e);\n    }, []);\n    const addLeftPad = markdown ? \"ml-6\" : \"\";\n\n    if (editMode) {\n        return (\n            <MarkdownOverlayEditorStyle targetWidth={targetRect.width - 20}>\n                <GrowingEntry\n                    autoFocus={true}\n                    highlight={false}\n                    validatedSelection={validatedSelection}\n                    value={markdown}\n                    onKeyDown={e => {\n                        if (e.key === \"Enter\") e.stopPropagation();\n                    }}\n                    onChange={onChange}\n                />\n                <div className={`edit-icon checkmark-hover ${addLeftPad}`} onClick={() => onFinish()}>\n                    <Checkmark />\n                </div>\n            </MarkdownOverlayEditorStyle>\n        );\n    }\n    return (\n        <MarkdownOverlayEditorStyle targetWidth={targetRect.width}>\n            <MarkdownDiv contents={markdown} createNode={createNode} />\n            {!readonly && (\n                <>\n                    <div className=\"spacer\" />\n                    <div className={`edit-icon edit-hover ${addLeftPad}`} onClick={onEditClick}>\n                        <EditPencil />\n                    </div>\n                </>\n            )}\n            <textarea className=\"md-edit-textarea gdg-input\" autoFocus={true} />\n        </MarkdownOverlayEditorStyle>\n    );\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { MarkdownOverlayEditor } from \"../../data-grid-overlay-editor/private/markdown-overlay-editor\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, MarkdownCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const markdownCellRenderer: InternalCellRenderer<MarkdownCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Markdown,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: prepTextCell,\n    measure: (ctx, cell, t) => {\n        const firstLine = cell.data.split(\"\\n\")[0];\n        return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;\n    },\n    draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: () => p => {\n        const {\n            onChange,\n            value,\n            target,\n            onFinishedEditing,\n            markdownDivCreateNode,\n            forceEditMode,\n            validatedSelection,\n        } = p;\n        return (\n            <MarkdownOverlayEditor\n                onFinish={onFinishedEditing}\n                targetRect={target}\n                readonly={value.readonly === true}\n                markdown={value.data}\n                validatedSelection={validatedSelection}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n                forceEditMode={forceEditMode}\n                createNode={markdownDivCreateNode}\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => (toPaste === cell.data ? undefined : { ...cell, data: toPaste }),\n};\n","import { drawMarkerRowCell, prepMarkerRowCell } from \"../data-grid-lib\";\nimport { InnerGridCellKind, MarkerCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const markerCellRenderer: InternalCellRenderer<MarkerCell> = {\n    getAccessibilityString: c => c.row.toString(),\n    kind: InnerGridCellKind.Marker,\n    needsHover: true,\n    needsHoverPosition: false,\n    drawPrep: prepMarkerRowCell,\n    measure: () => 44,\n    draw: a => drawMarkerRowCell(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle),\n    onClick: e => {\n        const { bounds, cell, posX: x, posY: y } = e;\n        const { width, height } = bounds;\n\n        const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;\n        const centerY = height / 2;\n\n        if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {\n            return {\n                ...cell,\n                checked: !cell.checked,\n            };\n        }\n        return undefined;\n    },\n    onPaste: () => undefined,\n};\n","import { drawNewRowCell } from \"../data-grid-lib\";\nimport { InnerGridCellKind, NewRowCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const newRowCellRenderer: InternalCellRenderer<NewRowCell> = {\n    getAccessibilityString: () => \"\",\n    kind: InnerGridCellKind.NewRow,\n    needsHover: true,\n    needsHoverPosition: false,\n    measure: () => 200,\n    draw: a => drawNewRowCell(a, a.cell.hint, a.cell.icon),\n    onPaste: () => undefined,\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, NumberCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nconst NumberOverlayEditor = React.lazy(\n    async () => await import(\"../../data-grid-overlay-editor/private/number-overlay-editor\")\n);\n\nexport const numberCellRenderer: InternalCellRenderer<NumberCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Number,\n    needsHover: false,\n    needsHoverPosition: false,\n    useLabel: true,\n    drawPrep: prepTextCell,\n    draw: a => drawTextCell(a, a.cell.displayData, a.cell.contentAlign),\n    measure: (ctx, cell) => ctx.measureText(cell.displayData).width + 16,\n    onDelete: c => ({\n        ...c,\n        data: undefined,\n    }),\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (\n            <React.Suspense fallback={null}>\n                <NumberOverlayEditor\n                    highlight={isHighlighted}\n                    disabled={value.readonly === true}\n                    value={value.data}\n                    validatedSelection={validatedSelection}\n                    onChange={x =>\n                        onChange({\n                            ...value,\n                            data: Number.isNaN(x.floatValue ?? 0) ? 0 : x.floatValue,\n                        })\n                    }\n                />\n            </React.Suspense>\n        );\n    },\n    onPaste: (toPaste, cell) => {\n        const newNumber = Number.parseFloat(toPaste);\n        if (Number.isNaN(newNumber) || cell.data === newNumber) return undefined;\n        return { ...cell, data: newNumber };\n    },\n};\n","import { drawProtectedCell } from \"../data-grid-lib\";\nimport { GridCellKind, ProtectedCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const protectedCellRenderer: InternalCellRenderer<ProtectedCell> = {\n    getAccessibilityString: () => \"\",\n    measure: () => 108,\n    kind: GridCellKind.Protected,\n    needsHover: false,\n    needsHoverPosition: false,\n    draw: drawProtectedCell,\n    onPaste: () => undefined,\n};\n","import React from \"react\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, RowIDCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const rowIDCellRenderer: InternalCellRenderer<RowIDCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.RowID,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: (a, b) => prepTextCell(a, b, a.theme.textLight),\n    draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),\n    measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,\n    // eslint-disable-next-line react/display-name\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (\n            <GrowingEntry\n                highlight={isHighlighted}\n                autoFocus={value.readonly !== true}\n                disabled={value.readonly !== false}\n                value={value.data}\n                validatedSelection={validatedSelection}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n            />\n        );\n    },\n    onPaste: () => undefined,\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, TextCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const textCellRenderer: InternalCellRenderer<TextCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Text,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: prepTextCell,\n    useLabel: true,\n    draw: a => (drawTextCell(a, a.cell.displayData, a.cell.contentAlign, a.cell.allowWrapping, a.hyperWrapping), true),\n    measure: (ctx, cell, t) => {\n        const lines = cell.displayData.split(\"\\n\").slice(0, cell.allowWrapping === true ? undefined : 1);\n        return Math.max(...lines.map(l => ctx.measureText(l).width + 2 * t.cellHorizontalPadding));\n    },\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (\n            <GrowingEntry\n                highlight={isHighlighted}\n                autoFocus={value.readonly !== true}\n                disabled={value.readonly === true}\n                altNewline={true}\n                value={value.data}\n                validatedSelection={validatedSelection}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => (toPaste === cell.data ? undefined : { ...cell, data: toPaste }),\n};\n","import { styled } from \"@linaria/react\";\n\nexport const UriOverlayEditorStyle = styled.div`\n    display: flex;\n\n    flex-grow: 1;\n\n    align-items: center;\n\n    min-height: 21px;\n\n    .link-area {\n        flex-grow: 1;\n        flex-shrink: 1;\n\n        cursor: pointer;\n\n        margin-right: 8px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n\n        color: var(--gdg-link-color);\n        text-decoration: underline !important;\n    }\n\n    .edit-icon {\n        flex-shrink: 0;\n        width: 32px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n","import { EditPencil } from \"../../common/utils\";\nimport * as React from \"react\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { UriOverlayEditorStyle } from \"./uri-overlay-editor-style\";\nimport type { SelectionRange } from \"../../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly uri: string;\n    readonly onChange: (ev: React.ChangeEvent<HTMLTextAreaElement>) => void;\n    readonly forceEditMode: boolean;\n    readonly readonly: boolean;\n    readonly validatedSelection?: SelectionRange;\n}\n\nconst UriOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { uri, onChange, forceEditMode, readonly, validatedSelection } = p;\n\n    const [editMode, setEditMode] = React.useState<boolean>(uri === \"\" || forceEditMode);\n\n    const onEditClick = React.useCallback(() => {\n        setEditMode(true);\n    }, []);\n\n    if (editMode) {\n        return (\n            <GrowingEntry\n                validatedSelection={validatedSelection}\n                highlight={true}\n                autoFocus={true}\n                value={uri}\n                onChange={onChange}\n            />\n        );\n    }\n\n    return (\n        <UriOverlayEditorStyle>\n            <a className=\"link-area\" href={uri} target=\"_blank\" rel=\"noopener noreferrer\">\n                {uri}\n            </a>\n            {!readonly && (\n                <div className=\"edit-icon\" onClick={onEditClick}>\n                    <EditPencil />\n                </div>\n            )}\n            <textarea className=\"gdg-input\" autoFocus={true} />\n        </UriOverlayEditorStyle>\n    );\n};\n\nexport default UriOverlayEditor;\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport UriOverlayEditor from \"../../data-grid-overlay-editor/private/uri-overlay-editor\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, UriCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const uriCellRenderer: InternalCellRenderer<UriCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Uri,\n    needsHover: false,\n    needsHoverPosition: false,\n    useLabel: true,\n    drawPrep: prepTextCell,\n    draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),\n    measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: () => p => {\n        const { onChange, value, forceEditMode, validatedSelection } = p;\n        return (\n            <UriOverlayEditor\n                forceEditMode={forceEditMode}\n                uri={value.data}\n                validatedSelection={validatedSelection}\n                readonly={value.readonly === true}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => (toPaste === cell.data ? undefined : { ...cell, data: toPaste }),\n};\n","import { GridCellKind, InnerGridCellKind } from \"../data-grid-types\";\nimport { booleanCellRenderer } from \"./boolean-cell\";\nimport { bubbleCellRenderer } from \"./bubble-cell\";\nimport { drilldownCellRenderer } from \"./drilldown-cell\";\nimport { imageCellRenderer } from \"./image-cell\";\nimport { loadingCellRenderer } from \"./loading-cell\";\nimport { markdownCellRenderer } from \"./markdown-cell\";\nimport { markerCellRenderer } from \"./marker-cell\";\nimport { newRowCellRenderer } from \"./new-row-cell\";\nimport { numberCellRenderer } from \"./number-cell\";\nimport { protectedCellRenderer } from \"./protected-cell\";\nimport { rowIDCellRenderer } from \"./row-id-cell\";\nimport { textCellRenderer } from \"./text-cell\";\nimport { uriCellRenderer } from \"./uri-cell\";\n\nexport const CellRenderers = {\n    [InnerGridCellKind.Marker]: markerCellRenderer,\n    [InnerGridCellKind.NewRow]: newRowCellRenderer,\n    [GridCellKind.Boolean]: booleanCellRenderer,\n    [GridCellKind.Bubble]: bubbleCellRenderer,\n    [GridCellKind.Drilldown]: drilldownCellRenderer,\n    [GridCellKind.Image]: imageCellRenderer,\n    [GridCellKind.Loading]: loadingCellRenderer,\n    [GridCellKind.Markdown]: markdownCellRenderer,\n    [GridCellKind.Number]: numberCellRenderer,\n    [GridCellKind.Protected]: protectedCellRenderer,\n    [GridCellKind.RowID]: rowIDCellRenderer,\n    [GridCellKind.Text]: textCellRenderer,\n    [GridCellKind.Uri]: uriCellRenderer,\n};\n","/* eslint-disable unicorn/no-for-loop */\nimport type { Theme } from \"../common/styles\";\nimport {\n    DrilldownCellData,\n    Item,\n    GridSelection,\n    InnerGridCell,\n    SizedGridColumn,\n    Rectangle,\n    BaseGridCell,\n    BooleanEmpty,\n    BooleanIndeterminate,\n} from \"./data-grid-types\";\nimport { degreesToRadians, direction } from \"../common/utils\";\nimport React from \"react\";\nimport type { BaseDrawArgs, PrepResult } from \"./cells/cell-types\";\nimport { assertNever } from \"../common/support\";\nimport { split as splitText, clearCache } from \"canvas-hypertxt\";\n\nexport interface MappedGridColumn extends SizedGridColumn {\n    sourceIndex: number;\n    sticky: boolean;\n}\n\nexport function useMappedColumns(\n    columns: readonly SizedGridColumn[],\n    freezeColumns: number\n): readonly MappedGridColumn[] {\n    return React.useMemo(\n        () =>\n            columns.map((c, i) => ({\n                ...c,\n                sourceIndex: i,\n                sticky: i < freezeColumns,\n            })),\n        [columns, freezeColumns]\n    );\n}\n\nexport function isGroupEqual(left: string | undefined, right: string | undefined): boolean {\n    return (left ?? \"\") === (right ?? \"\");\n}\n\nexport function cellIsSelected(location: Item, cell: InnerGridCell, selection: GridSelection): boolean {\n    if (selection?.current === undefined) return false;\n\n    const [col, row] = selection.current.cell;\n    const [cellCol, cellRow] = location;\n    if (cellRow !== row) return false;\n\n    if (cell.span === undefined) {\n        return col === cellCol;\n    }\n\n    return col >= cell.span[0] && col <= cell.span[1];\n}\n\nfunction cellIsInRect(location: Item, cell: InnerGridCell, rect: Rectangle): boolean {\n    const startX = rect.x;\n    const endX = rect.x + rect.width - 1;\n    const startY = rect.y;\n    const endY = rect.y + rect.height - 1;\n\n    const [cellCol, cellRow] = location;\n    if (cellRow < startY || cellRow > endY) return false;\n\n    if (cell.span === undefined) {\n        return cellCol >= startX && cellCol <= endX;\n    }\n\n    const [spanStart, spanEnd] = cell.span;\n    return (\n        (spanStart >= startX && spanStart <= endX) ||\n        (spanEnd >= startX && spanStart <= endX) ||\n        (spanStart < startX && spanEnd > endX)\n    );\n}\n\nexport function cellIsInRange(location: Item, cell: InnerGridCell, selection: GridSelection): number {\n    let result = 0;\n    if (selection.current === undefined) return result;\n\n    if (cellIsInRect(location, cell, selection.current.range)) result++;\n    for (const r of selection.current.rangeStack) {\n        if (cellIsInRect(location, cell, r)) {\n            result++;\n        }\n    }\n    return result;\n}\n\nfunction remapForDnDState(\n    columns: readonly MappedGridColumn[],\n    dndState?: {\n        src: number;\n        dest: number;\n    }\n) {\n    let mappedCols = columns;\n    if (dndState !== undefined) {\n        let writable = [...columns];\n        const temp = mappedCols[dndState.src];\n        if (dndState.src > dndState.dest) {\n            writable.splice(dndState.src, 1);\n            writable.splice(dndState.dest, 0, temp);\n        } else {\n            writable.splice(dndState.dest + 1, 0, temp);\n            writable.splice(dndState.src, 1);\n        }\n        writable = writable.map((c, i) => ({\n            ...c,\n            sticky: columns[i].sticky,\n        }));\n        mappedCols = writable;\n    }\n    return mappedCols;\n}\n\nexport function getStickyWidth(\n    columns: readonly MappedGridColumn[],\n    dndState?: {\n        src: number;\n        dest: number;\n    }\n): number {\n    let result = 0;\n    const remapped = remapForDnDState(columns, dndState);\n    for (let i = 0; i < remapped.length; i++) {\n        const c = remapped[i];\n        if (c.sticky) result += c.width;\n        else break;\n    }\n\n    return result;\n}\n\nexport function getEffectiveColumns(\n    columns: readonly MappedGridColumn[],\n    cellXOffset: number,\n    width: number,\n    dndState?: {\n        src: number;\n        dest: number;\n    },\n    tx?: number\n): readonly MappedGridColumn[] {\n    const mappedCols = remapForDnDState(columns, dndState);\n\n    const sticky: MappedGridColumn[] = [];\n    for (const c of mappedCols) {\n        if (c.sticky) {\n            sticky.push(c);\n        } else {\n            break;\n        }\n    }\n    if (sticky.length > 0) {\n        for (const c of sticky) {\n            width -= c.width;\n        }\n    }\n    let endIndex = cellXOffset;\n    let curX = tx ?? 0;\n\n    while (curX <= width && endIndex < mappedCols.length) {\n        curX += mappedCols[endIndex].width;\n        endIndex++;\n    }\n\n    for (let i = cellXOffset; i < endIndex; i++) {\n        const c = mappedCols[i];\n        if (!c.sticky) {\n            sticky.push(c);\n        }\n    }\n\n    return sticky;\n}\n\nexport function getColumnIndexForX(\n    targetX: number,\n    effectiveColumns: readonly MappedGridColumn[],\n    translateX?: number\n): number {\n    let x = 0;\n    for (const c of effectiveColumns) {\n        const cx = c.sticky ? x : x + (translateX ?? 0);\n        if (targetX <= cx + c.width) {\n            return c.sourceIndex;\n        }\n        x += c.width;\n    }\n    return -1;\n}\n\nexport function getRowIndexForY(\n    targetY: number,\n    height: number,\n    hasGroups: boolean,\n    headerHeight: number,\n    groupHeaderHeight: number,\n    rows: number,\n    rowHeight: number | ((index: number) => number),\n    cellYOffset: number,\n    translateY: number,\n    lastRowSticky: boolean\n): number | undefined {\n    const totalHeaderHeight = headerHeight + groupHeaderHeight;\n    if (hasGroups && targetY <= groupHeaderHeight) return -2;\n    if (targetY <= totalHeaderHeight) return -1;\n\n    const lastRowHeight = typeof rowHeight === \"number\" ? rowHeight : rowHeight(rows - 1);\n    if (lastRowSticky && targetY > height - lastRowHeight) {\n        return rows - 1;\n    }\n\n    const effectiveRows = rows - (lastRowSticky ? 1 : 0);\n\n    const ty = targetY - (translateY ?? 0);\n    if (typeof rowHeight === \"number\") {\n        const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;\n        if (target >= effectiveRows) return undefined;\n        return target;\n    } else {\n        let curY = totalHeaderHeight;\n        for (let i = cellYOffset; i < effectiveRows; i++) {\n            const rh = rowHeight(i);\n            if (ty <= curY + rh) return i;\n            curY += rh;\n        }\n        return undefined;\n    }\n}\n\nlet metricsSize = 0;\nlet metricsCache: Record<string, TextMetrics | undefined> = {};\nconst isSSR = typeof window === \"undefined\";\n\nasync function clearCacheOnLoad() {\n    if (isSSR || document?.fonts?.ready === undefined) return;\n    await document.fonts.ready;\n    metricsSize = 0;\n    metricsCache = {};\n    clearCache();\n}\n\nvoid clearCacheOnLoad();\n\nfunction makeCacheKey(s: string, ctx: CanvasRenderingContext2D, baseline: \"alphabetic\" | \"middle\", font?: string) {\n    return `${s}_${font ?? ctx.font}_${baseline}`;\n}\n\n/** @category Drawing */\nexport function measureTextCached(s: string, ctx: CanvasRenderingContext2D, font?: string): TextMetrics {\n    const key = makeCacheKey(s, ctx, \"middle\", font);\n    let metrics = metricsCache[key];\n    if (metrics === undefined) {\n        metrics = ctx.measureText(s);\n        metricsCache[key] = metrics;\n        metricsSize++;\n    }\n\n    if (metricsSize > 10_000) {\n        metricsCache = {};\n        metricsSize = 0;\n    }\n\n    return metrics;\n}\n\n/** @category Drawing */\nexport function getMiddleCenterBias(ctx: CanvasRenderingContext2D, font: string | Theme): number {\n    if (typeof font !== \"string\") {\n        font = `${font.baseFontStyle} ${font.fontFamily}`;\n    }\n    return getMiddleCenterBiasInner(ctx, font);\n}\n\nfunction loadMetric(ctx: CanvasRenderingContext2D, baseline: \"alphabetic\" | \"middle\") {\n    const sample = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    ctx.save();\n    ctx.textBaseline = baseline;\n    const result = ctx.measureText(sample);\n\n    ctx.restore();\n\n    return result;\n}\n\nconst biasCache: { key: string; val: number }[] = [];\n\nfunction getMiddleCenterBiasInner(ctx: CanvasRenderingContext2D, font: string): number {\n    for (const x of biasCache) {\n        if (x.key === font) return x.val;\n    }\n\n    const alphabeticMetrics = loadMetric(ctx, \"alphabetic\");\n    const middleMetrics = loadMetric(ctx, \"middle\");\n\n    const bias =\n        -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) +\n        alphabeticMetrics.actualBoundingBoxAscent / 2;\n\n    biasCache.push({\n        key: font,\n        val: bias,\n    });\n\n    return bias;\n}\n\n/** @category Drawing */\nexport function drawWithLastUpdate(\n    args: BaseDrawArgs,\n    lastUpdate: number | undefined,\n    frameTime: number,\n    lastPrep: PrepResult | undefined,\n    draw: () => void\n) {\n    const { ctx, rect, theme } = args;\n    let progress = Number.MAX_SAFE_INTEGER;\n    const animTime = 500;\n    if (lastUpdate !== undefined) {\n        progress = frameTime - lastUpdate;\n\n        if (progress < animTime) {\n            const fade = 1 - progress / animTime;\n            ctx.globalAlpha = fade;\n            ctx.fillStyle = theme.bgSearchResult;\n            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);\n            ctx.globalAlpha = 1;\n            if (lastPrep !== undefined) {\n                lastPrep.fillStyle = theme.bgSearchResult;\n            }\n        }\n    }\n\n    draw();\n\n    return progress < animTime;\n}\n\nexport function prepTextCell(\n    args: BaseDrawArgs,\n    lastPrep: PrepResult | undefined,\n    overrideColor?: string\n): Partial<PrepResult> {\n    const { ctx, theme } = args;\n    const result: Partial<PrepResult> = lastPrep ?? {};\n\n    const newFill = overrideColor ?? theme.textDark;\n    if (newFill !== result.fillStyle) {\n        ctx.fillStyle = newFill;\n        result.fillStyle = newFill;\n    }\n    return result;\n}\n\n/** @category Drawing */\nexport function drawTextCellExternal(args: BaseDrawArgs, data: string, contentAlign?: BaseGridCell[\"contentAlign\"]) {\n    const { rect, ctx, theme } = args;\n\n    ctx.fillStyle = theme.textDark;\n    drawTextCell(\n        {\n            ctx: ctx,\n            rect,\n            theme: theme,\n        },\n        data,\n        contentAlign\n    );\n}\n\nfunction drawSingleTextLine(\n    ctx: CanvasRenderingContext2D,\n    data: string,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    bias: number,\n    theme: Theme,\n    contentAlign?: BaseGridCell[\"contentAlign\"]\n) {\n    if (contentAlign === \"right\") {\n        ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);\n    } else if (contentAlign === \"center\") {\n        ctx.fillText(data, x + w / 2, y + h / 2 + bias);\n    } else {\n        ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);\n    }\n}\n\n/** @category Drawing */\nexport function drawTextCell(\n    args: Pick<BaseDrawArgs, \"rect\" | \"ctx\" | \"theme\">,\n    data: string,\n    contentAlign?: BaseGridCell[\"contentAlign\"],\n    allowWrapping?: boolean,\n    hyperWrapping?: boolean\n) {\n    const { ctx, rect, theme } = args;\n\n    const { x, y, width: w, height: h } = rect;\n\n    allowWrapping = allowWrapping ?? false;\n\n    if (!allowWrapping) {\n        if (data.includes(\"\\n\")) {\n            // new lines are rare and split is relatively expensive compared to the search\n            // it pays off to not do the split contantly.\n            data = data.split(/\\r?\\n/)[0];\n        }\n        const max = w / 4; // no need to round, slice will just truncate this\n        if (data.length > max) {\n            data = data.slice(0, max);\n        }\n    }\n\n    const bias = getMiddleCenterBias(ctx, theme);\n\n    const isRtl = direction(data) === \"rtl\";\n\n    if (contentAlign === undefined && isRtl) {\n        contentAlign = \"right\";\n    }\n\n    if (isRtl) {\n        ctx.direction = \"rtl\";\n    }\n\n    if (data.length > 0) {\n        let changed = false;\n        if (contentAlign === \"right\") {\n            // Use right alignment as default for RTL text\n            ctx.textAlign = \"right\";\n            changed = true;\n        } else if (contentAlign !== undefined && contentAlign !== \"left\") {\n            // Since default is start (=left), only apply if alignment is center or right\n            ctx.textAlign = contentAlign;\n            changed = true;\n        }\n\n        if (!allowWrapping) {\n            drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);\n        } else {\n            const fontStyle = `${theme.fontFamily} ${theme.baseFontStyle}`;\n            const split = splitText(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping ?? false);\n\n            const textMetrics = measureTextCached(\"ABCi09jgqpy\", ctx, fontStyle); // do not question the magic string\n            const emHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;\n            const lineHeight = theme.lineHeight * emHeight;\n\n            const actualHeight = emHeight + lineHeight * (split.length - 1);\n            const mustClip = actualHeight + theme.cellVerticalPadding > h;\n\n            if (mustClip) {\n                // well now we have to clip because we might render outside the cell vertically\n                ctx.save();\n                ctx.rect(x, y, w, h);\n                ctx.clip();\n            }\n\n            const optimalY = y + h / 2 - actualHeight / 2;\n            let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);\n            for (const line of split) {\n                drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);\n                drawY += lineHeight;\n                if (drawY > y + h) break;\n            }\n            if (mustClip) {\n                ctx.restore();\n            }\n        }\n\n        if (changed) {\n            // Reset alignment to default\n            ctx.textAlign = \"start\";\n        }\n\n        if (isRtl) {\n            ctx.direction = \"inherit\";\n        }\n    }\n}\n\nexport function drawNewRowCell(args: BaseDrawArgs, data: string, icon?: string) {\n    const { ctx, rect, hoverAmount, theme, spriteManager } = args;\n    const { x, y, width: w, height: h } = rect;\n    ctx.beginPath();\n    ctx.globalAlpha = hoverAmount;\n    ctx.rect(x, y, w, h);\n    ctx.fillStyle = theme.bgHeaderHovered;\n    ctx.fill();\n    ctx.globalAlpha = 1;\n    ctx.beginPath();\n\n    const alwaysShowIcon = data !== \"\";\n\n    let textX = 0;\n\n    if (icon !== undefined) {\n        const padding = 8;\n        const size = h - padding;\n        const px = x + padding / 2;\n        const py = y + padding / 2;\n\n        spriteManager.drawSprite(icon, \"normal\", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);\n        textX = size;\n    } else {\n        textX = 24;\n        const finalLineSize = 12;\n        const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;\n        const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;\n\n        const padPlus = theme.cellHorizontalPadding + 4;\n        if (lineSize > 0) {\n            ctx.moveTo(x + padPlus + xTranslate, y + h / 2);\n            ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);\n            ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);\n            ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);\n            ctx.lineWidth = 2;\n            ctx.strokeStyle = theme.bgIconHeader;\n            ctx.lineCap = \"round\";\n            ctx.stroke();\n        }\n    }\n\n    ctx.fillStyle = theme.textMedium;\n    ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + getMiddleCenterBias(ctx, theme));\n    ctx.beginPath();\n}\n\nexport function drawCheckbox(\n    ctx: CanvasRenderingContext2D,\n    theme: Theme,\n    checked: boolean | BooleanEmpty | BooleanIndeterminate,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    highlighted: boolean,\n    hoverX: number = -20,\n    hoverY: number = -20\n) {\n    const centerX = x + width / 2;\n    const centerY = y + height / 2;\n\n    const hovered = Math.abs(hoverX - width / 2) < 10 && Math.abs(hoverY - height / 2) < 10;\n\n    switch (checked) {\n        case true: {\n            ctx.beginPath();\n            roundedRect(ctx, centerX - 9, centerY - 9, 18, 18, 4);\n\n            ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;\n            ctx.fill();\n\n            ctx.beginPath();\n            ctx.moveTo(centerX - 8 + 3.650_05, centerY - 8 + 7.849_95);\n            ctx.lineTo(centerX - 8 + 6.375_87, centerY - 8 + 10.7304);\n            ctx.lineTo(centerX - 8 + 11.9999, centerY - 8 + 4.749_95);\n\n            ctx.strokeStyle = theme.bgCell;\n            ctx.lineJoin = \"round\";\n            ctx.lineCap = \"round\";\n            ctx.lineWidth = 1.9;\n            ctx.stroke();\n            break;\n        }\n\n        case BooleanEmpty:\n        case false: {\n            ctx.beginPath();\n            roundedRect(ctx, centerX - 8.5, centerY - 8.5, 17, 17, 4);\n\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;\n            ctx.stroke();\n            break;\n        }\n\n        case BooleanIndeterminate: {\n            ctx.beginPath();\n            roundedRect(ctx, centerX - 8.5, centerY - 8.5, 17, 17, 4);\n\n            ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;\n            ctx.fill();\n\n            ctx.beginPath();\n            ctx.moveTo(centerX - 4, centerY);\n            ctx.lineTo(centerX + 4, centerY);\n            ctx.strokeStyle = theme.bgCell;\n            ctx.lineCap = \"round\";\n            ctx.lineWidth = 1.9;\n            ctx.stroke();\n            break;\n        }\n\n        default:\n            assertNever(checked);\n    }\n}\n\nexport function prepMarkerRowCell(args: BaseDrawArgs, lastPrep: PrepResult | undefined): Partial<PrepResult> {\n    const { ctx, theme } = args;\n    const newFont = `9px ${theme.fontFamily}`;\n    const result: Partial<PrepResult> = lastPrep ?? {};\n    if (result?.font !== newFont) {\n        ctx.font = newFont;\n        result.font = newFont;\n    }\n    result.deprep = deprepMarkerRowCell;\n    ctx.textAlign = \"center\";\n    return result;\n}\n\nexport function deprepMarkerRowCell(args: Pick<BaseDrawArgs, \"ctx\">) {\n    const { ctx } = args;\n    ctx.textAlign = \"start\";\n}\n\nexport function drawMarkerRowCell(\n    args: BaseDrawArgs,\n    index: number,\n    checked: boolean,\n    markerKind: \"checkbox\" | \"both\" | \"number\",\n    drawHandle: boolean\n) {\n    const { ctx, rect, hoverAmount, theme } = args;\n    const { x, y, width, height } = rect;\n    const checkedboxAlpha = checked ? 1 : hoverAmount;\n    if (markerKind !== \"number\" && checkedboxAlpha > 0) {\n        ctx.globalAlpha = checkedboxAlpha;\n        const offsetAmount = 7 * (checked ? hoverAmount : 1);\n        drawCheckbox(\n            ctx,\n            theme,\n            checked,\n            drawHandle ? x + offsetAmount : x,\n            y,\n            drawHandle ? width - offsetAmount : width,\n            height,\n            true\n        );\n        if (drawHandle) {\n            ctx.globalAlpha = hoverAmount;\n            ctx.beginPath();\n            for (const xOffset of [3, 6]) {\n                for (const yOffset of [-5, -1, 3]) {\n                    ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);\n                }\n            }\n\n            ctx.fillStyle = theme.textLight;\n            ctx.fill();\n            ctx.beginPath();\n        }\n        ctx.globalAlpha = 1;\n    }\n    if (markerKind === \"number\" || (markerKind === \"both\" && !checked)) {\n        const text = index.toString();\n\n        const start = x + width / 2;\n        if (markerKind === \"both\" && hoverAmount !== 0) {\n            ctx.globalAlpha = 1 - hoverAmount;\n        }\n        ctx.fillStyle = theme.textLight;\n        ctx.fillText(text, start, y + height / 2 + getMiddleCenterBias(ctx, `9px ${theme.fontFamily}`));\n        if (hoverAmount !== 0) {\n            ctx.globalAlpha = 1;\n        }\n    }\n}\n\nexport function drawProtectedCell(args: BaseDrawArgs) {\n    const { ctx, theme, rect } = args;\n    const { x, y, height: h } = rect;\n\n    ctx.beginPath();\n\n    const radius = 2.5;\n    let xStart = x + theme.cellHorizontalPadding + radius;\n    const center = y + h / 2;\n    const p = Math.cos(degreesToRadians(30)) * radius;\n    const q = Math.sin(degreesToRadians(30)) * radius;\n\n    for (let i = 0; i < 12; i++) {\n        ctx.moveTo(xStart, center - radius);\n        ctx.lineTo(xStart, center + radius);\n\n        ctx.moveTo(xStart + p, center - q);\n        ctx.lineTo(xStart - p, center + q);\n\n        ctx.moveTo(xStart - p, center - q);\n        ctx.lineTo(xStart + p, center + q);\n        xStart += 8;\n    }\n    ctx.lineWidth = 1.1;\n    ctx.lineCap = \"square\";\n    ctx.strokeStyle = theme.textLight;\n    ctx.stroke();\n}\n\ninterface CornerRadius {\n    tl: number;\n    tr: number;\n    bl: number;\n    br: number;\n}\n\nfunction roundedRect(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number | CornerRadius\n) {\n    if (typeof radius === \"number\") {\n        radius = { tl: radius, tr: radius, br: radius, bl: radius };\n    }\n\n    // restrict radius to a reasonable max\n    radius = {\n        tl: Math.min(radius.tl, height / 2, width / 2),\n        tr: Math.min(radius.tr, height / 2, width / 2),\n        bl: Math.min(radius.bl, height / 2, width / 2),\n        br: Math.min(radius.br, height / 2, width / 2),\n    };\n\n    ctx.moveTo(x + radius.tl, y);\n    ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);\n    ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);\n    ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);\n    ctx.arcTo(x, y, x + radius.tl, y, radius.tl);\n}\n\nexport function drawBoolean(args: BaseDrawArgs, data: boolean | BooleanEmpty | BooleanIndeterminate, canEdit: boolean) {\n    if (!canEdit && data === BooleanEmpty) {\n        return;\n    }\n\n    const { ctx, hoverAmount, theme, rect, highlighted, hoverX, hoverY } = args;\n    const { x, y, width: w, height: h } = rect;\n\n    const hoverEffect = 0.35;\n\n    let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;\n    if (data === BooleanEmpty) {\n        alpha *= hoverAmount;\n    }\n    if (alpha === 0) {\n        return;\n    }\n    ctx.globalAlpha = alpha;\n\n    drawCheckbox(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY);\n\n    ctx.globalAlpha = 1;\n}\n\nconst itemMargin = 4;\n\nexport function drawBubbles(args: BaseDrawArgs, data: readonly string[]) {\n    const { rect, theme, ctx, highlighted } = args;\n    const { x, y, width: w, height: h } = rect;\n    const bubbleHeight = 20;\n    const bubblePad = 8;\n    const bubbleMargin = itemMargin;\n    let renderX = x + theme.cellHorizontalPadding;\n\n    const renderBoxes: { x: number; width: number }[] = [];\n    for (const s of data) {\n        if (renderX > x + w) break;\n        const textWidth = measureTextCached(s, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;\n        renderBoxes.push({\n            x: renderX,\n            width: textWidth,\n        });\n\n        renderX += textWidth + bubblePad * 2 + bubbleMargin;\n    }\n\n    ctx.beginPath();\n    for (const rectInfo of renderBoxes) {\n        roundedRect(\n            ctx,\n            rectInfo.x,\n            y + (h - bubbleHeight) / 2,\n            rectInfo.width + bubblePad * 2,\n            bubbleHeight,\n            bubbleHeight / 2\n        );\n    }\n    ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;\n    ctx.fill();\n\n    for (const [i, rectInfo] of renderBoxes.entries()) {\n        ctx.beginPath();\n        ctx.fillStyle = theme.textBubble;\n        ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + getMiddleCenterBias(ctx, theme));\n    }\n}\n\nconst drilldownCache: {\n    [key: string]: HTMLCanvasElement;\n} = {};\n\nfunction getAndCacheDrilldownBorder(\n    bgCell: string,\n    border: string\n): {\n    el: HTMLCanvasElement;\n    height: number;\n    width: number;\n    middleWidth: number;\n    sideWidth: number;\n} | null {\n    const dpr = Math.ceil(window.devicePixelRatio);\n    const targetHeight = 24;\n    const shadowBlur = 5;\n    const middleWidth = 4;\n\n    const innerHeight = (targetHeight + shadowBlur * 2) * dpr; // 68\n    const innerWidth = innerHeight + middleWidth * dpr; // 76\n    const sideWidth = innerHeight / 2;\n\n    const key = `${bgCell},${border},${dpr}`;\n    if (drilldownCache[key] !== undefined) {\n        return {\n            el: drilldownCache[key],\n            height: innerHeight,\n            width: innerWidth,\n            middleWidth: middleWidth * dpr,\n            sideWidth,\n        };\n    }\n\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\"); // alpha needed\n\n    if (ctx === null) return null;\n\n    canvas.width = innerWidth;\n    canvas.height = innerHeight;\n\n    ctx.scale(dpr, dpr);\n\n    drilldownCache[key] = canvas;\n\n    ctx.beginPath();\n    roundedRect(ctx, shadowBlur, shadowBlur, targetHeight + middleWidth, targetHeight, 6);\n\n    ctx.shadowColor = \"rgba(24, 25, 34, 0.4)\";\n    ctx.shadowBlur = 1;\n    ctx.fillStyle = bgCell;\n    ctx.fill();\n\n    ctx.shadowColor = \"rgba(24, 25, 34, 0.3)\";\n    ctx.shadowOffsetY = 1;\n    ctx.shadowBlur = 5;\n    ctx.fillStyle = bgCell;\n    ctx.fill();\n\n    ctx.shadowOffsetY = 0;\n    ctx.shadowBlur = 0;\n    ctx.shadowBlur = 0;\n\n    ctx.beginPath();\n    roundedRect(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetHeight + middleWidth, targetHeight, 6);\n\n    ctx.strokeStyle = border;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n\n    return { el: canvas, height: innerHeight, width: innerWidth, sideWidth, middleWidth: middleWidth * dpr };\n}\n\nexport function drawDrilldownCell(args: BaseDrawArgs, data: readonly DrilldownCellData[]) {\n    const { rect, theme, ctx, imageLoader, col, row } = args;\n    const { x, y, width: w, height: h } = rect;\n    const bubbleHeight = 24;\n    const bubblePad = 8;\n    const bubbleMargin = itemMargin;\n    let renderX = x + theme.cellHorizontalPadding;\n\n    const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder);\n\n    const renderBoxes: { x: number; width: number }[] = [];\n    for (const el of data) {\n        if (renderX > x + w) break;\n        const textWidth = measureTextCached(el.text, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;\n        let imgWidth = 0;\n        if (el.img !== undefined) {\n            const img = imageLoader.loadOrGetImage(el.img, col, row);\n            if (img !== undefined) {\n                imgWidth = bubbleHeight - 8 + 4;\n            }\n        }\n        const renderWidth = textWidth + imgWidth + bubblePad * 2;\n        renderBoxes.push({\n            x: renderX,\n            width: renderWidth,\n        });\n\n        renderX += renderWidth + bubbleMargin;\n    }\n\n    if (tileMap !== null) {\n        const { el, height, middleWidth, sideWidth, width } = tileMap;\n        for (const rectInfo of renderBoxes) {\n            const rx = Math.floor(rectInfo.x);\n            const rw = Math.floor(rectInfo.width);\n            ctx.imageSmoothingEnabled = false;\n            const maxSideWidth = Math.min(17, rw / 2 + 5);\n            ctx.drawImage(el, 0, 0, sideWidth, height, rx - 5, y + h / 2 - 17, maxSideWidth, 34);\n            if (rectInfo.width > 24)\n                ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + 12, y + h / 2 - 17, rw - 24, 34);\n            ctx.drawImage(\n                el,\n                width - sideWidth,\n                0,\n                sideWidth,\n                height,\n                rx + rw - (maxSideWidth - 5),\n                y + h / 2 - 17,\n                maxSideWidth,\n                34\n            );\n            ctx.imageSmoothingEnabled = true;\n        }\n    }\n\n    ctx.beginPath();\n\n    for (const [i, rectInfo] of renderBoxes.entries()) {\n        const d = data[i];\n        let drawX = rectInfo.x + bubblePad;\n\n        if (d.img !== undefined) {\n            const img = imageLoader.loadOrGetImage(d.img, col, row);\n            if (img !== undefined) {\n                const imgSize = bubbleHeight - 8;\n                let srcX = 0;\n                let srcY = 0;\n                let srcWidth = img.width;\n                let srcHeight = img.height;\n\n                if (srcWidth > srcHeight) {\n                    // landscape\n                    srcX += (srcWidth - srcHeight) / 2;\n                    srcWidth = srcHeight;\n                } else if (srcHeight > srcWidth) {\n                    //portrait\n                    srcY += (srcHeight - srcWidth) / 2;\n                    srcHeight = srcWidth;\n                }\n                ctx.beginPath();\n                roundedRect(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, 3);\n                ctx.save();\n                ctx.clip();\n                ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);\n                ctx.restore();\n\n                drawX += imgSize + 4;\n            }\n        }\n\n        ctx.beginPath();\n        ctx.fillStyle = theme.textBubble;\n        ctx.fillText(d.text, drawX, y + h / 2 + getMiddleCenterBias(ctx, theme));\n    }\n}\n\nexport function drawImage(args: BaseDrawArgs, data: readonly string[], rounding: number = 4) {\n    const { rect, col, row, theme, ctx, imageLoader } = args;\n    const { x, y, height: h } = rect;\n    let drawX = x + theme.cellHorizontalPadding;\n    for (const i of data) {\n        if (i.length === 0) continue;\n        const img = imageLoader.loadOrGetImage(i, col, row);\n\n        if (img !== undefined) {\n            const imgHeight = h - theme.cellVerticalPadding * 2;\n            const imgWidth = img.width * (imgHeight / img.height);\n            if (rounding > 0) {\n                roundedRect(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);\n                ctx.save();\n                ctx.clip();\n            }\n            ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);\n            if (rounding > 0) {\n                ctx.restore();\n            }\n\n            drawX += imgWidth + itemMargin;\n        }\n    }\n}\n\ninterface Point {\n    x: number;\n    y: number;\n    radius?: number;\n}\n\ninterface Vector {\n    nx: number;\n    ny: number;\n    len: number;\n    x: number;\n    y: number;\n    ang: number;\n}\n\nexport function roundedPoly(ctx: CanvasRenderingContext2D, points: Point[], radiusAll: number) {\n    // convert 2 points into vector form, polar form, and normalised\n    const asVec = function (p: Point, pp: Point): Vector {\n        const vx = pp.x - p.x;\n        const vy = pp.y - p.y;\n        const vlen = Math.sqrt(vx * vx + vy * vy);\n        const vnx = vx / vlen;\n        const vny = vy / vlen;\n        return {\n            x: vx,\n            y: pp.y - p.y,\n            len: vlen,\n            nx: vnx,\n            ny: vny,\n            ang: Math.atan2(vny, vnx),\n        };\n    };\n    let radius: number;\n    // const v1: Vector = {} as any;\n    // const v2: Vector = {} as any;\n    const len = points.length;\n    let p1 = points[len - 1];\n    // for each point\n    for (let i = 0; i < len; i++) {\n        let p2 = points[i % len];\n        const p3 = points[(i + 1) % len];\n        //-----------------------------------------\n        // Part 1\n        const v1 = asVec(p2, p1);\n        const v2 = asVec(p2, p3);\n        const sinA = v1.nx * v2.ny - v1.ny * v2.nx;\n        const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;\n        let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);\n        //-----------------------------------------\n        let radDirection = 1;\n        let drawDirection = false;\n        if (sinA90 < 0) {\n            if (angle < 0) {\n                angle = Math.PI + angle;\n            } else {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        } else {\n            if (angle > 0) {\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        radius = p2.radius !== undefined ? p2.radius : radiusAll;\n        //-----------------------------------------\n        // Part 2\n        const halfAngle = angle / 2;\n        //-----------------------------------------\n\n        //-----------------------------------------\n        // Part 3\n        let lenOut = Math.abs((Math.cos(halfAngle) * radius) / Math.sin(halfAngle));\n        //-----------------------------------------\n\n        //-----------------------------------------\n        // Special part A\n        let cRadius: number;\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        } else {\n            cRadius = radius;\n        }\n        //-----------------------------------------\n        // Part 4\n        let x = p2.x + v2.nx * lenOut;\n        let y = p2.y + v2.ny * lenOut;\n        //-----------------------------------------\n        // Part 5\n        x += -v2.ny * cRadius * radDirection;\n        y += v2.nx * cRadius * radDirection;\n        //-----------------------------------------\n        // Part 6\n        ctx.arc(\n            x,\n            y,\n            cRadius,\n            v1.ang + (Math.PI / 2) * radDirection,\n            v2.ang - (Math.PI / 2) * radDirection,\n            drawDirection\n        );\n        //-----------------------------------------\n        p1 = p2;\n        p2 = p3;\n    }\n    ctx.closePath();\n}\n\nexport function computeBounds(\n    col: number,\n    row: number,\n    width: number,\n    height: number,\n    groupHeaderHeight: number,\n    totalHeaderHeight: number,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    rows: number,\n    freezeColumns: number,\n    lastRowSticky: boolean,\n    mappedColumns: readonly MappedGridColumn[],\n    rowHeight: number | ((index: number) => number)\n): Rectangle {\n    const result: Rectangle = {\n        x: 0,\n        y: totalHeaderHeight + translateY,\n        width: 0,\n        height: 0,\n    };\n\n    const headerHeight = totalHeaderHeight - groupHeaderHeight;\n\n    if (col >= freezeColumns) {\n        const dir = cellXOffset > col ? -1 : 1;\n        const freezeWidth = getStickyWidth(mappedColumns);\n        result.x += freezeWidth + translateX;\n        for (let i = cellXOffset; i !== col; i += dir) {\n            result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;\n        }\n    } else {\n        for (let i = 0; i < col; i++) {\n            result.x += mappedColumns[i].width;\n        }\n    }\n    result.width = mappedColumns[col].width + 1;\n\n    if (row === -1) {\n        result.y = groupHeaderHeight;\n        result.height = headerHeight;\n    } else if (row === -2) {\n        result.y = 0;\n        result.height = groupHeaderHeight;\n\n        let start = col;\n        const group = mappedColumns[col].group;\n        const sticky = mappedColumns[col].sticky;\n        while (\n            start > 0 &&\n            isGroupEqual(mappedColumns[start - 1].group, group) &&\n            mappedColumns[start - 1].sticky === sticky\n        ) {\n            const c = mappedColumns[start - 1];\n            result.x -= c.width;\n            result.width += c.width;\n            start--;\n        }\n\n        let end = col;\n        while (\n            end + 1 < mappedColumns.length &&\n            isGroupEqual(mappedColumns[end + 1].group, group) &&\n            mappedColumns[end + 1].sticky === sticky\n        ) {\n            const c = mappedColumns[end + 1];\n            result.width += c.width;\n            end++;\n        }\n        if (!sticky) {\n            const freezeWidth = getStickyWidth(mappedColumns);\n            const clip = result.x - freezeWidth;\n            if (clip < 0) {\n                result.x -= clip;\n                result.width += clip;\n            }\n\n            if (result.x + result.width > width) {\n                result.width = width - result.x;\n            }\n        }\n    } else if (lastRowSticky && row === rows - 1) {\n        const stickyHeight = typeof rowHeight === \"number\" ? rowHeight : rowHeight(row);\n        result.y = height - stickyHeight;\n        result.height = stickyHeight;\n    } else {\n        const dir = cellYOffset > row ? -1 : 1;\n        if (typeof rowHeight === \"number\") {\n            const delta = row - cellYOffset;\n            result.y += delta * rowHeight;\n        } else {\n            for (let r = cellYOffset; r !== row; r += dir) {\n                result.y += rowHeight(r) * dir;\n            }\n        }\n        result.height = (typeof rowHeight === \"number\" ? rowHeight : rowHeight(row)) + 1;\n    }\n\n    return result;\n}\n","import type { Theme } from \"../common/styles\";\nimport { assertNever, proveType } from \"../common/support\";\nimport has from \"lodash/has.js\";\nimport type React from \"react\";\nimport type { CSSProperties } from \"react\";\nimport type { SpriteManager } from \"./data-grid-sprites\";\nimport type { OverlayImageEditorProps } from \"../data-grid-overlay-editor/private/image-overlay-editor\";\n\n// Thoughts:\n// rows/columns are called out as selected, but when selected they must also be added\n// to the range. Handling delete events may have different desired outcomes depending on\n// how the range came to be selected. The rows/columns properties retain this essential\n// information.\n/** @category Selection */\nexport interface GridSelection {\n    readonly current?: {\n        readonly cell: Item;\n        readonly range: Readonly<Rectangle>;\n        readonly rangeStack: readonly Readonly<Rectangle>[]; // lowest to highest, does not include range\n    };\n    readonly columns: CompactSelection;\n    readonly rows: CompactSelection;\n}\n\n/** @category Types */\nexport type ImageEditorType = React.ComponentType<OverlayImageEditorProps>;\n\n/** @category Types */\nexport type GridMouseEventArgs =\n    | GridMouseCellEventArgs\n    | GridMouseHeaderEventArgs\n    | GridMouseOutOfBoundsEventArgs\n    | GridMouseGroupHeaderEventArgs;\n\ninterface PreventableEvent {\n    preventDefault: () => void;\n}\n/** @category Types */\nexport interface CellClickedEventArgs extends GridMouseCellEventArgs, PreventableEvent {}\n\n/** @category Types */\nexport interface HeaderClickedEventArgs extends GridMouseHeaderEventArgs, PreventableEvent {}\n\n/** @category Types */\nexport interface GroupHeaderClickedEventArgs extends GridMouseGroupHeaderEventArgs, PreventableEvent {}\n\n/** @category Types */\nexport interface ImageWindowLoader {\n    setWindow(newWindow: Rectangle, freezeCols: number): void;\n    loadOrGetImage(url: string, col: number, row: number): HTMLImageElement | ImageBitmap | undefined;\n    setCallback(imageLoaded: (locations: readonly Item[]) => void): void;\n}\n\n/** @category Types */\nexport const BooleanEmpty = null;\n/** @category Types */\nexport const BooleanIndeterminate = undefined;\n\n/** @category Types */\nexport type BooleanEmpty = null;\n/** @category Types */\nexport type BooleanIndeterminate = undefined;\n\ninterface PositionableMouseEventArgs {\n    readonly localEventX: number;\n    readonly localEventY: number;\n}\n\n/** @category Types */\nexport interface BaseGridMouseEventArgs {\n    readonly shiftKey: boolean;\n    readonly ctrlKey: boolean;\n    readonly metaKey: boolean;\n    readonly isTouch: boolean;\n    readonly isLongTouch?: boolean;\n    readonly isEdge: boolean;\n    readonly button: number;\n    readonly scrollEdge: readonly [xDir: -1 | 0 | 1, yDir: -1 | 0 | 1];\n}\n\n/** @category Types */\nexport interface GridMouseCellEventArgs extends BaseGridMouseEventArgs, PositionableMouseEventArgs {\n    readonly kind: \"cell\";\n    readonly location: Item;\n    readonly bounds: Rectangle;\n    readonly isFillHandle: boolean;\n}\n\n/** @category Types */\nexport const headerKind = \"header\" as const;\n/** @category Types */\nexport interface GridMouseHeaderEventArgs extends BaseGridMouseEventArgs, PositionableMouseEventArgs {\n    readonly kind: typeof headerKind;\n    readonly location: readonly [number, -1];\n    readonly bounds: Rectangle;\n    readonly group: string;\n}\n\n/** @category Types */\nexport const groupHeaderKind = \"group-header\" as const;\n/** @category Types */\nexport interface GridMouseGroupHeaderEventArgs extends BaseGridMouseEventArgs, PositionableMouseEventArgs {\n    readonly kind: typeof groupHeaderKind;\n    readonly location: readonly [number, -2];\n    readonly bounds: Rectangle;\n    readonly group: string;\n}\n\n/** @category Types */\nexport const outOfBoundsKind = \"out-of-bounds\" as const;\n/** @category Types */\nexport interface GridMouseOutOfBoundsEventArgs extends BaseGridMouseEventArgs {\n    readonly kind: typeof outOfBoundsKind;\n    readonly location: Item;\n    readonly direction: readonly [-1 | 0 | 1, -1 | 0 | 1];\n}\n\n/** @category Types */\nexport interface GridKeyEventArgs {\n    readonly bounds: Rectangle | undefined;\n    readonly key: string;\n    readonly keyCode: number;\n    readonly altKey: boolean;\n    readonly shiftKey: boolean;\n    readonly ctrlKey: boolean;\n    readonly metaKey: boolean;\n    readonly cancel: () => void;\n    readonly stopPropagation: () => void;\n    readonly preventDefault: () => void;\n    readonly rawEvent: React.KeyboardEvent<HTMLElement> | undefined;\n}\n\ninterface DragHandler {\n    readonly setData: (mime: string, payload: string) => void;\n    readonly setDragImage: (image: Element, x: number, y: number) => void;\n    readonly preventDefault: () => void;\n    readonly defaultPrevented: () => boolean;\n}\n\n/** @category Types */\nexport type GridDragEventArgs = GridMouseEventArgs & DragHandler;\n\n/** @category Types */\nexport type TrailingRowType = \"sticky\" | \"appended\" | \"none\";\n\n/** @category Types */\nexport type DrawCustomCellCallback = (args: {\n    ctx: CanvasRenderingContext2D;\n    cell: GridCell;\n    theme: Theme;\n    rect: Rectangle;\n    col: number;\n    row: number;\n    hoverAmount: number;\n    hoverX: number | undefined;\n    hoverY: number | undefined;\n    highlighted: boolean;\n    imageLoader: ImageWindowLoader;\n    requestAnimationFrame: () => void;\n}) => boolean;\n\n/** @category Types */\nexport type DrawHeaderCallback = (args: {\n    ctx: CanvasRenderingContext2D;\n    column: GridColumn;\n    columnIndex: number;\n    theme: Theme;\n    rect: Rectangle;\n    hoverAmount: number;\n    isSelected: boolean;\n    isHovered: boolean;\n    hasSelectedCell: boolean;\n    spriteManager: SpriteManager;\n    menuBounds: Rectangle;\n}) => boolean;\n\n/** @category Cells */\nexport enum GridCellKind {\n    Uri = \"uri\",\n    Text = \"text\",\n    Image = \"image\",\n    RowID = \"row-id\",\n    Number = \"number\",\n    Bubble = \"bubble\",\n    Boolean = \"boolean\",\n    Loading = \"loading\",\n    Markdown = \"markdown\",\n    Drilldown = \"drilldown\",\n    Protected = \"protected\",\n    Custom = \"custom\",\n}\n\n/** @category Columns */\nexport enum GridColumnIcon {\n    HeaderRowID = \"headerRowID\",\n    HeaderCode = \"headerCode\",\n    HeaderNumber = \"headerNumber\",\n    HeaderString = \"headerString\",\n    HeaderBoolean = \"headerBoolean\",\n    HeaderAudioUri = \"headerAudioUri\",\n    HeaderVideoUri = \"headerVideoUri\",\n    HeaderEmoji = \"headerEmoji\",\n    HeaderImage = \"headerImage\",\n    HeaderUri = \"headerUri\",\n    HeaderPhone = \"headerPhone\",\n    HeaderMarkdown = \"headerMarkdown\",\n    HeaderDate = \"headerDate\",\n    HeaderTime = \"headerTime\",\n    HeaderEmail = \"headerEmail\",\n    HeaderReference = \"headerReference\",\n    HeaderIfThenElse = \"headerIfThenElse\",\n    HeaderSingleValue = \"headerSingleValue\",\n    HeaderLookup = \"headerLookup\",\n    HeaderTextTemplate = \"headerTextTemplate\",\n    HeaderMath = \"headerMath\",\n    HeaderRollup = \"headerRollup\",\n    HeaderJoinStrings = \"headerJoinStrings\",\n    HeaderSplitString = \"headerSplitString\",\n    HeaderGeoDistance = \"headerGeoDistance\",\n    HeaderArray = \"headerArray\",\n    RowOwnerOverlay = \"rowOwnerOverlay\",\n    ProtectedColumnOverlay = \"protectedColumnOverlay\",\n}\n\n/** @category Types */\nexport type CellArray = readonly (readonly GridCell[])[];\n\n/** @category Types */\nexport type Item = readonly [col: number, row: number];\n\n/** @category Types */\nexport const headerCellCheckboxPrefix = \"___gdg_header_cell_\";\n/** @category Types */\nexport const headerCellCheckedMarker = headerCellCheckboxPrefix + \"checked\";\n/** @category Types */\nexport const headerCellUnheckedMarker = headerCellCheckboxPrefix + \"unchecked\";\n/** @category Types */\nexport const headerCellIndeterminateMarker = headerCellCheckboxPrefix + \"indeterminate\";\n\ninterface BaseGridColumn {\n    readonly title: string;\n    readonly group?: string;\n    readonly icon?: GridColumnIcon | string;\n    readonly overlayIcon?: GridColumnIcon | string;\n    readonly hasMenu?: boolean;\n    readonly grow?: number;\n    readonly style?: \"normal\" | \"highlight\";\n    readonly themeOverride?: Partial<Theme>;\n    readonly trailingRowOptions?: {\n        readonly hint?: string;\n        readonly addIcon?: string;\n        readonly targetColumn?: number | GridColumn;\n        readonly themeOverride?: Partial<Theme>;\n        readonly disabled?: boolean;\n    };\n}\n\n/** @category Columns */\nexport function isSizedGridColumn(c: GridColumn): c is SizedGridColumn {\n    return \"width\" in c && typeof c.width === \"number\";\n}\n\n/** @category Columns */\nexport interface SizedGridColumn extends BaseGridColumn {\n    readonly width: number;\n    readonly id?: string;\n}\n\n/** @category Columns */\nexport interface AutoGridColumn extends BaseGridColumn {\n    readonly id: string;\n}\n\n/** @category Types */\nexport async function resolveCellsThunk(thunk: GetCellsThunk | CellArray): Promise<CellArray> {\n    if (typeof thunk === \"object\") return thunk;\n    return await thunk();\n}\n\n/** @category Types */\nexport type GetCellsThunk = () => Promise<CellArray>;\n\n/** @category Columns */\nexport type GridColumn = SizedGridColumn | AutoGridColumn;\n\n/** @category Columns */\nexport type InnerGridColumn = SizedGridColumn & { growOffset?: number };\n\n// export type SizedGridColumn = Omit<GridColumn, \"width\"> & { readonly width: number };\n\n/** @category Cells */\nexport type ReadWriteGridCell = TextCell | NumberCell | MarkdownCell | UriCell | CustomCell | BooleanCell;\n\n/** @category Cells */\nexport type EditableGridCell = TextCell | ImageCell | BooleanCell | MarkdownCell | UriCell | NumberCell | CustomCell;\n\n/** @category Cells */\nexport type EditableGridCellKind = EditableGridCell[\"kind\"];\n\n// All EditableGridCells are inherently ValidatedGridCells, and this is more specific and thus more useful.\n/** @category Cells */\nexport function isEditableGridCell(cell: GridCell): cell is ValidatedGridCell {\n    if (\n        cell.kind === GridCellKind.Loading ||\n        cell.kind === GridCellKind.Bubble ||\n        cell.kind === GridCellKind.RowID ||\n        cell.kind === GridCellKind.Protected ||\n        cell.kind === GridCellKind.Drilldown\n    ) {\n        return false;\n    }\n\n    proveType<EditableGridCell>(cell);\n    return true;\n}\n\n/** @category Cells */\nexport function isTextEditableGridCell(cell: GridCell): cell is ReadWriteGridCell {\n    if (\n        cell.kind === GridCellKind.Loading ||\n        cell.kind === GridCellKind.Bubble ||\n        cell.kind === GridCellKind.RowID ||\n        cell.kind === GridCellKind.Protected ||\n        cell.kind === GridCellKind.Drilldown ||\n        cell.kind === GridCellKind.Boolean ||\n        cell.kind === GridCellKind.Image ||\n        cell.kind === GridCellKind.Custom\n    ) {\n        return false;\n    }\n\n    proveType<ReadWriteGridCell>(cell);\n    return true;\n}\n\n/** @category Cells */\nexport function isInnerOnlyCell(cell: InnerGridCell): cell is InnerOnlyGridCell {\n    return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;\n}\n\n/** @category Cells */\nexport function isReadWriteCell(cell: GridCell): cell is ReadWriteGridCell {\n    if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image) return false;\n\n    if (\n        cell.kind === GridCellKind.Text ||\n        cell.kind === GridCellKind.Number ||\n        cell.kind === GridCellKind.Markdown ||\n        cell.kind === GridCellKind.Uri ||\n        cell.kind === GridCellKind.Custom ||\n        cell.kind === GridCellKind.Boolean\n    ) {\n        return cell.readonly !== true;\n    }\n    assertNever(cell);\n}\n\n/** @category Cells */\nexport type GridCell =\n    | EditableGridCell\n    | BubbleCell\n    | RowIDCell\n    | LoadingCell\n    | ProtectedCell\n    | DrilldownCell\n    | CustomCell;\n\ntype InnerOnlyGridCell = NewRowCell | MarkerCell;\n/** @category Cells */\nexport type InnerGridCell = GridCell | InnerOnlyGridCell;\n\n/** @category Cells */\nexport type CellList = readonly Item[];\n\n/** @category Types */\nexport interface Rectangle {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/** @category Cells */\nexport interface BaseGridCell {\n    readonly allowOverlay: boolean;\n    readonly lastUpdated?: number;\n    readonly style?: \"normal\" | \"faded\";\n    readonly themeOverride?: Partial<Theme>;\n    readonly span?: readonly [start: number, end: number];\n    readonly contentAlign?: \"left\" | \"right\" | \"center\";\n    readonly cursor?: CSSProperties[\"cursor\"];\n}\n\n/** @category Cells */\nexport interface LoadingCell extends BaseGridCell {\n    readonly kind: GridCellKind.Loading;\n}\n\n/** @category Cells */\nexport interface ProtectedCell extends BaseGridCell {\n    readonly kind: GridCellKind.Protected;\n}\n\n/** @category Cells */\nexport interface TextCell extends BaseGridCell {\n    readonly kind: GridCellKind.Text;\n    readonly displayData: string;\n    readonly data: string;\n    readonly readonly?: boolean;\n    readonly allowWrapping?: boolean;\n}\n\n/** @category Cells */\nexport interface NumberCell extends BaseGridCell {\n    readonly kind: GridCellKind.Number;\n    readonly displayData: string;\n    readonly data: number | undefined;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface ImageCell extends BaseGridCell {\n    readonly kind: GridCellKind.Image;\n    readonly data: string[];\n    readonly rounding?: number;\n    readonly displayData?: string[]; // used for small images for faster scrolling\n    readonly allowAdd: boolean;\n}\n\n/** @category Cells */\nexport interface BubbleCell extends BaseGridCell {\n    readonly kind: GridCellKind.Bubble;\n    readonly data: string[];\n}\n\n/** @category Renderers */\nexport type SelectionRange = number | readonly [number, number];\n\n/** @category Renderers */\nexport type ProvideEditorComponent<T extends InnerGridCell> = React.FunctionComponent<{\n    readonly onChange: (newValue: T) => void;\n    readonly onFinishedEditing: (newValue?: T) => void;\n    readonly isHighlighted: boolean;\n    readonly value: T;\n    readonly initialValue?: string;\n    readonly validatedSelection?: SelectionRange;\n    readonly imageEditorOverride?: ImageEditorType;\n    readonly markdownDivCreateNode?: (content: string) => DocumentFragment;\n    readonly target: Rectangle;\n    readonly forceEditMode: boolean;\n    readonly isValid?: boolean;\n}>;\n\ntype ObjectEditorCallbackResult<T extends InnerGridCell> = {\n    editor: ProvideEditorComponent<T>;\n    deletedValue?: (toDelete: T) => T;\n    styleOverride?: CSSProperties;\n    disablePadding?: boolean;\n    disableStyling?: boolean;\n};\n\n/** @category Renderers */\nexport type ProvideEditorCallbackResult<T extends InnerGridCell> =\n    | (ProvideEditorComponent<T> & {\n          disablePadding?: boolean;\n          disableStyling?: boolean;\n      })\n    | ObjectEditorCallbackResult<T>\n    | undefined;\n\n/** @category Renderers */\nexport function isObjectEditorCallbackResult<T extends InnerGridCell>(\n    obj: ProvideEditorCallbackResult<T>\n): obj is ObjectEditorCallbackResult<T> {\n    return has(obj, \"editor\");\n}\n\n/** @category Renderers */\nexport type ProvideEditorCallback<T extends InnerGridCell> = (cell: T) => ProvideEditorCallbackResult<T>;\n\n/** @category Cells */\nexport type ValidatedGridCell = EditableGridCell & {\n    selectionRange?: SelectionRange;\n};\n\n/** @category Cells */\nexport interface CustomCell<T extends {} = {}> extends BaseGridCell {\n    readonly kind: GridCellKind.Custom;\n    readonly data: T;\n    readonly copyData: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface DrilldownCellData {\n    readonly text: string;\n    readonly img?: string;\n}\n\n/** @category Cells */\nexport interface DrilldownCell extends BaseGridCell {\n    readonly kind: GridCellKind.Drilldown;\n    readonly data: readonly DrilldownCellData[];\n}\n\n/** @category Cells */\nexport interface BooleanCell extends BaseGridCell {\n    readonly kind: GridCellKind.Boolean;\n    readonly data: boolean | BooleanEmpty | BooleanIndeterminate;\n    readonly readonly?: boolean;\n    readonly allowOverlay: false;\n}\n\n// Can be written more concisely, not easier to read if more concise.\n/** @category Cells */\nexport function booleanCellIsEditable(cell: BooleanCell): boolean {\n    return !(cell.readonly ?? false);\n}\n\n/** @category Cells */\nexport interface RowIDCell extends BaseGridCell {\n    readonly kind: GridCellKind.RowID;\n    readonly data: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface MarkdownCell extends BaseGridCell {\n    readonly kind: GridCellKind.Markdown;\n    readonly data: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface UriCell extends BaseGridCell {\n    readonly kind: GridCellKind.Uri;\n    readonly data: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport enum InnerGridCellKind {\n    NewRow = \"new-row\",\n    Marker = \"marker\",\n}\n\n/** @category Cells */\nexport interface NewRowCell extends BaseGridCell {\n    readonly kind: InnerGridCellKind.NewRow;\n    readonly hint: string;\n    readonly allowOverlay: false;\n    readonly icon?: string;\n}\n\n/** @category Cells */\nexport interface MarkerCell extends BaseGridCell {\n    readonly kind: InnerGridCellKind.Marker;\n    readonly allowOverlay: false;\n    readonly row: number;\n    readonly drawHandle: boolean;\n    readonly checked: boolean;\n    readonly markerKind: \"checkbox\" | \"number\" | \"both\";\n}\n\n/** @category Selection */\nexport type Slice = [start: number, end: number];\n/** @category Selection */\nexport type CompactSelectionRanges = readonly Slice[];\n\nfunction mergeRanges(input: CompactSelectionRanges) {\n    if (input.length === 0) {\n        return [];\n    }\n    const ranges = [...input];\n\n    const stack: [number, number][] = [];\n\n    ranges.sort(function (a, b) {\n        return a[0] - b[0];\n    });\n\n    stack.push([...ranges[0]]);\n\n    for (const range of ranges.slice(1)) {\n        const top = stack[stack.length - 1];\n\n        if (top[1] < range[0]) {\n            stack.push([...range]);\n        } else if (top[1] < range[1]) {\n            top[1] = range[1];\n        }\n    }\n\n    return stack;\n}\n\nlet emptyCompactSelection: CompactSelection | undefined;\n\n/** @category Selection */\nexport class CompactSelection {\n    private constructor(private readonly items: CompactSelectionRanges) {}\n\n    static empty = (): CompactSelection => {\n        return emptyCompactSelection ?? (emptyCompactSelection = new CompactSelection([]));\n    };\n\n    static fromSingleSelection = (selection: number | Slice) => {\n        return CompactSelection.empty().add(selection);\n    };\n\n    offset = (amount: number): CompactSelection => {\n        if (amount === 0) return this;\n        const newItems = this.items.map(x => [x[0] + amount, x[1] + amount] as Slice);\n        return new CompactSelection(newItems);\n    };\n\n    add = (selection: number | Slice): CompactSelection => {\n        const slice: Slice = typeof selection === \"number\" ? [selection, selection + 1] : selection;\n\n        const newItems = mergeRanges([...this.items, slice]);\n\n        return new CompactSelection(newItems);\n    };\n\n    remove = (selection: number | Slice): CompactSelection => {\n        const items = [...this.items];\n\n        const selMin = typeof selection === \"number\" ? selection : selection[0];\n        const selMax = typeof selection === \"number\" ? selection + 1 : selection[1];\n\n        for (const [i, slice] of items.entries()) {\n            const [start, end] = slice;\n            // Remove part of slice that intersects removed selection.\n            if (start <= selMax && selMin <= end) {\n                const toAdd: Slice[] = [];\n                if (start < selMin) {\n                    toAdd.push([start, selMin]);\n                }\n                if (selMax < end) {\n                    toAdd.push([selMax, end]);\n                }\n                items.splice(i, 1, ...toAdd);\n            }\n        }\n        return new CompactSelection(items);\n    };\n\n    first = (): number | undefined => {\n        if (this.items.length === 0) return undefined;\n        return this.items[0][0];\n    };\n\n    last = (): number | undefined => {\n        if (this.items.length === 0) return undefined;\n        return this.items.slice(-1)[0][1] - 1;\n    };\n\n    hasIndex = (index: number): boolean => {\n        for (let i = 0; i < this.items.length; i++) {\n            const [start, end] = this.items[i];\n            if (index >= start && index < end) return true;\n        }\n        return false;\n    };\n\n    hasAll = (index: Slice): boolean => {\n        for (let x = index[0]; x < index[1]; x++) {\n            if (!this.hasIndex(x)) return false;\n        }\n        return true;\n    };\n\n    some = (predicate: (index: number) => boolean): boolean => {\n        for (const i of this) {\n            if (predicate(i)) return true;\n        }\n        return false;\n    };\n\n    equals = (other: CompactSelection): boolean => {\n        if (other === this) return true;\n\n        if (other.items.length !== this.items.length) return false;\n\n        for (let i = 0; i < this.items.length; i++) {\n            const left = other.items[i];\n            const right = this.items[i];\n\n            if (left[0] !== right[0] || left[1] !== right[1]) return false;\n        }\n\n        return true;\n    };\n\n    // Really old JS wont have access to the iterator and babel will stop people using it\n    // when trying to support browsers so old we don't support them anyway. What goes on\n    // between an engineer and their bundler in the privacy of their CI server is none of\n    // my business anyway.\n    toArray = (): number[] => {\n        const result: number[] = [];\n        for (const [start, end] of this.items) {\n            for (let x = start; x < end; x++) {\n                result.push(x);\n            }\n        }\n        return result;\n    };\n\n    get length(): number {\n        let len = 0;\n        for (const [start, end] of this.items) {\n            len += end - start;\n        }\n\n        return len;\n    }\n\n    *[Symbol.iterator]() {\n        for (const [start, end] of this.items) {\n            for (let x = start; x < end; x++) {\n                yield x;\n            }\n        }\n    }\n}\n","/* eslint-disable sonarjs/no-identical-functions */\nimport * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport DataGrid from \"./data-grid\";\nimport { CompactSelection, GridCellKind, GridSelection } from \"./data-grid-types\";\nimport { getDataEditorTheme } from \"../common/styles\";\nimport type { GetCellRendererCallback } from \"./cells/cell-types\";\nimport { CellRenderers } from \"./cells\";\n\nexport default {\n    title: \"Subcomponents/DataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1800} height={1000}>\n                    <div style={{ position: \"relative\" }}>\n                        <Story />\n                    </div>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nconst emptyGridSelection: GridSelection = {\n    columns: CompactSelection.empty(),\n    rows: CompactSelection.empty(),\n    current: undefined,\n};\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport function Simplenotest() {\n    let x = 0;\n\n    const [y, setY] = React.useState(0);\n\n    React.useEffect(() => {\n        let handle = 0;\n        const cb = () => {\n            setY(cv => cv + 1);\n            handle = window.requestAnimationFrame(cb);\n        };\n\n        cb();\n\n        return () => window.cancelAnimationFrame(handle);\n    }, []);\n\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            isFocused={true}\n            cellYOffset={y}\n            isFilling={false}\n            onMouseMove={() => undefined}\n            groupHeaderHeight={0}\n            accessibilityHeight={50}\n            enableGroups={false}\n            selection={emptyGridSelection}\n            rows={100_000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\"].map(\n                t => ({\n                    title: t,\n                    width: 122 + (x += 10),\n                })\n            )}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport function SelectedCellnotest() {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            onMouseMove={() => undefined}\n            accessibilityHeight={50}\n            isFilling={false}\n            cellYOffset={0}\n            groupHeaderHeight={34}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: {\n                    cell: [2, 2],\n                    range: { x: 2, y: 2, width: 1, height: 1 },\n                    rangeStack: [],\n                },\n                columns: CompactSelection.empty(),\n                rows: CompactSelection.empty(),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport function SelectedRownotest() {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            cellYOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            groupHeaderHeight={34}\n            accessibilityHeight={50}\n            isFilling={false}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.fromSingleSelection([2, 4]),\n                columns: CompactSelection.empty(),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n}\n\nexport const SelectedColumnnotest = () => {\n    let x = 0;\n    return (\n        <DataGrid\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            width={1800}\n            height={1000}\n            cellXOffset={0}\n            cellYOffset={0}\n            isFocused={true}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseMoveRaw={() => undefined}\n            onMouseUp={() => undefined}\n            smoothScrollX={undefined}\n            smoothScrollY={undefined}\n            allowResize={undefined}\n            canvasRef={undefined}\n            disabledRows={undefined}\n            eventTargetRef={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            translateX={undefined}\n            translateY={undefined}\n            dragAndDropState={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            accessibilityHeight={50}\n            isFilling={false}\n            groupHeaderHeight={34}\n            enableGroups={false}\n            rows={1000}\n            headerHeight={44}\n            rowHeight={34}\n            columns={[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"].map(t => ({\n                title: t,\n                width: 122 + (x += 10),\n            }))}\n            getCellContent={([col, row]) => ({\n                kind: GridCellKind.Text,\n                displayData: `${col},${row} Testing things that are way too long`,\n                data: `${col},${row} Testing things that are way too long`,\n                allowOverlay: false,\n                owned: true,\n            })}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.fromSingleSelection([2, 4]),\n            }}\n            freezeColumns={0}\n            firstColAccessible={true}\n            verticalBorder={() => true}\n            trailingRowType={\"none\"}\n            isResizing={false}\n            isDragging={false}\n            theme={getDataEditorTheme()}\n        />\n    );\n};\n","import type { ImageWindowLoader, Item, Rectangle } from \"../data-grid/data-grid-types\";\nimport throttle from \"lodash/throttle.js\";\n\ninterface LoadResult {\n    img: HTMLImageElement | undefined;\n    cancel: () => void;\n    url: string;\n    cells: number[];\n}\n\nconst rowShift = 1 << 16;\n\nconst imgPool: HTMLImageElement[] = [];\n\nfunction packColRowToNumber(col: number, row: number) {\n    return row * rowShift + col;\n}\n\nfunction unpackCol(packed: number): number {\n    return packed % rowShift;\n}\n\nfunction unpackRow(packed: number, col: number): number {\n    return (packed - col) / rowShift;\n}\n\nfunction unpackNumberToColRow(packed: number): [number, number] {\n    const col = unpackCol(packed);\n    const row = unpackRow(packed, col);\n    return [col, row];\n}\n\nclass ImageWindowLoaderImpl implements ImageWindowLoader {\n    private imageLoaded: (locations: readonly Item[]) => void = () => undefined;\n    private loadedLocations: [number, number][] = [];\n\n    private visibleWindow: Rectangle = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n    };\n\n    private freezeCols: number = 0;\n\n    private isInWindow = (packed: number) => {\n        const col = unpackCol(packed);\n        const row = unpackRow(packed, col);\n        const w = this.visibleWindow;\n        if (col < this.freezeCols && row >= w.y && row <= w.y + w.height) return true;\n        return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;\n    };\n\n    private cache: Record<string, LoadResult> = {};\n\n    public setCallback(imageLoaded: (locations: readonly Item[]) => void) {\n        this.imageLoaded = imageLoaded;\n    }\n\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    private sendLoaded = throttle(() => {\n        this.imageLoaded(this.loadedLocations);\n        this.loadedLocations = [];\n    }, 20);\n\n    private clearOutOfWindow = () => {\n        const keys = Object.keys(this.cache);\n        for (const key of keys) {\n            const obj = this.cache[key];\n\n            let keep = false;\n            for (let j = 0; j < obj.cells.length; j++) {\n                const packed = obj.cells[j];\n                if (this.isInWindow(packed)) {\n                    keep = true;\n                    break;\n                }\n            }\n\n            if (keep) {\n                obj.cells = obj.cells.filter(this.isInWindow);\n            } else {\n                obj.cancel();\n                delete this.cache[key];\n            }\n        }\n    };\n\n    public setWindow(newWindow: Rectangle, freezeCols: number): void {\n        if (\n            this.visibleWindow.x === newWindow.x &&\n            this.visibleWindow.y === newWindow.y &&\n            this.visibleWindow.width === newWindow.width &&\n            this.visibleWindow.height === newWindow.height &&\n            this.freezeCols === freezeCols\n        )\n            return;\n        this.visibleWindow = newWindow;\n        this.freezeCols = freezeCols;\n        this.clearOutOfWindow();\n    }\n\n    private loadImage(url: string, col: number, row: number, key: string) {\n        let loaded = false;\n        const img = imgPool.pop() ?? new Image();\n\n        let canceled = false;\n        const result: LoadResult = {\n            img: undefined,\n            cells: [packColRowToNumber(col, row)],\n            url,\n            cancel: () => {\n                if (canceled) return;\n                canceled = true;\n                if (imgPool.length < 12) {\n                    imgPool.unshift(img); // never retain more than 12\n                } else if (!loaded) {\n                    img.src = \"\";\n                }\n            },\n        };\n\n        const loadPromise = new Promise(r => img.addEventListener(\"load\", () => r(null)));\n        // use request animation time to avoid paying src set costs during draw calls\n        requestAnimationFrame(async () => {\n            try {\n                img.src = url;\n                await loadPromise;\n                await img.decode();\n                const toWrite = this.cache[key];\n                if (toWrite !== undefined && !canceled) {\n                    toWrite.img = img;\n                    for (const packed of toWrite.cells) {\n                        this.loadedLocations.push(unpackNumberToColRow(packed));\n                    }\n                    loaded = true;\n                    this.sendLoaded();\n                }\n            } catch {\n                result.cancel();\n            }\n        });\n        this.cache[key] = result;\n    }\n\n    public loadOrGetImage(url: string, col: number, row: number): HTMLImageElement | ImageBitmap | undefined {\n        const key = url;\n\n        const current = this.cache[key];\n        if (current !== undefined) {\n            const packed = packColRowToNumber(col, row);\n            if (!current.cells.includes(packed)) {\n                current.cells.push(packed);\n            }\n            return current.img;\n        } else {\n            this.loadImage(url, col, row, key);\n        }\n        return undefined;\n    }\n}\n\nexport default ImageWindowLoaderImpl;\n","import type { SpriteProps } from \"../common/utils\";\n\nconst iconHead = `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">`;\nconst headerRowID = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n\n    return `\n    ${iconHead}<rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/><path d=\"M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z\" fill=\"${fg}\"/></svg>`;\n};\n\nconst headerCode = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}<rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"4\" fill=\"${bg}\"/><path d=\"m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z\" fill=\"${fg}\"/></svg>`;\n};\n\nconst headerNumber = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerString = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerBoolean = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path\n        d=\"M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z\"\n        fill=\"${bg}\"\n    />\n    <path\n        fill-rule=\"evenodd\"\n        clip-rule=\"evenodd\"\n        d=\"M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z\"\n        fill=\"${fg}\"\n    />\n</svg>`;\n};\n\nconst headerUri = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n<path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z\" fill=\"${fg}\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z\" fill=\"${fg}\"/>\n</svg>\n  `;\n};\n\nconst renameIcon = (props: SpriteProps) => {\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path stroke=\"${bg}\" stroke-width=\"2\" d=\"M12 3v14\"/>\n    <path stroke=\"${bg}\" stroke-width=\"2\" stroke-linecap=\"round\" d=\"M10 4h4m-4 12h4\"/>\n    <path d=\"M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z\" fill=\"${bg}\"/>\n  </svg>\n`;\n};\n\nconst headerAudioUri = headerUri;\n\nconst headerVideoUri = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerEmoji = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z\" fill=\"${fg}\"/>\n    <path d=\"M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z\" fill=\"${fg}\"/>\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z\" fill=\"${fg}\"/>\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z\" fill=\"${fg}\"/>\n    <path d=\"M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z\" fill=\"${fg}\"/>\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerImage = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path opacity=\".5\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerPhone = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path fill=\"${fg}\" d=\"M3 3h14v14H3z\"/>\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z\" fill=\"${bg}\"/>\n  </svg>`;\n};\n\nconst headerMarkdown = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerDate = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerTime = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z\" fill=\"${fg}\"/>\n    <path d=\"M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerEmail = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerReference = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"8\" width=\"10\" height=\"8\" rx=\"2\" fill=\"${bg}\"/>\n    <rect x=\"8\" y=\"4\" width=\"10\" height=\"8\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerIfThenElse = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path fill=\"${fg}\" d=\"M4 3h12v14H4z\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z\" fill=\"${bg}\"/>\n</svg>`;\n};\n\nconst headerSingleValue = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerLookup = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerTextTemplate = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path d=\"M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerMath = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z\" fill=\"${fg}\"/>\n  <path d=\"M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerRollup = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerJoinStrings = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path d=\"M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerSplitString = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerGeoDistance = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerArray = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst rowOwnerOverlay = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    <svg width=\"18\" height=\"18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z\" fill=\"${bg}\" stroke=\"${fg}\" stroke-width=\"2\"/>\n  </svg>`;\n};\n\nconst protectedColumnOverlay = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    <svg width=\"18\" height=\"18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z\" fill=\"${bg}\" stroke=\"${fg}\" stroke-width=\"2\"/>\n  </svg>\n`;\n};\n\nexport const sprites = {\n    headerRowID,\n    headerNumber,\n    headerCode,\n    headerString,\n    headerBoolean,\n    headerAudioUri,\n    headerVideoUri,\n    headerEmoji,\n    headerImage,\n    headerUri,\n    headerPhone,\n    headerMarkdown,\n    headerDate,\n    headerTime,\n    headerEmail,\n    headerReference,\n    headerIfThenElse,\n    headerSingleValue,\n    headerLookup,\n    headerTextTemplate,\n    headerMath,\n    headerRollup,\n    headerJoinStrings,\n    headerSplitString,\n    headerGeoDistance,\n    headerArray,\n    rowOwnerOverlay,\n    protectedColumnOverlay,\n    renameIcon,\n};\n\nexport type HeaderIconMap = Readonly<typeof sprites>;\n","import type { Theme } from \"../common/styles\";\nimport { HeaderIconMap, sprites } from \"./sprites\";\n\ntype HeaderIcon = keyof HeaderIconMap;\ntype Sprite = HeaderIconMap[\"headerArray\"];\n\n/** @category Columns */\nexport type SpriteMap = Record<string | HeaderIcon, Sprite>;\n\n/** @category Columns */\nexport type SpriteVariant = \"normal\" | \"selected\" | \"special\";\n\nfunction getColors(variant: SpriteVariant, theme: Theme): readonly [string, string] {\n    if (variant === \"normal\") {\n        return [theme.bgIconHeader, theme.fgIconHeader];\n    } else if (variant === \"selected\") {\n        return [\"white\", theme.accentColor];\n    } else {\n        return [theme.accentColor, theme.bgHeader];\n    }\n}\n\n/** @category Columns */\nexport class SpriteManager {\n    private spriteMap: Map<string, HTMLCanvasElement> = new Map();\n    private headerIcons: SpriteMap;\n    private inFlight = 0;\n\n    constructor(headerIcons: SpriteMap | undefined, private onSettled: () => void) {\n        this.headerIcons = {\n            ...sprites,\n            ...headerIcons,\n        };\n    }\n\n    public drawSprite(\n        sprite: HeaderIcon | string,\n        variant: SpriteVariant,\n        ctx: CanvasRenderingContext2D,\n        x: number,\n        y: number,\n        size: number,\n        theme: Theme,\n        alpha: number = 1\n    ) {\n        const [bgColor, fgColor] = getColors(variant, theme);\n        const rSize = size * Math.ceil(window.devicePixelRatio);\n        const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;\n\n        let spriteCanvas = this.spriteMap.get(key);\n        if (spriteCanvas === undefined) {\n            const spriteCb = this.headerIcons[sprite];\n\n            if (spriteCb === undefined) return;\n\n            spriteCanvas = document.createElement(\"canvas\");\n            const spriteCtx = spriteCanvas.getContext(\"2d\");\n\n            if (spriteCtx === null) return;\n\n            const imgSource = new Image();\n            imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({ fgColor, bgColor }))}`;\n            this.spriteMap.set(key, spriteCanvas);\n            const promise: Promise<void> | undefined = imgSource.decode();\n\n            if (promise === undefined) return;\n\n            this.inFlight++;\n            promise\n                .then(() => {\n                    spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);\n                })\n                .finally(() => {\n                    this.inFlight--;\n                    if (this.inFlight === 0) {\n                        this.onSettled();\n                    }\n                });\n        } else {\n            if (alpha < 1) {\n                ctx.globalAlpha = alpha;\n            }\n            ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);\n            if (alpha < 1) {\n                ctx.globalAlpha = 1;\n            }\n        }\n    }\n}\n","// Shamelessly stolen from https://github.com/ricokahler/color2k\n// We don't need all the color functions but we deeply appreciate their work.\n\nconst cache: {\n    [color: string]: [number, number, number, number];\n} = {};\n\nlet div: HTMLDivElement | null = null;\n\nfunction createDiv() {\n    const d = document.createElement(\"div\");\n    d.style.opacity = \"0\";\n    d.style.pointerEvents = \"none\";\n    d.style.position = \"fixed\";\n    // div must be mounted for `getComputedStyle` to work\n    document.body.append(d);\n    return d;\n}\n\n/** @category Drawing */\nexport function parseToRgba(color: string): readonly [number, number, number, number] {\n    // normalize the color\n    const normalizedColor = color.toLowerCase().trim();\n\n    if (cache[normalizedColor] !== undefined) return cache[normalizedColor];\n\n    div = div || createDiv();\n\n    div.style.color = \"#000\";\n    div.style.color = normalizedColor;\n    const control = getComputedStyle(div).color;\n\n    div.style.color = \"#fff\";\n    div.style.color = normalizedColor;\n    const computedColor = getComputedStyle(div).color;\n\n    if (computedColor !== control) throw new Error(\"Could not parse color\");\n\n    const result = computedColor\n        // eslint-disable-next-line unicorn/better-regex\n        .replace(/[^\\d.,]/g, \"\")\n        .split(\",\")\n        .map(Number.parseFloat) as [number, number, number, number];\n\n    if (result.length < 4) {\n        result.push(1);\n    }\n\n    cache[normalizedColor] = result;\n    return result;\n}\n\n/** @category Drawing */\nexport function withAlpha(color: string, alpha: number): string {\n    const [r, g, b] = parseToRgba(color);\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\n/** @category Drawing */\nexport function blend(color: string, background: string | undefined): string {\n    if (background === undefined) return color;\n    const [r, g, b, a] = parseToRgba(color);\n    if (a === 1) return color;\n    const [br, bg, bb, ba] = parseToRgba(background);\n    const ao = a + ba * (1 - a);\n    // (xaA + xaB(1aA))/aR\n    const ro = (a * r + ba * br * (1 - a)) / ao;\n    const go = (a * g + ba * bg * (1 - a)) / ao;\n    const bo = (a * b + ba * bb * (1 - a)) / ao;\n    return `rgba(${ro}, ${go}, ${bo}, ${ao})`;\n}\n\n/** @category Drawing */\nexport function interpolateColors(leftColor: string, rightColor: string, val: number): string {\n    // toot toot im a GPU\n    if (val <= 0) return leftColor;\n    if (val >= 1) return rightColor;\n\n    // Parse to rgba returns straight alpha colors, for interpolation we want pre-multiplied alpha\n    const left = [...parseToRgba(leftColor)];\n    left[0] = left[0] * left[3];\n    left[1] = left[1] * left[3];\n    left[2] = left[2] * left[3];\n    const right = [...parseToRgba(rightColor)];\n    right[0] = right[0] * right[3];\n    right[1] = right[1] * right[3];\n    right[2] = right[2] * right[3];\n\n    const hScaler = val;\n    const nScaler = 1 - val;\n\n    const a = left[3] * nScaler + right[3] * hScaler;\n    // now we need to divide the alpha back out to get linear alpha back for the final result\n    const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);\n    const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);\n    const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);\n    return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n","/* eslint-disable unicorn/no-for-loop */\nimport {\n    GridSelection,\n    DrawHeaderCallback,\n    InnerGridCell,\n    Rectangle,\n    CompactSelection,\n    DrawCustomCellCallback,\n    GridColumnIcon,\n    Item,\n    CellList,\n    GridMouseGroupHeaderEventArgs,\n    headerCellCheckboxPrefix,\n    GridCellKind,\n    isInnerOnlyCell,\n    BooleanIndeterminate,\n    headerCellCheckedMarker,\n    headerCellUnheckedMarker,\n    TrailingRowType,\n    ImageWindowLoader,\n    GridCell,\n} from \"./data-grid-types\";\nimport groupBy from \"lodash/groupBy.js\";\nimport type { HoverValues } from \"./animation-manager\";\nimport {\n    getEffectiveColumns,\n    getStickyWidth,\n    MappedGridColumn,\n    roundedPoly,\n    drawWithLastUpdate,\n    isGroupEqual,\n    cellIsSelected,\n    cellIsInRange,\n    computeBounds,\n    getMiddleCenterBias,\n    drawCheckbox,\n} from \"./data-grid-lib\";\nimport type { SpriteManager, SpriteVariant } from \"./data-grid-sprites\";\nimport type { Theme } from \"../common/styles\";\nimport { blend, withAlpha } from \"./color-parser\";\nimport type { DrawArgs, GetCellRendererCallback, PrepResult } from \"./cells/cell-types\";\nimport { assert, deepEqual } from \"../common/support\";\n\n// Future optimization opportunities\n// - Create a cache of a buffer used to render the full view of a partially displayed column so that when\n//   scrolling horizontally you can simply blit the pre-drawn column instead of continually paying the draw\n//   cost as it slides into view.\n// - Blit headers on horizontal scroll\n// - Use webworker to load images, helpful with lots of large images\n// - Sprite map currently wastes a lot of canvas texture space\n// - Retain mode for drawing cells. Instead of drawing cells as we come across them, first build a data\n//   structure which contains all operations to perform, then sort them all by \"prep\" requirement, then do\n//   all like operations at once.\n\ntype HoverInfo = readonly [Item, Item];\n\nexport interface Highlight {\n    readonly color: string;\n    readonly range: Rectangle;\n    readonly style?: \"dashed\" | \"solid\" | \"no-outline\";\n}\n\ninterface GroupDetails {\n    readonly name: string;\n    readonly icon?: string;\n    readonly overrideTheme?: Partial<Theme>;\n    readonly actions?: readonly {\n        readonly title: string;\n        readonly onClick: (e: GridMouseGroupHeaderEventArgs) => void;\n        readonly icon: GridColumnIcon | string;\n    }[];\n}\n\nexport type GroupDetailsCallback = (groupName: string) => GroupDetails;\nexport type GetRowThemeCallback = (row: number) => Partial<Theme> | undefined;\n\nconst loadingCell: InnerGridCell = {\n    kind: GridCellKind.Loading,\n    allowOverlay: false,\n};\n\nexport interface BlitData {\n    readonly cellXOffset: number;\n    readonly cellYOffset: number;\n    readonly translateX: number;\n    readonly translateY: number;\n    readonly mustDrawFocusOnHeader: boolean;\n    readonly lastBuffer: \"a\" | \"b\" | undefined;\n}\n\ninterface DragAndDropState {\n    src: number;\n    dest: number;\n}\n\nexport function drawCell(\n    ctx: CanvasRenderingContext2D,\n    row: number,\n    cell: InnerGridCell,\n    col: number,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    highlighted: boolean,\n    theme: Theme,\n    drawCustomCell: DrawCustomCellCallback | undefined,\n    imageLoader: ImageWindowLoader,\n    spriteManager: SpriteManager,\n    hoverAmount: number,\n    hoverInfo: HoverInfo | undefined,\n    hyperWrapping: boolean,\n    frameTime: number,\n    lastPrep: PrepResult | undefined,\n    enqueue: ((item: Item) => void) | undefined,\n    getCellRenderer: GetCellRendererCallback\n): PrepResult | undefined {\n    let hoverX: number | undefined;\n    let hoverY: number | undefined;\n    if (hoverInfo !== undefined && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {\n        hoverX = hoverInfo[1][0];\n        hoverY = hoverInfo[1][1];\n    }\n    let result: PrepResult | undefined = undefined;\n    const args: DrawArgs<typeof cell> = {\n        ctx,\n        theme,\n        col,\n        row,\n        cell,\n        rect: { x, y, width: w, height: h },\n        highlighted,\n        hoverAmount,\n        hoverX,\n        hoverY,\n        imageLoader,\n        spriteManager,\n        hyperWrapping,\n        requestAnimationFrame: () => {\n            forceAnim = true;\n        },\n    };\n    let forceAnim = false;\n    const needsAnim = drawWithLastUpdate(args, cell.lastUpdated, frameTime, lastPrep, () => {\n        const drawn = isInnerOnlyCell(cell) ? false : drawCustomCell?.(args as DrawArgs<GridCell>) === true;\n        if (!drawn) {\n            const r = getCellRenderer(cell);\n            if (r !== undefined) {\n                if (lastPrep?.renderer !== r) {\n                    lastPrep?.deprep?.(args);\n                    lastPrep = undefined;\n                }\n                const partialPrepResult = r.drawPrep?.(args, lastPrep);\n                r.draw(args, cell);\n                result = {\n                    deprep: partialPrepResult?.deprep,\n                    fillStyle: partialPrepResult?.fillStyle,\n                    font: partialPrepResult?.font,\n                    renderer: r,\n                };\n            }\n        }\n    });\n    if (needsAnim || forceAnim) enqueue?.([col, row]);\n    return result;\n}\n\nfunction blitLastFrame(\n    ctx: CanvasRenderingContext2D,\n    canvas: HTMLCanvasElement,\n    last: BlitData,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    lastRowSticky: boolean,\n    width: number,\n    height: number,\n    rows: number,\n    totalHeaderHeight: number,\n    dpr: number,\n    mappedColumns: readonly MappedGridColumn[],\n    effectiveCols: readonly MappedGridColumn[],\n    getRowHeight: number | ((r: number) => number),\n    doubleBuffer: boolean\n) {\n    const drawRegions: Rectangle[] = [];\n    let blittedYOnly = false;\n\n    ctx.imageSmoothingEnabled = false;\n    const minY = Math.min(last.cellYOffset, cellYOffset);\n    const maxY = Math.max(last.cellYOffset, cellYOffset);\n    let deltaY = 0;\n    if (typeof getRowHeight === \"number\") {\n        deltaY += (maxY - minY) * getRowHeight;\n    } else {\n        for (let i = minY; i < maxY; i++) {\n            deltaY += getRowHeight(i);\n        }\n    }\n    if (cellYOffset > last.cellYOffset) {\n        deltaY = -deltaY;\n    }\n    deltaY += translateY - last.translateY;\n\n    const minX = Math.min(last.cellXOffset, cellXOffset);\n    const maxX = Math.max(last.cellXOffset, cellXOffset);\n    let deltaX = 0;\n    for (let i = minX; i < maxX; i++) {\n        deltaX += mappedColumns[i].width;\n    }\n    if (cellXOffset > last.cellXOffset) {\n        deltaX = -deltaX;\n    }\n    deltaX += translateX - last.translateX;\n\n    let stickyWidth = getStickyWidth(effectiveCols);\n    if (stickyWidth > 0) stickyWidth++;\n\n    if (deltaX !== 0 && deltaY !== 0) {\n        return {\n            regions: [],\n            yOnly: false,\n        };\n    }\n\n    const stickyRowHeight = lastRowSticky\n        ? typeof getRowHeight === \"number\"\n            ? getRowHeight\n            : getRowHeight(rows - 1)\n        : 0;\n\n    const blitWidth = width - stickyWidth - Math.abs(deltaX);\n    const blitHeight = height - totalHeaderHeight - stickyRowHeight - Math.abs(deltaY) - 1;\n\n    if (blitWidth > 150 && blitHeight > 150) {\n        blittedYOnly = deltaX === 0;\n\n        const args = {\n            sx: 0,\n            sy: 0,\n            sw: width * dpr,\n            sh: height * dpr,\n            dx: 0,\n            dy: 0,\n            dw: width * dpr,\n            dh: height * dpr,\n        };\n\n        // blit Y\n        if (deltaY > 0) {\n            // scrolling up\n            args.sy = (totalHeaderHeight + 1) * dpr;\n            args.sh = blitHeight * dpr;\n            args.dy = (deltaY + totalHeaderHeight + 1) * dpr;\n            args.dh = blitHeight * dpr;\n\n            drawRegions.push({\n                x: 0,\n                y: totalHeaderHeight,\n                width: width,\n                height: deltaY + 1,\n            });\n        } else if (deltaY < 0) {\n            // scrolling down\n            args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;\n            args.sh = blitHeight * dpr;\n            args.dy = (totalHeaderHeight + 1) * dpr;\n            args.dh = blitHeight * dpr;\n\n            drawRegions.push({\n                x: 0,\n                y: height + deltaY - stickyRowHeight,\n                width: width,\n                height: -deltaY + stickyRowHeight,\n            });\n        }\n\n        // blit X\n        if (deltaX > 0) {\n            // pixels moving right\n            args.sx = stickyWidth * dpr;\n            args.sw = blitWidth * dpr;\n            args.dx = (deltaX + stickyWidth) * dpr;\n            args.dw = blitWidth * dpr;\n\n            drawRegions.push({\n                x: stickyWidth - 1,\n                y: 0,\n                width: deltaX + 2, // extra width to account for first col not drawing a left side border\n                height: height,\n            });\n        } else if (deltaX < 0) {\n            // pixels moving left\n            args.sx = (stickyWidth - deltaX) * dpr;\n            args.sw = blitWidth * dpr;\n            args.dx = stickyWidth * dpr;\n            args.dw = blitWidth * dpr;\n\n            drawRegions.push({\n                x: width + deltaX,\n                y: 0,\n                width: -deltaX,\n                height: height,\n            });\n        }\n\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        if (deltaX !== 0 && deltaY === 0 && doubleBuffer) {\n            // When double buffering the freeze columns can be offset by a couple pixels vertically between the two\n            // buffers. We don't want to redraw them so we need to make sure to copy them.\n            ctx.drawImage(canvas, 0, 0, stickyWidth * dpr, height * dpr, 0, 0, stickyWidth * dpr, height * dpr);\n        }\n        ctx.drawImage(canvas, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);\n        ctx.scale(dpr, dpr);\n    }\n    ctx.imageSmoothingEnabled = true;\n\n    return {\n        regions: drawRegions,\n        yOnly: blittedYOnly,\n    };\n}\n\nfunction blitResizedCol(\n    // ctx: CanvasRenderingContext2D,\n    // canvas: HTMLCanvasElement,\n    last: BlitData,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    width: number,\n    height: number,\n    totalHeaderHeight: number,\n    // dpr: number,\n    effectiveCols: readonly MappedGridColumn[],\n    resizedIndex: number\n) {\n    const drawRegions: Rectangle[] = [];\n\n    // ctx.imageSmoothingEnabled = false;\n\n    if (\n        cellXOffset !== last.cellXOffset ||\n        cellYOffset !== last.cellYOffset ||\n        translateX !== last.translateX ||\n        translateY !== last.translateY\n    ) {\n        return drawRegions;\n    }\n\n    walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {\n        if (c.sourceIndex === resizedIndex) {\n            const x = Math.max(drawX, clipX) + 1;\n            drawRegions.push({\n                x,\n                y: 0,\n                width: width - x,\n                height,\n            });\n            return true;\n        }\n    });\n    return drawRegions;\n}\n\n// lines are effectively drawn on the top left edge of a cell.\nfunction drawGridLines(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    width: number,\n    height: number,\n    drawRegions: Rectangle[] | undefined,\n    spans: Rectangle[] | undefined,\n    groupHeaderHeight: number,\n    totalHeaderHeight: number,\n    getRowHeight: (row: number) => number,\n    getRowThemeOverride: GetRowThemeCallback | undefined,\n    verticalBorder: (col: number) => boolean,\n    trailingRowType: TrailingRowType,\n    rows: number,\n    theme: Theme,\n    verticalOnly: boolean = false\n) {\n    if (spans !== undefined) {\n        ctx.beginPath();\n        ctx.save();\n        ctx.rect(0, 0, width, height);\n        for (const span of spans) {\n            ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);\n        }\n        ctx.clip(\"evenodd\");\n    }\n    const hColor = theme.horizontalBorderColor ?? theme.borderColor;\n    const vColor = theme.borderColor;\n\n    let minX = 0;\n    let maxX = width;\n    let minY = 0;\n    let maxY = height;\n\n    if (drawRegions !== undefined && drawRegions.length > 0) {\n        minX = Number.MAX_SAFE_INTEGER;\n        minY = Number.MAX_SAFE_INTEGER;\n        maxX = Number.MIN_SAFE_INTEGER;\n        maxY = Number.MIN_SAFE_INTEGER;\n        for (const r of drawRegions) {\n            minX = Math.min(minX, r.x - 1);\n            maxX = Math.max(maxX, r.x + r.width + 1);\n            minY = Math.min(minY, r.y - 1);\n            maxY = Math.max(maxY, r.y + r.height + 1);\n        }\n    }\n\n    const toDraw: { x1: number; y1: number; x2: number; y2: number; color: string }[] = [];\n\n    ctx.beginPath();\n\n    // vertical lines\n    let x = 0.5;\n    for (let index = 0; index < effectiveCols.length; index++) {\n        const c = effectiveCols[index];\n        if (c.width === 0) continue;\n        x += c.width;\n        const tx = c.sticky ? x : x + translateX;\n        if (tx >= minX && tx <= maxX - 1 && verticalBorder(index + 1)) {\n            toDraw.push({\n                x1: tx,\n                y1: Math.max(groupHeaderHeight, minY),\n                x2: tx,\n                y2: Math.min(height, maxY),\n                color: vColor,\n            });\n        }\n    }\n\n    const stickyHeight = getRowHeight(rows - 1);\n    const stickyRowY = height - stickyHeight + 0.5;\n    const lastRowSticky = trailingRowType === \"sticky\";\n    if (lastRowSticky) {\n        toDraw.push({ x1: minX, y1: stickyRowY, x2: maxX, y2: stickyRowY, color: hColor });\n    }\n\n    if (verticalOnly !== true) {\n        // horizontal lines\n        let y = totalHeaderHeight + 0.5;\n        let row = cellYOffset;\n        const target = lastRowSticky ? height - stickyHeight : height;\n        while (y + translateY <= target) {\n            const ty = y + translateY;\n            // This shouldn't be needed it seems like... yet it is. We're not sure why.\n            if (ty >= minY && ty <= maxY - 1 && (!lastRowSticky || row !== rows - 1 || Math.abs(ty - stickyRowY) > 1)) {\n                const rowTheme = getRowThemeOverride?.(row);\n                toDraw.push({\n                    x1: minX,\n                    y1: ty,\n                    x2: maxX,\n                    y2: ty,\n                    color: rowTheme?.horizontalBorderColor ?? rowTheme?.borderColor ?? hColor,\n                });\n            }\n\n            y += getRowHeight(row);\n            row++;\n        }\n    }\n\n    const groups = groupBy(toDraw, line => line.color);\n    for (const g of Object.keys(groups)) {\n        ctx.strokeStyle = g;\n        for (const line of groups[g]) {\n            ctx.moveTo(line.x1, line.y1);\n            ctx.lineTo(line.x2, line.y2);\n        }\n        ctx.stroke();\n        ctx.beginPath();\n    }\n\n    if (spans !== undefined) {\n        ctx.restore();\n    }\n}\n\nexport function getActionBoundsForGroup(\n    box: Rectangle,\n    actions: NonNullable<GroupDetails[\"actions\"]>\n): readonly Rectangle[] {\n    const result: Rectangle[] = [];\n    let x = box.x + box.width - 26 * actions.length;\n    const y = box.y + box.height / 2 - 13;\n    const height = 26;\n    const width = 26;\n    for (let i = 0; i < actions.length; i++) {\n        result.push({\n            x,\n            y,\n            width,\n            height,\n        });\n        x += 26;\n    }\n    return result;\n}\n\nexport function pointInRect(rect: Rectangle, x: number, y: number): boolean {\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n}\n\nfunction drawGroups(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    width: number,\n    translateX: number,\n    groupHeaderHeight: number,\n    hovered: HoverInfo | undefined,\n    theme: Theme,\n    spriteManager: SpriteManager,\n    _hoverValues: HoverValues,\n    verticalBorder: (col: number) => boolean,\n    getGroupDetails: GroupDetailsCallback,\n    damage: CellList | undefined\n) {\n    const xPad = 8;\n    const [hCol, hRow] = hovered?.[0] ?? [];\n\n    let finalX = 0;\n    walkGroups(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {\n        if (damage !== undefined && !damage.some(d => d[1] === -2 && d[0] >= span[0] && d[0] <= span[1])) return;\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x, y, w, h);\n        ctx.clip();\n\n        const group = getGroupDetails(groupName);\n        const groupTheme = group?.overrideTheme === undefined ? theme : { ...theme, ...group.overrideTheme };\n        const isHovered = hRow === -2 && hCol !== undefined && hCol >= span[0] && hCol <= span[1];\n\n        const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;\n        if (fillColor !== theme.bgHeader) {\n            ctx.fillStyle = fillColor;\n            ctx.fill();\n        }\n\n        ctx.fillStyle = groupTheme.textGroupHeader ?? groupTheme.textHeader;\n        if (group !== undefined) {\n            let drawX = x;\n            if (group.icon !== undefined) {\n                spriteManager.drawSprite(\n                    group.icon,\n                    \"normal\",\n                    ctx,\n                    drawX + xPad,\n                    (groupHeaderHeight - 20) / 2,\n                    20,\n                    groupTheme\n                );\n                drawX += 26;\n            }\n            ctx.fillText(\n                group.name,\n                drawX + xPad,\n                groupHeaderHeight / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`)\n            );\n\n            if (group.actions !== undefined && isHovered) {\n                const actionBoxes = getActionBoundsForGroup({ x, y, width: w, height: h }, group.actions);\n\n                ctx.beginPath();\n                const fadeStartX = actionBoxes[0].x - 10;\n                const fadeWidth = x + w - fadeStartX;\n                ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);\n                const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);\n                const trans = withAlpha(fillColor, 0);\n                grad.addColorStop(0, trans);\n                grad.addColorStop(10 / fadeWidth, fillColor);\n                grad.addColorStop(1, fillColor);\n                ctx.fillStyle = grad;\n\n                ctx.fill();\n\n                ctx.globalAlpha = 0.6;\n\n                // eslint-disable-next-line prefer-const\n                const [mouseX, mouseY] = hovered?.[1] ?? [-1, -1];\n                for (let i = 0; i < group.actions.length; i++) {\n                    const action = group.actions[i];\n                    const box = actionBoxes[i];\n                    const actionHovered = pointInRect(box, mouseX + x, mouseY);\n                    if (actionHovered) {\n                        ctx.globalAlpha = 1;\n                    }\n                    spriteManager.drawSprite(\n                        action.icon,\n                        \"normal\",\n                        ctx,\n                        box.x + box.width / 2 - 10,\n                        box.y + box.height / 2 - 10,\n                        20,\n                        groupTheme\n                    );\n                    if (actionHovered) {\n                        ctx.globalAlpha = 0.6;\n                    }\n                }\n\n                ctx.globalAlpha = 1;\n            }\n        }\n\n        if (verticalBorder(span[0])) {\n            ctx.beginPath();\n            ctx.moveTo(x + 0.5, 0);\n            ctx.lineTo(x + 0.5, groupHeaderHeight);\n            ctx.strokeStyle = theme.borderColor;\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        }\n\n        ctx.restore();\n\n        finalX = x + w;\n    });\n\n    ctx.beginPath();\n    ctx.moveTo(finalX + 0.5, 0);\n    ctx.lineTo(finalX + 0.5, groupHeaderHeight);\n\n    ctx.moveTo(0, groupHeaderHeight + 0.5);\n    ctx.lineTo(width, groupHeaderHeight + 0.5);\n    ctx.strokeStyle = theme.borderColor;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n}\n\nconst menuButtonSize = 30;\nexport function getHeaderMenuBounds(x: number, y: number, width: number, height: number): Rectangle {\n    return {\n        x: x + width - menuButtonSize, // right align\n        y: Math.max(y, y + height / 2 - menuButtonSize / 2), // center vertically\n        width: menuButtonSize,\n        height: Math.min(menuButtonSize, height),\n    };\n}\n\nexport function drawHeader(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    c: MappedGridColumn,\n    selected: boolean,\n    theme: Theme,\n    isHovered: boolean,\n    hasSelectedCell: boolean,\n    hoverAmount: number,\n    spriteManager: SpriteManager,\n    drawHeaderCallback: DrawHeaderCallback | undefined,\n    touchMode: boolean\n) {\n    const isCheckboxHeader = c.title.startsWith(headerCellCheckboxPrefix);\n    const menuBounds = getHeaderMenuBounds(x, y, width, height);\n    if (drawHeaderCallback !== undefined) {\n        let passCol = c;\n        if (isCheckboxHeader) {\n            passCol = {\n                ...c,\n                title: \"\",\n            };\n        }\n        if (\n            drawHeaderCallback({\n                ctx,\n                theme,\n                rect: { x, y, width, height },\n                column: passCol,\n                columnIndex: passCol.sourceIndex,\n                isSelected: selected,\n                hoverAmount,\n                isHovered,\n                hasSelectedCell,\n                spriteManager,\n                menuBounds,\n            })\n        ) {\n            return;\n        }\n    }\n\n    if (isCheckboxHeader) {\n        let checked: boolean | BooleanIndeterminate = undefined;\n        if (c.title === headerCellCheckedMarker) checked = true;\n        if (c.title === headerCellUnheckedMarker) checked = false;\n        if (checked !== true) {\n            ctx.globalAlpha = hoverAmount;\n        }\n        drawCheckbox(ctx, theme, checked, x, y, width, height, false, undefined, undefined);\n        if (checked !== true) {\n            ctx.globalAlpha = 1;\n        }\n        return;\n    }\n\n    const xPad = 8;\n    const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;\n\n    const shouldDrawMenu = c.hasMenu === true && (isHovered || (touchMode && selected));\n\n    let drawX = x + xPad;\n    if (c.icon !== undefined) {\n        let variant: SpriteVariant = selected ? \"selected\" : \"normal\";\n        if (c.style === \"highlight\") {\n            variant = selected ? \"selected\" : \"special\";\n        }\n        spriteManager.drawSprite(c.icon, variant, ctx, drawX, y + (height - 20) / 2, 20, theme);\n\n        if (c.overlayIcon !== undefined) {\n            spriteManager.drawSprite(\n                c.overlayIcon,\n                selected ? \"selected\" : \"special\",\n                ctx,\n                drawX + 9,\n                y + ((height - 18) / 2 + 6),\n                18,\n                theme\n            );\n        }\n\n        drawX += 26;\n    }\n\n    if (shouldDrawMenu && c.hasMenu === true && width > 35) {\n        const fadeWidth = 35;\n        const fadeStart = width - fadeWidth;\n        const fadeEnd = width - fadeWidth * 0.7;\n\n        const fadeStartPercent = fadeStart / width;\n        const fadeEndPercent = fadeEnd / width;\n\n        const grad = ctx.createLinearGradient(x, 0, x + width, 0);\n        const trans = withAlpha(fillStyle, 0);\n\n        grad.addColorStop(0, fillStyle);\n        grad.addColorStop(fadeStartPercent, fillStyle);\n        grad.addColorStop(fadeEndPercent, trans);\n        grad.addColorStop(1, trans);\n        ctx.fillStyle = grad;\n    } else {\n        ctx.fillStyle = fillStyle;\n    }\n    ctx.fillText(\n        c.title,\n        drawX,\n        y + height / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`)\n    );\n\n    if (shouldDrawMenu && c.hasMenu === true) {\n        ctx.beginPath();\n        const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;\n        const triangleY = menuBounds.y + menuBounds.height / 2 - 3;\n        roundedPoly(\n            ctx,\n            [\n                {\n                    x: triangleX,\n                    y: triangleY,\n                },\n                {\n                    x: triangleX + 11,\n                    y: triangleY,\n                },\n                {\n                    x: triangleX + 5.5,\n                    y: triangleY + 6,\n                },\n            ],\n            1\n        );\n\n        ctx.fillStyle = fillStyle;\n        ctx.fill();\n    }\n}\n\nfunction drawGridHeaders(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    enableGroups: boolean,\n    hovered: HoverInfo | undefined,\n    width: number,\n    translateX: number,\n    headerHeight: number,\n    groupHeaderHeight: number,\n    dragAndDropState: DragAndDropState | undefined,\n    isResizing: boolean,\n    selection: GridSelection,\n    outerTheme: Theme,\n    spriteManager: SpriteManager,\n    hoverValues: HoverValues,\n    verticalBorder: (col: number) => boolean,\n    getGroupDetails: GroupDetailsCallback,\n    damage: CellList | undefined,\n    drawHeaderCallback: DrawHeaderCallback | undefined,\n    touchMode: boolean\n) {\n    const totalHeaderHeight = headerHeight + groupHeaderHeight;\n    if (totalHeaderHeight <= 0) return;\n\n    ctx.fillStyle = outerTheme.bgHeader;\n    ctx.fillRect(0, 0, width, totalHeaderHeight);\n\n    const [hCol, hRow] = hovered?.[0] ?? [];\n\n    const font = `${outerTheme.headerFontStyle} ${outerTheme.fontFamily}`;\n    // Assinging the context font too much can be expensive, it can be worth it to minimze this\n    ctx.font = font;\n    walkColumns(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {\n        if (damage !== undefined && !damage.some(d => d[1] === -1 && d[0] === c.sourceIndex)) return;\n        const diff = Math.max(0, clipX - x);\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);\n        ctx.clip();\n\n        const groupTheme = getGroupDetails(c.group ?? \"\").overrideTheme;\n        const theme =\n            c.themeOverride === undefined && groupTheme === undefined\n                ? outerTheme\n                : { ...outerTheme, ...groupTheme, ...c.themeOverride };\n\n        if (theme.bgHeader !== outerTheme.bgHeader) {\n            ctx.fillStyle = theme.bgHeader;\n            ctx.fill();\n        }\n\n        const f = `${theme.headerFontStyle} ${theme.fontFamily}`;\n        if (font !== f) {\n            ctx.font = f;\n        }\n        const selected = selection.columns.hasIndex(c.sourceIndex);\n        const noHover = dragAndDropState !== undefined || isResizing;\n        const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;\n        const hover = noHover\n            ? 0\n            : hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)?.hoverAmount ?? 0;\n\n        const hasSelectedCell = selection?.current !== undefined && selection.current.cell[0] === c.sourceIndex;\n\n        const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;\n\n        const y = enableGroups ? groupHeaderHeight : 0;\n        const xOffset = c.sourceIndex === 0 ? 0 : 1;\n\n        if (selected) {\n            ctx.fillStyle = bgFillStyle;\n            ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);\n        } else if (hasSelectedCell || hover > 0) {\n            ctx.beginPath();\n            ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);\n            if (hasSelectedCell) {\n                ctx.fillStyle = theme.bgHeaderHasFocus;\n                ctx.fill();\n            }\n            if (hover > 0) {\n                ctx.globalAlpha = hover;\n                ctx.fillStyle = theme.bgHeaderHovered;\n                ctx.fill();\n                ctx.globalAlpha = 1;\n            }\n        }\n\n        drawHeader(\n            ctx,\n            x,\n            y,\n            c.width,\n            headerHeight,\n            c,\n            selected,\n            theme,\n            hoveredBoolean,\n            hasSelectedCell,\n            hover,\n            spriteManager,\n            drawHeaderCallback,\n            touchMode\n        );\n        ctx.restore();\n    });\n\n    if (enableGroups) {\n        drawGroups(\n            ctx,\n            effectiveCols,\n            width,\n            translateX,\n            groupHeaderHeight,\n            hovered,\n            outerTheme,\n            spriteManager,\n            hoverValues,\n            verticalBorder,\n            getGroupDetails,\n            damage\n        );\n    }\n}\n\nfunction intersectRect(x1: number, y1: number, w1: number, h1: number, x2: number, y2: number, w2: number, h2: number) {\n    return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;\n}\n\nfunction clipDamage(\n    ctx: CanvasRenderingContext2D,\n    effectiveColumns: readonly MappedGridColumn[],\n    width: number,\n    height: number,\n    groupHeaderHeight: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    trailingRowType: TrailingRowType,\n    damage: CellList | undefined,\n    includeCells: boolean\n): void {\n    if (damage === undefined || damage.length === 0) return;\n\n    const stickyRowHeight = trailingRowType === \"sticky\" ? getRowHeight(rows - 1) : 0;\n\n    ctx.beginPath();\n\n    walkGroups(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {\n        for (let i = 0; i < damage.length; i++) {\n            const d = damage[i];\n            if (d[1] === -2 && d[0] >= span[0] && d[0] <= span[1]) {\n                ctx.rect(x, y, w, h);\n                break;\n            }\n        }\n    });\n\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (c, drawX, colDrawY, clipX, startRow) => {\n            const diff = Math.max(0, clipX - drawX);\n\n            const finalX = drawX + diff + 1;\n            const finalWidth = c.width - diff - 1;\n            for (let i = 0; i < damage.length; i++) {\n                const d = damage[i];\n                if (d[0] === c.sourceIndex && (d[1] === -1 || d[1] === undefined)) {\n                    ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);\n                    break;\n                }\n            }\n\n            if (!includeCells) return;\n\n            walkRowsInCol(\n                startRow,\n                colDrawY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (drawY, row, rh, isSticky) => {\n                    let isDamaged = false;\n                    for (let i = 0; i < damage.length; i++) {\n                        const d = damage[i];\n                        if (d[0] === c.sourceIndex && d[1] === row) {\n                            isDamaged = true;\n                            break;\n                        }\n                    }\n                    if (isDamaged) {\n                        const top = drawY + 1;\n                        const bottom = isSticky ? top + rh - 1 : Math.min(top + rh - 1, height - stickyRowHeight);\n                        const h = bottom - top;\n\n                        if (h > 0) {\n                            ctx.rect(finalX, top, finalWidth, h);\n                        }\n                    }\n                }\n            );\n        }\n    );\n    ctx.clip();\n}\n\nfunction getSpanBounds(\n    span: Item,\n    cellX: number,\n    cellY: number,\n    cellW: number,\n    cellH: number,\n    column: MappedGridColumn,\n    allColumns: readonly MappedGridColumn[]\n): [Rectangle | undefined, Rectangle | undefined] {\n    const [startCol, endCol] = span;\n\n    let frozenRect: Rectangle | undefined;\n    let contentRect: Rectangle | undefined;\n\n    const firstNonSticky = allColumns.find(x => !x.sticky)?.sourceIndex ?? 0;\n    if (endCol > firstNonSticky) {\n        const renderFromCol = Math.max(startCol, firstNonSticky);\n        let tempX = cellX;\n        let tempW = cellW;\n        for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {\n            tempX -= allColumns[x].width;\n            tempW += allColumns[x].width;\n        }\n        for (let x = column.sourceIndex + 1; x <= endCol; x++) {\n            tempW += allColumns[x].width;\n        }\n        contentRect = {\n            x: tempX,\n            y: cellY,\n            width: tempW,\n            height: cellH,\n        };\n    }\n\n    if (firstNonSticky > startCol) {\n        const renderToCol = Math.min(endCol, firstNonSticky - 1);\n        let tempX = cellX;\n        let tempW = cellW;\n        for (let x = column.sourceIndex - 1; x >= startCol; x--) {\n            tempX -= allColumns[x].width;\n            tempW += allColumns[x].width;\n        }\n        for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {\n            tempW += allColumns[x].width;\n        }\n        frozenRect = {\n            x: tempX,\n            y: cellY,\n            width: tempW,\n            height: cellH,\n        };\n    }\n\n    return [frozenRect, contentRect];\n}\n\n// preppable items:\n// - font\n// - fillStyle\n\n// Column draw loop prep cycle\n// - Prep item\n// - Prep sets props\n// - Prep returns list of cared about props\n// - Draw item\n// - Loop may set some items, if present in args list, set undefined\n// - Prep next item, giving previous result\n// - If next item type is different, de-prep\n// - Result per column\nfunction drawCells(\n    ctx: CanvasRenderingContext2D,\n    effectiveColumns: readonly MappedGridColumn[],\n    allColumns: readonly MappedGridColumn[],\n    height: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    getCellContent: (cell: Item) => InnerGridCell,\n    getGroupDetails: GroupDetailsCallback,\n    getRowThemeOverride: GetRowThemeCallback | undefined,\n    disabledRows: CompactSelection,\n    isFocused: boolean,\n    drawFocus: boolean,\n    trailingRowType: TrailingRowType,\n    drawRegions: readonly Rectangle[],\n    damage: CellList | undefined,\n    selection: GridSelection,\n    prelightCells: CellList | undefined,\n    highlightRegions: readonly Highlight[] | undefined,\n    drawCustomCell: DrawCustomCellCallback | undefined,\n    imageLoader: ImageWindowLoader,\n    spriteManager: SpriteManager,\n    hoverValues: HoverValues,\n    hoverInfo: HoverInfo | undefined,\n    hyperWrapping: boolean,\n    outerTheme: Theme,\n    enqueue: (item: Item) => void,\n    getCellRenderer: GetCellRendererCallback\n): Rectangle[] | undefined {\n    let toDraw = damage?.length ?? Number.MAX_SAFE_INTEGER;\n    const frameTime = performance.now();\n    let font = `${outerTheme.baseFontStyle} ${outerTheme.fontFamily}`;\n    ctx.font = font;\n    let result: Rectangle[] | undefined;\n    const handledSpans = new Set<string>();\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (c, drawX, colDrawStartY, clipX, startRow) => {\n            const diff = Math.max(0, clipX - drawX);\n\n            const colDrawX = drawX + diff;\n            const colDrawY = totalHeaderHeight + 1;\n            const colWidth = c.width - diff;\n            const colHeight = height - totalHeaderHeight - 1;\n            if (drawRegions.length > 0) {\n                let found = false;\n                for (let i = 0; i < drawRegions.length; i++) {\n                    const dr = drawRegions[i];\n                    if (intersectRect(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) return;\n            }\n\n            const reclip = () => {\n                ctx.save();\n                ctx.beginPath();\n                ctx.rect(colDrawX, colDrawY, colWidth, colHeight);\n                ctx.clip();\n            };\n\n            const colSelected = selection.columns.hasIndex(c.sourceIndex);\n\n            const groupTheme = getGroupDetails(c.group ?? \"\").overrideTheme;\n            const colTheme =\n                c.themeOverride === undefined && groupTheme === undefined\n                    ? outerTheme\n                    : { ...outerTheme, ...groupTheme, ...c.themeOverride };\n            const colFont = `${colTheme.baseFontStyle} ${colTheme.fontFamily}`;\n            if (colFont !== font) {\n                font = colFont;\n                ctx.font = colFont;\n            }\n            reclip();\n            let prepResult: PrepResult | undefined = undefined;\n\n            walkRowsInCol(\n                startRow,\n                colDrawStartY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (drawY, row, rh, isSticky, isTrailingRow) => {\n                    if (row < 0) return;\n                    // if (damage !== undefined && !damage.some(d => d[0] === c.sourceIndex && d[1] === row)) {\n                    //     return;\n                    // }\n                    // if (\n                    //     drawRegions.length > 0 &&\n                    //     !drawRegions.some(dr => intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height))\n                    // ) {\n                    //     return;\n                    // }\n\n                    // These are dumb versions of the above. I cannot for the life of believe that this matters but this is\n                    // the tightest part of the draw loop and the allocations above actually has a very measurable impact\n                    // on performance. For the love of all that is unholy please keep checking this again in the future.\n                    // As soon as this doesn't have any impact of note go back to the saner looking code. The smoke test\n                    // here is to scroll to the bottom of a test case first, then scroll back up while profiling and see\n                    // how many major GC collections you get. These allocate a lot of objects.\n                    if (damage !== undefined) {\n                        let found = false;\n                        for (let i = 0; i < damage.length; i++) {\n                            const d = damage[i];\n                            if (d[0] === c.sourceIndex && d[1] === row) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) return;\n                    }\n                    if (drawRegions.length > 0) {\n                        let found = false;\n                        for (let i = 0; i < drawRegions.length; i++) {\n                            const dr = drawRegions[i];\n                            if (intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) return;\n                    }\n\n                    const rowSelected = selection.rows.hasIndex(row);\n                    const rowDisabled = disabledRows.hasIndex(row);\n\n                    const cell: InnerGridCell = row < rows ? getCellContent([c.sourceIndex, row]) : loadingCell;\n\n                    let cellX = drawX;\n                    let cellWidth = c.width;\n                    let drawingSpan = false;\n                    let skipContents = false;\n                    if (cell.span !== undefined) {\n                        const [startCol, endCol] = cell.span;\n                        const spanKey = `${row},${startCol},${endCol},${c.sticky}`;\n                        if (!handledSpans.has(spanKey)) {\n                            const areas = getSpanBounds(cell.span, drawX, drawY, c.width, rh, c, allColumns);\n                            const area = c.sticky ? areas[0] : areas[1];\n                            if (!c.sticky && areas[0] !== undefined) {\n                                skipContents = true;\n                            }\n                            if (area !== undefined) {\n                                cellX = area.x;\n                                cellWidth = area.width;\n                                handledSpans.add(spanKey);\n                                ctx.restore();\n                                prepResult = undefined;\n                                ctx.save();\n                                ctx.beginPath();\n                                const d = Math.max(0, clipX - area.x);\n                                ctx.rect(area.x + d, drawY, area.width - d, rh);\n                                if (result === undefined) {\n                                    result = [];\n                                }\n                                result.push({\n                                    x: area.x + d,\n                                    y: drawY,\n                                    width: area.width - d,\n                                    height: rh,\n                                });\n                                ctx.clip();\n                                drawingSpan = true;\n                            }\n                        } else {\n                            toDraw--;\n                            return;\n                        }\n                    }\n\n                    const rowTheme = getRowThemeOverride?.(row);\n                    const trailingTheme =\n                        isTrailingRow && c.trailingRowOptions?.themeOverride !== undefined\n                            ? c.trailingRowOptions?.themeOverride\n                            : undefined;\n                    const theme =\n                        cell.themeOverride === undefined && rowTheme === undefined && trailingTheme === undefined\n                            ? colTheme\n                            : { ...colTheme, ...rowTheme, ...trailingTheme, ...cell.themeOverride };\n\n                    ctx.beginPath();\n\n                    const cellIndex = [c.sourceIndex, row] as const;\n                    const isSelected = cellIsSelected(cellIndex, cell, selection);\n                    let accentCount = cellIsInRange(cellIndex, cell, selection);\n                    const spanIsHighlighted =\n                        cell.span !== undefined &&\n                        selection.columns.some(\n                            index => cell.span !== undefined && index >= cell.span[0] && index <= cell.span[1]\n                        );\n                    if (isSelected && !isFocused && drawFocus) {\n                        accentCount = 0;\n                    } else if (isSelected) {\n                        accentCount = Math.max(accentCount, 1);\n                    }\n                    if (spanIsHighlighted) {\n                        accentCount++;\n                    }\n                    if (!isSelected) {\n                        if (rowSelected) accentCount++;\n                        if (colSelected && !isSticky) accentCount++;\n                    }\n\n                    const bgCell = cell.kind === GridCellKind.Protected ? theme.bgCellMedium : theme.bgCell;\n                    let fill: string | undefined;\n                    if (isSticky || bgCell !== outerTheme.bgCell) {\n                        fill = blend(bgCell, fill);\n                    }\n\n                    if (accentCount > 0 || rowDisabled) {\n                        if (rowDisabled) {\n                            fill = blend(theme.bgHeader, fill);\n                        }\n                        for (let i = 0; i < accentCount; i++) {\n                            fill = blend(theme.accentLight, fill);\n                        }\n                    } else {\n                        if (prelightCells?.some(pre => pre[0] === c.sourceIndex && pre[1] === row) === true) {\n                            fill = blend(theme.bgSearchResult, fill);\n                        }\n                    }\n\n                    if (highlightRegions !== undefined) {\n                        for (const region of highlightRegions) {\n                            const r = region.range;\n                            if (\n                                r.x <= c.sourceIndex &&\n                                c.sourceIndex < r.x + r.width &&\n                                r.y <= row &&\n                                row < r.y + r.height\n                            ) {\n                                fill = blend(region.color, fill);\n                            }\n                        }\n                    }\n\n                    if (fill !== undefined) {\n                        ctx.fillStyle = fill;\n                        if (prepResult !== undefined) {\n                            prepResult.fillStyle = fill;\n                        }\n                        ctx.fillRect(cellX, drawY, cellWidth, rh);\n                    }\n\n                    if (cell.style === \"faded\") {\n                        ctx.globalAlpha = 0.6;\n                    }\n\n                    const hoverValue = hoverValues.find(hv => hv.item[0] === c.sourceIndex && hv.item[1] === row);\n\n                    if (cellWidth > 10 && !skipContents) {\n                        const cellFont = `${theme.baseFontStyle} ${theme.fontFamily}`;\n                        if (cellFont !== font) {\n                            ctx.font = cellFont;\n                            font = cellFont;\n                        }\n                        prepResult = drawCell(\n                            ctx,\n                            row,\n                            cell,\n                            c.sourceIndex,\n                            cellX,\n                            drawY,\n                            cellWidth,\n                            rh,\n                            accentCount > 0,\n                            theme,\n                            drawCustomCell,\n                            imageLoader,\n                            spriteManager,\n                            hoverValue?.hoverAmount ?? 0,\n                            hoverInfo,\n                            hyperWrapping,\n                            frameTime,\n                            prepResult,\n                            enqueue,\n                            getCellRenderer\n                        );\n                    }\n\n                    if (cell.style === \"faded\") {\n                        ctx.globalAlpha = 1;\n                    }\n                    toDraw--;\n                    if (drawingSpan) {\n                        ctx.restore();\n                        prepResult?.deprep?.({ ctx });\n                        prepResult = undefined;\n                        reclip();\n                        font = colFont;\n                        ctx.font = colFont;\n                    }\n                    return toDraw <= 0;\n                }\n            );\n\n            ctx.restore();\n            return toDraw <= 0;\n        }\n    );\n    return result;\n}\n\nfunction drawBlanks(\n    ctx: CanvasRenderingContext2D,\n    effectiveColumns: readonly MappedGridColumn[],\n    allColumns: readonly MappedGridColumn[],\n    width: number,\n    height: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    getRowTheme: GetRowThemeCallback | undefined,\n    selectedRows: CompactSelection,\n    disabledRows: CompactSelection,\n    trailingRowType: TrailingRowType,\n    drawRegions: readonly Rectangle[],\n    damage: CellList | undefined,\n    theme: Theme\n): void {\n    if (\n        damage !== undefined ||\n        effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1]\n    )\n        return;\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (c, drawX, colDrawY, clipX, startRow) => {\n            if (c !== effectiveColumns[effectiveColumns.length - 1]) return;\n            drawX += c.width;\n            const x = Math.max(drawX, clipX);\n            if (x > width) return;\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(x, totalHeaderHeight + 1, 10_000, height - totalHeaderHeight - 1);\n            ctx.clip();\n\n            walkRowsInCol(\n                startRow,\n                colDrawY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (drawY, row, rh, isSticky) => {\n                    if (\n                        !isSticky &&\n                        drawRegions.length > 0 &&\n                        !drawRegions.some(dr =>\n                            intersectRect(drawX, drawY, 10_000, rh, dr.x, dr.y, dr.width, dr.height)\n                        )\n                    ) {\n                        return;\n                    }\n\n                    const rowSelected = selectedRows.hasIndex(row);\n                    const rowDisabled = disabledRows.hasIndex(row);\n\n                    ctx.beginPath();\n\n                    const rowTheme = getRowTheme?.(row);\n\n                    const blankTheme = rowTheme === undefined ? theme : { ...theme, ...rowTheme };\n\n                    if (blankTheme.bgCell !== theme.bgCell) {\n                        ctx.fillStyle = blankTheme.bgCell;\n                        ctx.fillRect(drawX, drawY, 10_000, rh);\n                    }\n                    if (rowDisabled) {\n                        ctx.fillStyle = blankTheme.bgHeader;\n                        ctx.fillRect(drawX, drawY, 10_000, rh);\n                    }\n                    if (rowSelected) {\n                        ctx.fillStyle = blankTheme.accentLight;\n                        ctx.fillRect(drawX, drawY, 10_000, rh);\n                    }\n                }\n            );\n\n            ctx.restore();\n        }\n    );\n}\n\nfunction overdrawStickyBoundaries(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    width: number,\n    height: number,\n    lastRowSticky: boolean,\n    rows: number,\n    verticalBorder: (col: number) => boolean,\n    getRowHeight: (row: number) => number,\n    theme: Theme\n) {\n    let drawFreezeBorder = false;\n    for (const c of effectiveCols) {\n        if (c.sticky) continue;\n        drawFreezeBorder = verticalBorder(c.sourceIndex);\n        break;\n    }\n    const hColor = theme.horizontalBorderColor ?? theme.borderColor;\n    const vColor = theme.borderColor;\n    const drawX = drawFreezeBorder ? getStickyWidth(effectiveCols) : 0;\n\n    if (drawX !== 0) {\n        ctx.beginPath();\n        ctx.moveTo(drawX + 0.5, 0);\n        ctx.lineTo(drawX + 0.5, height);\n        ctx.strokeStyle = blend(vColor, theme.bgCell);\n        ctx.stroke();\n    }\n\n    if (lastRowSticky) {\n        const h = getRowHeight(rows - 1);\n        ctx.beginPath();\n        ctx.moveTo(0, height - h + 0.5);\n        ctx.lineTo(width, height - h + 0.5);\n        ctx.strokeStyle = blend(hColor, theme.bgCell);\n        ctx.stroke();\n    }\n}\n\nfunction drawHighlightRings(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    mappedColumns: readonly MappedGridColumn[],\n    freezeColumns: number,\n    headerHeight: number,\n    groupHeaderHeight: number,\n    rowHeight: number | ((index: number) => number),\n    lastRowSticky: boolean,\n    rows: number,\n    allHighlightRegions: readonly Highlight[] | undefined\n): (() => void) | undefined {\n    const highlightRegions = allHighlightRegions?.filter(x => x.style !== \"no-outline\");\n    if (highlightRegions === undefined || highlightRegions.length === 0) return undefined;\n    const drawRects = highlightRegions.map(h => {\n        const r = h.range;\n        const topLeftBounds = computeBounds(\n            r.x,\n            r.y,\n            width,\n            height,\n            groupHeaderHeight,\n            headerHeight + groupHeaderHeight,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            rows,\n            freezeColumns,\n            lastRowSticky,\n            mappedColumns,\n            rowHeight\n        );\n        if (r.width === 1 && r.height === 1) {\n            if (r.x < freezeColumns) {\n                return [{ color: h.color, style: h.style ?? \"dashed\", rect: topLeftBounds }, undefined];\n            }\n            return [undefined, { color: h.color, style: h.style ?? \"dashed\", rect: topLeftBounds }];\n        }\n\n        const bottomRightBounds = computeBounds(\n            r.x + r.width - 1,\n            r.y + r.height - 1,\n            width,\n            height,\n            groupHeaderHeight,\n            headerHeight + groupHeaderHeight,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            rows,\n            freezeColumns,\n            lastRowSticky,\n            mappedColumns,\n            rowHeight\n        );\n        if (r.x < freezeColumns && r.x + r.width >= freezeColumns) {\n            const freezeSectionRightBounds = computeBounds(\n                freezeColumns - 1,\n                r.y + r.height - 1,\n                width,\n                height,\n                groupHeaderHeight,\n                headerHeight + groupHeaderHeight,\n                cellXOffset,\n                cellYOffset,\n                translateX,\n                translateY,\n                rows,\n                freezeColumns,\n                lastRowSticky,\n                mappedColumns,\n                rowHeight\n            );\n            const unfreezeSectionleftBounds = computeBounds(\n                freezeColumns,\n                r.y + r.height - 1,\n                width,\n                height,\n                groupHeaderHeight,\n                headerHeight + groupHeaderHeight,\n                cellXOffset,\n                cellYOffset,\n                translateX,\n                translateY,\n                rows,\n                freezeColumns,\n                lastRowSticky,\n                mappedColumns,\n                rowHeight\n            );\n\n            return [\n                {\n                    color: h.color,\n                    style: h.style ?? \"dashed\",\n                    rect: {\n                        x: topLeftBounds.x,\n                        y: topLeftBounds.y,\n                        width: freezeSectionRightBounds.x + freezeSectionRightBounds.width - topLeftBounds.x,\n                        height: freezeSectionRightBounds.y + freezeSectionRightBounds.height - topLeftBounds.y,\n                    } as Rectangle,\n                },\n                {\n                    color: h.color,\n                    style: h.style ?? \"dashed\",\n                    rect: {\n                        x: unfreezeSectionleftBounds.x,\n                        y: unfreezeSectionleftBounds.y,\n                        width: bottomRightBounds.x + bottomRightBounds.width - unfreezeSectionleftBounds.x,\n                        height: bottomRightBounds.y + bottomRightBounds.height - unfreezeSectionleftBounds.y,\n                    } as Rectangle,\n                },\n            ];\n        } else {\n            return [\n                undefined,\n                {\n                    color: h.color,\n                    style: h.style ?? \"dashed\",\n                    rect: {\n                        x: topLeftBounds.x,\n                        y: topLeftBounds.y,\n                        width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,\n                        height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y,\n                    } as Rectangle,\n                },\n            ];\n        }\n    });\n\n    const stickyWidth = getStickyWidth(mappedColumns);\n\n    const drawCb = () => {\n        ctx.beginPath();\n        ctx.save();\n        let dashed = false;\n        const setDashed = (dash: boolean) => {\n            if (dashed === dash) return;\n            ctx.setLineDash(dash ? [5, 3] : []);\n            dashed = dash;\n        };\n\n        ctx.lineWidth = 1;\n        for (const dr of drawRects) {\n            const [s] = dr;\n            if (\n                s !== undefined &&\n                intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)\n            ) {\n                setDashed(s.style === \"dashed\");\n                ctx.strokeStyle = withAlpha(s.color, 1);\n                ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);\n            }\n        }\n        let clipped = false;\n        for (const dr of drawRects) {\n            const [, s] = dr;\n            if (\n                s !== undefined &&\n                intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)\n            ) {\n                setDashed(s.style === \"dashed\");\n                if (!clipped && s.rect.x < stickyWidth) {\n                    ctx.rect(stickyWidth, 0, width, height);\n                    ctx.clip();\n                    clipped = true;\n                }\n                ctx.strokeStyle = withAlpha(s.color, 1);\n                ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);\n            }\n        }\n        ctx.restore();\n    };\n\n    drawCb();\n    return drawCb;\n}\n\nfunction drawFocusRing(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    effectiveCols: readonly MappedGridColumn[],\n    allColumns: readonly MappedGridColumn[],\n    theme: Theme,\n    totalHeaderHeight: number,\n    selectedCell: GridSelection,\n    getRowHeight: (row: number) => number,\n    getCellContent: (cell: Item) => InnerGridCell,\n    trailingRowType: TrailingRowType,\n    fillHandle: boolean,\n    rows: number\n): (() => void) | undefined {\n    if (selectedCell.current === undefined || !effectiveCols.some(c => c.sourceIndex === selectedCell.current?.cell[0]))\n        return undefined;\n    const [targetCol, targetRow] = selectedCell.current.cell;\n    const cell = getCellContent(selectedCell.current.cell);\n    const targetColSpan = cell.span ?? [targetCol, targetCol];\n\n    const isStickyRow = trailingRowType === \"sticky\" && targetRow === rows - 1;\n    const stickRowHeight = trailingRowType === \"sticky\" && !isStickyRow ? getRowHeight(rows - 1) - 1 : 0;\n\n    let drawCb: (() => void) | undefined = undefined;\n\n    walkColumns(\n        effectiveCols,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (col, drawX, colDrawY, clipX, startRow) => {\n            if (col.sticky && targetCol > col.sourceIndex) return;\n            if (col.sourceIndex < targetColSpan[0] || col.sourceIndex > targetColSpan[1]) {\n                return;\n            }\n\n            walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh) => {\n                if (row !== targetRow) return;\n\n                let cellX = drawX;\n                let cellWidth = col.width;\n\n                if (cell.span !== undefined) {\n                    const areas = getSpanBounds(cell.span, drawX, drawY, col.width, rh, col, allColumns);\n                    const area = col.sticky ? areas[0] : areas[1];\n\n                    if (area !== undefined) {\n                        cellX = area.x;\n                        cellWidth = area.width;\n                    }\n                }\n\n                drawCb = () => {\n                    if (clipX > cellX && !col.sticky) {\n                        ctx.beginPath();\n                        ctx.rect(clipX, 0, width - clipX, height);\n                        ctx.clip();\n                    }\n                    ctx.beginPath();\n                    ctx.rect(cellX + 0.5, drawY + 0.5, cellWidth, rh);\n                    ctx.strokeStyle = col.themeOverride?.accentColor ?? theme.accentColor;\n                    ctx.lineWidth = 1;\n                    ctx.stroke();\n\n                    if (fillHandle) {\n                        ctx.beginPath();\n                        ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);\n                        ctx.fillStyle = col.themeOverride?.accentColor ?? theme.accentColor;\n                        ctx.fill();\n                    }\n                };\n                return true;\n            });\n\n            return true;\n        }\n    );\n\n    if (drawCb === undefined) return undefined;\n\n    const result = () => {\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);\n        ctx.clip();\n\n        drawCb?.();\n\n        ctx.restore();\n    };\n\n    result();\n\n    return result;\n}\n\nfunction getLastRow(\n    effectiveColumns: readonly MappedGridColumn[],\n    height: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    trailingRowType: TrailingRowType\n): number {\n    let result = 0;\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (_c, __drawX, colDrawY, _clipX, startRow) => {\n            walkRowsInCol(\n                startRow,\n                colDrawY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (_drawY, row, _rh, isSticky) => {\n                    if (!isSticky) {\n                        result = Math.max(row, result);\n                    }\n                }\n            );\n\n            return true;\n        }\n    );\n    return result;\n}\n\nexport interface DrawGridArg {\n    readonly canvas: HTMLCanvasElement;\n    readonly headerCanvas: HTMLCanvasElement;\n    readonly bufferA: HTMLCanvasElement;\n    readonly bufferB: HTMLCanvasElement;\n    readonly width: number;\n    readonly height: number;\n    readonly cellXOffset: number;\n    readonly cellYOffset: number;\n    readonly translateX: number;\n    readonly translateY: number;\n    readonly mappedColumns: readonly MappedGridColumn[];\n    readonly enableGroups: boolean;\n    readonly freezeColumns: number;\n    readonly dragAndDropState: DragAndDropState | undefined;\n    readonly theme: Theme;\n    readonly headerHeight: number;\n    readonly groupHeaderHeight: number;\n    readonly disabledRows: CompactSelection;\n    readonly rowHeight: number | ((index: number) => number);\n    readonly verticalBorder: (col: number) => boolean;\n    readonly isResizing: boolean;\n    readonly isFocused: boolean;\n    readonly drawFocus: boolean;\n    readonly selection: GridSelection;\n    readonly fillHandle: boolean;\n    readonly lastRowSticky: TrailingRowType;\n    readonly hyperWrapping: boolean;\n    readonly rows: number;\n    readonly getCellContent: (cell: Item) => InnerGridCell;\n    readonly getGroupDetails: GroupDetailsCallback;\n    readonly getRowThemeOverride: GetRowThemeCallback | undefined;\n    readonly drawCustomCell: DrawCustomCellCallback | undefined;\n    readonly drawHeaderCallback: DrawHeaderCallback | undefined;\n    readonly prelightCells: CellList | undefined;\n    readonly highlightRegions: readonly Highlight[] | undefined;\n    readonly imageLoader: ImageWindowLoader;\n    readonly lastBlitData: React.MutableRefObject<BlitData | undefined>;\n    readonly damage: CellList | undefined;\n    readonly hoverValues: HoverValues;\n    readonly hoverInfo: HoverInfo | undefined;\n    readonly spriteManager: SpriteManager;\n    readonly scrolling: boolean;\n    readonly touchMode: boolean;\n    readonly renderStrategy: \"single-buffer\" | \"double-buffer\" | \"direct\";\n    readonly enqueue: (item: Item) => void;\n    readonly getCellRenderer: GetCellRendererCallback;\n}\n\nfunction computeCanBlit(current: DrawGridArg, last: DrawGridArg | undefined): boolean | number {\n    if (last === undefined) return false;\n    if (\n        current.width !== last.width ||\n        current.height !== last.height ||\n        current.theme !== last.theme ||\n        current.headerHeight !== last.headerHeight ||\n        current.rowHeight !== last.rowHeight ||\n        current.rows !== last.rows ||\n        current.getRowThemeOverride !== last.getRowThemeOverride ||\n        current.isFocused !== last.isFocused ||\n        current.isResizing !== last.isResizing ||\n        current.verticalBorder !== last.verticalBorder ||\n        current.getCellContent !== last.getCellContent ||\n        current.highlightRegions !== last.highlightRegions ||\n        current.selection !== last.selection ||\n        current.dragAndDropState !== last.dragAndDropState ||\n        current.prelightCells !== last.prelightCells ||\n        current.touchMode !== last.touchMode ||\n        current.scrolling !== last.scrolling\n    ) {\n        return false;\n    }\n    if (current.mappedColumns !== last.mappedColumns) {\n        if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {\n            // The array is big, let's just redraw the damned thing rather than check these all. Or the number of cols\n            // changed in which case I dont want to figure out what happened.\n            return false;\n        }\n        // We want to know if only one column has resized. If this is the case we can do a special left/right sliding\n        // blit. Or just not redraw shit on the left.\n        let resized: number | undefined;\n        for (let i = 0; i < current.mappedColumns.length; i++) {\n            const curCol = current.mappedColumns[i];\n            const lastCol = last.mappedColumns[i];\n\n            if (deepEqual(curCol, lastCol)) continue;\n\n            // two columns changed, abort\n            if (resized !== undefined) return false;\n\n            if (curCol.width === lastCol.width) return false;\n\n            const { width, ...curRest } = curCol;\n            const { width: lastWidth, ...lastRest } = lastCol;\n\n            // more than width changed, abort\n            if (!deepEqual(curRest, lastRest)) return false;\n            resized = i;\n        }\n        if (resized === undefined) {\n            // we never found a changed column, cool, we can blit\n            return true;\n        }\n        return resized;\n    }\n    return true;\n}\n\nexport function drawGrid(arg: DrawGridArg, lastArg: DrawGridArg | undefined) {\n    const {\n        canvas,\n        headerCanvas,\n        width,\n        height,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mappedColumns,\n        enableGroups,\n        freezeColumns,\n        dragAndDropState,\n        theme,\n        drawFocus,\n        headerHeight,\n        groupHeaderHeight,\n        disabledRows,\n        rowHeight,\n        verticalBorder,\n        isResizing,\n        selection,\n        fillHandle,\n        lastRowSticky: trailingRowType,\n        rows,\n        getCellContent,\n        getGroupDetails,\n        getRowThemeOverride,\n        isFocused,\n        drawCustomCell,\n        drawHeaderCallback,\n        prelightCells,\n        highlightRegions,\n        imageLoader,\n        lastBlitData,\n        hoverValues,\n        hyperWrapping,\n        hoverInfo,\n        spriteManager,\n        scrolling,\n        touchMode,\n        enqueue,\n        getCellRenderer,\n        renderStrategy,\n        bufferA,\n        bufferB,\n    } = arg;\n    let { damage } = arg;\n    if (width === 0 || height === 0) return;\n    const doubleBuffer = renderStrategy === \"double-buffer\";\n    const dpr = scrolling ? 1 : Math.ceil(window.devicePixelRatio ?? 1);\n\n    const canBlit = renderStrategy !== \"direct\" && computeCanBlit(arg, lastArg);\n\n    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {\n        canvas.width = width * dpr;\n        canvas.height = height * dpr;\n\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n    }\n\n    const overlayCanvas = headerCanvas;\n    const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;\n\n    const overlayHeight = totalHeaderHeight + 1; // border\n    if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {\n        overlayCanvas.width = width * dpr;\n        overlayCanvas.height = overlayHeight * dpr;\n\n        overlayCanvas.style.width = width + \"px\";\n        overlayCanvas.style.height = overlayHeight + \"px\";\n    }\n\n    if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {\n        bufferA.width = width * dpr;\n        bufferA.height = height * dpr;\n    }\n\n    if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {\n        bufferB.width = width * dpr;\n        bufferB.height = height * dpr;\n    }\n\n    const last = lastBlitData.current;\n    if (\n        canBlit === true &&\n        cellXOffset === last?.cellXOffset &&\n        cellYOffset === last?.cellYOffset &&\n        translateX === last?.translateX &&\n        translateY === last?.translateY\n    )\n        return;\n\n    let mainCtx: CanvasRenderingContext2D | null = null;\n    if (doubleBuffer) {\n        mainCtx = canvas.getContext(\"2d\", {\n            alpha: false,\n        });\n    }\n    const overlayCtx = overlayCanvas.getContext(\"2d\", {\n        alpha: false,\n    });\n    let targetBuffer: HTMLCanvasElement;\n    if (!doubleBuffer) {\n        targetBuffer = canvas;\n    } else if (damage !== undefined) {\n        targetBuffer = last?.lastBuffer === \"b\" ? bufferB : bufferA;\n    } else {\n        targetBuffer = last?.lastBuffer === \"b\" ? bufferA : bufferB;\n    }\n    const targetCtx = targetBuffer.getContext(\"2d\", {\n        alpha: false,\n    });\n    const blitSource = doubleBuffer ? (targetBuffer === bufferA ? bufferB : bufferA) : canvas;\n\n    if (overlayCtx === null || targetCtx === null) return;\n\n    const getRowHeight = typeof rowHeight === \"number\" ? () => rowHeight : rowHeight;\n\n    overlayCtx.save();\n    overlayCtx.beginPath();\n    targetCtx.save();\n    targetCtx.beginPath();\n\n    overlayCtx.textBaseline = \"middle\";\n    targetCtx.textBaseline = \"middle\";\n\n    if (dpr !== 1) {\n        overlayCtx.scale(dpr, dpr);\n        targetCtx.scale(dpr, dpr);\n    }\n\n    const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);\n\n    let drawRegions: Rectangle[] = [];\n\n    const mustDrawFocusOnHeader = drawFocus && selection.current?.cell[1] === cellYOffset && translateY === 0;\n    const drawHeaderTexture = () => {\n        drawGridHeaders(\n            overlayCtx,\n            effectiveCols,\n            enableGroups,\n            hoverInfo,\n            width,\n            translateX,\n            headerHeight,\n            groupHeaderHeight,\n            dragAndDropState,\n            isResizing,\n            selection,\n            theme,\n            spriteManager,\n            hoverValues,\n            verticalBorder,\n            getGroupDetails,\n            damage,\n            drawHeaderCallback,\n            touchMode\n        );\n\n        drawGridLines(\n            overlayCtx,\n            effectiveCols,\n            cellYOffset,\n            translateX,\n            translateY,\n            width,\n            height,\n            undefined,\n            undefined,\n            groupHeaderHeight,\n            totalHeaderHeight,\n            getRowHeight,\n            getRowThemeOverride,\n            verticalBorder,\n            trailingRowType,\n            rows,\n            theme,\n            true\n        );\n\n        overlayCtx.beginPath();\n        overlayCtx.moveTo(0, overlayHeight - 0.5);\n        overlayCtx.lineTo(width, overlayHeight - 0.5);\n        overlayCtx.strokeStyle = blend(\n            theme.headerBottomBorderColor ?? theme.horizontalBorderColor ?? theme.borderColor,\n            theme.bgHeader\n        );\n        overlayCtx.stroke();\n\n        if (mustDrawFocusOnHeader) {\n            drawFocusRing(\n                overlayCtx,\n                width,\n                height,\n                cellYOffset,\n                translateX,\n                translateY,\n                effectiveCols,\n                mappedColumns,\n                theme,\n                totalHeaderHeight,\n                selection,\n                getRowHeight,\n                getCellContent,\n                trailingRowType,\n                fillHandle,\n                rows\n            );\n        }\n    };\n\n    // handle damage updates by directly drawing to the target to avoid large blits\n    if (damage !== undefined) {\n        let doHeaders = false;\n        damage = damage.filter(x => {\n            doHeaders = doHeaders || x[1] < 0;\n            return (\n                x[1] < 0 ||\n                intersectRect(cellXOffset, cellYOffset, effectiveCols.length, 300, x[0], x[1], 1, 1) ||\n                intersectRect(0, cellYOffset, freezeColumns, 300, x[0], x[1], 1, 1) ||\n                (trailingRowType && intersectRect(cellXOffset, rows - 1, effectiveCols.length, 1, x[0], x[1], 1, 1))\n            );\n        });\n\n        if (damage.length > 0) {\n            clipDamage(\n                targetCtx,\n                effectiveCols,\n                width,\n                height,\n                groupHeaderHeight,\n                totalHeaderHeight,\n                translateX,\n                translateY,\n                cellYOffset,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                damage,\n                true\n            );\n\n            targetCtx.fillStyle = theme.bgCell;\n            targetCtx.fillRect(0, totalHeaderHeight + 1, width, height - totalHeaderHeight - 1);\n\n            drawCells(\n                targetCtx,\n                effectiveCols,\n                mappedColumns,\n                height,\n                totalHeaderHeight,\n                translateX,\n                translateY,\n                cellYOffset,\n                rows,\n                getRowHeight,\n                getCellContent,\n                getGroupDetails,\n                getRowThemeOverride,\n                disabledRows,\n                isFocused,\n                drawFocus,\n                trailingRowType,\n                drawRegions,\n                damage,\n                selection,\n                prelightCells,\n                highlightRegions,\n                drawCustomCell,\n                imageLoader,\n                spriteManager,\n                hoverValues,\n                hoverInfo,\n                hyperWrapping,\n                theme,\n                enqueue,\n                getCellRenderer\n            );\n\n            if (\n                fillHandle &&\n                drawFocus &&\n                selection.current !== undefined &&\n                damage.some(x => x[0] === selection.current?.cell[0] && x[1] === selection.current?.cell[1])\n            ) {\n                drawFocusRing(\n                    targetCtx,\n                    width,\n                    height,\n                    cellYOffset,\n                    translateX,\n                    translateY,\n                    effectiveCols,\n                    mappedColumns,\n                    theme,\n                    totalHeaderHeight,\n                    selection,\n                    getRowHeight,\n                    getCellContent,\n                    trailingRowType,\n                    fillHandle,\n                    rows\n                );\n            }\n        }\n\n        if (doHeaders) {\n            clipDamage(\n                overlayCtx,\n                effectiveCols,\n                width,\n                totalHeaderHeight,\n                groupHeaderHeight,\n                totalHeaderHeight,\n                translateX,\n                translateY,\n                cellYOffset,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                damage,\n                false\n            );\n            drawHeaderTexture();\n        }\n        targetCtx.restore();\n        overlayCtx.restore();\n\n        if (mainCtx !== null) {\n            mainCtx.fillStyle = theme.bgCell;\n            mainCtx.fillRect(0, 0, width, height);\n            mainCtx.drawImage(targetCtx.canvas, 0, 0);\n        }\n\n        return;\n    }\n\n    if (\n        canBlit !== true ||\n        cellXOffset !== last?.cellXOffset ||\n        translateX !== last?.translateX ||\n        mustDrawFocusOnHeader !== last?.mustDrawFocusOnHeader\n    ) {\n        drawHeaderTexture();\n    }\n\n    if (canBlit === true) {\n        assert(blitSource !== undefined && last !== undefined);\n        const { regions } = blitLastFrame(\n            targetCtx,\n            blitSource,\n            last,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            trailingRowType === \"sticky\",\n            width,\n            height,\n            rows,\n            totalHeaderHeight,\n            dpr,\n            mappedColumns,\n            effectiveCols,\n            rowHeight,\n            doubleBuffer\n        );\n        drawRegions = regions;\n    } else if (canBlit !== false) {\n        assert(last !== undefined);\n        const resizedCol = canBlit;\n        drawRegions = blitResizedCol(\n            last,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            width,\n            height,\n            totalHeaderHeight,\n            effectiveCols,\n            resizedCol\n        );\n    }\n\n    overdrawStickyBoundaries(\n        targetCtx,\n        effectiveCols,\n        width,\n        height,\n        trailingRowType === \"sticky\",\n        rows,\n        verticalBorder,\n        getRowHeight,\n        theme\n    );\n\n    // the overdraw may have nuked out our focus ring right edge.\n    const focusRedraw = drawFocus\n        ? drawFocusRing(\n              targetCtx,\n              width,\n              height,\n              cellYOffset,\n              translateX,\n              translateY,\n              effectiveCols,\n              mappedColumns,\n              theme,\n              totalHeaderHeight,\n              selection,\n              getRowHeight,\n              getCellContent,\n              trailingRowType,\n              fillHandle,\n              rows\n          )\n        : undefined;\n\n    const highlightRedraw = drawHighlightRings(\n        targetCtx,\n        width,\n        height,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mappedColumns,\n        freezeColumns,\n        headerHeight,\n        groupHeaderHeight,\n        rowHeight,\n        trailingRowType === \"sticky\",\n        rows,\n        highlightRegions\n    );\n\n    targetCtx.fillStyle = theme.bgCell;\n    if (drawRegions.length > 0) {\n        targetCtx.beginPath();\n        for (const r of drawRegions) {\n            targetCtx.rect(r.x, r.y, r.width, r.height);\n        }\n        targetCtx.clip();\n        targetCtx.fill();\n        targetCtx.beginPath();\n    } else {\n        targetCtx.fillRect(0, 0, width, height);\n    }\n\n    const spans = drawCells(\n        targetCtx,\n        effectiveCols,\n        mappedColumns,\n        height,\n        totalHeaderHeight,\n        translateX,\n        translateY,\n        cellYOffset,\n        rows,\n        getRowHeight,\n        getCellContent,\n        getGroupDetails,\n        getRowThemeOverride,\n        disabledRows,\n        isFocused,\n        drawFocus,\n        trailingRowType,\n        drawRegions,\n        damage,\n        selection,\n        prelightCells,\n        highlightRegions,\n        drawCustomCell,\n        imageLoader,\n        spriteManager,\n        hoverValues,\n        hoverInfo,\n        hyperWrapping,\n        theme,\n        enqueue,\n        getCellRenderer\n    );\n\n    drawBlanks(\n        targetCtx,\n        effectiveCols,\n        mappedColumns,\n        width,\n        height,\n        totalHeaderHeight,\n        translateX,\n        translateY,\n        cellYOffset,\n        rows,\n        getRowHeight,\n        getRowThemeOverride,\n        selection.rows,\n        disabledRows,\n        trailingRowType,\n        drawRegions,\n        damage,\n        theme\n    );\n\n    drawGridLines(\n        targetCtx,\n        effectiveCols,\n        cellYOffset,\n        translateX,\n        translateY,\n        width,\n        height,\n        drawRegions,\n        spans,\n        groupHeaderHeight,\n        totalHeaderHeight,\n        getRowHeight,\n        getRowThemeOverride,\n        verticalBorder,\n        trailingRowType,\n        rows,\n        theme\n    );\n\n    focusRedraw?.();\n    highlightRedraw?.();\n\n    if (mainCtx !== null) {\n        mainCtx.fillStyle = theme.bgCell;\n        mainCtx.fillRect(0, 0, width, height);\n        mainCtx.drawImage(targetCtx.canvas, 0, 0);\n    }\n\n    const lastRowDrawn = getLastRow(\n        effectiveCols,\n        height,\n        totalHeaderHeight,\n        translateX,\n        translateY,\n        cellYOffset,\n        rows,\n        getRowHeight,\n        trailingRowType\n    );\n\n    imageLoader?.setWindow(\n        {\n            x: cellXOffset,\n            y: cellYOffset,\n            width: effectiveCols.length,\n            height: lastRowDrawn - cellYOffset,\n        },\n        freezeColumns\n    );\n\n    lastBlitData.current = {\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mustDrawFocusOnHeader,\n        lastBuffer: doubleBuffer ? (targetBuffer === bufferA ? \"a\" : \"b\") : undefined,\n    };\n\n    targetCtx.restore();\n    overlayCtx.restore();\n}\n\ntype WalkRowsCallback = (\n    drawY: number,\n    row: number,\n    rowHeight: number,\n    isSticky: boolean,\n    isTrailingRow: boolean\n) => boolean | void;\n\nfunction walkRowsInCol(\n    startRow: number,\n    drawY: number,\n    height: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    trailingRowType: TrailingRowType,\n    cb: WalkRowsCallback\n): void {\n    let y = drawY;\n    let row = startRow;\n    let doSticky = trailingRowType === \"sticky\";\n    while (y < height || doSticky) {\n        const doingSticky = doSticky && y >= height;\n        if (doingSticky) {\n            doSticky = false;\n            row = rows - 1;\n        }\n        const rh = getRowHeight(row);\n\n        if (doingSticky) {\n            y = height - rh;\n        }\n\n        const isMovedStickyRow = doSticky && row === rows - 1;\n\n        if (!isMovedStickyRow && cb(y, row, rh, doingSticky, trailingRowType !== \"none\" && row === rows - 1) === true) {\n            break;\n        }\n\n        if (doingSticky) {\n            break;\n        }\n        y += rh;\n        row++;\n    }\n}\n\ntype WalkColsCallback = (\n    col: MappedGridColumn,\n    drawX: number,\n    drawY: number,\n    clipX: number,\n    startRow: number\n) => boolean | void;\n\nfunction walkColumns(\n    effectiveCols: readonly MappedGridColumn[],\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    totalHeaderHeight: number,\n    cb: WalkColsCallback\n): void {\n    let x = 0;\n    let clipX = 0; // this tracks the total width of sticky cols\n    const drawY = totalHeaderHeight + translateY;\n    for (const c of effectiveCols) {\n        const drawX = c.sticky ? clipX : x + translateX;\n        if (cb(c, drawX, drawY, clipX, cellYOffset) === true) {\n            break;\n        }\n\n        x += c.width;\n        clipX += c.sticky ? c.width : 0;\n    }\n}\n\ntype WalkGroupsCallback = (colSpan: Item, group: string, x: number, y: number, width: number, height: number) => void;\nfunction walkGroups(\n    effectiveCols: readonly MappedGridColumn[],\n    width: number,\n    translateX: number,\n    groupHeaderHeight: number,\n    cb: WalkGroupsCallback\n): void {\n    let x = 0;\n    let clipX = 0;\n    for (let index = 0; index < effectiveCols.length; index++) {\n        const startCol = effectiveCols[index];\n\n        let end = index + 1;\n        let boxWidth = startCol.width;\n        if (startCol.sticky) {\n            clipX += boxWidth;\n        }\n        while (\n            end < effectiveCols.length &&\n            isGroupEqual(effectiveCols[end].group, startCol.group) &&\n            effectiveCols[end].sticky === effectiveCols[index].sticky\n        ) {\n            const endCol = effectiveCols[end];\n            boxWidth += endCol.width;\n            end++;\n            index++;\n            if (endCol.sticky) {\n                clipX += endCol.width;\n            }\n        }\n\n        const t = startCol.sticky ? 0 : translateX;\n        const localX = x + t;\n        const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);\n        const w = Math.min(boxWidth - delta, width - (localX + delta));\n        cb(\n            [startCol.sourceIndex, effectiveCols[end - 1].sourceIndex],\n            startCol.group ?? \"\",\n            localX + delta,\n            0,\n            w,\n            groupHeaderHeight\n        );\n\n        x += boxWidth;\n    }\n}\n","import clamp from \"lodash/clamp.js\";\nimport type { Item } from \"./data-grid-types\";\n\ntype StateItem = { item: Item; hoverAmount: number };\nexport type HoverValues = readonly Readonly<StateItem>[];\nexport type StepCallback = (values: HoverValues) => void;\n\nconst hoverTime = 80;\n\nfunction easeOutCubic(x: number) {\n    const x1 = x - 1;\n    return x1 * x1 * x1 + 1;\n}\n\nexport class AnimationManager {\n    constructor(private callback: StepCallback) {}\n\n    private currentHoveredItem: StateItem | undefined = undefined;\n    private leavingItems: StateItem[] = [];\n\n    private lastAnimationTime: number | undefined;\n\n    private areSameItems = (left: Item | undefined, right: Item | undefined) => {\n        return left?.[0] === right?.[0] && left?.[1] === right?.[1];\n    };\n\n    private addToLeavingItems = (item: StateItem) => {\n        const isAlreadyLeaving = this.leavingItems.some(i => this.areSameItems(i.item, item.item));\n\n        if (isAlreadyLeaving) {\n            return;\n        }\n\n        this.leavingItems.push(item);\n    };\n\n    /**\n     * @returns the hover amount of the item, if it was leaving (0 if not).\n     */\n    private removeFromLeavingItems = (item: Item): number => {\n        const leavingItem = this.leavingItems.find(e => this.areSameItems(e.item, item));\n\n        this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);\n\n        return leavingItem?.hoverAmount ?? 0;\n    };\n\n    private cleanUpLeavingElements = () => {\n        this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);\n    };\n\n    private shouldStep = () => {\n        const hasLeavingItems = this.leavingItems.length > 0;\n        const currentHoveredIsAnimating =\n            this.currentHoveredItem !== undefined && this.currentHoveredItem.hoverAmount < 1;\n\n        return hasLeavingItems || currentHoveredIsAnimating;\n    };\n\n    private getAnimatingItems = (): StateItem[] => {\n        if (this.currentHoveredItem !== undefined) {\n            return [...this.leavingItems, this.currentHoveredItem];\n        }\n        return this.leavingItems.map(x => ({ ...x, hoverAmount: easeOutCubic(x.hoverAmount) }));\n    };\n\n    private step = (timestamp: number): void => {\n        if (this.lastAnimationTime === undefined) {\n            this.lastAnimationTime = timestamp;\n        } else {\n            const step = timestamp - this.lastAnimationTime;\n            const delta = step / hoverTime;\n\n            for (const item of this.leavingItems) {\n                item.hoverAmount = clamp(item.hoverAmount - delta, 0, 1);\n            }\n\n            if (this.currentHoveredItem !== undefined) {\n                this.currentHoveredItem.hoverAmount = clamp(this.currentHoveredItem.hoverAmount + delta, 0, 1);\n            }\n\n            const animating = this.getAnimatingItems();\n            this.callback(animating);\n\n            this.cleanUpLeavingElements();\n        }\n\n        if (this.shouldStep()) {\n            this.lastAnimationTime = timestamp;\n            window.requestAnimationFrame(this.step);\n        } else {\n            this.lastAnimationTime = undefined;\n        }\n    };\n\n    public setHovered = (item: Item | undefined): void => {\n        if (this.areSameItems(this.currentHoveredItem?.item, item)) {\n            return;\n        }\n\n        if (this.currentHoveredItem !== undefined) {\n            this.addToLeavingItems(this.currentHoveredItem);\n        }\n\n        if (item !== undefined) {\n            const hoverAmount = this.removeFromLeavingItems(item);\n            this.currentHoveredItem = {\n                item,\n                hoverAmount,\n            };\n        } else {\n            this.currentHoveredItem = undefined;\n        }\n\n        if (this.lastAnimationTime === undefined) {\n            window.requestAnimationFrame(this.step);\n        }\n    };\n}\n","import * as React from \"react\";\nimport type { Item } from \"./data-grid-types\";\n\nfunction hasItem(arr: readonly Item[], item: Item) {\n    for (const element of arr) {\n        if (element[0] === item[0] && element[1] === item[1]) return true;\n    }\n    return false;\n}\n\nexport function useAnimationQueue(draw: (items: readonly Item[]) => void) {\n    const queue = React.useRef<Item[]>([]);\n    const seq = React.useRef(0);\n    const drawRef = React.useRef(draw);\n    drawRef.current = draw;\n\n    const loop = React.useCallback(() => {\n        const requeue = () => window.requestAnimationFrame(fn);\n\n        const fn = () => {\n            const toDraw = queue.current;\n            queue.current = [];\n            drawRef.current(toDraw);\n            if (queue.current.length > 0) {\n                seq.current++;\n            } else {\n                seq.current = 0;\n            }\n        };\n\n        window.requestAnimationFrame(seq.current > 600 ? requeue : fn);\n    }, []);\n\n    return React.useCallback(\n        (item: Item) => {\n            if (hasItem(queue.current, item)) return;\n            if (queue.current.length === 0) {\n                loop();\n            }\n            queue.current.push(item);\n        },\n        [loop]\n    );\n}\n","import * as React from \"react\";\nimport type { Theme } from \"../common/styles\";\nimport ImageWindowLoaderImpl from \"../common/image-window-loader\";\nimport {\n    computeBounds,\n    getColumnIndexForX,\n    getEffectiveColumns,\n    getRowIndexForY,\n    getStickyWidth,\n    useMappedColumns,\n} from \"./data-grid-lib\";\nimport {\n    GridCellKind,\n    Rectangle,\n    GridSelection,\n    GridMouseEventArgs,\n    GridDragEventArgs,\n    GridKeyEventArgs,\n    InnerGridCell,\n    InnerGridCellKind,\n    CompactSelection,\n    DrawCustomCellCallback,\n    CellList,\n    Item,\n    DrawHeaderCallback,\n    isReadWriteCell,\n    isInnerOnlyCell,\n    booleanCellIsEditable,\n    InnerGridColumn,\n    TrailingRowType,\n    groupHeaderKind,\n    headerKind,\n    outOfBoundsKind,\n    ImageWindowLoader,\n} from \"./data-grid-types\";\nimport { SpriteManager, SpriteMap } from \"./data-grid-sprites\";\nimport { useDebouncedMemo, useEventListener } from \"../common/utils\";\nimport clamp from \"lodash/clamp.js\";\nimport makeRange from \"lodash/range.js\";\nimport {\n    BlitData,\n    drawCell,\n    drawGrid,\n    DrawGridArg,\n    drawHeader,\n    getActionBoundsForGroup,\n    getHeaderMenuBounds,\n    GetRowThemeCallback,\n    GroupDetailsCallback,\n    Highlight,\n    pointInRect,\n} from \"./data-grid-render\";\nimport { AnimationManager, StepCallback } from \"./animation-manager\";\nimport { browserIsFirefox, browserIsSafari } from \"../common/browser-detect\";\nimport { useAnimationQueue } from \"./use-animation-queue\";\nimport { assert } from \"../common/support\";\nimport type { CellRenderer, GetCellRendererCallback } from \"./cells/cell-types\";\n\nexport interface DataGridProps {\n    readonly width: number;\n    readonly height: number;\n\n    readonly cellXOffset: number;\n    readonly cellYOffset: number;\n\n    readonly translateX: number | undefined;\n    readonly translateY: number | undefined;\n\n    readonly accessibilityHeight: number;\n\n    readonly freezeColumns: number;\n    readonly trailingRowType: TrailingRowType;\n    readonly firstColAccessible: boolean;\n\n    /**\n     * Enables or disables the overlay shadow when scrolling horizontally\n     * @group Style\n     */\n    readonly fixedShadowX: boolean | undefined;\n    /**\n     * Enables or disables the overlay shadow when scrolling vertical\n     * @group Style\n     */\n    readonly fixedShadowY: boolean | undefined;\n\n    readonly allowResize: boolean | undefined;\n    readonly isResizing: boolean;\n    readonly isDragging: boolean;\n    readonly isFilling: boolean;\n    readonly isFocused: boolean;\n\n    readonly columns: readonly InnerGridColumn[];\n    /**\n     * The number of rows in the grid.\n     * @group Data\n     */\n    readonly rows: number;\n\n    readonly headerHeight: number;\n    readonly groupHeaderHeight: number;\n    readonly enableGroups: boolean;\n    readonly rowHeight: number | ((index: number) => number);\n\n    readonly canvasRef: React.MutableRefObject<HTMLCanvasElement | null> | undefined;\n\n    readonly eventTargetRef: React.MutableRefObject<HTMLDivElement | null> | undefined;\n\n    readonly getCellContent: (cell: Item) => InnerGridCell;\n    /**\n     * Provides additional details about groups to extend group functionality.\n     * @group Data\n     */\n    readonly getGroupDetails: GroupDetailsCallback | undefined;\n    /**\n     * Provides per row theme overrides.\n     * @group Style\n     */\n    readonly getRowThemeOverride: GetRowThemeCallback | undefined;\n    /**\n     * Emitted when a header menu disclosure indicator is clicked.\n     * @group Events\n     */\n    readonly onHeaderMenuClick: ((col: number, screenPosition: Rectangle) => void) | undefined;\n\n    readonly selection: GridSelection;\n    readonly prelightCells: readonly Item[] | undefined;\n    /**\n     * Highlight regions provide hints to users about relations between cells and selections.\n     * @group Selection\n     */\n    readonly highlightRegions: readonly Highlight[] | undefined;\n\n    /**\n     * Enabled/disables the fill handle.\n     * @defaultValue false\n     * @group Editing\n     */\n    readonly fillHandle: boolean | undefined;\n\n    readonly disabledRows: CompactSelection | undefined;\n    /**\n     * Allows passing a custom image window loader.\n     * @group Advanced\n     */\n    readonly imageWindowLoader: ImageWindowLoader | undefined;\n\n    /**\n     * Emitted when an item is hovered.\n     * @group Events\n     */\n    readonly onItemHovered: (args: GridMouseEventArgs) => void;\n    readonly onMouseMove: (args: GridMouseEventArgs) => void;\n    readonly onMouseDown: (args: GridMouseEventArgs) => void;\n    readonly onMouseUp: (args: GridMouseEventArgs, isOutside: boolean) => void;\n    readonly onContextMenu: (args: GridMouseEventArgs, preventDefault: () => void) => void;\n\n    readonly onCanvasFocused: () => void;\n    readonly onCanvasBlur: () => void;\n    readonly onCellFocused: (args: Item) => void;\n\n    readonly onMouseMoveRaw: (event: MouseEvent) => void;\n\n    /**\n     * Emitted when the canvas receives a key down event.\n     * @group Events\n     */\n    readonly onKeyDown: (event: GridKeyEventArgs) => void;\n    /**\n     * Emitted when the canvas receives a key up event.\n     * @group Events\n     */\n    readonly onKeyUp: ((event: GridKeyEventArgs) => void) | undefined;\n\n    readonly verticalBorder: (col: number) => boolean;\n\n    /**\n     * Determines what can be dragged using HTML drag and drop\n     * @group Drag and Drop\n     */\n    readonly isDraggable: boolean | \"cell\" | \"header\" | undefined;\n    /**\n     * If `isDraggable` is set, the grid becomes HTML draggable, and `onDragStart` will be called when dragging starts.\n     * You can use this to build a UI where the user can drag the Grid around.\n     * @group Drag and Drop\n     */\n    readonly onDragStart: (args: GridDragEventArgs) => void;\n    readonly onDragEnd: () => void;\n\n    /** @group Drag and Drop */\n    readonly onDragOverCell: ((cell: Item, dataTransfer: DataTransfer | null) => void) | undefined;\n    /** @group Drag and Drop */\n    readonly onDragLeave: (() => void) | undefined;\n\n    /**\n     * Called when a HTML Drag and Drop event is ended on the data grid.\n     * @group Drag and Drop\n     */\n    readonly onDrop: ((cell: Item, dataTransfer: DataTransfer | null) => void) | undefined;\n\n    readonly drawCustomCell: DrawCustomCellCallback | undefined;\n    /**\n     * Overrides the rendering of a header. The grid will call this for every header it needs to render. Header\n     * rendering is not as well optimized because they do not redraw as often, but very heavy drawing methods can\n     * negatively impact horizontal scrolling performance.\n     *\n     * It is possible to return `false` after rendering just a background and the regular foreground rendering\n     * will happen.\n     * @group Drawing\n     * @returns `false` if default header rendering should still happen, `true` to cancel rendering.\n     */\n    readonly drawHeader: DrawHeaderCallback | undefined;\n    /**\n     * Controls the drawing of the focus ring.\n     * @defaultValue true\n     * @group Style\n     */\n    readonly drawFocusRing: boolean | undefined;\n\n    readonly dragAndDropState:\n        | {\n              src: number;\n              dest: number;\n          }\n        | undefined;\n\n    /**\n     * Experimental features\n     * @group Advanced\n     * @experimental\n     */\n    readonly experimental:\n        | {\n              readonly paddingRight?: number;\n              readonly paddingBottom?: number;\n              readonly enableFirefoxRescaling?: boolean;\n              readonly isSubGrid?: boolean;\n              readonly strict?: boolean;\n              readonly scrollbarWidthOverride?: number;\n              readonly hyperWrapping?: boolean;\n              readonly renderStrategy?: \"single-buffer\" | \"double-buffer\" | \"direct\";\n          }\n        | undefined;\n\n    /**\n     * Additional header icons for use by `GridColumn`.\n     *\n     * Providing custom header icons to the data grid must be done with a somewhat non-standard mechanism to allow\n     * theming and scaling. The `headerIcons` property takes a dictionary which maps icon names to functions which can\n     * take a foreground and background color and returns back a string representation of an svg. The svg should contain\n     * a header similar to this `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">` and\n     * interpolate the fg/bg colors into the string.\n     *\n     * We recognize this process is not fantastic from a graphics workflow standpoint, improvements are very welcome\n     * here.\n     *\n     * @group Style\n     */\n    readonly headerIcons: SpriteMap | undefined;\n\n    /** Controls smooth scrolling in the data grid. If smooth scrolling is not enabled the grid will always be cell\n     * aligned.\n     * @defaultValue `false`\n     * @group Style\n     */\n    readonly smoothScrollX: boolean | undefined;\n    /** Controls smooth scrolling in the data grid. If smooth scrolling is not enabled the grid will always be cell\n     * aligned.\n     * @defaultValue `false`\n     * @group Style\n     */\n    readonly smoothScrollY: boolean | undefined;\n\n    readonly theme: Theme;\n\n    readonly getCellRenderer: <T extends InnerGridCell>(cell: T) => CellRenderer<T> | undefined;\n}\n\ntype DamageUpdateList = readonly {\n    cell: Item;\n    // newValue: GridCell,\n}[];\n\nexport interface DataGridRef {\n    focus: () => void;\n    getBounds: (col: number, row?: number) => Rectangle | undefined;\n    damage: (cells: DamageUpdateList) => void;\n}\n\nconst getRowData = (cell: InnerGridCell, getCellRenderer?: GetCellRendererCallback) => {\n    if (cell.kind === GridCellKind.Custom) return cell.copyData;\n    const r = getCellRenderer?.(cell);\n    return r?.getAccessibilityString(cell) ?? \"\";\n};\n\nconst DataGrid: React.ForwardRefRenderFunction<DataGridRef, DataGridProps> = (p, forwardedRef) => {\n    const {\n        width,\n        height,\n        accessibilityHeight,\n        columns,\n        cellXOffset: cellXOffsetReal,\n        cellYOffset,\n        headerHeight,\n        fillHandle = false,\n        groupHeaderHeight,\n        rowHeight,\n        rows,\n        getCellContent,\n        getRowThemeOverride,\n        onHeaderMenuClick,\n        enableGroups,\n        isFilling,\n        onCanvasFocused,\n        onCanvasBlur,\n        isFocused,\n        selection,\n        freezeColumns,\n        onContextMenu,\n        trailingRowType: trailingRowType,\n        fixedShadowX = true,\n        fixedShadowY = true,\n        drawFocusRing = true,\n        onMouseDown,\n        onMouseUp,\n        onMouseMoveRaw,\n        onMouseMove,\n        onItemHovered,\n        dragAndDropState,\n        firstColAccessible,\n        onKeyDown,\n        onKeyUp,\n        highlightRegions,\n        canvasRef,\n        onDragStart,\n        onDragEnd,\n        eventTargetRef,\n        isResizing,\n        isDragging,\n        isDraggable = false,\n        allowResize,\n        disabledRows,\n        getGroupDetails,\n        theme,\n        prelightCells,\n        headerIcons,\n        verticalBorder,\n        drawHeader: drawHeaderCallback,\n        drawCustomCell,\n        onCellFocused,\n        onDragOverCell,\n        onDrop,\n        onDragLeave,\n        imageWindowLoader,\n        smoothScrollX = false,\n        smoothScrollY = false,\n        experimental,\n        getCellRenderer,\n    } = p;\n    const translateX = p.translateX ?? 0;\n    const translateY = p.translateY ?? 0;\n    const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));\n\n    const ref = React.useRef<HTMLCanvasElement | null>(null);\n    const imageWindowLoaderInternal = React.useMemo<ImageWindowLoader>(() => new ImageWindowLoaderImpl(), []);\n    const imageLoader = imageWindowLoader ?? imageWindowLoaderInternal;\n    const damageRegion = React.useRef<readonly Item[] | undefined>();\n    const [scrolling, setScrolling] = React.useState<boolean>(false);\n    const hoverValues = React.useRef<readonly { item: Item; hoverAmount: number }[]>([]);\n    const lastBlitData = React.useRef<BlitData | undefined>();\n    const [hoveredItemInfo, setHoveredItemInfo] = React.useState<[Item, readonly [number, number]] | undefined>();\n    const [hoveredOnEdge, setHoveredOnEdge] = React.useState<boolean>();\n    const overlayRef = React.useRef<HTMLCanvasElement | null>(null);\n\n    const [lastWasTouch, setLastWasTouch] = React.useState(false);\n    const lastWasTouchRef = React.useRef(lastWasTouch);\n    lastWasTouchRef.current = lastWasTouch;\n\n    const spriteManager = React.useMemo(\n        () =>\n            new SpriteManager(headerIcons, () => {\n                lastArgsRef.current = undefined;\n                lastDrawRef.current();\n            }),\n        [headerIcons]\n    );\n    const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;\n\n    const scrollingStopRef = React.useRef(-1);\n    const disableFirefoxRescaling = experimental?.enableFirefoxRescaling !== true;\n    React.useLayoutEffect(() => {\n        if (!browserIsFirefox.value || window.devicePixelRatio === 1 || disableFirefoxRescaling) return;\n        // We don't want to go into scroll mode for a single repaint\n        if (scrollingStopRef.current !== -1) {\n            setScrolling(true);\n        }\n        window.clearTimeout(scrollingStopRef.current);\n        scrollingStopRef.current = window.setTimeout(() => {\n            setScrolling(false);\n            scrollingStopRef.current = -1;\n        }, 200);\n    }, [cellYOffset, cellXOffset, translateX, translateY, disableFirefoxRescaling]);\n\n    const mappedColumns = useMappedColumns(columns, freezeColumns);\n\n    // row: -1 === columnHeader, -2 === groupHeader\n    const getBoundsForItem = React.useCallback(\n        (canvas: HTMLCanvasElement, col: number, row: number): Rectangle | undefined => {\n            const rect = canvas.getBoundingClientRect();\n\n            if (col >= mappedColumns.length || row >= rows) {\n                return undefined;\n            }\n\n            const scale = rect.width / width;\n\n            const result = computeBounds(\n                col,\n                row,\n                width,\n                height,\n                groupHeaderHeight,\n                totalHeaderHeight,\n                cellXOffset,\n                cellYOffset,\n                translateX,\n                translateY,\n                rows,\n                freezeColumns,\n                trailingRowType === \"sticky\",\n                mappedColumns,\n                rowHeight\n            );\n\n            if (scale !== 1) {\n                result.x *= scale;\n                result.y *= scale;\n                result.width *= scale;\n                result.height *= scale;\n            }\n\n            result.x += rect.x;\n            result.y += rect.y;\n\n            return result;\n        },\n        [\n            width,\n            height,\n            groupHeaderHeight,\n            totalHeaderHeight,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            rows,\n            freezeColumns,\n            trailingRowType,\n            mappedColumns,\n            rowHeight,\n        ]\n    );\n\n    const getMouseArgsForPosition = React.useCallback(\n        (canvas: HTMLCanvasElement, posX: number, posY: number, ev?: MouseEvent | TouchEvent): GridMouseEventArgs => {\n            const rect = canvas.getBoundingClientRect();\n            const scale = rect.width / width;\n            const x = (posX - rect.left) / scale;\n            const y = (posY - rect.top) / scale;\n            const edgeDetectionBuffer = 5;\n\n            const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, undefined, translateX);\n\n            let button = 0;\n            if (ev instanceof MouseEvent) {\n                button = ev.button;\n            }\n\n            // -1 === off right edge\n            const col = getColumnIndexForX(x, effectiveCols, translateX);\n\n            // -1: header or above\n            // undefined: offbottom\n            const row = getRowIndexForY(\n                y,\n                height,\n                enableGroups,\n                headerHeight,\n                groupHeaderHeight,\n                rows,\n                rowHeight,\n                cellYOffset,\n                translateY,\n                trailingRowType === \"sticky\"\n            );\n\n            const shiftKey = ev?.shiftKey === true;\n            const ctrlKey = ev?.ctrlKey === true;\n            const metaKey = ev?.metaKey === true;\n            const isTouch = ev !== undefined && !(ev instanceof MouseEvent);\n\n            const edgeSize = 20;\n            const scrollEdge: GridMouseEventArgs[\"scrollEdge\"] = [\n                Math.abs(x) < edgeSize ? -1 : Math.abs(rect.width - x) < edgeSize ? 1 : 0,\n                Math.abs(y) < edgeSize ? -1 : Math.abs(rect.height - y) < edgeSize ? 1 : 0,\n            ];\n\n            let result: GridMouseEventArgs;\n            if (col === -1 || y < 0 || x < 0 || row === undefined || x > width || y > height) {\n                const horizontal = x > width ? -1 : x < 0 ? 1 : 0;\n                const vertical = y > height ? 1 : y < 0 ? -1 : 0;\n\n                let isEdge = false;\n                if (col === -1 && row === -1) {\n                    const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);\n                    assert(b !== undefined);\n                    isEdge = posX < b.x + b.width + edgeDetectionBuffer;\n                }\n\n                result = {\n                    kind: outOfBoundsKind,\n                    location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row ?? rows - 1],\n                    direction: [horizontal, vertical],\n                    shiftKey,\n                    ctrlKey,\n                    metaKey,\n                    isEdge,\n                    isTouch,\n                    button,\n                    scrollEdge,\n                };\n            } else if (row <= -1) {\n                let bounds = getBoundsForItem(canvas, col, row);\n                assert(bounds !== undefined);\n                let isEdge = bounds !== undefined && bounds.x + bounds.width - posX <= edgeDetectionBuffer;\n\n                const previousCol = col - 1;\n                if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {\n                    isEdge = true;\n                    bounds = getBoundsForItem(canvas, previousCol, row);\n                    assert(bounds !== undefined);\n                    result = {\n                        kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,\n                        location: [previousCol, row] as any,\n                        bounds: bounds,\n                        group: mappedColumns[previousCol].group ?? \"\",\n                        isEdge,\n                        shiftKey,\n                        ctrlKey,\n                        metaKey,\n                        isTouch,\n                        localEventX: posX - bounds.x,\n                        localEventY: posY - bounds.y,\n                        button,\n                        scrollEdge,\n                    };\n                } else {\n                    result = {\n                        kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,\n                        group: mappedColumns[col].group ?? \"\",\n                        location: [col, row] as any,\n                        bounds: bounds,\n                        isEdge,\n                        shiftKey,\n                        ctrlKey,\n                        metaKey,\n                        isTouch,\n                        localEventX: posX - bounds.x,\n                        localEventY: posY - bounds.y,\n                        button,\n                        scrollEdge,\n                    };\n                }\n            } else {\n                const bounds = getBoundsForItem(canvas, col, row);\n                assert(bounds !== undefined);\n                const isEdge = bounds !== undefined && bounds.x + bounds.width - posX < edgeDetectionBuffer;\n                const isFillHandle =\n                    fillHandle &&\n                    bounds !== undefined &&\n                    bounds.x + bounds.width - posX < 6 &&\n                    bounds.y + bounds.height - posY < 6;\n                result = {\n                    kind: \"cell\",\n                    location: [col, row],\n                    bounds: bounds,\n                    isEdge,\n                    shiftKey,\n                    ctrlKey,\n                    isFillHandle,\n                    metaKey,\n                    isTouch,\n                    localEventX: posX - bounds.x,\n                    localEventY: posY - bounds.y,\n                    button,\n                    scrollEdge,\n                };\n            }\n            return result;\n        },\n        [\n            mappedColumns,\n            cellXOffset,\n            width,\n            translateX,\n            height,\n            enableGroups,\n            headerHeight,\n            groupHeaderHeight,\n            rows,\n            rowHeight,\n            cellYOffset,\n            translateY,\n            trailingRowType,\n            getBoundsForItem,\n            fillHandle,\n        ]\n    );\n\n    function isSameItem(item: GridMouseEventArgs | undefined, other: GridMouseEventArgs | undefined) {\n        if (item === other) return true;\n        return (\n            item?.kind === other?.kind &&\n            item?.location[0] === other?.location[0] &&\n            item?.location[1] === other?.location[1]\n        );\n    }\n\n    const [hoveredItem] = hoveredItemInfo ?? [];\n\n    const enqueueRef = React.useRef((_item: Item) => {\n        // do nothing\n    });\n    const hoverInfoRef = React.useRef(hoveredItemInfo);\n    hoverInfoRef.current = hoveredItemInfo;\n\n    const [bufferA, bufferB] = React.useMemo(() => {\n        return [document.createElement(\"canvas\"), document.createElement(\"canvas\")];\n    }, []);\n\n    const lastArgsRef = React.useRef<DrawGridArg>();\n    const draw = React.useCallback(() => {\n        const canvas = ref.current;\n        const overlay = overlayRef.current;\n        if (canvas === null || overlay === null) return;\n\n        const last = lastArgsRef.current;\n        const current = {\n            canvas,\n            bufferA,\n            bufferB,\n            headerCanvas: overlay,\n            width,\n            height,\n            cellXOffset,\n            cellYOffset,\n            translateX: Math.round(translateX),\n            translateY: Math.round(translateY),\n            mappedColumns,\n            enableGroups,\n            freezeColumns,\n            dragAndDropState,\n            theme,\n            headerHeight,\n            groupHeaderHeight,\n            disabledRows: disabledRows ?? CompactSelection.empty(),\n            rowHeight,\n            verticalBorder,\n            isResizing,\n            isFocused,\n            selection,\n            fillHandle,\n            lastRowSticky: trailingRowType,\n            rows,\n            drawFocus: drawFocusRing,\n            getCellContent,\n            getGroupDetails: getGroupDetails ?? (name => ({ name })),\n            getRowThemeOverride,\n            drawCustomCell,\n            drawHeaderCallback,\n            prelightCells,\n            highlightRegions,\n            imageLoader,\n            lastBlitData,\n            damage: damageRegion.current,\n            hoverValues: hoverValues.current,\n            hoverInfo: hoverInfoRef.current,\n            spriteManager,\n            scrolling,\n            hyperWrapping: experimental?.hyperWrapping ?? false,\n            touchMode: lastWasTouch,\n            enqueue: enqueueRef.current,\n            renderStrategy: experimental?.renderStrategy ?? (browserIsSafari.value ? \"double-buffer\" : \"single-buffer\"),\n            getCellRenderer,\n        };\n\n        // This confusing bit of code due to some poor design. Long story short, the damage property is only used\n        // with what is effectively the \"last args\" for the last normal draw anyway. We don't want the drawing code\n        // to look at this and go \"shit dawg, nothing changed\" so we force it to draw frash, but the damage restricts\n        // the draw anyway.\n        //\n        // Dear future Jason, I'm sorry. It was expedient, it worked, and had almost zero perf overhead. THe universe\n        // basically made me do it. What choice did I have?\n        if (current.damage === undefined) {\n            lastArgsRef.current = current;\n            drawGrid(current, last);\n        } else {\n            drawGrid(current, undefined);\n        }\n    }, [\n        bufferA,\n        bufferB,\n        width,\n        height,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mappedColumns,\n        enableGroups,\n        freezeColumns,\n        dragAndDropState,\n        theme,\n        headerHeight,\n        groupHeaderHeight,\n        disabledRows,\n        rowHeight,\n        verticalBorder,\n        isResizing,\n        isFocused,\n        selection,\n        fillHandle,\n        trailingRowType,\n        rows,\n        drawFocusRing,\n        getCellContent,\n        getGroupDetails,\n        getRowThemeOverride,\n        drawCustomCell,\n        drawHeaderCallback,\n        prelightCells,\n        highlightRegions,\n        imageLoader,\n        spriteManager,\n        scrolling,\n        experimental?.hyperWrapping,\n        experimental?.renderStrategy,\n        lastWasTouch,\n        getCellRenderer,\n    ]);\n\n    const lastDrawRef = React.useRef(draw);\n    React.useLayoutEffect(() => {\n        draw();\n        lastDrawRef.current = draw;\n    }, [draw]);\n\n    React.useLayoutEffect(() => {\n        const fn = async () => {\n            if (document?.fonts?.ready === undefined) return;\n            await document.fonts.ready;\n            lastArgsRef.current = undefined;\n            lastDrawRef.current();\n        };\n        void fn();\n    }, []);\n\n    const damageInternal = React.useCallback((locations: CellList) => {\n        damageRegion.current = locations;\n        lastDrawRef.current();\n        damageRegion.current = undefined;\n    }, []);\n\n    const enqueue = useAnimationQueue(damageInternal);\n    enqueueRef.current = enqueue;\n\n    const damage = React.useCallback(\n        (cells: DamageUpdateList) => {\n            damageInternal(cells.map(x => x.cell));\n        },\n        [damageInternal]\n    );\n\n    imageLoader.setCallback(damageInternal);\n\n    const [overFill, setOverFill] = React.useState(false);\n\n    const [hCol, hRow] = hoveredItem ?? [];\n    const headerHovered = hCol !== undefined && hRow === -1;\n    const groupHeaderHovered = hCol !== undefined && hRow === -2;\n    let clickableInnerCellHovered = false;\n    let editableBoolHovered = false;\n    let cursorOverride: React.CSSProperties[\"cursor\"] | undefined;\n    if (hCol !== undefined && hRow !== undefined && hRow > -1) {\n        const cell = getCellContent([hCol, hRow]);\n        clickableInnerCellHovered =\n            cell.kind === InnerGridCellKind.NewRow ||\n            (cell.kind === InnerGridCellKind.Marker && cell.markerKind !== \"number\");\n        editableBoolHovered = cell.kind === GridCellKind.Boolean && booleanCellIsEditable(cell);\n        cursorOverride = cell.cursor;\n    }\n    const canDrag = hoveredOnEdge ?? false;\n    const cursor = isDragging\n        ? \"grabbing\"\n        : canDrag || isResizing\n        ? \"col-resize\"\n        : overFill || isFilling\n        ? \"crosshair\"\n        : cursorOverride !== undefined\n        ? cursorOverride\n        : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered\n        ? \"pointer\"\n        : \"default\";\n    const style = React.useMemo(\n        () => ({\n            // width,\n            // height,\n            contain: \"strict\",\n            display: \"block\",\n            cursor,\n        }),\n        [cursor]\n    );\n\n    const lastSetCursor = React.useRef<typeof cursor>(\"default\");\n    const target = eventTargetRef?.current;\n    if (target !== null && target !== undefined && lastSetCursor.current !== style.cursor) {\n        // because we have an event target we need to set its cursor instead.\n        target.style.cursor = lastSetCursor.current = style.cursor;\n    }\n\n    const groupHeaderActionForEvent = React.useCallback(\n        (group: string, bounds: Rectangle, localEventX: number, localEventY: number) => {\n            if (getGroupDetails === undefined) return undefined;\n            const groupDesc = getGroupDetails(group);\n            if (groupDesc.actions !== undefined) {\n                const boxes = getActionBoundsForGroup(bounds, groupDesc.actions);\n                for (const [i, box] of boxes.entries()) {\n                    if (pointInRect(box, localEventX + bounds.x, localEventY + box.y)) {\n                        return groupDesc.actions[i];\n                    }\n                }\n            }\n            return undefined;\n        },\n        [getGroupDetails]\n    );\n\n    const isOverHeaderMenu = React.useCallback(\n        (canvas: HTMLCanvasElement, col: number, clientX: number, clientY: number) => {\n            const header = columns[col];\n\n            if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge ?? false)) {\n                const headerBounds = getBoundsForItem(canvas, col, -1);\n                assert(headerBounds !== undefined);\n                const menuBounds = getHeaderMenuBounds(\n                    headerBounds.x,\n                    headerBounds.y,\n                    headerBounds.width,\n                    headerBounds.height\n                );\n                if (\n                    clientX > menuBounds.x &&\n                    clientX < menuBounds.x + menuBounds.width &&\n                    clientY > menuBounds.y &&\n                    clientY < menuBounds.y + menuBounds.height\n                ) {\n                    return headerBounds;\n                }\n            }\n            return undefined;\n        },\n        [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]\n    );\n\n    const downTime = React.useRef(0);\n    const downPosition = React.useRef<Item>();\n    const onMouseDownImpl = React.useCallback(\n        (ev: MouseEvent | TouchEvent) => {\n            const canvas = ref.current;\n            const eventTarget = eventTargetRef?.current;\n            if (canvas === null || (ev.target !== canvas && ev.target !== eventTarget)) return;\n\n            let clientX: number;\n            let clientY: number;\n            if (ev instanceof MouseEvent) {\n                clientX = ev.clientX;\n                clientY = ev.clientY;\n            } else {\n                clientX = ev.touches[0].clientX;\n                clientY = ev.touches[0].clientY;\n            }\n            if (ev.target === eventTarget && eventTarget !== null) {\n                const bounds = eventTarget.getBoundingClientRect();\n                if (clientX > bounds.left + eventTarget.clientWidth) return;\n                if (clientY > bounds.top + eventTarget.clientHeight) return;\n            }\n\n            const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);\n            downPosition.current = args.location;\n\n            if (args.isTouch) {\n                downTime.current = Date.now();\n            }\n            if (lastWasTouchRef.current !== args.isTouch) {\n                setLastWasTouch(args.isTouch);\n            }\n\n            if (\n                args.kind === headerKind &&\n                isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== undefined\n            ) {\n                return;\n            } else if (args.kind === groupHeaderKind) {\n                const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);\n                if (action !== undefined) {\n                    return;\n                }\n            }\n\n            onMouseDown?.(args);\n            if (!args.isTouch && isDraggable !== true && isDraggable !== args.kind) {\n                // preventing default in touch events stops scroll\n                ev.preventDefault();\n            }\n        },\n        [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]\n    );\n    useEventListener(\"touchstart\", onMouseDownImpl, window, false);\n    useEventListener(\"mousedown\", onMouseDownImpl, window, false);\n\n    const onMouseUpImpl = React.useCallback(\n        (ev: MouseEvent | TouchEvent) => {\n            const canvas = ref.current;\n            if (onMouseUp === undefined || canvas === null) return;\n            const eventTarget = eventTargetRef?.current;\n\n            const isOutside = ev.target !== canvas && ev.target !== eventTarget;\n\n            let clientX: number;\n            let clientY: number;\n            if (ev instanceof MouseEvent) {\n                clientX = ev.clientX;\n                clientY = ev.clientY;\n            } else {\n                clientX = ev.changedTouches[0].clientX;\n                clientY = ev.changedTouches[0].clientY;\n            }\n\n            let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);\n\n            if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {\n                args = {\n                    ...args,\n                    isLongTouch: true,\n                };\n            }\n\n            if (lastWasTouchRef.current !== args.isTouch) {\n                setLastWasTouch(args.isTouch);\n            }\n\n            if (!isOutside && ev.cancelable) {\n                ev.preventDefault();\n            }\n\n            if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY)) {\n                const [col] = args.location;\n                const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);\n                if (headerBounds !== undefined) {\n                    if (args.button === 0 && downPosition.current?.[0] === col && downPosition.current?.[1] === -1) {\n                        onHeaderMenuClick?.(col, headerBounds);\n                    } else {\n                        // force outside so that click will not process\n                        onMouseUp(args, true);\n                    }\n                    return;\n                }\n            } else if (args.kind === groupHeaderKind) {\n                const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);\n                if (action !== undefined) {\n                    if (args.button === 0) {\n                        action.onClick(args);\n                    }\n                    return;\n                }\n            }\n\n            onMouseUp(args, isOutside);\n        },\n        [\n            onMouseUp,\n            eventTargetRef,\n            getMouseArgsForPosition,\n            isOverHeaderMenu,\n            onHeaderMenuClick,\n            groupHeaderActionForEvent,\n        ]\n    );\n    useEventListener(\"mouseup\", onMouseUpImpl, window, false);\n    useEventListener(\"touchend\", onMouseUpImpl, window, false);\n\n    const onContextMenuImpl = React.useCallback(\n        (ev: MouseEvent) => {\n            const canvas = ref.current;\n            if (canvas === null || onContextMenu === undefined) return;\n            const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);\n            onContextMenu(args, () => {\n                if (ev.cancelable) ev.preventDefault();\n            });\n        },\n        [getMouseArgsForPosition, onContextMenu]\n    );\n    useEventListener(\"contextmenu\", onContextMenuImpl, eventTargetRef?.current ?? null, false);\n\n    const onAnimationFrame = React.useCallback<StepCallback>(values => {\n        damageRegion.current = values.map(x => x.item);\n        hoverValues.current = values;\n        lastDrawRef.current();\n        damageRegion.current = undefined;\n    }, []);\n\n    const animManagerValue = React.useMemo(() => new AnimationManager(onAnimationFrame), [onAnimationFrame]);\n    const animationManager = React.useRef(animManagerValue);\n    animationManager.current = animManagerValue;\n    React.useLayoutEffect(() => {\n        const am = animationManager.current;\n        if (hoveredItem === undefined || hoveredItem[1] < 0) {\n            am.setHovered(hoveredItem);\n            return;\n        }\n        const cell = getCellContent(hoveredItem as [number, number]);\n        const r = getCellRenderer(cell);\n        am.setHovered(\n            (r === undefined && cell.kind === GridCellKind.Custom) || r?.needsHover === true ? hoveredItem : undefined\n        );\n    }, [getCellContent, getCellRenderer, hoveredItem]);\n\n    const hoveredRef = React.useRef<GridMouseEventArgs>();\n    const onMouseMoveImpl = React.useCallback(\n        (ev: MouseEvent) => {\n            const canvas = ref.current;\n            if (canvas === null) return;\n\n            const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);\n            if (!isSameItem(args, hoveredRef.current)) {\n                onItemHovered?.(args);\n                setHoveredItemInfo(\n                    args.kind === outOfBoundsKind ? undefined : [args.location, [args.localEventX, args.localEventY]]\n                );\n                hoveredRef.current = args;\n            } else if (args.kind === \"cell\" || args.kind === headerKind || args.kind === groupHeaderKind) {\n                const newInfo: typeof hoverInfoRef.current = [args.location, [args.localEventX, args.localEventY]];\n                setHoveredItemInfo(newInfo);\n                hoverInfoRef.current = newInfo;\n\n                if (args.kind === \"cell\") {\n                    const toCheck = getCellContent(args.location);\n                    if (toCheck.kind === GridCellKind.Custom || getCellRenderer(toCheck)?.needsHoverPosition === true) {\n                        damageInternal([args.location]);\n                    }\n                } else if (args.kind === groupHeaderKind) {\n                    damageInternal([args.location]);\n                }\n            }\n\n            setHoveredOnEdge(args.kind === headerKind && args.isEdge && allowResize === true);\n\n            if (fillHandle && selection.current !== undefined) {\n                const [col, row] = selection.current.cell;\n                const sb = getBoundsForItem(canvas, col, row);\n                const x = ev.clientX;\n                const y = ev.clientY;\n                assert(sb !== undefined);\n                setOverFill(\n                    x >= sb.x + sb.width - 6 &&\n                        x <= sb.x + sb.width &&\n                        y >= sb.y + sb.height - 6 &&\n                        y <= sb.y + sb.height\n                );\n            } else {\n                setOverFill(false);\n            }\n\n            onMouseMoveRaw?.(ev);\n            onMouseMove(args);\n        },\n        [\n            getMouseArgsForPosition,\n            allowResize,\n            fillHandle,\n            selection,\n            onMouseMoveRaw,\n            onMouseMove,\n            onItemHovered,\n            getCellContent,\n            getCellRenderer,\n            damageInternal,\n            getBoundsForItem,\n        ]\n    );\n    useEventListener(\"mousemove\", onMouseMoveImpl, window, true);\n\n    const onKeyDownImpl = React.useCallback(\n        (event: React.KeyboardEvent<HTMLCanvasElement>) => {\n            const canvas = ref.current;\n            if (canvas === null) return;\n\n            let bounds: Rectangle | undefined;\n            if (selection.current !== undefined) {\n                bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);\n            }\n\n            onKeyDown?.({\n                bounds,\n                stopPropagation: () => event.stopPropagation(),\n                preventDefault: () => event.preventDefault(),\n                cancel: () => undefined,\n                ctrlKey: event.ctrlKey,\n                metaKey: event.metaKey,\n                shiftKey: event.shiftKey,\n                altKey: event.altKey,\n                key: event.key,\n                keyCode: event.keyCode,\n                rawEvent: event,\n            });\n        },\n        [onKeyDown, selection, getBoundsForItem]\n    );\n\n    const onKeyUpImpl = React.useCallback(\n        (event: React.KeyboardEvent<HTMLCanvasElement>) => {\n            const canvas = ref.current;\n            if (canvas === null) return;\n\n            let bounds: Rectangle | undefined;\n            if (selection.current !== undefined) {\n                bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);\n            }\n\n            onKeyUp?.({\n                bounds,\n                stopPropagation: () => event.stopPropagation(),\n                preventDefault: () => event.preventDefault(),\n                cancel: () => undefined,\n                ctrlKey: event.ctrlKey,\n                metaKey: event.metaKey,\n                shiftKey: event.shiftKey,\n                altKey: event.altKey,\n                key: event.key,\n                keyCode: event.keyCode,\n                rawEvent: event,\n            });\n        },\n        [onKeyUp, selection, getBoundsForItem]\n    );\n\n    const refImpl = React.useCallback(\n        (instance: HTMLCanvasElement | null) => {\n            ref.current = instance;\n            if (canvasRef !== undefined) {\n                canvasRef.current = instance;\n            }\n        },\n        [canvasRef]\n    );\n\n    const onDragStartImpl = React.useCallback(\n        (event: DragEvent) => {\n            const canvas = ref.current;\n            if (canvas === null || isDraggable === false || isResizing) {\n                event.preventDefault();\n                return;\n            }\n\n            let dragMime: string | undefined;\n            let dragData: string | undefined;\n\n            const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n\n            if (isDraggable !== true && args.kind !== isDraggable) {\n                event.preventDefault();\n                return;\n            }\n\n            const setData = (mime: string, payload: string) => {\n                dragMime = mime;\n                dragData = payload;\n            };\n\n            let dragImage: Element | undefined;\n            let dragImageX: number | undefined;\n            let dragImageY: number | undefined;\n            const setDragImage = (image: Element, x: number, y: number) => {\n                dragImage = image;\n                dragImageX = x;\n                dragImageY = y;\n            };\n\n            let prevented = false;\n\n            onDragStart?.({\n                ...args,\n                setData,\n                setDragImage,\n                preventDefault: () => (prevented = true),\n                defaultPrevented: () => prevented,\n            });\n            if (!prevented && dragMime !== undefined && dragData !== undefined && event.dataTransfer !== null) {\n                event.dataTransfer.setData(dragMime, dragData);\n                event.dataTransfer.effectAllowed = \"copyLink\";\n\n                if (dragImage !== undefined && dragImageX !== undefined && dragImageY !== undefined) {\n                    event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);\n                } else {\n                    const [col, row] = args.location;\n                    if (row !== undefined) {\n                        const offscreen = document.createElement(\"canvas\");\n                        const boundsForDragTarget = getBoundsForItem(canvas, col, row);\n\n                        assert(boundsForDragTarget !== undefined);\n                        offscreen.width = boundsForDragTarget.width;\n                        offscreen.height = boundsForDragTarget.height;\n\n                        const ctx = offscreen.getContext(\"2d\");\n                        if (ctx !== null) {\n                            ctx.textBaseline = \"middle\";\n                            if (row === -1) {\n                                ctx.font = `${theme.headerFontStyle} ${theme.fontFamily}`;\n                                ctx.fillStyle = theme.bgHeader;\n                                ctx.fillRect(0, 0, offscreen.width, offscreen.height);\n                                drawHeader(\n                                    ctx,\n                                    0,\n                                    0,\n                                    boundsForDragTarget.width,\n                                    boundsForDragTarget.height,\n                                    mappedColumns[col],\n                                    false,\n                                    theme,\n                                    false,\n                                    false,\n                                    0,\n                                    spriteManager,\n                                    drawHeaderCallback,\n                                    false\n                                );\n                            } else {\n                                ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n                                ctx.fillStyle = theme.bgCell;\n                                ctx.fillRect(0, 0, offscreen.width, offscreen.height);\n                                drawCell(\n                                    ctx,\n                                    row,\n                                    getCellContent([col, row]),\n                                    0,\n                                    0,\n                                    0,\n                                    boundsForDragTarget.width,\n                                    boundsForDragTarget.height,\n                                    false,\n                                    theme,\n                                    drawCustomCell,\n                                    imageLoader,\n                                    spriteManager,\n                                    1,\n                                    undefined,\n                                    false,\n                                    0,\n                                    undefined,\n                                    undefined,\n                                    getCellRenderer\n                                );\n                            }\n                        }\n\n                        offscreen.style.left = \"-100%\";\n                        offscreen.style.position = \"absolute\";\n\n                        document.body.append(offscreen);\n\n                        event.dataTransfer.setDragImage(\n                            offscreen,\n                            boundsForDragTarget.width / 2,\n                            boundsForDragTarget.height / 2\n                        );\n\n                        window.setTimeout(() => {\n                            offscreen.remove();\n                        }, 0);\n                    }\n                }\n            } else {\n                event.preventDefault();\n            }\n        },\n        [\n            isDraggable,\n            isResizing,\n            getMouseArgsForPosition,\n            onDragStart,\n            getBoundsForItem,\n            theme,\n            mappedColumns,\n            spriteManager,\n            drawHeaderCallback,\n            getCellContent,\n            drawCustomCell,\n            imageLoader,\n            getCellRenderer,\n        ]\n    );\n    useEventListener(\"dragstart\", onDragStartImpl, eventTargetRef?.current ?? null, false, false);\n\n    const activeDropTarget = React.useRef<Item | undefined>();\n\n    const onDragOverImpl = React.useCallback(\n        (event: DragEvent) => {\n            const canvas = ref.current;\n            if (onDrop !== undefined) {\n                // Need to preventDefault to allow drop\n                event.preventDefault();\n            }\n\n            if (canvas === null || onDragOverCell === undefined) {\n                return;\n            }\n\n            const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n\n            const [rawCol, row] = args.location;\n            const col = rawCol - (firstColAccessible ? 0 : 1);\n            const [activeCol, activeRow] = activeDropTarget.current ?? [];\n\n            if (activeCol !== col || activeRow !== row) {\n                activeDropTarget.current = [col, row];\n                onDragOverCell([col, row], event.dataTransfer);\n            }\n        },\n        [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]\n    );\n    useEventListener(\"dragover\", onDragOverImpl, eventTargetRef?.current ?? null, false, false);\n\n    const onDragEndImpl = React.useCallback(() => {\n        activeDropTarget.current = undefined;\n        onDragEnd?.();\n    }, [onDragEnd]);\n    useEventListener(\"dragend\", onDragEndImpl, eventTargetRef?.current ?? null, false, false);\n\n    const onDropImpl = React.useCallback(\n        (event: DragEvent) => {\n            const canvas = ref.current;\n            if (canvas === null || onDrop === undefined) {\n                return;\n            }\n\n            // Default can mess up sometimes.\n            event.preventDefault();\n\n            const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n\n            const [rawCol, row] = args.location;\n            const col = rawCol - (firstColAccessible ? 0 : 1);\n\n            onDrop([col, row], event.dataTransfer);\n        },\n        [firstColAccessible, getMouseArgsForPosition, onDrop]\n    );\n    useEventListener(\"drop\", onDropImpl, eventTargetRef?.current ?? null, false, false);\n\n    const onDragLeaveImpl = React.useCallback(() => {\n        onDragLeave?.();\n    }, [onDragLeave]);\n    useEventListener(\"dragleave\", onDragLeaveImpl, eventTargetRef?.current ?? null, false, false);\n\n    const selectionRef = React.useRef(selection);\n    selectionRef.current = selection;\n    const focusRef = React.useRef<HTMLElement | null>(null);\n    const focusElement = React.useCallback(\n        (el: HTMLElement | null) => {\n            // We don't want to steal the focus if we don't currently own the focus.\n            if (ref.current === null || !ref.current.contains(document.activeElement)) return;\n            if (el === null && selectionRef.current.current !== undefined) {\n                canvasRef?.current?.focus({\n                    preventScroll: true,\n                });\n            } else if (el !== null) {\n                el.focus({\n                    preventScroll: true,\n                });\n            }\n            focusRef.current = el;\n        },\n        [canvasRef]\n    );\n\n    React.useImperativeHandle(\n        forwardedRef,\n        () => ({\n            focus: () => {\n                const el = focusRef.current;\n                // The element in the ref may have been removed however our callback method ref\n                // won't see the removal so bad things happen. Checking to see if the element is\n                // no longer attached is enough to resolve the problem. In the future this\n                // should be replaced with something much more robust.\n                if (el === null || !document.contains(el)) {\n                    canvasRef?.current?.focus({\n                        preventScroll: true,\n                    });\n                } else {\n                    el.focus({\n                        preventScroll: true,\n                    });\n                }\n            },\n            getBounds: (col: number, row?: number) => {\n                if (canvasRef === undefined || canvasRef.current === null) {\n                    return undefined;\n                }\n\n                return getBoundsForItem(canvasRef.current, col, row ?? -1);\n            },\n            damage,\n        }),\n        [canvasRef, damage, getBoundsForItem]\n    );\n\n    const lastFocusedSubdomNode = React.useRef<Item>();\n\n    const accessibilityTree = useDebouncedMemo(\n        () => {\n            if (width < 50) return null;\n            let effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);\n            const colOffset = firstColAccessible ? 0 : -1;\n            if (!firstColAccessible && effectiveCols[0]?.sourceIndex === 0) {\n                effectiveCols = effectiveCols.slice(1);\n            }\n\n            const [fCol, fRow] = selection.current?.cell ?? [];\n            const range = selection.current?.range;\n\n            const visibleCols = effectiveCols.map(c => c.sourceIndex);\n            const visibleRows = makeRange(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));\n\n            // Maintain focus within grid if we own it but focused cell is outside visible viewport\n            // and not rendered.\n            if (\n                fCol !== undefined &&\n                fRow !== undefined &&\n                !(visibleCols.includes(fCol) && visibleRows.includes(fRow))\n            ) {\n                focusElement(null);\n            }\n\n            return (\n                <table\n                    key=\"access-tree\"\n                    role=\"grid\"\n                    aria-rowcount={rows + 1}\n                    aria-multiselectable=\"true\"\n                    aria-colcount={mappedColumns.length + colOffset}>\n                    <thead role=\"rowgroup\">\n                        <tr role=\"row\" aria-rowindex={1}>\n                            {effectiveCols.map(c => (\n                                <th\n                                    role=\"columnheader\"\n                                    aria-selected={selection.columns.hasIndex(c.sourceIndex)}\n                                    aria-colindex={c.sourceIndex + 1 + colOffset}\n                                    tabIndex={-1}\n                                    onFocus={e => {\n                                        if (e.target === focusRef.current) return;\n                                        return onCellFocused?.([c.sourceIndex, -1]);\n                                    }}\n                                    key={c.sourceIndex}>\n                                    {c.title}\n                                </th>\n                            ))}\n                        </tr>\n                    </thead>\n                    <tbody role=\"rowgroup\">\n                        {visibleRows.map(row => (\n                            <tr\n                                role=\"row\"\n                                aria-selected={selection.rows.hasIndex(row)}\n                                key={row}\n                                aria-rowindex={row + 2}>\n                                {effectiveCols.map(c => {\n                                    const col = c.sourceIndex;\n                                    const key = `${col},${row}`;\n                                    const focused = fCol === col && fRow === row;\n                                    const selected =\n                                        range !== undefined &&\n                                        col >= range.x &&\n                                        col < range.x + range.width &&\n                                        row >= range.y &&\n                                        row < range.y + range.height;\n                                    const id = `glide-cell-${col}-${row}`;\n                                    const cellContent = getCellContent([col, row]);\n                                    return (\n                                        <td\n                                            key={key}\n                                            role=\"gridcell\"\n                                            aria-colindex={col + 1 + colOffset}\n                                            aria-selected={selected}\n                                            aria-readonly={\n                                                isInnerOnlyCell(cellContent) || !isReadWriteCell(cellContent)\n                                            }\n                                            id={id}\n                                            data-testid={id}\n                                            onClick={() => {\n                                                const canvas = canvasRef?.current;\n                                                if (canvas === null || canvas === undefined) return;\n                                                return onKeyDown?.({\n                                                    bounds: getBoundsForItem(canvas, col, row),\n                                                    cancel: () => undefined,\n                                                    preventDefault: () => undefined,\n                                                    stopPropagation: () => undefined,\n                                                    ctrlKey: false,\n                                                    key: \"Enter\",\n                                                    keyCode: 13,\n                                                    metaKey: false,\n                                                    shiftKey: false,\n                                                    altKey: false,\n                                                    rawEvent: undefined,\n                                                });\n                                            }}\n                                            onFocusCapture={e => {\n                                                if (\n                                                    e.target === focusRef.current ||\n                                                    (lastFocusedSubdomNode.current?.[0] === col &&\n                                                        lastFocusedSubdomNode.current?.[1] === row)\n                                                )\n                                                    return;\n                                                lastFocusedSubdomNode.current = [col, row];\n                                                return onCellFocused?.([col, row]);\n                                            }}\n                                            ref={focused ? focusElement : undefined}\n                                            tabIndex={-1}>\n                                            {getRowData(cellContent, getCellRenderer)}\n                                        </td>\n                                    );\n                                })}\n                            </tr>\n                        ))}\n                    </tbody>\n                </table>\n            );\n        },\n        [\n            width,\n            mappedColumns,\n            cellXOffset,\n            dragAndDropState,\n            translateX,\n            rows,\n            cellYOffset,\n            accessibilityHeight,\n            selection,\n            focusElement,\n            getCellContent,\n            canvasRef,\n            onKeyDown,\n            getBoundsForItem,\n            onCellFocused,\n        ],\n        200\n    );\n\n    const stickyX = fixedShadowX ? getStickyWidth(mappedColumns, dragAndDropState) : 0;\n    const opacityX =\n        freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : clamp(-translateX / 100, 0, 1);\n\n    const absoluteOffsetY = -cellYOffset * 32 + translateY;\n    const opacityY = !fixedShadowY ? 0 : clamp(-absoluteOffsetY / 100, 0, 1);\n\n    const stickyShadow = React.useMemo(() => {\n        if (!opacityX && !opacityY) {\n            return null;\n        }\n\n        const styleX: React.CSSProperties = {\n            position: \"absolute\",\n            top: 0,\n            left: stickyX,\n            width: width - stickyX,\n            height: height,\n            opacity: opacityX,\n            pointerEvents: \"none\",\n            transition: !smoothScrollX ? \"opacity 0.2s\" : undefined,\n            boxShadow: \"inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)\",\n        };\n\n        const styleY: React.CSSProperties = {\n            position: \"absolute\",\n            top: totalHeaderHeight,\n            left: 0,\n            width: width,\n            height: height,\n            opacity: opacityY,\n            pointerEvents: \"none\",\n            transition: !smoothScrollY ? \"opacity 0.2s\" : undefined,\n            boxShadow: \"inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)\",\n        };\n\n        return (\n            <>\n                {opacityX > 0 && <div id=\"shadow-x\" style={styleX} />}\n                {opacityY > 0 && <div id=\"shadow-y\" style={styleY} />}\n            </>\n        );\n    }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);\n\n    const overlayStyle = React.useMemo<React.CSSProperties>(\n        () => ({\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n        }),\n        []\n    );\n\n    return (\n        <>\n            <canvas\n                data-testid=\"data-grid-canvas\"\n                tabIndex={0}\n                onKeyDown={onKeyDownImpl}\n                onKeyUp={onKeyUpImpl}\n                onFocus={onCanvasFocused}\n                onBlur={onCanvasBlur}\n                ref={refImpl}\n                style={style}>\n                {accessibilityTree}\n            </canvas>\n            <canvas ref={overlayRef} style={overlayStyle} />\n            {stickyShadow}\n        </>\n    );\n};\n\nexport default React.memo(React.forwardRef(DataGrid));\n","import * as React from \"react\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Marked } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const FAQ: React.VFC = () => {\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# FAQ\n\n### Nothing shows up? It crashes when I edit a cell?\n\nPlease read the [Prerequisites section in the docs](https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md).\n\n### Does it work with screen readers and other a11y tools?\n\nYes. Unfortunately none of the primary developers are accessibility users so there are likely flaws in the implementation we are not aware of. Bug reports welcome!\n\n### Does it support my data source?\n\nYes.\n\nData Grid is agnostic about the way you load/store/generate/mutate your data. What it requires is that you tell it which columns you have, how many rows, and to give it a function it can call to get the data for a cell in a specific row and column.\n\n### Does it do sorting?\n\nYes through the [glide-data-grid-source](https://www.npmjs.com/package/@glideapps/glide-data-grid-source) package.\n\n### Does it do search?\n\nYes, built in! There are examples in the storybook.\n\n### Can it filter?\n\nNothing built in yet. It is planned for the \\`glide-data-grid-source\\`.\n\n### Can it do frozen columns?\n\nYes\n\n### Can I render my own cells?\n\nYes\n\n`}\n            </Marked>\n        </DocWrapper>\n    );\n};\n(FAQ as any).storyName = \"00. FAQ\";\n(FAQ as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const GettingStarted: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: false,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const [rowMarkers, setRowMarkers] = React.useState(false);\n    const [smoothScroll, setSmoothScroll] = React.useState(false);\n    const [verticalBorder, setVerticalBorder] = React.useState(true);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Getting Started\n\nGlide data grid is a powerful but flexible library requiring very few concepts required to get started. The grid will need data, columns, and a \\`getCellContent\\` callback to convert our data into cells on demand. Because the callback is used, there is no need to pre-format the data in any particular way, so long as it can be transformed into a cell. This example uses a flat array of objects.`}\n            </Marked>\n            <Highlight>\n                {`\nconst data = [\n    {\n      \"name\": \"Hines Fowler\",\n      \"company\": \"BUZZNESS\",\n      \"email\": \"hinesfowler@buzzness.com\",\n      \"phone\": \"+1 (869) 405-3127\"\n    },\n    ...rest\n]\n`}\n            </Highlight>\n            <Marked>\n                {`\nThe columns of the data grid may contain many options, including icons, menus, theme overrides, however at their most basic they only require a \\`title\\` and an \\`id\\`. The id is technically optional but it is best not to omit it.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    {\n        title: \"Name\",\n        id: \"name\"\n    },\n    {\n        title: \"Company\",\n        id: \"company\"\n    },\n    {\n        title: \"Email\",\n        id: \"email\"\n    },\n    {\n        title: \"Phone\",\n        id: \"phone\"\n    }\n]\n`}\n            </Highlight>\n            <Marked>\n                {`\nEach column will automatically size based on its contents. If desired the sise of each column can be overridden by setting the width parameter.\n\nFinally the data grid requires a cell fetch callback. This callback should be memoized using \\`React.useCallback\\` or be a static function.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const dataRow = data[row];\n    // dumb but simple way to do this\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const d = dataRow[indexes[col]]\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: false,\n        displayData: d,\n        data: d,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n> Avoid excessive changes to the identity of the \\`getCellContent\\` callback as the grid will re-render from scratch every time it changes.\n\nThat is all the basic requirements put together.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />\n            </Wrapper>\n            <Marked>\n                {`\n# Going further\n\nThere is so much more that can be done:\n\n- Header icons\n- Smooth scrolling\n- Header menus\n- Grouping\n- Row markers\n- Freeze Columns\n- Column reordering and resizing\n- Cell spans\n- Search\n- Copy/paste support\n\nHere are a few to play with.`}\n            </Marked>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={rowMarkers} onChange={e => setRowMarkers(e.target.checked)} /> Row\n                Markers\n            </label>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={smoothScroll} onChange={e => setSmoothScroll(e.target.checked)} />{\" \"}\n                Smooth Scroll\n            </label>\n            <label style={{ display: \"block\" }}>\n                <input type=\"checkbox\" checked={verticalBorder} onChange={e => setVerticalBorder(e.target.checked)} />{\" \"}\n                Vertical Borders\n            </label>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    verticalBorder={verticalBorder}\n                    smoothScrollX={smoothScroll}\n                    smoothScrollY={smoothScroll}\n                    rowMarkers={rowMarkers ? \"both\" : \"none\"}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(GettingStarted as any).storyName = \"01. Getting Started\";\n(GettingStarted as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { EditableGridCell, GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst fixedData: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const EditingData: React.VFC = () => {\n    const dataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n        },\n    ]);\n\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = dataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const getFixedContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = fixedData[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {\n        if (newValue.kind !== GridCellKind.Text) {\n            // we only have text cells, might as well just die here.\n            return;\n        }\n\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const [col, row] = cell;\n        const key = indexes[col];\n        dataRef.current[row][key] = newValue.data;\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Editing Data\n\nEditing data is handled via callbacks. Taking the getting started example as a starting point, the \\`getContent\\` callback can be modified to allow editing.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const dataRow = data[row];\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const d = dataRow[indexes[col]];\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        readonly: false,\n        displayData: d,\n        data: d,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n\\`allowOverlay\\` has been set to true. This allows the overlay to come up. For explanatory purposes the \\`readonly\\` field is being set to false. This is the default value, setting it to true would allow the overlay to come up but not allow editing.`}\n            </Marked>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={getFixedContent} columns={columns} rows={dataRef.current.length} />\n            </Wrapper>\n            <Marked>\n                {`\n> You can see the editor now, but the data is not saved.\n\nImplementing the \\`onCellEdited\\` callback allows responding to cell edit events. Edit events pass back a mutated version of the original \\`GridCell\\` returned from \\`getContent\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {\n    if (newValue.kind !== GridCellKind.Text) {\n        // we only have text cells, might as well just die here.\n        return;\n    }\n\n    const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n    const [col, row] = cell;\n    const key = indexes[col];\n    data[row][key] = newValue.data;\n}, []);`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    onCellEdited={onCellEdited}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(EditingData as any).storyName = \"02. Editing Data\";\n(EditingData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumnIcon, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nexport const GridColumns: React.VFC = () => {\n    const basicGetCellContent = React.useCallback((cell: Item): GridCell => {\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: false,\n            displayData: cell.toString(),\n            data: cell.toString(),\n        };\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return [\n            {\n                title: \"First\",\n                width: 150,\n            },\n            {\n                title: \"Second\",\n                width: 150,\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Basic usage\n\n> The \\`GridColumn[]\\` passed to the \\`DataEditor\\` in the \\`columns\\` property should be memoized to avoid excessive re-rendering. These samples may not do this for the sake of brevity.\n\nThere are only two mandatory properties for each \\`GridColumn\\`: \\`title\\` and \\`id\\`. The id should be a stable id and not the index of the column. Additionally a \\`width\\` property can be provided which represents the width of the column in pixels. If a width is provided the id may be omited. This may change in a future version.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"First\", id: \"first\", width: 150 },\n    { title: \"Second\", id: \"second\", width: 150 }\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor getCellContent={basicGetCellContent} columns={cols} rows={50} />\n            </Wrapper>\n\n            <Marked>\n                {`\n# Header icons\n\nDefault header icons are available. They can also be reaplced by passing a new map to the \\`headerIcons\\` property.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"Name\", id: \"name\", width: 250, icon: GridColumnIcon.HeaderString, \n      overlayIcon: GridColumnIcon.RowOwnerOverlay \n    },\n    { title: \"Age\", id: \"age\", width: 100, icon: GridColumnIcon.HeaderNumber },\n    { title: \"Avatar\", id: \"avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={basicGetCellContent}\n                    columns={[\n                        {\n                            title: \"Name\",\n                            width: 250,\n                            icon: GridColumnIcon.HeaderString,\n                            overlayIcon: GridColumnIcon.RowOwnerOverlay,\n                        },\n                        { title: \"Age\", width: 120, icon: GridColumnIcon.HeaderNumber },\n                        { title: \"Avatar\", width: 100, icon: GridColumnIcon.HeaderImage },\n                    ]}\n                    rows={50}\n                />\n            </Wrapper>\n\n            <Marked>\n                {`\n# Header theming\n\nHeaders can be provided with individual theme overrides which themes both the header and its column cells.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns: GridColumn[] = [\n    { title: \"Name\", id=\"name\", width: 250, icon: GridColumnIcon.HeaderString },\n    { title: \"Age\", id=\"age\", width: 100, icon: GridColumnIcon.HeaderNumber, themeOverride: {\n        bgIconHeader: \"#00967d\",\n        textDark: \"#00c5a4\",\n        textHeader: \"#00c5a4\",\n    } },\n    { title: \"Avatar\", id=\"avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n];\n\n<DataEditor {...rest} columns={columns} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={basicGetCellContent}\n                    columns={[\n                        { title: \"Name\", width: 250, icon: GridColumnIcon.HeaderString },\n                        {\n                            title: \"Age\",\n                            width: 100,\n                            icon: GridColumnIcon.HeaderNumber,\n                            themeOverride: {\n                                bgIconHeader: \"#00967d\",\n                                textDark: \"#00c5a4\",\n                                textHeader: \"#00c5a4\",\n                            },\n                        },\n                        { title: \"Avatar\", width: 80, icon: GridColumnIcon.HeaderImage },\n                    ]}\n                    rows={50}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(GridColumns as any).storyName = \"03. Grid Columns\";\n(GridColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor, DataEditorRef } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n    update: number;\n}\n\nexport const StreamingData: React.VFC = () => {\n    const highlightDataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n            update: 0,\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n            update: 0,\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n            update: 0,\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n            update: 0,\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n            update: 0,\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n            update: 0,\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n            update: 0,\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n            update: 0,\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n            update: 0,\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n            update: 0,\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n            update: 0,\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n            update: 0,\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n            update: 0,\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n            update: 0,\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n            update: 0,\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n            update: 0,\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n            update: 0,\n        },\n    ]);\n\n    const dataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n            update: 0,\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n            update: 0,\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n            update: 0,\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n            update: 0,\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n            update: 0,\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n            update: 0,\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n            update: 0,\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n            update: 0,\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n            update: 0,\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n            update: 0,\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n            update: 0,\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n            update: 0,\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n            update: 0,\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n            update: 0,\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n            update: 0,\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n            update: 0,\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n            update: 0,\n        },\n    ]);\n\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = dataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d as string,\n            data: d as string,\n        };\n    }, []);\n\n    const getContentHighlighted = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = highlightDataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d as string,\n            data: d as string,\n            lastUpdated: dataRow.update,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const ref = React.useRef<DataEditorRef | null>(null);\n\n    const onButtonClick = () => {\n        // Swap the emails of 2 random people\n        const randomRow1 = Math.floor(Math.random() * dataRef.current.length);\n        const randomRow2 = Math.floor(Math.random() * dataRef.current.length);\n\n        const temp = dataRef.current[randomRow1].email;\n        dataRef.current[randomRow1].email = dataRef.current[randomRow2].email;\n        dataRef.current[randomRow2].email = temp;\n\n        ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r] })));\n    };\n\n    const onHighlightButtonClick = () => {\n        // Swap the emails of 2 random people\n        const randomRow1 = Math.floor(Math.random() * highlightDataRef.current.length);\n        const randomRow2 = Math.floor(Math.random() * highlightDataRef.current.length);\n\n        const temp = highlightDataRef.current[randomRow1].email;\n        highlightDataRef.current[randomRow1].email = highlightDataRef.current[randomRow2].email;\n        highlightDataRef.current[randomRow2].email = temp;\n\n        highlightDataRef.current[randomRow1].update = performance.now();\n        highlightDataRef.current[randomRow2].update = performance.now();\n\n        ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r] })));\n    };\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Streaming Data\n\n> Glide Data Grid is capable of streaming hundreds of thousands of updates per second. You won't need that, but every millisecond the grid doesn't take is another millisecond your app has to process data and remain responsive.\n\nStreaming data is done as a two step process.\n\n1. Update the data backing store.\n2. Inform the Glide Data Grid of the changed data.\n\nThe Grid does not care of the data is coming down over the wire or being generated locally. Informing the grid of changes to the data is done by calling the \\`updateCells\\` function on a bound ref.`}\n            </Marked>\n            <Highlight>\n                {`\nconst ref = React.useRef<DataEditorRef | null>(null);\n\nreturn <DataEditor {...rest} ref={ref} />\n`}\n            </Highlight>\n            <Marked>\n                {`\nData can now be updated by calling mutating the backing store and using the ref to update cells.`}\n            </Marked>\n            <Highlight>\n                {`\nconst onButtonClick = () => {\n    // Swap the emails of 2 random people\n    const randomRow1 = Math.floor(Math.random()*data.length);\n    const randomRow2 = Math.floor(Math.random()*data.length);\n\n    const temp = data[randomRow1].email;\n    data[randomRow1].email = data[randomRow2].email;\n    data[randomRow2].email = temp;\n\n    ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r]})));\n}\n`}\n            </Highlight>\n            <button onClick={onButtonClick}>Swappy Swappy</button>\n            <Wrapper height={400}>\n                <DataEditor ref={ref} getCellContent={getContent} columns={columns} rows={dataRef.current.length} />\n            </Wrapper>\n            <Marked>\n                {`\n## Showing updates\n        \nIf \\`getContent\\` is updated to also return the last time a cell was updated the data grid will highlight cells as they update.`}\n            </Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    const [col, row] = cell;\n    const data = fetchDataFromBackend(col, row);\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        displayData: data.value,\n        data: data.value,\n        lastUpdated: data.updatedAt,\n    };\n}, []);\n`}\n            </Highlight>\n            <Marked>\n                {`\n> Note that timestamps are based on performance.now() and not Date.now(). This is to ensure that timestamps always increase monotonically and nothing weird will happen if the clock adjusts.`}\n            </Marked>\n            <button style={{ marginTop: 16 }} onClick={onHighlightButtonClick}>\n                Swapity Swap Swap\n            </button>\n            <Wrapper height={600}>\n                <DataEditor\n                    ref={ref}\n                    getCellContent={getContentHighlighted}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(StreamingData as any).storyName = \"04. Streaming Data\";\n(StreamingData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { EditableGridCell, GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nexport const CopyPaste: React.VFC = () => {\n    const dataRef = React.useRef([\n        {\n            name: \"Deidre Morris\",\n            company: \"GONKLE\",\n            email: \"deidremorris@gonkle.com\",\n            phone: \"+1 (867) 507-3332\",\n        },\n        {\n            name: \"Sheryl Craig\",\n            company: \"EVENTAGE\",\n            email: \"sherylcraig@eventage.com\",\n            phone: \"+1 (869) 520-2227\",\n        },\n        {\n            name: \"Lidia Bowers\",\n            company: \"ANOCHA\",\n            email: \"lidiabowers@anocha.com\",\n            phone: \"+1 (808) 414-3826\",\n        },\n        {\n            name: \"Jones Norton\",\n            company: \"REPETWIRE\",\n            email: \"jonesnorton@repetwire.com\",\n            phone: \"+1 (875) 582-3320\",\n        },\n        {\n            name: \"Lula Bruce\",\n            company: \"COMDOM\",\n            email: \"lulabruce@comdom.com\",\n            phone: \"+1 (873) 452-2472\",\n        },\n        {\n            name: \"Larsen Montgomery\",\n            company: \"SQUISH\",\n            email: \"larsenmontgomery@squish.com\",\n            phone: \"+1 (893) 482-3651\",\n        },\n        {\n            name: \"Becky Bright\",\n            company: \"COMCUR\",\n            email: \"beckybright@comcur.com\",\n            phone: \"+1 (879) 494-2331\",\n        },\n        {\n            name: \"Charlotte Rowland\",\n            company: \"FROLIX\",\n            email: \"charlotterowland@frolix.com\",\n            phone: \"+1 (861) 439-2134\",\n        },\n        {\n            name: \"Sonya Hensley\",\n            company: \"GEEKETRON\",\n            email: \"sonyahensley@geeketron.com\",\n            phone: \"+1 (802) 553-2194\",\n        },\n        {\n            name: \"Stephenson Guthrie\",\n            company: \"EXOSWITCH\",\n            email: \"stephensonguthrie@exoswitch.com\",\n            phone: \"+1 (903) 449-3271\",\n        },\n        {\n            name: \"Mcmillan Cline\",\n            company: \"TURNLING\",\n            email: \"mcmillancline@turnling.com\",\n            phone: \"+1 (982) 496-2454\",\n        },\n        {\n            name: \"Kemp Davis\",\n            company: \"TETRATREX\",\n            email: \"kempdavis@tetratrex.com\",\n            phone: \"+1 (859) 594-2982\",\n        },\n        {\n            name: \"Matilda Levy\",\n            company: \"SLOFAST\",\n            email: \"matildalevy@slofast.com\",\n            phone: \"+1 (841) 521-2444\",\n        },\n        {\n            name: \"Hattie Simpson\",\n            company: \"COMTRAK\",\n            email: \"hattiesimpson@comtrak.com\",\n            phone: \"+1 (962) 587-3805\",\n        },\n        {\n            name: \"Kinney Munoz\",\n            company: \"IDETICA\",\n            email: \"kinneymunoz@idetica.com\",\n            phone: \"+1 (921) 513-2012\",\n        },\n        {\n            name: \"Lambert Raymond\",\n            company: \"TURNABOUT\",\n            email: \"lambertraymond@turnabout.com\",\n            phone: \"+1 (919) 519-2442\",\n        },\n        {\n            name: \"Bryant Dunlap\",\n            company: \"BYTREX\",\n            email: \"bryantdunlap@bytrex.com\",\n            phone: \"+1 (872) 583-2883\",\n        },\n    ]);\n\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = dataRef.current[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d as string,\n            data: d as string,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {\n        if (newValue.kind !== GridCellKind.Text) {\n            // we only have text cells, might as well just die here.\n            return;\n        }\n\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const [col, row] = cell;\n        const key = indexes[col];\n        dataRef.current[row][key] = newValue.data;\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Copy Paste\n\nCopy and Paste support is built in to Glide Data Grid. It is not enabled by default to ensure developers are expecting its behavior.\n\n## Copy\n\nBy default copy is not enabled, to enabled copy implement the \\`getCellsForSelection\\` callback. The callback returns results as row-major ordering.\n\n> \\`getCellsForSelection\\` is used instead of \\`getCellContent\\` to allow optimization when fetching large amounts of data outside of the visible region.\n\nThis example uses the built in generic function which simply calls \\`getContent\\`, which is inefficient but fine for a local data source.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor {...rest} getCellsForSelection={true} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n            <textarea\n                style={{ padding: 12, width: \"100%\", height: \"200px\", borderRadius: 9 }}\n                placeholder=\"Highlight some stuff up there and paste it here\"\n            />\n            <Marked>\n                {`\nImplementations may wish to use far more efficient mechanisms for fetching data.\n\n## Paste\n\nThe easiest way to enable paste is to set \\`onPaste\\` to true when \\`onCellEdited\\` is already working. The Glide Data Grid will automatically parse the paste buffer and send cell update events.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor {...rest} onCellEdited={onCellEdited} onPaste={true} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    onCellEdited={onCellEdited}\n                    getCellsForSelection={true}\n                    onPaste={true}\n                    columns={columns}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n            <Marked>{`Try copying this.`}</Marked>\n            <textarea\n                style={{ padding: 12, width: \"100%\", height: \"80px\", borderRadius: 9 }}\n                value=\"Sheryl Craig\tEVENTAGE\tsherylcraig@eventage.com\nLidia Bowers\tANOCHA\tlidiabowers@anocha.com\nJones Norton\tREPETWIRE\tjonesnorton@repetwire.com\"\n            />\n            <Marked>\n                {`\nIf desired paste events can be handled manually. Passing a callback to \\`onPaste\\` will instead receive a parsed verison of the pasted data. Returning \\`true\\` from the callback will cause the paste event to be handled the same as before, emitting \\`onCellEdited\\`. Returning \\`false\\` will prevent the edit callback from being emitted.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor\n    {...rest}\n    onCellEdited={onCellEdited}\n    onPaste={(target, value) => {\n        window.alert(JSON.stringify({ target, value }));\n        return false;\n    }}\n/>\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    onCellEdited={onCellEdited}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    onPaste={(target, value) => {\n                        window.alert(JSON.stringify({ target, value }));\n                        return false;\n                    }}\n                    rows={dataRef.current.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(CopyPaste as any).storyName = \"05. Copy/Paste Support\";\n(CopyPaste as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Search: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const [showSearch, setShowSearch] = React.useState(false);\n    const onSearchClose = React.useCallback(() => setShowSearch(false), []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Search\n\nSearch is a controlled property in Glide Data Grid. Triggering the search interface is up to the application but once triggered search is handled interally on the data grid. Search always depends on a properly implemented \\`getCellsForSelection\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst [showSearch, setShowSearch] = React.useState(false);\nconst onSearchClose = React.useCallback(() => setShowSearch(false), []);\n\nreturn <DataEditor {...rest} showSearch={showSearch} getCellsForSelection={true} onSearchClose={onSearchClose}  />\n`}\n            </Highlight>\n            <button onClick={() => setShowSearch(true)}>Show Search</button>\n            <Wrapper height={200}>\n                <DataEditor\n                    showSearch={showSearch}\n                    onSearchClose={onSearchClose}\n                    getCellContent={getContent}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>\n                {`\n# Automatic Search\n\nSearch can also be handled by the data grid automatically if you enable the search keybinding.`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor {...rest} keybindings={{search: true}} getCellsForSelection={true}  />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    keybindings={{ search: true }}\n                    getCellContent={getContent}\n                    getCellsForSelection={true}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Search as any).storyName = \"06. Search\";\n(Search as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const ColumnGrouping: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n                group: \"Core\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n                group: \"Core\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n                group: \"Extra\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n                group: \"Extra\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Column Grouping\n\nColumns can be grouped by assinging them a group. Easy peasy.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n            group: \"Core\",\n        },\n        {\n            title: \"Company\",\n            id: \"company\",\n            group: \"Core\",\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n            group: \"Extra\",\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n            group: \"Extra\",\n        },\n    ];\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={500}>\n                <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(ColumnGrouping as any).storyName = \"07. Column Grouping\";\n(ColumnGrouping as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\nimport type { Theme } from \"../common/styles\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Theming: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const getContentThemed = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n\n        let theme: Partial<Theme> | undefined = undefined;\n\n        if (col === 1 && row === 1) {\n            theme = {\n                textDark: \"#FF0000\",\n            };\n        }\n\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n            themeOverride: theme,\n        };\n    }, []);\n\n    const getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {\n        if (row % 2 === 0) {\n            return {\n                bgCell: \"#F9FDFF\",\n            };\n        }\n        return undefined;\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    const themeColumns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n            },\n            {\n                title: \"Company\",\n                themeOverride: {\n                    textDark: \"#225588\",\n                    baseFontStyle: \"600 13px\",\n                },\n                id: \"company\",\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n            },\n        ];\n    }, []);\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Theming\n\nTheming the Glide Data Grid is a cascaded through 5 levels\n\n0. Default theme\n1. Global\n2. Group\n3. Column\n4. Row\n5. Cell\n\nAt each level parts of the theme can be overridden. This example will pro\n\n## Global Theming\n\nThe global theme is provided by the DataEditor by default and can be overriden by setting the \\`theme\\` prop. All themes contain the following properties.\n\n| Property | CSS Variable | Type | Description |\n|---|---|---|----|\n| accentColor | --gdg-accent-color | string | The primary accent color of the grid. This will show up in focus rings and selected rows/headers. |\n| accentFg | --gdg-accent-fg | string | A foreground color which works well on top of the accent color. |\n| accentLight | --gdg-accent-light | string | A lighter version of the accent color used to hint selection. |\n| textDark | --gdg-text-dark | string | The standard text color. |\n| textMedium | --gdg-text-medium | string | A lighter text color used for non-editable data in some cases. |\n| textLight | --gdg-text-light | string | An even lighter text color |\n| textBubble | --gdg-text-bubble | string | The text color used in bubbles |\n| bgIconHeader | --gdg-bg-icon-header | string | The background color for header icons |\n| fgIconHeader | --gdg-fg-icon-header | string | The foreground color for header icons |\n| textHeader | --gdg-text-header | string | The header text color |\n| textGroupHeader | --gdg-text-group-header | string \\\\| undefined | The group header text color, if none provided the \\`textHeader\\` is used instead. |\n| textHeaderSelected | --gdg-text-header-selected | string | The text color used for selected headers |\n| bgCell | --gdg-bg-cell | string | The primary background color of the data grid. |\n| bgCellMedium | --gdg-bg-cell-medium | string | Used for disabled or otherwise off colored cells. |\n| bgHeader | --gdg-bg-header | string | The header background color |\n| bgHeaderHasFocus | --gdg-bg-header-has | string | The header background color when its column contains the selected cell |\n| bgHeaderHovered | --gdg-bg-header-hovered | string | The header background color when it is hovered |\n| bgBubble | --gdg-bg-bubble | string | The background color used in bubbles |\n| bgBubbleSelected | --gdg-bg-bubble-selected | string | The background color used in bubbles when the cell is selected |\n| bgSearchResult | --gdg-bg-search-result | string | The background color used for cells which match the search string |\n| borderColor | --gdg-border-color | string | The color of all vertical borders and horizontal borders if a horizontal override is not provided |\n| horizontalBorderColor | --gdg-horizontal-border-color | string \\\\| undefined | The horizontal border color override |\n| drilldownBorder | --gdg-drilldown-border | string | The ring color of a drilldown cell |\n| linkColor | --gdg-link-color | string | What color to render links |\n| cellHorizontalPadding | --gdg-cell-horizontal-padding | number | The internal horizontal padding size of a cell. |\n| cellVerticalPadding | --gdg-cell-vertical-padding | number | The internal vertical padding size of a cell. |\n| headerFontStyle | --gdg-header-font-style | string | The font style of the header. e.g. \\`bold 15px\\` |\n| baseFontStyle | --gdg-base-font-style | string | The font style used for cells by default, e.g. \\`13px\\` |\n| fontFamily | --gdg-font-family | string | The font family used by the data grid. |\n| editorFontSize | --gdg-editor-font-size | string | The font size used by overlay editors. |\n| lineHeight | None | number | A unitless scaler which defines the height of a line of text relative to the ink size. |\n\nIf an option is missing from any theme it will be filled in with the default theme.\n`}\n            </Marked>\n            <Highlight>\n                {`\nreturn <DataEditor \n        theme={{\n          bgCell: \"#F2F9FF\"\n        }} \n        getCellContent={getContent} columns={columns} rows={data.length} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>\n                {`### Column themes\nThemes can be applied at the column level as well by setting the \\`themeOverride\\` on the \\`GridColumn\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n        },\n        {\n            title: \"Company\",\n            themeOverride: {\n                textDark: \"#225588\",\n                baseFontStyle: \"600 13px\",\n            },\n            id: \"company\",\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n        },\n    ];\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getCellContent={getContent}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>{`### Row themes`}</Marked>\n            <Highlight>\n                {`\nconst getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {\n    if (row % 2 === 0) {\n        return {\n            bgCell: \"#F9FDFF\"\n        }\n    }\n    return undefined;\n}, []);\n\nreturn <DataEditor {...rest} getRowThemeOverride={getRowThemeOverride} />\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getRowThemeOverride={getRowThemeOverride}\n                    getCellContent={getContent}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n            <Marked>{`### Cell themes`}</Marked>\n            <Highlight>\n                {`\nconst getContent = React.useCallback((cell: Item): GridCell => {\n    let theme: Partial<Theme> | undefined = undefined;\n    if (col === 1 && row === 1) {\n        theme = {\n            textDark: \"#FF0000\",\n        }\n    }\n    \n    const d = getDataForCell(col, row);\n    return {\n        kind: GridCellKind.Text,\n        allowOverlay: true,\n        displayData: d,\n        data: d,\n        themeOverride: theme\n    };\n}, []);\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    theme={{\n                        bgCell: \"#F2F9FF\",\n                    }}\n                    getRowThemeOverride={getRowThemeOverride}\n                    getCellContent={getContentThemed}\n                    columns={themeColumns}\n                    rows={data.length}\n                />\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Theming as any).storyName = \"08. Theming\";\n(Theming as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import * as React from \"react\";\n\nimport { GridCell, GridCellKind, GridColumn, Item, Rectangle } from \"../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor/data-editor\";\n\nimport { SimpleThemeWrapper } from \"../stories/story-utils\";\nimport { DocWrapper, Highlight, Marked, Wrapper } from \"./doc-wrapper\";\nimport { useLayer } from \"react-laag\";\n\nexport default {\n    title: \"Glide-Data-Grid/Docs\",\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\ninterface DummyItem {\n    name: string;\n    company: string;\n    phone: string;\n    email: string;\n}\n\nconst data: DummyItem[] = [\n    {\n        name: \"Deidre Morris\",\n        company: \"GONKLE\",\n        email: \"deidremorris@gonkle.com\",\n        phone: \"+1 (867) 507-3332\",\n    },\n    {\n        name: \"Sheryl Craig\",\n        company: \"EVENTAGE\",\n        email: \"sherylcraig@eventage.com\",\n        phone: \"+1 (869) 520-2227\",\n    },\n    {\n        name: \"Lidia Bowers\",\n        company: \"ANOCHA\",\n        email: \"lidiabowers@anocha.com\",\n        phone: \"+1 (808) 414-3826\",\n    },\n    {\n        name: \"Jones Norton\",\n        company: \"REPETWIRE\",\n        email: \"jonesnorton@repetwire.com\",\n        phone: \"+1 (875) 582-3320\",\n    },\n    {\n        name: \"Lula Bruce\",\n        company: \"COMDOM\",\n        email: \"lulabruce@comdom.com\",\n        phone: \"+1 (873) 452-2472\",\n    },\n    {\n        name: \"Larsen Montgomery\",\n        company: \"SQUISH\",\n        email: \"larsenmontgomery@squish.com\",\n        phone: \"+1 (893) 482-3651\",\n    },\n    {\n        name: \"Becky Bright\",\n        company: \"COMCUR\",\n        email: \"beckybright@comcur.com\",\n        phone: \"+1 (879) 494-2331\",\n    },\n    {\n        name: \"Charlotte Rowland\",\n        company: \"FROLIX\",\n        email: \"charlotterowland@frolix.com\",\n        phone: \"+1 (861) 439-2134\",\n    },\n    {\n        name: \"Sonya Hensley\",\n        company: \"GEEKETRON\",\n        email: \"sonyahensley@geeketron.com\",\n        phone: \"+1 (802) 553-2194\",\n    },\n    {\n        name: \"Stephenson Guthrie\",\n        company: \"EXOSWITCH\",\n        email: \"stephensonguthrie@exoswitch.com\",\n        phone: \"+1 (903) 449-3271\",\n    },\n    {\n        name: \"Mcmillan Cline\",\n        company: \"TURNLING\",\n        email: \"mcmillancline@turnling.com\",\n        phone: \"+1 (982) 496-2454\",\n    },\n    {\n        name: \"Kemp Davis\",\n        company: \"TETRATREX\",\n        email: \"kempdavis@tetratrex.com\",\n        phone: \"+1 (859) 594-2982\",\n    },\n    {\n        name: \"Matilda Levy\",\n        company: \"SLOFAST\",\n        email: \"matildalevy@slofast.com\",\n        phone: \"+1 (841) 521-2444\",\n    },\n    {\n        name: \"Hattie Simpson\",\n        company: \"COMTRAK\",\n        email: \"hattiesimpson@comtrak.com\",\n        phone: \"+1 (962) 587-3805\",\n    },\n    {\n        name: \"Kinney Munoz\",\n        company: \"IDETICA\",\n        email: \"kinneymunoz@idetica.com\",\n        phone: \"+1 (921) 513-2012\",\n    },\n    {\n        name: \"Lambert Raymond\",\n        company: \"TURNABOUT\",\n        email: \"lambertraymond@turnabout.com\",\n        phone: \"+1 (919) 519-2442\",\n    },\n    {\n        name: \"Bryant Dunlap\",\n        company: \"BYTREX\",\n        email: \"bryantdunlap@bytrex.com\",\n        phone: \"+1 (872) 583-2883\",\n    },\n];\n\nexport const Menus: React.VFC = () => {\n    const getContent = React.useCallback((cell: Item): GridCell => {\n        const [col, row] = cell;\n        const dataRow = data[row];\n        const indexes: (keyof DummyItem)[] = [\"name\", \"company\", \"email\", \"phone\"];\n        const d = dataRow[indexes[col]];\n        return {\n            kind: GridCellKind.Text,\n            allowOverlay: true,\n            displayData: d,\n            data: d,\n        };\n    }, []);\n\n    const columns = React.useMemo<GridColumn[]>(() => {\n        return [\n            {\n                title: \"Name\",\n                id: \"name\",\n                hasMenu: true,\n            },\n            {\n                title: \"Company\",\n                id: \"company\",\n                hasMenu: true,\n            },\n            {\n                title: \"Email\",\n                id: \"email\",\n                hasMenu: true,\n            },\n            {\n                title: \"Phone\",\n                id: \"phone\",\n                hasMenu: true,\n            },\n        ];\n    }, []);\n\n    const onHeaderMenuClickedStage1 = React.useCallback((col: number, position: Rectangle) => {\n        window.alert(\"Header menu clicked \" + col + JSON.stringify(position));\n    }, []);\n\n    const [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();\n\n    const onHeaderMenuClickedStage2 = React.useCallback((col: number, bounds: Rectangle) => {\n        setShowMenu({ col, bounds });\n    }, []);\n\n    const { renderLayer, layerProps } = useLayer({\n        isOpen: showMenu !== undefined,\n        triggerOffset: 4,\n        onOutsideClick: () => setShowMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),\n                height: showMenu?.bounds.height ?? 0,\n                left: showMenu?.bounds.x ?? 0,\n                right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),\n                top: showMenu?.bounds.y ?? 0,\n                width: showMenu?.bounds.width ?? 0,\n            }),\n        },\n        placement: \"bottom-start\",\n        auto: true,\n        possiblePlacements: [\"bottom-start\", \"bottom-end\"],\n    });\n\n    return (\n        <DocWrapper>\n            <Marked>\n                {`\n# Menus\n\nGlide Data Grid doesn't come with built in menus. Instead it is evented and ready to work with whatever menus you want \nto use. Let's learn how to add basic menus using [react-laag](https://www.react-laag.com/). Adding menu drop down indicators to headers is as simple\nas passing a bool and listening to click events using \\`onHeaderMenuClick\\`.`}\n            </Marked>\n            <Highlight>\n                {`\nconst columns = React.useMemo<GridColumn[]>(() => {\n    return [\n        {\n            title: \"Name\",\n            id: \"name\",\n            hasMenu: true,\n        },\n        {\n            title: \"Company\",\n            id: \"company\",\n            hasMenu: true,\n        },\n        {\n            title: \"Email\",\n            id: \"email\",\n            hasMenu: true,\n        },\n        {\n            title: \"Phone\",\n            id: \"phone\",\n            hasMenu: true,\n        },\n    ];\n}, []);\n\nconst onHeaderMenuClick = React.useCallback((col: number, position: Rectangle) => {\n    window.alert(\"Header menu clicked \" + col + JSON.stringify(position));\n}, []);\n\nreturn <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                    onHeaderMenuClick={onHeaderMenuClickedStage1}\n                />\n            </Wrapper>\n            <Marked>\n                {`\nThe provided coordinates are in page space. This makes it trivial to use [react-laag](https://www.react-laag.com/) to create a basic menu. Some \nstyling would go a long way here.`}\n            </Marked>\n            <Highlight>\n                {`\nconst [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();\n\nconst onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n    setShowMenu({ col, bounds });\n}, []);\n\nconst { renderLayer, layerProps } = useLayer({\n    isOpen: showMenu !== undefined,\n    triggerOffset: 4,\n    onOutsideClick: () => setShowMenu(undefined),\n    trigger: {\n        getBounds: () => ({\n            bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),\n            height: showMenu?.bounds.height ?? 0,\n            left: showMenu?.bounds.x ?? 0,\n            right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),\n            top: showMenu?.bounds.y ?? 0,\n            width: showMenu?.bounds.width ?? 0,\n        }),\n    },\n    placement: \"bottom-start\",\n    auto: true,\n    possiblePlacements: [\"bottom-start\", \"bottom-end\"],\n    });\n\nreturn <>\n    <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />\n    {showMenu !== undefined &&\n        renderLayer(\n            <div\n                {...layerProps}\n                style={{\n                    ...layerProps.style,\n                    width: 300,\n                    padding: 4,\n                    borderRadius: 8,\n                    backgroundColor: \"white\",\n                    border: \"1px solid black\",\n                }}>\n                <ul>\n                    <li>Item 1</li>\n                    <li>Item 2</li>\n                    <li>Item 3</li>\n                </ul>\n            </div>\n        )}\n</>;\n`}\n            </Highlight>\n            <Wrapper height={200}>\n                <DataEditor\n                    getCellContent={getContent}\n                    columns={columns}\n                    rows={data.length}\n                    onHeaderMenuClick={onHeaderMenuClickedStage2}\n                />\n                {showMenu !== undefined &&\n                    renderLayer(\n                        <div\n                            {...layerProps}\n                            style={{\n                                ...layerProps.style,\n                                width: 300,\n                                padding: 4,\n                                borderRadius: 8,\n                                backgroundColor: \"white\",\n                                border: \"1px solid black\",\n                            }}>\n                            <ul>\n                                <li>Item 1</li>\n                                <li>Item 2</li>\n                                <li>Item 3</li>\n                            </ul>\n                        </div>\n                    )}\n            </Wrapper>\n        </DocWrapper>\n    );\n};\n(Menus as any).storyName = \"09. Menus\";\n(Menus as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { marked } from \"marked\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\nimport highlightStyle from \"react-syntax-highlighter/dist/esm/styles/hljs/github\";\n\nexport interface WrapperProps {\n    height: number;\n}\n\nexport const Wrapper = styled.div<WrapperProps>`\n    overflow: hidden;\n    position: relative;\n\n    border-radius: 12px;\n\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2), 0 0 1px rgba(0, 0, 0, 0.4);\n\n    width: 100%;\n    height: ${p => p.height}px;\n\n    margin: 24px 0;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nexport const Highlight: React.VFC<{ children: string }> = p => {\n    return (\n        <SyntaxHighlighter\n            style={highlightStyle}\n            showLineNumbers={true}\n            lineNumberStyle={{ opacity: 0.5 }}\n            language=\"typescript\">\n            {p.children.trim()}\n        </SyntaxHighlighter>\n    );\n};\n\nexport const Marked: React.VFC<{ children: string }> = p => {\n    return (\n        <div\n            className=\"marked\"\n            dangerouslySetInnerHTML={{\n                __html: marked(p.children),\n            }}\n        />\n    );\n};\n\nconst BeautifulStyle = styled.div`\n    background: white;\n    color: #222222;\n\n    padding: 32px 48px;\n\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n    min-height: 100vh;\n\n    font-family: sans-serif;\n\n    & .inner {\n        position: relative;\n        width: 900px;\n\n        > pre {\n            font-size: 14px;\n            border-radius: 9px;\n        }\n    }\n\n    .marked {\n        font-family: Helvetica, arial, sans-serif;\n        font-size: 18px;\n        line-height: 1.6;\n\n        > *:first-child {\n            margin-top: 0 !important;\n        }\n        > *:last-child {\n            margin-bottom: 0 !important;\n        }\n\n        a {\n            color: #4183c4;\n        }\n        a.absent {\n            color: #cc0000;\n        }\n        a.anchor {\n            display: block;\n            padding-left: 30px;\n            margin-left: -30px;\n            cursor: pointer;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n            margin: 20px 0 10px;\n            padding: 0;\n            font-weight: bold;\n            -webkit-font-smoothing: antialiased;\n            cursor: text;\n            position: relative;\n        }\n\n        h1:hover a.anchor,\n        h2:hover a.anchor,\n        h3:hover a.anchor,\n        h4:hover a.anchor,\n        h5:hover a.anchor,\n        h6:hover a.anchor {\n            text-decoration: none;\n        }\n\n        h1 tt,\n        h1 code {\n            font-size: inherit;\n        }\n\n        h2 tt,\n        h2 code {\n            font-size: inherit;\n        }\n\n        h3 tt,\n        h3 code {\n            font-size: inherit;\n        }\n\n        h4 tt,\n        h4 code {\n            font-size: inherit;\n        }\n\n        h5 tt,\n        h5 code {\n            font-size: inherit;\n        }\n\n        h6 tt,\n        h6 code {\n            font-size: inherit;\n        }\n\n        h1 {\n            font-size: 32px;\n            color: black;\n        }\n\n        h2 {\n            font-size: 28px;\n            border-bottom: 1px solid #cccccc;\n            color: black;\n        }\n\n        h3 {\n            font-size: 22px;\n        }\n\n        h4 {\n            font-size: 20px;\n        }\n\n        h5 {\n            font-size: 18px;\n        }\n\n        h6 {\n            color: #777777;\n            font-size: 18px;\n        }\n\n        p,\n        blockquote,\n        ul,\n        ol,\n        dl,\n        li,\n        table,\n        pre {\n            margin: 20px 0;\n        }\n\n        hr {\n            border: 0 none;\n            color: #cccccc;\n            height: 4px;\n            padding: 0;\n        }\n\n        > h2:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h1:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h1:first-child + h2 {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h3:first-child,\n        > h4:first-child,\n        > h5:first-child,\n        > h6:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n\n        a:first-child h1,\n        a:first-child h2,\n        a:first-child h3,\n        a:first-child h4,\n        a:first-child h5,\n        a:first-child h6 {\n            margin-top: 0;\n            padding-top: 0;\n        }\n\n        h1 p,\n        h2 p,\n        h3 p,\n        h4 p,\n        h5 p,\n        h6 p {\n            margin-top: 0;\n        }\n\n        li p.first {\n            display: inline-block;\n        }\n        li {\n            margin: 0;\n        }\n        ul,\n        ol {\n            padding-left: 30px;\n        }\n\n        ul :first-child,\n        ol :first-child {\n            margin-top: 0;\n        }\n\n        dl {\n            padding: 0;\n        }\n        dl dt {\n            font-size: 18px;\n            font-weight: bold;\n            font-style: italic;\n            padding: 0;\n            margin: 15px 0 5px;\n        }\n        dl dt:first-child {\n            padding: 0;\n        }\n        dl dt > :first-child {\n            margin-top: 0;\n        }\n        dl dt > :last-child {\n            margin-bottom: 0;\n        }\n        dl dd {\n            margin: 0 0 15px;\n            padding: 0 15px;\n        }\n        dl dd > :first-child {\n            margin-top: 0;\n        }\n        dl dd > :last-child {\n            margin-bottom: 0;\n        }\n\n        blockquote {\n            border-left: 4px solid #dddddd;\n            padding: 0 15px;\n            color: #777777;\n        }\n        blockquote > :first-child {\n            margin-top: 0;\n        }\n        blockquote > :last-child {\n            margin-bottom: 0;\n        }\n\n        table {\n            font-size: 14px;\n            padding: 0;\n            border-collapse: collapse;\n        }\n        table tr {\n            border-top: 1px solid #cccccc;\n            background-color: white;\n            margin: 0;\n            padding: 0;\n        }\n        table tr:nth-child(2n) {\n            background-color: #f8f8f8;\n        }\n        table tr th {\n            font-weight: bold;\n            border: 1px solid #cccccc;\n            margin: 0;\n            padding: 6px 13px;\n        }\n        table tr td {\n            border: 1px solid #cccccc;\n            margin: 0;\n            padding: 6px 13px;\n        }\n        table tr th :first-child,\n        table tr td :first-child {\n            margin-top: 0;\n        }\n        table tr th :last-child,\n        table tr td :last-child {\n            margin-bottom: 0;\n        }\n\n        img {\n            max-width: 100%;\n        }\n\n        span.frame {\n            display: block;\n            overflow: hidden;\n        }\n        span.frame > span {\n            border: 1px solid #dddddd;\n            display: block;\n            float: left;\n            overflow: hidden;\n            margin: 13px 0 0;\n            padding: 7px;\n            width: auto;\n        }\n        span.frame span img {\n            display: block;\n            float: left;\n        }\n        span.frame span span {\n            clear: both;\n            color: #333333;\n            display: block;\n            padding: 5px 0 0;\n        }\n        span.align-center {\n            display: block;\n            overflow: hidden;\n            clear: both;\n        }\n        span.align-center > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px auto 0;\n            text-align: center;\n        }\n        span.align-center span img {\n            margin: 0 auto;\n            text-align: center;\n        }\n        span.align-right {\n            display: block;\n            overflow: hidden;\n            clear: both;\n        }\n        span.align-right > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px 0 0;\n            text-align: right;\n        }\n        span.align-right span img {\n            margin: 0;\n            text-align: right;\n        }\n        span.float-left {\n            display: block;\n            margin-right: 13px;\n            overflow: hidden;\n            float: left;\n        }\n        span.float-left span {\n            margin: 13px 0 0;\n        }\n        span.float-right {\n            display: block;\n            margin-left: 13px;\n            overflow: hidden;\n            float: right;\n        }\n        span.float-right > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px auto 0;\n            text-align: right;\n        }\n\n        code,\n        tt {\n            margin: 0 2px;\n            padding: 0 5px;\n            white-space: nowrap;\n            border: 1px solid #eaeaea;\n            background-color: #f8f8f8;\n            border-radius: 3px;\n        }\n\n        pre code {\n            margin: 0;\n            padding: 0;\n            white-space: pre;\n            border: none;\n            background: transparent;\n        }\n\n        .highlight pre {\n            background-color: #f8f8f8;\n            border: 1px solid #cccccc;\n            font-size: 17px;\n            line-height: 23px;\n            overflow: auto;\n            padding: 6px 10px;\n            border-radius: 3px;\n        }\n\n        pre {\n            background-color: #f8f8f8;\n            border: 1px solid #cccccc;\n            font-size: 17px;\n            line-height: 23px;\n            overflow: auto;\n            padding: 6px 10px;\n            border-radius: 3px;\n        }\n        pre code,\n        pre tt {\n            background-color: transparent;\n            border: none;\n        }\n\n        sup {\n            font-size: 0.83em;\n            vertical-align: super;\n            line-height: 0;\n        }\n        * {\n            -webkit-print-color-adjust: exact;\n        }\n    }\n`;\n\nexport const PropName = styled.span`\n    font-family: monospace;\n    font-weight: 500;\n    color: #ffe394;\n`;\n\nexport const Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\nexport const DocWrapper: React.FC = p => {\n    const { children } = p;\n    return (\n        <BeautifulStyle>\n            <div className=\"inner\">{children}</div>\n        </BeautifulStyle>\n    );\n};\n","import * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport GridScroller from \"./scrolling-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \"../data-grid/data-grid-types\";\nimport { getDefaultTheme } from \"..\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport { CellRenderers } from \"../data-grid/cells\";\n\nconst InnerContainer = styled.div`\n    width: 100%;\n    height: 100px;\n\n    > * {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport default {\n    title: \"Subcomponents/ScrollingDataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1500} height={1000}>\n                    <InnerContainer>\n                        <Story />\n                    </InnerContainer>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nexport function Simplenotest() {\n    const [x, setX] = React.useState<number>(0);\n    const [y, setY] = React.useState<number>(0);\n    const [translateX, setTx] = React.useState<number | undefined>(0);\n    const [translateY, setTy] = React.useState<number | undefined>(0);\n\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\n        setX(range.x);\n        setY(range.y);\n        setTx(tx);\n        setTy(ty);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        let j = 0;\n        return [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\"].map(t => ({\n            title: t,\n            width: 122 + (j += 50),\n        }));\n    }, []);\n\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => ({\n            kind: GridCellKind.Text,\n            displayData: `${col},${row} Testing things that are way too long`,\n            data: `${col},${row} Testing things that are way too long`,\n            allowOverlay: true,\n        }),\n        []\n    );\n\n    return (\n        <GridScroller\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            rows={10_000}\n            enableGroups={false}\n            clientSize={[1000, 1000]}\n            cellXOffset={x}\n            cellYOffset={y}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseUp={() => undefined}\n            canvasRef={undefined}\n            className={undefined}\n            disabledRows={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            initialSize={undefined}\n            overscrollX={undefined}\n            overscrollY={undefined}\n            preventDiagonalScrolling={undefined}\n            rightElement={undefined}\n            rightElementProps={undefined}\n            scrollRef={undefined}\n            showMinimap={undefined}\n            scrollToEnd={undefined}\n            minColumnWidth={50}\n            isFocused={true}\n            theme={getDefaultTheme()}\n            isFilling={false}\n            maxColumnWidth={500}\n            accessibilityHeight={50}\n            translateX={translateX}\n            translateY={translateY}\n            lockColumns={0}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.empty(),\n            }}\n            firstColAccessible={true}\n            groupHeaderHeight={34}\n            headerHeight={44}\n            trailingRowType={\"none\"}\n            rowHeight={34}\n            onVisibleRegionChanged={onVisibleRegionChanged}\n            columns={columns}\n            getCellContent={getCellContent}\n            freezeColumns={0}\n            verticalBorder={() => true}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n}\n","/* eslint-disable unicorn/consistent-destructuring */\nimport clamp from \"lodash/clamp.js\";\nimport * as React from \"react\";\nimport DataGrid, { DataGridProps, DataGridRef } from \"../data-grid/data-grid\";\nimport type { GridColumn, GridMouseEventArgs, InnerGridColumn, Rectangle } from \"../data-grid/data-grid-types\";\n\ntype Props = Omit<DataGridProps, \"dragAndDropState\" | \"isResizing\" | \"isDragging\" | \"onMouseMoveRaw\" | \"allowResize\">;\n\nexport interface DataGridDndProps extends Props {\n    /**\n     * Called whenever a row re-order operation is completed. Setting the callback enables re-ordering by dragging the\n     * first column of a row.\n     * @group Drag and Drop\n     */\n    readonly onRowMoved?: (startIndex: number, endIndex: number) => void;\n    /**\n     * Called when the user finishes moving a column. `startIndex` is the index of the column that was moved, and\n     * `endIndex` is the index at which it should end up. Note that you have to effect the move of the column, and pass\n     * the reordered columns back in the `columns` property.\n     * @group Drag and Drop\n     */\n    readonly onColumnMoved?: (startIndex: number, endIndex: number) => void;\n\n    /**\n     * Called when the user is resizing a column. `newSize` is the new size of the column. Note that you have change\n     * the size of the column in the `GridColumn` and pass it back to the grid in the `columns` property.\n     * @group Drag and Drop\n     * @param column The `GridColumn` being resized\n     * @param newSize The new size of the grid column\n     * @param colIndex The index of the column\n     * @param newSizeWithGrow The new size of the column including any addition pixels added by the grow parameter\n     */\n    readonly onColumnResize?: (column: GridColumn, newSize: number, colIndex: number, newSizeWithGrow: number) => void;\n    /**\n     * Called when the user starts resizing a column. `newSize` is the new size of the column.\n     * @group Drag and Drop\n     * @param column The `GridColumn` being resized\n     * @param newSize The new size of the grid column\n     * @param colIndex The index of the column\n     * @param newSizeWithGrow The new size of the column including any addition pixels added by the grow parameter\n     */\n    readonly onColumnResizeStart?: (\n        column: GridColumn,\n        newSize: number,\n        colIndex: number,\n        newSizeWithGrow: number\n    ) => void;\n    /**\n     * Called when the user finishes resizing a column. `newSize` is the new size of the column.\n     * @group Drag and Drop\n     * @param column The `GridColumn` being resized\n     * @param newSize The new size of the grid column\n     * @param colIndex The index of the column\n     * @param newSizeWithGrow The new size of the column including any addition pixels added by the grow parameter\n     */\n    readonly onColumnResizeEnd?: (\n        column: GridColumn,\n        newSize: number,\n        colIndex: number,\n        newSizeWithGrow: number\n    ) => void;\n\n    readonly gridRef?: React.MutableRefObject<DataGridRef | null>;\n    readonly maxColumnWidth: number;\n    readonly minColumnWidth: number;\n    readonly lockColumns: number;\n}\n\n// Dear Past Jason,\n// Wtf does this function do? If you remember in the future come back and add a comment\n// -- Future-Past Jason\nfunction offsetColumnSize(column: InnerGridColumn, width: number, min: number, max: number): number {\n    return clamp(Math.round(width - (column.growOffset ?? 0)), Math.ceil(min), Math.floor(max));\n}\n\nconst DataGridDnd: React.FunctionComponent<DataGridDndProps> = p => {\n    const [resizeColStartX, setResizeColStartX] = React.useState<number>();\n    const [resizeCol, setResizeCol] = React.useState<number>();\n\n    const [dragCol, setDragCol] = React.useState<number>();\n    const [dropCol, setDropCol] = React.useState<number>();\n    const [dragColActive, setDragColActive] = React.useState(false);\n    const [dragStartX, setDragStartX] = React.useState<number>();\n\n    const [dragRow, setDragRow] = React.useState<number>();\n    const [dropRow, setDropRow] = React.useState<number>();\n    const [dragRowActive, setDragRowActive] = React.useState(false);\n    const [dragStartY, setDragStartY] = React.useState<number>();\n\n    const {\n        onHeaderMenuClick,\n        getCellContent,\n        onColumnMoved,\n        onColumnResize,\n        onColumnResizeStart,\n        onColumnResizeEnd,\n        gridRef,\n        maxColumnWidth,\n        minColumnWidth,\n        onRowMoved,\n        lockColumns,\n        onMouseDown,\n        onMouseUp,\n        onItemHovered,\n        onDragStart,\n    } = p;\n\n    const canResize = (onColumnResize ?? onColumnResizeEnd ?? onColumnResizeStart) !== undefined;\n\n    const { columns, selection } = p;\n    const selectedColumns = selection.columns;\n\n    const onItemHoveredImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            const [col, row] = args.location;\n            if (dragCol !== undefined && dropCol !== col && col >= lockColumns) {\n                setDragColActive(true);\n                setDropCol(col);\n            } else if (dragRow !== undefined && row !== undefined) {\n                setDragRowActive(true);\n                setDropRow(Math.max(0, row));\n            } else {\n                onItemHovered?.(args);\n            }\n        },\n        [dragCol, dragRow, dropCol, onItemHovered, lockColumns]\n    );\n\n    const canDragCol = onColumnMoved !== undefined;\n    const onMouseDownImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            if (args.button === 0) {\n                const [col, row] = args.location;\n                if (args.kind === \"out-of-bounds\" && args.isEdge && canResize) {\n                    const bounds = gridRef?.current?.getBounds(columns.length - 1, -1);\n                    if (bounds !== undefined) {\n                        setResizeColStartX(bounds.x);\n                        setResizeCol(columns.length - 1);\n                    }\n                } else if (args.kind === \"header\" && col >= lockColumns) {\n                    if (args.isEdge && canResize) {\n                        setResizeColStartX(args.bounds.x);\n                        setResizeCol(col);\n                        onColumnResizeStart?.(\n                            columns[col],\n                            args.bounds.width,\n                            col,\n                            args.bounds.width + (columns[col].growOffset ?? 0)\n                        );\n                    } else if (args.kind === \"header\" && canDragCol) {\n                        setDragStartX(args.bounds.x);\n                        setDragCol(col);\n                    }\n                } else if (\n                    args.kind === \"cell\" &&\n                    lockColumns > 0 &&\n                    col === 0 &&\n                    row !== undefined &&\n                    onRowMoved !== undefined\n                ) {\n                    setDragStartY(args.bounds.y);\n                    setDragRow(row);\n                }\n            }\n            onMouseDown?.(args);\n        },\n        [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart]\n    );\n\n    const onHeaderMenuClickMangled = React.useCallback(\n        (col: number, screenPosition: Rectangle) => {\n            if (dragColActive || dragRowActive) return;\n            onHeaderMenuClick?.(col, screenPosition);\n        },\n        [dragColActive, dragRowActive, onHeaderMenuClick]\n    );\n\n    const lastResizeWidthRef = React.useRef(-1);\n\n    const clearAll = React.useCallback(() => {\n        lastResizeWidthRef.current = -1;\n        setDragRow(undefined);\n        setDropRow(undefined);\n        setDragStartY(undefined);\n        setDragRowActive(false);\n        setDragCol(undefined);\n        setDropCol(undefined);\n        setDragStartX(undefined);\n        setDragColActive(false);\n        setResizeCol(undefined);\n        setResizeColStartX(undefined);\n    }, []);\n\n    const onMouseUpImpl = React.useCallback(\n        (args: GridMouseEventArgs, isOutside: boolean) => {\n            if (args.button === 0) {\n                if (resizeCol !== undefined) {\n                    // if the column is in selection, the selection may contain extra cols, so lets just re-send the last\n                    // resize event to all those columns.\n                    if (selectedColumns?.hasIndex(resizeCol) === true) {\n                        for (const c of selectedColumns) {\n                            if (c === resizeCol) continue;\n                            const col = columns[c];\n                            const newSize = offsetColumnSize(\n                                col,\n                                lastResizeWidthRef.current,\n                                minColumnWidth,\n                                maxColumnWidth\n                            );\n                            onColumnResize?.(col, newSize, c, newSize + (col.growOffset ?? 0));\n                        }\n                    }\n\n                    const ns = offsetColumnSize(\n                        columns[resizeCol],\n                        lastResizeWidthRef.current,\n                        minColumnWidth,\n                        maxColumnWidth\n                    );\n                    onColumnResizeEnd?.(columns[resizeCol], ns, resizeCol, ns + (columns[resizeCol].growOffset ?? 0));\n                    for (const c of selectedColumns) {\n                        if (c === resizeCol) continue;\n                        const col = columns[c];\n                        const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                        onColumnResizeEnd?.(col, s, c, s + (col.growOffset ?? 0));\n                    }\n                }\n\n                clearAll();\n                if (dragCol !== undefined && dropCol !== undefined) {\n                    onColumnMoved?.(dragCol, dropCol);\n                }\n                if (dragRow !== undefined && dropRow !== undefined) {\n                    onRowMoved?.(dragRow, dropRow);\n                }\n            }\n            onMouseUp?.(args, isOutside);\n        },\n        [\n            onMouseUp,\n            resizeCol,\n            dragCol,\n            dropCol,\n            dragRow,\n            dropRow,\n            selectedColumns,\n            onColumnResizeEnd,\n            columns,\n            minColumnWidth,\n            maxColumnWidth,\n            onColumnResize,\n            onColumnMoved,\n            onRowMoved,\n            clearAll,\n        ]\n    );\n\n    const dragOffset = React.useMemo(() => {\n        if (dragCol === undefined || dropCol === undefined) return undefined;\n        if (dragCol === dropCol) return undefined;\n\n        return {\n            src: dragCol,\n            dest: dropCol,\n        };\n    }, [dragCol, dropCol]);\n\n    const onMouseMove = React.useCallback(\n        (event: MouseEvent) => {\n            if (dragCol !== undefined && dragStartX !== undefined) {\n                const diff = Math.abs(event.clientX - dragStartX);\n                if (diff > 20) {\n                    setDragColActive(true);\n                }\n            } else if (dragRow !== undefined && dragStartY !== undefined) {\n                const diff = Math.abs(event.clientY - dragStartY);\n                if (diff > 20) {\n                    setDragRowActive(true);\n                }\n            } else if (resizeCol !== undefined && resizeColStartX !== undefined) {\n                const column = columns[resizeCol];\n                const newWidth = event.clientX - resizeColStartX;\n                const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);\n                onColumnResize?.(column, ns, resizeCol, ns + (column.growOffset ?? 0));\n                lastResizeWidthRef.current = newWidth;\n\n                if (selectedColumns?.first() === resizeCol) {\n                    for (const c of selectedColumns) {\n                        if (c === resizeCol) continue;\n                        const col = columns[c];\n                        const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                        onColumnResize?.(col, s, c, s + (col.growOffset ?? 0));\n                    }\n                }\n            }\n        },\n        [\n            dragCol,\n            dragStartX,\n            dragRow,\n            dragStartY,\n            resizeCol,\n            resizeColStartX,\n            columns,\n            minColumnWidth,\n            maxColumnWidth,\n            onColumnResize,\n            selectedColumns,\n        ]\n    );\n\n    const getMangledCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            if (dragRow === undefined || dropRow === undefined) return getCellContent(cell);\n\n            // eslint-disable-next-line prefer-const\n            let [col, row] = cell;\n            if (row === dropRow) {\n                row = dragRow;\n            } else {\n                if (row > dropRow) row -= 1;\n                if (row >= dragRow) row += 1;\n            }\n\n            return getCellContent([col, row]);\n        },\n        [dragRow, dropRow, getCellContent]\n    );\n\n    const onDragStartImpl = React.useCallback<NonNullable<DataGridDndProps[\"onDragStart\"]>>(\n        args => {\n            onDragStart?.(args);\n            if (!args.defaultPrevented()) {\n                clearAll();\n            }\n        },\n        [clearAll, onDragStart]\n    );\n\n    return (\n        <DataGrid\n            accessibilityHeight={p.accessibilityHeight}\n            canvasRef={p.canvasRef}\n            cellXOffset={p.cellXOffset}\n            cellYOffset={p.cellYOffset}\n            columns={p.columns}\n            disabledRows={p.disabledRows}\n            drawCustomCell={p.drawCustomCell}\n            drawFocusRing={p.drawFocusRing}\n            drawHeader={p.drawHeader}\n            enableGroups={p.enableGroups}\n            eventTargetRef={p.eventTargetRef}\n            experimental={p.experimental}\n            fillHandle={p.fillHandle}\n            firstColAccessible={p.firstColAccessible}\n            fixedShadowX={p.fixedShadowX}\n            fixedShadowY={p.fixedShadowY}\n            freezeColumns={p.freezeColumns}\n            getCellRenderer={p.getCellRenderer}\n            getGroupDetails={p.getGroupDetails}\n            getRowThemeOverride={p.getRowThemeOverride}\n            groupHeaderHeight={p.groupHeaderHeight}\n            headerHeight={p.headerHeight}\n            headerIcons={p.headerIcons}\n            height={p.height}\n            highlightRegions={p.highlightRegions}\n            imageWindowLoader={p.imageWindowLoader}\n            isDraggable={p.isDraggable}\n            isFilling={p.isFilling}\n            isFocused={p.isFocused}\n            onCanvasBlur={p.onCanvasBlur}\n            onCanvasFocused={p.onCanvasFocused}\n            onCellFocused={p.onCellFocused}\n            onContextMenu={p.onContextMenu}\n            onDragEnd={p.onDragEnd}\n            onDragLeave={p.onDragLeave}\n            onDragOverCell={p.onDragOverCell}\n            onDrop={p.onDrop}\n            onKeyDown={p.onKeyDown}\n            onKeyUp={p.onKeyUp}\n            onMouseMove={p.onMouseMove}\n            prelightCells={p.prelightCells}\n            rowHeight={p.rowHeight}\n            rows={p.rows}\n            selection={p.selection}\n            smoothScrollX={p.smoothScrollX}\n            smoothScrollY={p.smoothScrollY}\n            theme={p.theme}\n            trailingRowType={p.trailingRowType}\n            translateX={p.translateX}\n            translateY={p.translateY}\n            verticalBorder={p.verticalBorder}\n            width={p.width}\n            getCellContent={getMangledCellContent}\n            isResizing={resizeCol !== undefined}\n            onHeaderMenuClick={onHeaderMenuClickMangled}\n            isDragging={dragColActive}\n            onItemHovered={onItemHoveredImpl}\n            onDragStart={onDragStartImpl}\n            onMouseDown={onMouseDownImpl}\n            allowResize={onColumnResize !== undefined}\n            onMouseUp={onMouseUpImpl}\n            dragAndDropState={dragOffset}\n            onMouseMoveRaw={onMouseMove}\n            ref={gridRef}\n        />\n    );\n};\n\nexport default DataGridDnd;\n","/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { useLayoutEffect, useState, useRef, MutableRefObject } from \"react\";\ninterface ReactResizeDetectorDimensions {\n    height?: number;\n    width?: number;\n}\n\nexport function useResizeDetector<T extends HTMLElement = HTMLElement>(\n    initialSize?: readonly [width: number, height: number]\n): UseResizeDetectorReturn<T> {\n    const ref = useRef<T>(null);\n\n    const [size, setSize] = useState<ReactResizeDetectorDimensions>({\n        width: initialSize?.[0],\n        height: initialSize?.[1],\n    });\n\n    useLayoutEffect(() => {\n        const resizeCallback: ResizeObserverCallback = entries => {\n            for (const entry of entries) {\n                const { width, height } = (entry && entry.contentRect) || {};\n                setSize(cv => (cv.width === width && cv.height === height ? cv : { width, height }));\n            }\n        };\n\n        const resizeObserver = new window.ResizeObserver(resizeCallback);\n\n        if (ref.current) {\n            resizeObserver.observe(ref.current, undefined);\n        }\n\n        return () => {\n            resizeObserver.disconnect();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [ref.current]);\n\n    return { ref, ...size };\n}\n\nexport interface UseResizeDetectorReturn<T> extends ReactResizeDetectorDimensions {\n    ref: MutableRefObject<T | null>;\n}\n","import { styled } from \"@linaria/react\";\nimport type { Rectangle } from \"..\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"../common/resize-detector\";\nimport { browserIsSafari } from \"../common/browser-detect\";\nimport { useEventListener } from \"../common/utils\";\n\ninterface Props {\n    readonly className?: string;\n    readonly preventDiagonalScrolling?: boolean;\n    readonly draggable: boolean;\n    readonly paddingRight?: number;\n    readonly paddingBottom?: number;\n    readonly clientHeight: number;\n    readonly scrollWidth: number;\n    readonly scrollHeight: number;\n    readonly scrollToEnd?: boolean;\n    readonly initialScrollPosition?: readonly [scrollX: number, scrollY: number];\n    readonly initialSize?: readonly [width: number, height: number];\n    readonly rightElementProps?: {\n        readonly sticky?: boolean;\n        readonly fill?: boolean;\n    };\n    readonly rightElement?: React.ReactNode;\n    readonly minimap?: React.ReactNode;\n    readonly scrollRef?: React.MutableRefObject<HTMLDivElement | null>;\n    readonly update: (region: Rectangle & { paddingRight: number }) => void;\n}\n\nconst ScrollRegionStyle = styled.div<{ isSafari: boolean }>`\n    .dvn-scroller {\n        overflow: ${p => (p.isSafari ? \"scroll\" : \"auto\")};\n        transform: translate3d(0, 0, 0);\n    }\n\n    .hidden {\n        visibility: hidden;\n    }\n\n    .dvn-scroll-inner {\n        display: flex;\n        pointer-events: none;\n\n        > * {\n            flex-shrink: 0;\n        }\n\n        .dvn-spacer {\n            flex-grow: 1;\n        }\n\n        .dvn-stack {\n            display: flex;\n            flex-direction: column;\n        }\n    }\n\n    .dvn-underlay > * {\n        position: absolute;\n        left: 0;\n        top: 0;\n    }\n\n    canvas {\n        outline: none;\n\n        * {\n            height: 0;\n        }\n    }\n`;\n\ntype ScrollLock = [undefined, number] | [number, undefined] | undefined;\n\nfunction eatEvent(e: React.MouseEvent) {\n    e.stopPropagation();\n}\n\nfunction useTouchUpDelayed(delay: number): boolean {\n    const [hasTouches, setHasTouches] = React.useState(false);\n\n    const cbTimer = React.useRef(0);\n    useEventListener(\n        \"touchstart\",\n        React.useCallback(() => {\n            window.clearTimeout(cbTimer.current);\n            setHasTouches(true);\n        }, []),\n        window,\n        true,\n        false\n    );\n\n    useEventListener(\n        \"touchend\",\n        React.useCallback(\n            e => {\n                if (e.touches.length === 0) {\n                    cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\n                }\n            },\n            [delay]\n        ),\n        window,\n        true,\n        false\n    );\n\n    return hasTouches;\n}\n\nexport const InfiniteScroller: React.FC<Props> = p => {\n    const {\n        children,\n        clientHeight,\n        scrollHeight,\n        scrollWidth,\n        update,\n        draggable,\n        className,\n        preventDiagonalScrolling = false,\n        paddingBottom = 0,\n        paddingRight = 0,\n        rightElement,\n        rightElementProps,\n        scrollRef,\n        scrollToEnd,\n        initialSize,\n        minimap,\n    } = p;\n    const padders: React.ReactNode[] = [];\n\n    const rightElementSticky = rightElementProps?.sticky ?? false;\n    const rightElementFill = rightElementProps?.fill ?? false;\n\n    const offsetY = React.useRef(0);\n    const lastScrollY = React.useRef(0);\n    const scroller = React.useRef<HTMLDivElement | null>(null);\n\n    const dpr = window.devicePixelRatio;\n\n    React.useEffect(() => {\n        const el = scroller.current;\n        if (el === null || scrollToEnd !== true) return;\n\n        el.scrollLeft = el.scrollWidth - el.clientWidth;\n    }, [scrollToEnd]);\n\n    const lastScrollPosition = React.useRef({\n        scrollLeft: 0,\n        scrollTop: 0,\n        lockDirection: undefined as ScrollLock,\n    });\n\n    const rightWrapRef = React.useRef<HTMLDivElement | null>(null);\n\n    const hasTouches = useTouchUpDelayed(200);\n    const [isIdle, setIsIdle] = React.useState(true);\n    const idleTimer = React.useRef(0);\n\n    React.useEffect(() => {\n        if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;\n        const el = scroller.current;\n        if (el === null) return;\n        const [lx, ly] = lastScrollPosition.current.lockDirection;\n        if (lx !== undefined) {\n            el.scrollLeft = lx;\n        } else if (ly !== undefined) {\n            el.scrollTop = ly;\n        }\n        lastScrollPosition.current.lockDirection = undefined;\n    }, [hasTouches, isIdle]);\n\n    const onScroll = React.useCallback(() => {\n        const el = scroller.current;\n        if (el === null) return;\n\n        let scrollTop = el.scrollTop;\n        let scrollLeft = el.scrollLeft;\n        const lastScrollTop = lastScrollPosition.current.scrollTop;\n        const lastScrollLeft = lastScrollPosition.current.scrollLeft;\n\n        const dx = scrollLeft - lastScrollLeft;\n        const dy = scrollTop - lastScrollTop;\n\n        if (\n            hasTouches &&\n            dx !== 0 &&\n            dy !== 0 &&\n            (Math.abs(dx) > 3 || Math.abs(dy) > 3) &&\n            preventDiagonalScrolling &&\n            lastScrollPosition.current.lockDirection === undefined\n        ) {\n            lastScrollPosition.current.lockDirection =\n                Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];\n        }\n\n        const lock = lastScrollPosition.current.lockDirection;\n\n        scrollLeft = lock?.[0] ?? scrollLeft;\n        scrollTop = lock?.[1] ?? scrollTop;\n        lastScrollPosition.current.scrollLeft = scrollLeft;\n        lastScrollPosition.current.scrollTop = scrollTop;\n\n        const newY = scrollTop;\n        const delta = lastScrollY.current - newY;\n        const scrollableHeight = el.scrollHeight - el.clientHeight;\n        lastScrollY.current = newY;\n\n        if (\n            scrollableHeight > 0 &&\n            (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) &&\n            scrollHeight > el.scrollHeight + 5\n        ) {\n            const prog = newY / scrollableHeight;\n            const recomputed = (scrollHeight - el.clientHeight) * prog;\n            offsetY.current = recomputed - newY;\n        }\n\n        if (lock !== undefined) {\n            window.clearTimeout(idleTimer.current);\n            setIsIdle(false);\n            idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\n        }\n\n        update({\n            x: scrollLeft,\n            y: newY + offsetY.current,\n            width: el.clientWidth - paddingRight,\n            height: el.clientHeight - paddingBottom,\n            paddingRight: rightWrapRef.current?.clientWidth ?? 0,\n        });\n    }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\n\n    const onScrollRef = React.useRef(onScroll);\n    onScrollRef.current = onScroll;\n\n    const lastProps = React.useRef<{ width?: number; height?: number }>();\n\n    React.useEffect(() => {\n        onScroll();\n    }, [onScroll, paddingBottom, paddingRight]);\n\n    const setRefs = React.useCallback(\n        (instance: HTMLDivElement | null) => {\n            scroller.current = instance;\n            if (scrollRef !== undefined) {\n                scrollRef.current = instance;\n            }\n        },\n        [scrollRef]\n    );\n\n    let key = 0;\n    let h = 0;\n    padders.push(<div key={key++} style={{ width: scrollWidth, height: 0 }} />);\n    while (h < scrollHeight) {\n        const toAdd = Math.min(5_000_000, scrollHeight - h);\n        padders.push(<div key={key++} style={{ width: 0, height: toAdd }} />);\n        h += toAdd;\n    }\n\n    const { ref, width, height } = useResizeDetector<HTMLDivElement>(initialSize);\n\n    if (lastProps.current?.height !== height || lastProps.current?.width !== width) {\n        window.setTimeout(() => onScrollRef.current(), 0);\n        lastProps.current = { width, height };\n    }\n\n    if ((width ?? 0) === 0 || (height ?? 0) === 0) return <div ref={ref} />;\n\n    return (\n        <div ref={ref}>\n            <ScrollRegionStyle isSafari={browserIsSafari.value}>\n                {minimap}\n                <div className=\"dvn-underlay\">{children}</div>\n                <div\n                    ref={setRefs}\n                    style={lastProps.current}\n                    draggable={draggable}\n                    onDragStart={e => {\n                        if (!draggable) {\n                            e.stopPropagation();\n                            e.preventDefault();\n                        }\n                    }}\n                    className={\"dvn-scroller \" + (className ?? \"\")}\n                    onScroll={onScroll}>\n                    <div className={\"dvn-scroll-inner\" + (rightElement === undefined ? \" hidden\" : \"\")}>\n                        <div className=\"dvn-stack\">{padders}</div>\n                        {rightElement !== undefined && (\n                            <>\n                                {!rightElementFill && <div className=\"dvn-spacer\" />}\n                                <div\n                                    ref={rightWrapRef}\n                                    onMouseDown={eatEvent}\n                                    onMouseUp={eatEvent}\n                                    onMouseMove={eatEvent}\n                                    style={{\n                                        height,\n                                        maxHeight: clientHeight - Math.ceil(dpr % 1),\n                                        position: \"sticky\",\n                                        top: 0,\n                                        paddingLeft: 1,\n                                        marginBottom: -40,\n                                        marginRight: paddingRight,\n                                        flexGrow: rightElementFill ? 1 : undefined,\n                                        right: rightElementSticky ? paddingRight ?? 0 : undefined,\n                                        pointerEvents: \"auto\",\n                                    }}>\n                                    {rightElement}\n                                </div>\n                            </>\n                        )}\n                    </div>\n                </div>\n            </ScrollRegionStyle>\n        </div>\n    );\n};\n","import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport DataGridDnd, { DataGridDndProps } from \"../data-grid-dnd/data-grid-dnd\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\nimport { InfiniteScroller } from \"./infinite-scroller\";\nimport clamp from \"lodash/clamp.js\";\n\ntype Props = Omit<DataGridDndProps, \"width\" | \"height\" | \"eventTargetRef\">;\n\nexport interface ScrollingDataGridProps extends Props {\n    readonly className: string | undefined;\n    readonly onVisibleRegionChanged:\n        | ((\n              range: Rectangle,\n              clientWidth: number,\n              clientHeight: number,\n              rightElWidth: number,\n              tx: number,\n              ty: number\n          ) => void)\n        | undefined;\n    /**\n     * Causes the grid to scroll to the end when flipped to true\n     * @deprecated Use {@link DataEditorRef.scrollTo} instead\n     * @group Deprecated\n     */\n    readonly scrollToEnd: boolean | undefined;\n    readonly scrollRef: React.MutableRefObject<HTMLDivElement | null> | undefined;\n\n    /**\n     * The overscroll properties are used to allow the grid to scroll past the logical end of the content by a fixed\n     * number of pixels. This is useful particularly on the X axis if you allow for resizing columns as it can make\n     * resizing the final column significantly easier.\n     *\n     * @group Advanced\n     */\n    readonly overscrollX: number | undefined;\n    /** {@inheritDoc overscrollX}\n     * @group Advanced\n     */\n    readonly overscrollY: number | undefined;\n    /**\n     * Provides an initial size for the grid which can prevent a flicker on load if the initial size is known prior to\n     * layout.\n     *\n     * @group Advanced\n     */\n    readonly initialSize: readonly [width: number, height: number] | undefined;\n    /**\n     * Set to true to prevent any diagonal scrolling.\n     * @group Advanced\n     */\n    readonly preventDiagonalScrolling: boolean | undefined;\n\n    /**\n     * If `rightElementProps.sticky` is set to true the right element will be visible at all times, otherwise the user\n     * will need to scroll to the end to reveal it.\n     *\n     * If `rightElementProps.fill` is set, the right elements container will fill to consume all remaining space (if\n     * any) at the end of the grid. This does not play nice with growing columns.\n     *\n     * @group Advanced\n     */\n    readonly rightElementProps:\n        | {\n              readonly sticky?: boolean;\n              readonly fill?: boolean;\n          }\n        | undefined;\n    /**\n     * The right element is a DOM node which can be inserted at the end of the horizontal scroll region. This can be\n     * used to create a right handle panel, make a big add button, or display messages.\n     * @group Advanced\n     */\n    readonly rightElement: React.ReactNode | undefined;\n    /**\n     * Enables/disables the interactive minimap.\n     * @defaultValue false\n     * @group Advanced\n     */\n    readonly showMinimap: boolean | undefined;\n    readonly clientSize: readonly [number, number];\n}\n\nconst MinimapStyle = styled.div`\n    position: absolute;\n    right: 44px;\n    bottom: 44px;\n    background-color: var(--gdg-bg-cell);\n    background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n    border-radius: 4px;\n    z-index: 1;\n    box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n\n    overflow: hidden;\n\n    .header {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 4px;\n        background-color: var(--gdg-bg-header);\n        box-shadow: 0 0 0 1px var(--gdg-border-color);\n    }\n\n    .locationMarker {\n        position: absolute;\n\n        border: 1px solid var(--gdg-accent-color);\n        background-color: var(--gdg-accent-light);\n    }\n`;\n\nconst GridScroller: React.FunctionComponent<ScrollingDataGridProps> = p => {\n    const {\n        columns,\n        rows,\n        rowHeight,\n        headerHeight,\n        groupHeaderHeight,\n        enableGroups,\n        freezeColumns,\n        experimental,\n        clientSize,\n        className,\n        onVisibleRegionChanged,\n        scrollToEnd,\n        scrollRef,\n        preventDiagonalScrolling,\n        rightElement,\n        rightElementProps,\n        overscrollX,\n        overscrollY,\n        showMinimap = false,\n        initialSize,\n        smoothScrollX = false,\n        smoothScrollY = false,\n        isDraggable,\n    } = p;\n    const { paddingRight, paddingBottom } = experimental ?? {};\n\n    const [clientWidth, clientHeight] = clientSize;\n    const last = React.useRef<Rectangle | undefined>();\n    const lastX = React.useRef<number | undefined>();\n    const lastY = React.useRef<number | undefined>();\n    const lastSize = React.useRef<readonly [number, number] | undefined>();\n\n    const width = React.useMemo(() => {\n        let r = Math.max(0, overscrollX ?? 0);\n        for (const c of columns) {\n            r += c.width;\n        }\n        return r;\n    }, [columns, overscrollX]);\n\n    let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n    if (typeof rowHeight === \"number\") {\n        height += rows * rowHeight;\n    } else {\n        for (let r = 0; r < rows; r++) {\n            height += rowHeight(r);\n        }\n    }\n    if (overscrollY !== undefined) {\n        height += overscrollY;\n    }\n\n    const lastArgs = React.useRef<Rectangle & { paddingRight: number }>();\n\n    const processArgs = React.useCallback(() => {\n        if (lastArgs.current === undefined) return;\n        const args = { ...lastArgs.current };\n\n        let x = 0;\n        let tx = args.x < 0 ? -args.x : 0;\n        let cellRight = 0;\n        let cellX = 0;\n\n        args.x = args.x < 0 ? 0 : args.x;\n\n        let stickyColWidth = 0;\n        for (let i = 0; i < freezeColumns; i++) {\n            stickyColWidth += columns[i].width;\n        }\n\n        for (const c of columns) {\n            const cx = x - stickyColWidth;\n            if (args.x >= cx + c.width) {\n                x += c.width;\n                cellX++;\n                cellRight++;\n            } else if (args.x > cx) {\n                x += c.width;\n                if (smoothScrollX) {\n                    tx += cx - args.x;\n                } else {\n                    cellX++;\n                }\n                cellRight++;\n            } else if (args.x + args.width > cx) {\n                x += c.width;\n                cellRight++;\n            } else {\n                break;\n            }\n        }\n\n        let ty = 0;\n        let cellY = 0;\n        let cellBottom = 0;\n        if (typeof rowHeight === \"number\") {\n            if (smoothScrollY) {\n                cellY = Math.floor(args.y / rowHeight);\n                ty = cellY * rowHeight - args.y;\n            } else {\n                cellY = Math.ceil(args.y / rowHeight);\n            }\n            cellBottom = Math.ceil(args.height / rowHeight) + cellY;\n            if (ty < 0) cellBottom++;\n        } else {\n            let y = 0;\n            for (let row = 0; row < rows; row++) {\n                const rh = rowHeight(row);\n                const cy = y + (smoothScrollY ? 0 : rh / 2);\n                if (args.y >= y + rh) {\n                    y += rh;\n                    cellY++;\n                    cellBottom++;\n                } else if (args.y > cy) {\n                    y += rh;\n                    if (smoothScrollY) {\n                        ty += cy - args.y;\n                    } else {\n                        cellY++;\n                    }\n                    cellBottom++;\n                } else if (args.y + args.height > rh / 2 + y) {\n                    y += rh;\n                    cellBottom++;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        const rect: Rectangle = {\n            x: cellX,\n            y: cellY,\n            width: cellRight - cellX,\n            height: cellBottom - cellY,\n        };\n\n        const oldRect = last.current;\n\n        if (\n            oldRect === undefined ||\n            oldRect.y !== rect.y ||\n            oldRect.x !== rect.x ||\n            oldRect.height !== rect.height ||\n            oldRect.width !== rect.width ||\n            lastX.current !== tx ||\n            lastY.current !== ty ||\n            args.width !== lastSize.current?.[0] ||\n            args.height !== lastSize.current?.[1]\n        ) {\n            onVisibleRegionChanged?.(\n                {\n                    x: cellX,\n                    y: cellY,\n                    width: cellRight - cellX,\n                    height: cellBottom - cellY,\n                },\n                args.width,\n                args.height,\n                args.paddingRight ?? 0,\n                tx,\n                ty\n            );\n            last.current = rect;\n            lastX.current = tx;\n            lastY.current = ty;\n            lastSize.current = [args.width, args.height];\n        }\n    }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\n\n    const onScrollUpdate = React.useCallback(\n        (args: Rectangle & { paddingRight: number }) => {\n            lastArgs.current = args;\n            processArgs();\n        },\n        [processArgs]\n    );\n\n    React.useEffect(() => {\n        processArgs();\n    }, [processArgs]);\n\n    const scroller = scrollRef?.current ?? undefined;\n    const aspect = clamp(width / height, 2 / 3, 1.5);\n    const maxSize = 200;\n    const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);\n    const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;\n    const hRatio = w / width;\n    const vRatio = h / height;\n    const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);\n    const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);\n    const left = ((scroller?.scrollLeft ?? 0) / (width - clientWidth)) * (w - vWidth);\n    const top = ((scroller?.scrollTop ?? 0) / (height - clientHeight)) * (h - vHeight);\n\n    const minimap: React.ReactNode = React.useMemo(() => {\n        if (!showMinimap || vWidth === 0 || vHeight === 0) return undefined;\n\n        const handleMouse = (e: React.MouseEvent) => {\n            if (scroller === undefined) return;\n            const bounds = e.currentTarget.getBoundingClientRect();\n            const x = e.clientX - bounds.x - vWidth / 2;\n            const y = e.clientY - bounds.y - vHeight / 2;\n\n            const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));\n            const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));\n\n            scroller.scrollTo({\n                left: newScrollLeft,\n                top: newScrollTop,\n                behavior: e.type === \"mousemove\" ? \"auto\" : \"smooth\",\n            });\n        };\n\n        return (\n            <MinimapStyle\n                style={{ width: w, height: h }}\n                data-testid=\"minimap-container\"\n                onMouseMove={e => {\n                    if (e.buttons !== 1) return;\n                    handleMouse(e);\n                }}\n                onClick={handleMouse}>\n                <div className=\"header\" />\n                <div\n                    className=\"locationMarker\"\n                    onDragStart={e => e.preventDefault()}\n                    style={{\n                        left,\n                        top,\n                        width: vWidth,\n                        height: vHeight,\n                        borderRadius: Math.min(vWidth, vHeight * 0.2, 9),\n                    }}></div>\n            </MinimapStyle>\n        );\n    }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);\n\n    return (\n        <InfiniteScroller\n            scrollRef={scrollRef}\n            minimap={minimap}\n            className={className}\n            preventDiagonalScrolling={preventDiagonalScrolling}\n            draggable={isDraggable === true || typeof isDraggable === \"string\"}\n            scrollWidth={width + (paddingRight ?? 0)}\n            scrollHeight={height + (paddingBottom ?? 0)}\n            clientHeight={clientHeight}\n            rightElement={rightElement}\n            paddingBottom={paddingBottom}\n            paddingRight={paddingRight}\n            rightElementProps={rightElementProps}\n            update={onScrollUpdate}\n            initialSize={initialSize}\n            scrollToEnd={scrollToEnd}>\n            <DataGridDnd\n                eventTargetRef={scrollRef}\n                width={clientWidth}\n                height={clientHeight}\n                accessibilityHeight={p.accessibilityHeight}\n                canvasRef={p.canvasRef}\n                cellXOffset={p.cellXOffset}\n                cellYOffset={p.cellYOffset}\n                columns={p.columns}\n                disabledRows={p.disabledRows}\n                enableGroups={p.enableGroups}\n                fillHandle={p.fillHandle}\n                firstColAccessible={p.firstColAccessible}\n                fixedShadowX={p.fixedShadowX}\n                fixedShadowY={p.fixedShadowY}\n                freezeColumns={p.freezeColumns}\n                getCellContent={p.getCellContent}\n                getCellRenderer={p.getCellRenderer}\n                getGroupDetails={p.getGroupDetails}\n                getRowThemeOverride={p.getRowThemeOverride}\n                groupHeaderHeight={p.groupHeaderHeight}\n                headerHeight={p.headerHeight}\n                highlightRegions={p.highlightRegions}\n                imageWindowLoader={p.imageWindowLoader}\n                isFilling={p.isFilling}\n                isFocused={p.isFocused}\n                lockColumns={p.lockColumns}\n                maxColumnWidth={p.maxColumnWidth}\n                minColumnWidth={p.minColumnWidth}\n                onHeaderMenuClick={p.onHeaderMenuClick}\n                onMouseMove={p.onMouseMove}\n                prelightCells={p.prelightCells}\n                rowHeight={p.rowHeight}\n                rows={p.rows}\n                selection={p.selection}\n                theme={p.theme}\n                trailingRowType={p.trailingRowType}\n                translateX={p.translateX}\n                translateY={p.translateY}\n                verticalBorder={p.verticalBorder}\n                drawCustomCell={p.drawCustomCell}\n                drawFocusRing={p.drawFocusRing}\n                drawHeader={p.drawHeader}\n                experimental={p.experimental}\n                gridRef={p.gridRef}\n                headerIcons={p.headerIcons}\n                isDraggable={p.isDraggable}\n                onCanvasBlur={p.onCanvasBlur}\n                onCanvasFocused={p.onCanvasFocused}\n                onCellFocused={p.onCellFocused}\n                onColumnMoved={p.onColumnMoved}\n                onColumnResize={p.onColumnResize}\n                onColumnResizeEnd={p.onColumnResizeEnd}\n                onColumnResizeStart={p.onColumnResizeStart}\n                onContextMenu={p.onContextMenu}\n                onDragEnd={p.onDragEnd}\n                onDragLeave={p.onDragLeave}\n                onDragOverCell={p.onDragOverCell}\n                onDragStart={p.onDragStart}\n                onDrop={p.onDrop}\n                onItemHovered={p.onItemHovered}\n                onKeyDown={p.onKeyDown}\n                onKeyUp={p.onKeyUp}\n                onMouseDown={p.onMouseDown}\n                onMouseUp={p.onMouseUp}\n                onRowMoved={p.onRowMoved}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n            />\n        </InfiniteScroller>\n    );\n};\n\nexport default GridScroller;\n","import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport type { StoryContext } from \"@storybook/addons\";\nimport \"react-responsive-carousel/lib/styles/carousel.min.css\";\n\ninterface Props {\n    width: number;\n    height: number;\n    useMoreTopPadding?: boolean;\n    figmaDoc?: string;\n    context?: StoryContext;\n}\n\nconst BuilderWrapper = styled.div<Pick<Props, \"width\" | \"height\">>`\n    display: flex;\n    height: 100vh;\n    width: 100vw;\n    position: relative;\n\n    & > .content {\n        display: block;\n\n        width: ${p => p.width}px;\n        height: ${p => p.height}px;\n        align-self: center;\n\n        position: relative;\n\n        text-rendering: optimizeLegibility;\n        -webkit-font-smoothing: antialiased;\n\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n\n        user-select: none;\n\n        box-sizing: border-box;\n\n        *,\n        *::before,\n        *::after {\n            box-sizing: inherit;\n        }\n    }\n`;\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nexport class BuilderThemeWrapper extends React.PureComponent<React.PropsWithChildren<Props>> {\n    public render(): React.ReactNode {\n        const { context, children, ...rest } = this.props;\n        return (\n            <>\n                <BuilderWrapper {...rest}>\n                    <div className=\"content\">{children}</div>\n                </BuilderWrapper>\n                <div id=\"portal\" />\n            </>\n        );\n    }\n}\n\nexport const SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n","import * as React from \"react\";\nimport type { DataEditorProps, GridColumn } from \"@glideapps/glide-data-grid\";\nimport orderBy from \"lodash/orderBy.js\";\n\nfunction colToKey(c: GridColumn) {\n    return c.id ?? `${c.group ?? \"\"}/${c.title}`;\n}\n\nfunction looseCompareCol(a: GridColumn, b: GridColumn | string): boolean {\n    if (typeof b === \"string\") {\n        return colToKey(a) === b;\n    }\n    return colToKey(a) === colToKey(b);\n}\n\nfunction getSortIndexByKey(needle: GridColumn, current: readonly GridColumn[], keys: readonly string[]) {\n    const index = current.indexOf(needle);\n    if (index === -1) return Number.MAX_SAFE_INTEGER; // should never happen\n\n    // if we can directly remap we will\n    const remapped = keys.findIndex(key => looseCompareCol(needle, key));\n    if (remapped !== -1) return remapped;\n\n    // look for its nearlest lefthand neighbor we can remap, and give a partial index\n    for (let n = index; n >= 0; n--) {\n        const ind = keys.findIndex(key => looseCompareCol(current[n], key));\n        if (ind !== -1) return ind + 0.5;\n    }\n\n    return -1;\n}\n\ntype Props = Pick<DataEditorProps, \"columns\" | \"onColumnMoved\" | \"getCellContent\">;\n\n// this cannot actually be made transparent to the user. Doing so would break things like\n// selection rnages being rectangular. The mangled columns need to actually be returned to the\n// user so they can be referenced and understood correctly in other callbacks they may provide\n\n// Darn\nexport function useMoveableColumns(p: Props): Required<Props> {\n    const { columns: columnsIn, getCellContent: getCellContentIn, onColumnMoved: onColumnMovedIn } = p;\n\n    const [keys, setKeys] = React.useState(() => columnsIn.map(colToKey));\n\n    const columns = React.useMemo(() => {\n        return orderBy(columnsIn, c => getSortIndexByKey(c, columnsIn, keys));\n    }, [keys, columnsIn]);\n\n    const onColumnMovedRef = React.useRef(onColumnMovedIn);\n    onColumnMovedRef.current = onColumnMovedIn;\n    const onColumnMoved = React.useCallback((startIndex: number, endIndex: number) => {\n        setKeys(old => {\n            const newCols = [...old];\n            const [toMove] = newCols.splice(startIndex, 1);\n            newCols.splice(endIndex, 0, toMove);\n            return newCols;\n        });\n        onColumnMovedRef.current?.(startIndex, endIndex);\n    }, []);\n\n    React.useEffect(() => {\n        setKeys(cv => {\n            return orderBy(columnsIn, x => getSortIndexByKey(x, columnsIn, cv)).map(colToKey);\n        });\n    }, [columnsIn]);\n\n    const getCellContent = React.useCallback<typeof getCellContentIn>(\n        cell => {\n            const [col, row] = cell;\n            const needle = columns[col];\n            const index = columnsIn.indexOf(needle);\n            return getCellContentIn([index, row]);\n        },\n        [columns, columnsIn, getCellContentIn]\n    );\n\n    return {\n        columns,\n        onColumnMoved,\n        getCellContent,\n    };\n}\n","import { DataEditorProps, GridCell, GridCellKind, GridColumn } from \"@glideapps/glide-data-grid\";\nimport range from \"lodash/range.js\";\nimport * as React from \"react\";\n\nfunction cellToSortData(c: GridCell): string {\n    switch (c.kind) {\n        case GridCellKind.Number:\n            return c.data?.toString() ?? \"\";\n        case GridCellKind.Boolean:\n            return c.data?.toString() ?? \"\";\n        case GridCellKind.Markdown:\n        case GridCellKind.RowID:\n        case GridCellKind.Text:\n        case GridCellKind.Uri:\n            return c.data ?? \"\";\n        case GridCellKind.Bubble:\n        case GridCellKind.Image:\n            return c.data.join(\"\");\n        case GridCellKind.Drilldown:\n            return c.data.map(x => x.text).join(\"\");\n        case GridCellKind.Protected:\n        case GridCellKind.Loading:\n            return \"\";\n        case GridCellKind.Custom:\n            return c.copyData;\n    }\n}\n\nfunction tryParse(val: string | number): number | string {\n    if (typeof val === \"number\") return val;\n    if (val.length > 0) {\n        const x = parseFloat(val);\n        if (!isNaN(x)) {\n            val = x;\n        }\n    }\n    return val;\n}\n\nexport function compareSmart(a: string | number, b: string | number): number {\n    a = tryParse(a);\n    b = tryParse(b);\n    if (typeof a === \"string\" && typeof b === \"string\") {\n        return a.localeCompare(b);\n    } else if (typeof a === \"number\" && typeof b === \"number\") {\n        if (a === b) return 0;\n        return a > b ? 1 : -1;\n    } else if (a == b) {\n        return 0;\n    }\n    return a > b ? 1 : -1;\n}\n\nexport function compareRaw(a: string | number, b: string | number) {\n    if (a > b) return 1;\n    if (a === b) return 0;\n    return -1;\n}\n\ntype Props = Pick<DataEditorProps, \"getCellContent\" | \"rows\" | \"columns\"> & {\n    sort?: {\n        column: GridColumn;\n        mode?: \"default\" | \"raw\" | \"smart\";\n        direction?: \"asc\" | \"desc\";\n    };\n};\ntype Result = Pick<DataEditorProps, \"getCellContent\"> & {\n    getOriginalIndex: (index: number) => number;\n};\n\nexport function useColumnSort(p: Props): Result {\n    const { sort, rows, getCellContent: getCellContentIn } = p;\n\n    let sortCol =\n        sort === undefined\n            ? undefined\n            : p.columns.findIndex(c => sort.column === c || (c.id !== undefined && sort.column.id === c.id));\n    if (sortCol === -1) sortCol = undefined;\n\n    // This scales to about 100k rows. Beyond that things take a pretty noticeable amount of time\n    // The performance \"issue\" from here on out seems to be the lookup to get the value. Not sure\n    // what to do there. We need the indirection to produce the final sort map. Perhaps someone\n    // more clever than me will wander in and save most of that time.\n    const dir = sort?.direction ?? \"asc\";\n    const sortMap = React.useMemo(() => {\n        if (sortCol === undefined) return undefined;\n        const vals: string[] = new Array(rows);\n\n        const index: [number, number] = [sortCol, 0];\n        for (let i = 0; i < rows; i++) {\n            index[1] = i;\n            vals[i] = cellToSortData(getCellContentIn(index));\n        }\n\n        let result: number[];\n        if (sort?.mode === \"raw\") {\n            result = range(rows).sort((a, b) => compareRaw(vals[a], vals[b]));\n        } else if (sort?.mode === \"smart\") {\n            result = range(rows).sort((a, b) => compareSmart(vals[a], vals[b]));\n        } else {\n            result = range(rows).sort((a, b) => vals[a].localeCompare(vals[b]));\n        }\n        if (dir === \"desc\") {\n            result.reverse();\n        }\n        return result;\n    }, [getCellContentIn, rows, sort?.mode, dir, sortCol]);\n\n    const getOriginalIndex = React.useCallback(\n        (index: number): number => {\n            if (sortMap === undefined) return index;\n            return sortMap[index];\n        },\n        [sortMap]\n    );\n\n    const getCellContent = React.useCallback<typeof getCellContentIn>(\n        ([col, row]) => {\n            if (sortMap === undefined) return getCellContentIn([col, row]);\n            row = sortMap[row];\n            return getCellContentIn([col, row]);\n        },\n        [getCellContentIn, sortMap]\n    );\n\n    if (sortMap === undefined) {\n        return { getCellContent: p.getCellContent, getOriginalIndex };\n    }\n\n    return {\n        getOriginalIndex,\n        getCellContent,\n    };\n}\n","import type { GridSelection, DataEditorProps, Theme } from \"@glideapps/glide-data-grid\";\nimport React from \"react\";\n\ntype Props = Pick<\n    DataEditorProps,\n    \"columns\" | \"onGroupHeaderClicked\" | \"onGridSelectionChange\" | \"getGroupDetails\" | \"gridSelection\" | \"freezeColumns\"\n> & { theme: Theme };\n\ntype Result = Pick<\n    DataEditorProps,\n    \"columns\" | \"onGroupHeaderClicked\" | \"onGridSelectionChange\" | \"getGroupDetails\" | \"gridSelection\"\n>;\n\nexport function useCollapsingGroups(props: Props): Result {\n    const [collapsed, setCollapsed] = React.useState<readonly string[]>([]);\n    const [gridSelectionInner, setGridSelectionsInner] = React.useState<GridSelection | undefined>(undefined);\n\n    const {\n        columns: columnsIn,\n        onGroupHeaderClicked: onGroupHeaderClickedIn,\n        onGridSelectionChange: onGridSelectionChangeIn,\n        getGroupDetails: getGroupDetailsIn,\n        gridSelection: gridSelectionIn,\n        freezeColumns = 0,\n        theme,\n    } = props;\n\n    const gridSelection = gridSelectionIn ?? gridSelectionInner;\n\n    const spans = React.useMemo(() => {\n        const result: [number, number][] = [];\n        let current: [number, number] = [-1, -1];\n        let lastGroup: string | undefined;\n        for (let i = freezeColumns; i < columnsIn.length; i++) {\n            const c = columnsIn[i];\n            const group = c.group ?? \"\";\n            const isCollapsed = collapsed.includes(group);\n\n            if (lastGroup !== group && current[0] !== -1) {\n                result.push(current);\n                current = [-1, -1];\n            }\n\n            if (isCollapsed && current[0] !== -1) {\n                current[1] += 1;\n            } else if (isCollapsed) {\n                current = [i, 1];\n            } else if (current[0] !== -1) {\n                result.push(current);\n                current = [-1, -1];\n            }\n            lastGroup = group;\n        }\n        if (current[0] !== -1) result.push(current);\n        return result;\n    }, [collapsed, columnsIn, freezeColumns]);\n\n    const columns = React.useMemo(() => {\n        if (spans.length === 0) return columnsIn;\n        return columnsIn.map((c, index) => {\n            for (const [start, length] of spans) {\n                if (index >= start && index < start + length) {\n                    let width = 8;\n                    if (index === start + length - 1) {\n                        width = 36;\n                    }\n\n                    return {\n                        ...c,\n                        width,\n                        themeOverride: { bgCell: theme.bgCellMedium },\n                    };\n                }\n            }\n            return c;\n        });\n    }, [columnsIn, spans, theme.bgCellMedium]);\n\n    const onGroupHeaderClicked = React.useCallback<NonNullable<Props[\"onGroupHeaderClicked\"]>>(\n        (index, a) => {\n            onGroupHeaderClickedIn?.(index, a);\n\n            const group = columns[index]?.group ?? \"\";\n            if (group === \"\") return;\n            a.preventDefault();\n            setCollapsed(cv => (cv.includes(group) ? cv.filter(x => x !== group) : [...cv, group]));\n        },\n        [columns, onGroupHeaderClickedIn]\n    );\n\n    const onGridSelectionChange = React.useCallback<NonNullable<Props[\"onGridSelectionChange\"]>>(\n        s => {\n            if (s.current !== undefined) {\n                const col = s.current.cell[0];\n                const column = columns[col];\n                setCollapsed(cv => {\n                    if (cv.includes(column?.group ?? \"\")) {\n                        return cv.filter(g => g !== column.group);\n                    }\n                    return cv;\n                });\n            }\n            if (onGridSelectionChangeIn !== undefined) {\n                onGridSelectionChangeIn(s);\n            } else {\n                setGridSelectionsInner(s);\n            }\n        },\n        [columns, onGridSelectionChangeIn]\n    );\n\n    const getGroupDetails = React.useCallback<NonNullable<Props[\"getGroupDetails\"]>>(\n        group => {\n            const result = getGroupDetailsIn?.(group);\n\n            return {\n                ...result,\n                name: group,\n                overrideTheme: collapsed.includes(group ?? \"\")\n                    ? {\n                          bgHeader: theme.bgHeaderHasFocus,\n                      }\n                    : undefined,\n            };\n        },\n        [collapsed, getGroupDetailsIn, theme.bgHeaderHasFocus]\n    );\n\n    return {\n        columns,\n        onGroupHeaderClicked,\n        onGridSelectionChange,\n        getGroupDetails,\n        gridSelection,\n    };\n}\n","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"react-resize-detector\";\nimport { DataEditor, DataEditorProps, GridCellKind, GridColumn, Theme } from \"@glideapps/glide-data-grid\";\nimport faker from \"faker\";\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \".\";\n\nfaker.seed(1337);\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Source\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nconst testTheme: Theme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n\n    bgSearchResult: \"#fff9e3\",\n\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    horizontalBorderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n\n    linkColor: \"#4F5DFF\",\n\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4,\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst cols: GridColumn[] = [\n    {\n        title: \"A\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"B\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"C\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"D\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"E\",\n        width: 200,\n        group: \"Group 2\",\n    },\n];\n\nexport const UseDataSource: React.VFC = () => {\n    const cache = React.useRef<Record<string, string>>({});\n\n    const rows = 100_000;\n\n    const moveArgs = useMoveableColumns({\n        columns: cols,\n        getCellContent: React.useCallback(([col, row]) => {\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    data: `${row}`,\n                    displayData: `${row}`,\n                };\n            }\n\n            const key = `${col},${row}`;\n            if (cache.current[key] === undefined) {\n                cache.current[key] = faker.name.firstName() + \" \" + faker.name.lastName();\n            }\n            const d = cache.current[key];\n\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: d,\n                displayData: d,\n            };\n        }, []),\n    });\n\n    const [sort, setSort] = React.useState<number>();\n\n    const sortArgs = useColumnSort({\n        columns: moveArgs.columns,\n        getCellContent: moveArgs.getCellContent,\n        rows,\n        sort:\n            sort === undefined\n                ? undefined\n                : {\n                      column: moveArgs.columns[sort],\n                      direction: \"desc\",\n                      mode: \"smart\",\n                  },\n    });\n\n    const collapseArgs = useCollapsingGroups({\n        columns: moveArgs.columns,\n        theme: testTheme,\n        freezeColumns: 0,\n    });\n\n    const onHeaderClick = React.useCallback((index: number) => {\n        setSort(index);\n    }, []);\n\n    return (\n        <BeautifulWrapper title=\"Custom source extensions\" description={<Description>Fixme.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...moveArgs}\n                {...sortArgs}\n                {...collapseArgs}\n                rows={rows}\n                onColumnMoved={moveArgs.onColumnMoved}\n                onHeaderClicked={onHeaderClick}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UseDataSource as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n","import '@storybook/react';","var map = {\n\t\"./packages/cells/src/cell.stories.tsx\": \"./packages/cells/src/cell.stories.tsx\",\n\t\"./packages/core/src/data-editor/stories/data-editor-async.stories.tsx\": \"./packages/core/src/data-editor/stories/data-editor-async.stories.tsx\",\n\t\"./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx\": \"./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx\",\n\t\"./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx\": \"./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx\",\n\t\"./packages/core/src/data-editor/stories/data-editor.stories.tsx\": \"./packages/core/src/data-editor/stories/data-editor.stories.tsx\",\n\t\"./packages/core/src/data-grid/data-grid.stories.tsx\": \"./packages/core/src/data-grid/data-grid.stories.tsx\",\n\t\"./packages/core/src/docs/00-faq.stories.tsx\": \"./packages/core/src/docs/00-faq.stories.tsx\",\n\t\"./packages/core/src/docs/01-getting-started.stories.tsx\": \"./packages/core/src/docs/01-getting-started.stories.tsx\",\n\t\"./packages/core/src/docs/02-editing-data.stories.tsx\": \"./packages/core/src/docs/02-editing-data.stories.tsx\",\n\t\"./packages/core/src/docs/03-grid-column.stories.tsx\": \"./packages/core/src/docs/03-grid-column.stories.tsx\",\n\t\"./packages/core/src/docs/04-streaming-data.stories.tsx\": \"./packages/core/src/docs/04-streaming-data.stories.tsx\",\n\t\"./packages/core/src/docs/05-copy-paste.stories.tsx\": \"./packages/core/src/docs/05-copy-paste.stories.tsx.tsx\",\n\t\"./packages/core/src/docs/06-search.stories.tsx\": \"./packages/core/src/docs/06-search.stories.tsx\",\n\t\"./packages/core/src/docs/07-column-grouping.stories.tsx\": \"./packages/core/src/docs/07-column-grouping.stories.tsx\",\n\t\"./packages/core/src/docs/08-theming.stories.tsx\": \"./packages/core/src/docs/08-theming.stories.tsx\",\n\t\"./packages/core/src/docs/09-menus.stories.tsx\": \"./packages/core/src/docs/09-menus.stories.tsx\",\n\t\"./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx\": \"./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx\",\n\t\"./packages/source/src/use-data-source.stories.tsx\": \"./packages/source/src/use-data-source.stories.tsx\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./. sync recursive ^\\\\.(?:(?:^%7C\\\\/%7C(?:(?:(?%21(?:^%7C\\\\/)\\\\.).)*?)\\\\/)src(?:\\\\/(?%21\\\\.)(?:(?:(?%21(?:^%7C\\\\/)\\\\.).)*?)\\\\/%7C\\\\/%7C$)(?%21\\\\.)(?=.)[^/]*?\\\\.stories\\\\.tsx)$\";","/* (ignored) */","\"use strict\";\n\nvar _frameworkImportPath = require(\"@storybook/react\");\n\n/* eslint-disable import/no-unresolved */\n(0, _frameworkImportPath.configure)([require.context('.', true, /^\\.(?:(?:^|\\/|(?:(?:(?!(?:^|\\/)\\.).)*?)\\/)src(?:\\/(?!\\.)(?:(?:(?!(?:^|\\/)\\.).)*?)\\/|\\/|$)(?!\\.)(?=.)[^/]*?\\.stories\\.tsx)$/)], module, false);","function memoize(fn) {\n  var cache = {};\n  return function (arg) {\n    if (cache[arg] === undefined) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\n\nexport default memoize;\n","import memoize from '@emotion/memoize';\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar index = memoize(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */\n  && prop.charCodeAt(1) === 110\n  /* n */\n  && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */\n);\n\nexport default index;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * This file contains an runtime version of `styled` component. Responsibilities of the component are:\n * - returns ReactElement based on HTML tag used with `styled` or custom React Component\n * - injects classNames for the returned component\n * - injects CSS variables used to define dynamic styles based on props\n */\nimport validAttr from '@emotion/is-prop-valid';\nimport React from 'react';\n\nimport { cx } from '@linaria/core';\nimport type { CSSProperties, StyledMeta } from '@linaria/core';\n\nexport type NoInfer<A> = [A][A extends any ? 0 : never];\n\ntype Component<TProps> =\n  | ((props: TProps) => unknown)\n  | { new (props: TProps): unknown };\n\ntype Has<T, TObj> = [T] extends [TObj] ? T : T & TObj;\n\ntype Options = {\n  name: string;\n  class: string;\n  atomic?: boolean;\n  vars?: {\n    [key: string]: [\n      string | number | ((props: unknown) => string | number),\n      string | void\n    ];\n  };\n};\n\nconst isCapital = (ch: string): boolean => ch.toUpperCase() === ch;\nconst filterKey =\n  <TExclude extends keyof any>(keys: TExclude[]) =>\n  <TAll extends keyof any>(key: TAll): key is Exclude<TAll, TExclude> =>\n    keys.indexOf(key as any) === -1;\n\nexport const omit = <T extends Record<string, unknown>, TKeys extends keyof T>(\n  obj: T,\n  keys: TKeys[]\n): Omit<T, TKeys> => {\n  const res = {} as Omit<T, TKeys>;\n  Object.keys(obj)\n    .filter(filterKey(keys))\n    .forEach((key) => {\n      res[key] = obj[key];\n    });\n\n  return res;\n};\n\nfunction filterProps<T extends Record<string, unknown>, TKeys extends keyof T>(\n  component: string | unknown,\n  props: T,\n  omitKeys: TKeys[]\n): Partial<Omit<T, TKeys>> {\n  const filteredProps = omit(props, omitKeys) as Partial<T>;\n\n  // Check if it's an HTML tag and not a custom element\n  if (\n    typeof component === 'string' &&\n    component.indexOf('-') === -1 &&\n    !isCapital(component[0])\n  ) {\n    Object.keys(filteredProps).forEach((key) => {\n      if (!validAttr(key)) {\n        // Don't pass through invalid attributes to HTML elements\n        delete filteredProps[key];\n      }\n    });\n  }\n\n  return filteredProps;\n}\n\nconst warnIfInvalid = (value: unknown, componentName: string) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      typeof value === 'string' ||\n      // eslint-disable-next-line no-self-compare,no-restricted-globals\n      (typeof value === 'number' && isFinite(value))\n    ) {\n      return;\n    }\n\n    const stringified =\n      typeof value === 'object' ? JSON.stringify(value) : String(value);\n\n    // eslint-disable-next-line no-console\n    console.warn(\n      `An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`\n    );\n  }\n};\n\ninterface IProps {\n  className?: string;\n  style?: Record<string, string>;\n  [props: string]: unknown;\n}\n\n// Property-based interpolation is allowed only if `style` property exists\nfunction styled<\n  TProps extends Has<TMustHave, { style?: React.CSSProperties }>,\n  TMustHave extends { style?: React.CSSProperties },\n  TConstructor extends Component<TProps>\n>(\n  componentWithStyle: TConstructor & Component<TProps>\n): ComponentStyledTagWithInterpolation<TProps, TConstructor>;\n// If styled wraps custom component, that component should have className property\nfunction styled<\n  TProps extends Has<TMustHave, { className?: string }>,\n  TMustHave extends { className?: string },\n  TConstructor extends Component<TProps>\n>(\n  componentWithoutStyle: TConstructor & Component<TProps>\n): ComponentStyledTagWithoutInterpolation<TConstructor>;\nfunction styled<TName extends keyof JSX.IntrinsicElements>(\n  tag: TName\n): HtmlStyledTag<TName>;\nfunction styled(\n  component: 'The target component should have a className prop'\n): never;\nfunction styled(tag: any): any {\n  return (options: Options) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (Array.isArray(options)) {\n        // We received a strings array since it's used as a tag\n        throw new Error(\n          'Using the \"styled\" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup'\n        );\n      }\n    }\n\n    const render = (props: any, ref: any) => {\n      const { as: component = tag, class: className } = props;\n      const filteredProps: IProps = filterProps(component, props, [\n        'as',\n        'class',\n      ]);\n\n      filteredProps.ref = ref;\n      filteredProps.className = options.atomic\n        ? cx(options.class, filteredProps.className || className)\n        : cx(filteredProps.className || className, options.class);\n\n      const { vars } = options;\n\n      if (vars) {\n        const style: { [key: string]: string } = {};\n\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const name in vars) {\n          const variable = vars[name];\n          const result = variable[0];\n          const unit = variable[1] || '';\n          const value = typeof result === 'function' ? result(props) : result;\n\n          warnIfInvalid(value, options.name);\n\n          style[`--${name}`] = `${value}${unit}`;\n        }\n\n        const ownStyle = filteredProps.style || {};\n        const keys = Object.keys(ownStyle);\n        if (keys.length > 0) {\n          keys.forEach((key) => {\n            style[key] = ownStyle[key];\n          });\n        }\n\n        filteredProps.style = style;\n      }\n\n      if ((tag as any).__linaria && tag !== component) {\n        // If the underlying tag is a styled component, forward the `as` prop\n        // Otherwise the styles from the underlying component will be ignored\n        filteredProps.as = component;\n\n        return React.createElement(tag, filteredProps);\n      }\n      return React.createElement(component, filteredProps);\n    };\n\n    const Result = React.forwardRef\n      ? React.forwardRef(render)\n      : // React.forwardRef won't available on older React versions and in Preact\n        // Fallback to a innerRef prop in that case\n        (props: any) => {\n          const rest = omit(props, ['innerRef']);\n          return render(rest, props.innerRef);\n        };\n\n    (Result as any).displayName = options.name;\n\n    // These properties will be read by the babel plugin for interpolation\n    (Result as any).__linaria = {\n      className: options.class,\n      extends: tag,\n    };\n\n    return Result;\n  };\n}\n\ntype StyledComponent<T> = StyledMeta &\n  ([T] extends [React.FunctionComponent<any>]\n    ? T\n    : React.FunctionComponent<T & { as?: React.ElementType }>);\n\ntype StaticPlaceholder = string | number | CSSProperties | StyledMeta;\n\ntype HtmlStyledTag<TName extends keyof JSX.IntrinsicElements> = <\n  TAdditionalProps = Record<string, unknown>\n>(\n  strings: TemplateStringsArray,\n  ...exprs: Array<\n    | StaticPlaceholder\n    | ((\n        // Without Omit here TS tries to infer TAdditionalProps\n        // from a component passed for interpolation\n        props: JSX.IntrinsicElements[TName] & Omit<TAdditionalProps, never>\n      ) => string | number)\n  >\n) => StyledComponent<JSX.IntrinsicElements[TName] & TAdditionalProps>;\n\ntype ComponentStyledTagWithoutInterpolation<TOrigCmp> = (\n  strings: TemplateStringsArray,\n  ...exprs: Array<\n    | StaticPlaceholder\n    | ((props: 'The target component should have a style prop') => never)\n  >\n) => StyledMeta & TOrigCmp;\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype ComponentStyledTagWithInterpolation<TTrgProps, TOrigCmp> = <OwnProps = {}>(\n  strings: TemplateStringsArray,\n  ...exprs: Array<\n    | StaticPlaceholder\n    | ((props: NoInfer<OwnProps & TTrgProps>) => string | number)\n  >\n) => keyof OwnProps extends never\n  ? StyledMeta & TOrigCmp\n  : StyledComponent<OwnProps & TTrgProps>;\n\ntype StyledJSXIntrinsics = {\n  readonly [P in keyof JSX.IntrinsicElements]: HtmlStyledTag<P>;\n};\n\nexport type Styled = typeof styled & StyledJSXIntrinsics;\n\nexport default (process.env.NODE_ENV !== 'production'\n  ? new Proxy(styled, {\n      get(o, prop: keyof JSX.IntrinsicElements) {\n        return o(prop);\n      },\n    })\n  : styled) as Styled;\n","export type LinariaClassName = string & { __linariaClassName: true };\n\nexport type ClassName<T = string> = T | false | void | null | 0 | '';\n\ninterface ICX {\n  (...classNames: ClassName<LinariaClassName>[]): LinariaClassName;\n  (...classNames: ClassName[]): string;\n}\n/**\n * Takes a list of class names and filters for truthy ones, joining them into a single class name for convenience.\n * eg.\n * ```js\n *  cx('red', isBig && 'big') // returns 'red big' if `isBig` is true, otherwise returns 'red'\n * ```\n * If space separated atomic styles are provided, they are deduplicated according to the first hashed valued:\n *\n * ```js\n *  cx('atm_a_class1 atm_b_class2', 'atm_a_class3') // returns `atm_a_class3 atm_b_class2`\n * ```\n *\n * @returns the combined, space separated class names that can be applied directly to the class attribute\n */\nconst cx: ICX = function cx() {\n  const presentClassNames: (ClassName | ClassName<LinariaClassName>)[] =\n    Array.prototype.slice\n      // eslint-disable-next-line prefer-rest-params\n      .call(arguments)\n      .filter(Boolean);\n\n  const atomicClasses: { [k: string]: string } = {};\n  const nonAtomicClasses: string[] = [];\n  presentClassNames.forEach((arg) => {\n    // className could be the output of a previous cx call, so split by ' ' first\n    const individualClassNames = arg ? arg.split(' ') : [];\n\n    individualClassNames.forEach((className) => {\n      if (className.startsWith('atm_')) {\n        const [, keyHash] = className.split('_');\n        atomicClasses[keyHash] = className;\n      } else {\n        nonAtomicClasses.push(className);\n      }\n    });\n  });\n\n  const result: string[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const keyHash in atomicClasses) {\n    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {\n      result.push(atomicClasses[keyHash]);\n    }\n  }\n\n  result.push(...nonAtomicClasses);\n\n  return result.join(' ') as LinariaClassName;\n};\n\nexport default cx;\n","/* eslint-disable sonarjs/no-duplicate-string */\nimport * as React from \"react\";\nimport { assert, assertNever, maybe } from \"../common/support\";\nimport clamp from \"lodash/clamp.js\";\nimport uniq from \"lodash/uniq.js\";\nimport flatten from \"lodash/flatten.js\";\nimport range from \"lodash/range.js\";\nimport debounce from \"lodash/debounce.js\";\nimport DataGridOverlayEditor from \"../data-grid-overlay-editor/data-grid-overlay-editor\";\nimport {\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridDragEventArgs,\n    GridKeyEventArgs,\n    GridMouseEventArgs,\n    GridSelection,\n    isEditableGridCell,\n    Rectangle,\n    isReadWriteCell,\n    InnerGridCell,\n    InnerGridCellKind,\n    CompactSelection,\n    Slice,\n    isInnerOnlyCell,\n    ProvideEditorCallback,\n    DrawCustomCellCallback,\n    GridMouseCellEventArgs,\n    GridColumn,\n    isObjectEditorCallbackResult,\n    GroupHeaderClickedEventArgs,\n    HeaderClickedEventArgs,\n    CellClickedEventArgs,\n    Item,\n    MarkerCell,\n    headerCellUnheckedMarker,\n    headerCellCheckedMarker,\n    headerCellIndeterminateMarker,\n    groupHeaderKind,\n    outOfBoundsKind,\n    ValidatedGridCell,\n    ImageEditorType,\n    CustomCell,\n} from \"../data-grid/data-grid-types\";\nimport DataGridSearch, { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport { browserIsOSX } from \"../common/browser-detect\";\nimport { getDataEditorTheme, makeCSSStyle, Theme, ThemeContext } from \"../common/styles\";\nimport type { DataGridRef } from \"../data-grid/data-grid\";\nimport { getScrollBarWidth, useEventListener, useStateWithReactiveInput, whenDefined } from \"../common/utils\";\nimport { isGroupEqual } from \"../data-grid/data-grid-lib\";\nimport { GroupRename } from \"./group-rename\";\nimport { measureColumn, useColumnSizer } from \"./use-column-sizer\";\nimport { isHotkey } from \"../common/is-hotkey\";\nimport { SelectionBlending, useSelectionBehavior } from \"../data-grid/use-selection-behavior\";\nimport { useCellsForSelection } from \"./use-cells-for-selection\";\nimport { unquote, expandSelection, copyToClipboard, decodeHTML } from \"./data-editor-fns\";\nimport { DataEditorContainer } from \"../data-editor-container/data-grid-container\";\nimport { toggleBoolean } from \"../data-grid/cells/boolean-cell\";\nimport { useAutoscroll } from \"./use-autoscroll\";\nimport type { CustomRenderer, CellRenderer } from \"../data-grid/cells/cell-types\";\nimport { CellRenderers } from \"../data-grid/cells\";\n\nlet idCounter = 0;\n\ninterface MouseState {\n    readonly previousSelection?: GridSelection;\n    readonly fillHandle?: boolean;\n}\n\ntype Props = Partial<\n    Omit<\n        DataGridSearchProps,\n        | \"accessibilityHeight\"\n        | \"canvasRef\"\n        | \"cellXOffset\"\n        | \"cellYOffset\"\n        | \"className\"\n        | \"clientSize\"\n        | \"columns\"\n        | \"disabledRows\"\n        | \"drawCustomCell\"\n        | \"enableGroups\"\n        | \"firstColAccessible\"\n        | \"firstColSticky\"\n        | \"freezeColumns\"\n        | \"getCellContent\"\n        | \"getCellRenderer\"\n        | \"getCellsForSelection\"\n        | \"gridRef\"\n        | \"groupHeaderHeight\"\n        | \"headerHeight\"\n        | \"isFilling\"\n        | \"isFocused\"\n        | \"lockColumns\"\n        | \"maxColumnWidth\"\n        | \"minColumnWidth\"\n        | \"onCanvasBlur\"\n        | \"onCanvasFocused\"\n        | \"onCellFocused\"\n        | \"onContextMenu\"\n        | \"onDragEnd\"\n        | \"onMouseDown\"\n        | \"onMouseMove\"\n        | \"onMouseUp\"\n        | \"onSearchResultsChanged\"\n        | \"onVisibleRegionChanged\"\n        | \"rowHeight\"\n        | \"rows\"\n        | \"scrollRef\"\n        | \"searchColOffset\"\n        | \"searchInputRef\"\n        | \"selectedColumns\"\n        | \"selection\"\n        | \"theme\"\n        | \"trailingRowType\"\n        | \"translateX\"\n        | \"translateY\"\n        | \"verticalBorder\"\n    >\n>;\n\ntype EditListItem = { location: Item; value: EditableGridCell };\n\ntype EmitEvents = \"copy\" | \"paste\" | \"delete\" | \"fill-right\" | \"fill-down\";\n\nfunction getSpanStops(cells: readonly (readonly GridCell[])[]): number[] {\n    return uniq(\n        flatten(\n            flatten(cells)\n                .filter(c => c.span !== undefined)\n                .map(c => range((c.span?.[0] ?? 0) + 1, (c.span?.[1] ?? 0) + 1))\n        )\n    );\n}\n\nfunction shiftSelection(input: GridSelection, offset: number): GridSelection {\n    if (input === undefined || offset === 0 || (input.columns.length === 0 && input.current === undefined))\n        return input;\n\n    return {\n        current:\n            input.current === undefined\n                ? undefined\n                : {\n                      cell: [input.current.cell[0] + offset, input.current.cell[1]],\n                      range: {\n                          ...input.current.range,\n                          x: input.current.range.x + offset,\n                      },\n                      rangeStack: input.current.rangeStack.map(r => ({\n                          ...r,\n                          x: r.x + offset,\n                      })),\n                  },\n        rows: input.rows,\n        columns: input.columns.offset(offset),\n    };\n}\n\ninterface Keybinds {\n    readonly selectAll: boolean;\n    readonly selectRow: boolean;\n    readonly selectColumn: boolean;\n    readonly downFill: boolean;\n    readonly rightFill: boolean;\n    readonly pageUp: boolean;\n    readonly pageDown: boolean;\n    readonly clear: boolean;\n    readonly copy: boolean;\n    readonly paste: boolean;\n    readonly search: boolean;\n    readonly first: boolean;\n    readonly last: boolean;\n}\n\nconst keybindingDefaults: Keybinds = {\n    selectAll: true,\n    selectRow: true,\n    selectColumn: true,\n    downFill: false,\n    rightFill: false,\n    pageUp: false,\n    pageDown: false,\n    clear: true,\n    copy: true,\n    paste: true,\n    search: false,\n    first: true,\n    last: true,\n};\n\n/**\n * @category DataEditor\n */\nexport interface DataEditorProps extends Props {\n    /** Emitted whenever the user has requested the deletion of the selection.\n     * @group Editing\n     */\n    readonly onDelete?: (selection: GridSelection) => boolean | GridSelection;\n    /** Emitted whenever a cell edit is completed.\n     * @group Editing\n     */\n    readonly onCellEdited?: (cell: Item, newValue: EditableGridCell) => void;\n    /** Emitted whenever a cell mutation is completed and provides all edits inbound as a single batch.\n     * @group Editing\n     */\n    readonly onCellsEdited?: (newValues: readonly EditListItem[]) => boolean | void;\n    /** Emitted whenever a row append operation is requested. Append location can be set in callback.\n     * @group Editing\n     */\n    readonly onRowAppended?: () => Promise<\"top\" | \"bottom\" | number | undefined> | void;\n    /** Emitted when a column header should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onHeaderClicked?: (colIndex: number, event: HeaderClickedEventArgs) => void;\n    /** Emitted when a group header is clicked.\n     * @group Events\n     */\n    readonly onGroupHeaderClicked?: (colIndex: number, event: GroupHeaderClickedEventArgs) => void;\n    /** Emitted whe the user wishes to rename a group.\n     * @group Events\n     */\n    readonly onGroupHeaderRenamed?: (groupName: string, newVal: string) => void;\n    /** Emitted when a cell is clicked.\n     * @group Events\n     */\n    readonly onCellClicked?: (cell: Item, event: CellClickedEventArgs) => void;\n    /** Emitted when a cell is activated, by pressing Enter, Space or double clicking it.\n     * @group Events\n     */\n    readonly onCellActivated?: (cell: Item) => void;\n    /** Emitted when editing has finished, regardless of data changing or not.\n     * @group Editing\n     */\n    readonly onFinishedEditing?: (newValue: GridCell | undefined, movement: Item) => void;\n    /** Emitted when a column header should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onHeaderContextMenu?: (colIndex: number, event: HeaderClickedEventArgs) => void;\n    /** Emitted when a group header should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onGroupHeaderContextMenu?: (colIndex: number, event: GroupHeaderClickedEventArgs) => void;\n    /** Emitted when a cell should show a context menu. Usually right click.\n     * @group Events\n     */\n    readonly onCellContextMenu?: (cell: Item, event: CellClickedEventArgs) => void;\n    /** Used for validating cell values during editing.\n     * @group Editing\n     * @param cell The cell which is being validated.\n     * @param newValue The new value being proposed.\n     * @param prevValue The previous value before the edit.\n     * @returns A return of false indicates the value will not be accepted. A value of\n     * true indicates the value will be accepted. Returning a new GridCell will immediately coerce the value to match.\n     */\n    readonly validateCell?: (\n        cell: Item,\n        newValue: EditableGridCell,\n        prevValue: GridCell\n    ) => boolean | ValidatedGridCell;\n\n    /** The columns to display in the data grid.\n     * @group Data\n     */\n    readonly columns: readonly GridColumn[];\n\n    /** Controls the trailing row used to insert new data into the grid.\n     * @group Editing\n     */\n    readonly trailingRowOptions?: {\n        /** If the trailing row should be tinted */\n        readonly tint?: boolean;\n        /** A hint string displayed on hover. Usually something like \"New row\" */\n        readonly hint?: string;\n        /** When set to true, the trailing row is always visible. */\n        readonly sticky?: boolean;\n        /** The icon to use for the cell. Either a GridColumnIcon or a member of the passed headerIcons */\n        readonly addIcon?: string;\n        /** Overrides the column to focus when a new row is created. */\n        readonly targetColumn?: number | GridColumn;\n    };\n    /** Controls the height of the header row\n     * @defaultValue 36\n     * @group Style\n     */\n    readonly headerHeight?: number;\n    /** Controls the header of the group header row\n     * @defaultValue `headerHeight`\n     * @group Style\n     */\n    readonly groupHeaderHeight?: number;\n\n    /**\n     * The number of rows in the grid.\n     * @group Data\n     */\n    readonly rows: number;\n\n    /** Determins if row markers should be automatically added to the grid.\n     * @defaultValue `none`\n     * @group Style\n     */\n    readonly rowMarkers?: \"checkbox\" | \"number\" | \"clickable-number\" | \"both\" | \"none\";\n    /**\n     * Sets the width of row markers in pixels, if unset row markers will automatically size.\n     * @group Style\n     */\n    readonly rowMarkerWidth?: number;\n    /** Changes the starting index for row markers.\n     * @defaultValue 1\n     * @group Style\n     */\n    readonly rowMarkerStartIndex?: number;\n\n    /** Sets the width of the data grid.\n     * @group Style\n     */\n    readonly width?: number | string;\n    /** Sets the height of the data grid.\n     * @group Style\n     */\n    readonly height?: number | string;\n    /** Custom classname for data grid wrapper.\n     * @group Style\n     */\n    readonly className?: string;\n\n    /** If set to `default`, `gridSelection` will be coerced to always include full spans.\n     * @group Selection\n     * @defaultValue `default`\n     */\n    readonly spanRangeBehavior?: \"default\" | \"allowPartial\";\n\n    /** Controls which types of selections can exist at the same time in the grid. If selection blending is set to\n     * exclusive, the grid will clear other types of selections when the exclusive selection is made. By default row,\n     * column, and range selections are exclusive.\n     * @group Selection\n     * @defaultValue `exclusive`\n     * */\n    readonly rangeSelectionBlending?: SelectionBlending;\n    /** {@inheritDoc rangeSelectionBlending}\n     * @group Selection\n     */\n    readonly columnSelectionBlending?: SelectionBlending;\n    /** {@inheritDoc rangeSelectionBlending}\n     * @group Selection\n     */\n    readonly rowSelectionBlending?: SelectionBlending;\n    /** Controls if multi-selection is allowed. If disabled, shift/ctrl/command clicking will work as if no modifiers\n     * are pressed.\n     *\n     * When range select is set to cell, only one cell may be selected at a time. When set to rect one one rect at a\n     * time. The multi variants allow for multiples of the rect or cell to be selected.\n     * @group Selection\n     * @defaultValue `rect`\n     */\n    readonly rangeSelect?: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\";\n    /** {@inheritDoc rangeSelect}\n     * @group Selection\n     * @defaultValue `multi`\n     */\n    readonly columnSelect?: \"none\" | \"single\" | \"multi\";\n    /** {@inheritDoc rangeSelect}\n     * @group Selection\n     * @defaultValue `multi`\n     */\n    readonly rowSelect?: \"none\" | \"single\" | \"multi\";\n\n    /** Sets the initial scroll Y offset.\n     * @see {@link scrollOffsetX}\n     * @group Advanced\n     */\n    readonly scrollOffsetY?: number;\n    /** Sets the initial scroll X offset\n     * @see {@link scrollOffsetY}\n     * @group Advanced\n     */\n    readonly scrollOffsetX?: number;\n\n    /** Determins the height of each row.\n     * @group Style\n     * @defaultValue 34\n     */\n    readonly rowHeight?: DataGridSearchProps[\"rowHeight\"];\n    /** Fires whenever the mouse moves\n     * @group Events\n     * @param args\n     */\n    readonly onMouseMove?: DataGridSearchProps[\"onMouseMove\"];\n\n    /**\n     * The minimum width a column can be resized to.\n     * @defaultValue 50\n     * @group Style\n     */\n    readonly minColumnWidth?: DataGridSearchProps[\"minColumnWidth\"];\n    /**\n     * The maximum width a column can be resized to.\n     * @defaultValue 500\n     * @group Style\n     */\n    readonly maxColumnWidth?: DataGridSearchProps[\"maxColumnWidth\"];\n    /**\n     * The maximum width a column can be automatically sized to.\n     * @defaultValue `maxColumnWidth`\n     * @group Style\n     */\n    readonly maxColumnAutoWidth?: number;\n\n    /**\n     * Used to provide an override to the default image editor for the data grid. `provideEditor` may be a better\n     * choice for most people.\n     * @group Advanced\n     * */\n    readonly imageEditorOverride?: ImageEditorType;\n    /**\n     * If specified, it will be used to render Markdown, instead of the default Markdown renderer used by the Grid.\n     * You'll want to use this if you need to process your Markdown for security purposes, or if you want to use a\n     * renderer with different Markdown features.\n     * @group Advanced\n     */\n    readonly markdownDivCreateNode?: (content: string) => DocumentFragment;\n\n    /** Callback for providing a custom editor for a cell.\n     * @group Editing\n     */\n    readonly provideEditor?: ProvideEditorCallback<GridCell>;\n    /**\n     * Allows coercion of pasted values.\n     * @group Editing\n     * @param val The pasted value\n     * @param cell The cell being pasted into\n     * @returns `undefined` to accept default behavior or a `GridCell` which should be used to represent the pasted value.\n     */\n    readonly coercePasteValue?: (val: string, cell: GridCell) => GridCell | undefined;\n\n    /**\n     * Emitted when the grid selection is cleared.\n     * @group Selection\n     */\n    readonly onSelectionCleared?: () => void;\n\n    /**\n     * Callback used to override the rendering of any cell.\n     * @group Drawing\n     */\n    readonly drawCell?: DrawCustomCellCallback;\n\n    /**\n     * The current selection of the data grid. Contains all selected cells, ranges, rows, and columns.\n     * @group Selection\n     */\n    readonly gridSelection?: GridSelection;\n    /**\n     * Emitted whenever the grid selection changes.\n     * @param newSelection The new gridSelection as created by user input.\n     * @group Selection\n     */\n    readonly onGridSelectionChange?: (newSelection: GridSelection) => void;\n    /**\n     * Emitted whenever the visible cells change, usually due to scrolling.\n     * @group Events\n     * @param range An inclusive range of all visible cells. May include cells obscured by UI elements such\n     * as headers.\n     * @param tx The x transform of the cell region.\n     * @param ty The y transform of the cell region.\n     * @param extras Contains information about the selected cell and\n     * any visible freeze columns.\n     */\n    readonly onVisibleRegionChanged?: (\n        range: Rectangle,\n        tx?: number,\n        ty?: number,\n        extras?: {\n            /** The selected item if visible */\n            selected?: Item;\n            /** A selection of visible freeze columns */\n            freezeRegion?: Rectangle;\n        }\n    ) => void;\n\n    /**\n     * The primary callback for getting cell data into the data grid.\n     * @group Data\n     * @param cell The location of the cell being requested.\n     * @returns A valid GridCell to be rendered by the Grid.\n     */\n    readonly getCellContent: (cell: Item) => GridCell;\n    /**\n     * Determines if row selection requires a modifier key to enable multi-selection or not. In auto mode it adapts to\n     * touch or mouse environments automatically, in multi-mode it always acts as if the multi key (Ctrl) is pressed.\n     * @group Editing\n     * @defaultValue `auto`\n     */\n    readonly rowSelectionMode?: \"auto\" | \"multi\";\n\n    /**\n     * Determins which keybindings are enabled.\n     * @group Editing\n     * @defaultValue is\n     \n            {  \n                selectAll: true,\n                selectRow: true,\n                selectColumn: true,\n                downFill: false,\n                rightFill: false,\n                pageUp: false,\n                pageDown: false,\n                clear: true,\n                copy: true,\n                paste: true,\n                search: false,\n                first: true,\n                last: true,\n            }\n     */\n    readonly keybindings?: Partial<Keybinds>;\n\n    /**\n     * Used to fetch large amounts of cells at once. Used for copy/paste, if unset copy will not work.\n     *\n     * `getCellsForSelection` is called when the user copies a selection to the clipboard or the data editor needs to\n     * inspect data which may be outside the curently visible range. It must return a two-dimensional array (an array of\n     * rows, where each row is an array of cells) of the cells in the selection's rectangle. Note that the rectangle can\n     * include cells that are not currently visible.\n     *\n     * If `true` is passed instead of a callback, the data grid will internally use the `getCellContent` callback to\n     * provide a basic implementation of `getCellsForSelection`. This can make it easier to light up more data grid\n     * functionality, but may have negative side effects if your data source is not able to handle being queried for\n     * data outside the normal window.\n     *\n     * If `getCellsForSelection` returns a thunk, the data may be loaded asynchronously, however the data grid may be\n     * unable to properly react to column spans when performing range selections. Copying large amounts of data out of\n     * the grid will depend on the performance of the thunk as well.\n     * @group Data\n     * @param {Rectangle} selection The range of requested cells\n     * @param {AbortSignal} abortSignal A signal indicating the requested cells are no longer needed\n     * @returns A row-major collection of cells or an async thunk which returns a row-major collection.\n     */\n    readonly getCellsForSelection?: DataGridSearchProps[\"getCellsForSelection\"] | true;\n\n    /** The number of columns which should remain in place when scrolling horizontally. The row marker column, if\n     * enabled is always frozen and is not included in this count.\n     * @defaultValue 0\n     * @group Style\n     */\n    readonly freezeColumns?: DataGridSearchProps[\"freezeColumns\"];\n\n    /**\n     * Controls the drawing of the left hand vertical border of a column. If set to a boolean value it controls all\n     * borders.\n     * @defaultValue `true`\n     * @group Style\n     */\n    readonly verticalBorder?: DataGridSearchProps[\"verticalBorder\"] | boolean;\n\n    /**\n     * Called when data is pasted into the grid. If left undefined, the `DataEditor` will operate in a\n     * fallback mode and attempt to paste the text buffer into the current cell assuming the current cell is not\n     * readonly and can accept the data type. If `onPaste` is set to false or the function returns false, the grid will\n     * simply ignore paste. If `onPaste` evaluates to true the grid will attempt to split the data by tabs and newlines\n     * and paste into available cells.\n     *\n     * The grid will not attempt to add additional rows if more data is pasted then can fit. In that case it is\n     * advisable to simply return false from onPaste and handle the paste manually.\n     * @group Editing\n     */\n    readonly onPaste?: ((target: Item, values: readonly (readonly string[])[]) => boolean) | boolean;\n\n    /**\n     * The theme used by the data grid to get all color and font information\n     * @group Style\n     */\n    readonly theme?: Partial<Theme>;\n\n    /**\n     * An array of custom renderers which can be used to extend the data grid.\n     * @group Advanced\n     */\n    readonly customRenderers?: readonly CustomRenderer<CustomCell<any>>[];\n}\n\ntype ScrollToFn = (\n    col: number | { amount: number; unit: \"cell\" | \"px\" },\n    row: number | { amount: number; unit: \"cell\" | \"px\" },\n    dir?: \"horizontal\" | \"vertical\" | \"both\",\n    paddingX?: number,\n    paddingY?: number,\n    options?: {\n        hAlign?: \"start\" | \"center\" | \"end\";\n        vAlign?: \"start\" | \"center\" | \"end\";\n    }\n) => void;\n\n/** @category DataEditor */\nexport interface DataEditorRef {\n    /**\n     * Programatically appends a row.\n     * @param col The column index to focus in the new row.\n     * @returns A promise which waits for the append to complete.\n     */\n    appendRow: (col: number) => Promise<void>;\n    /**\n     * Triggers cells to redraw.\n     */\n    updateCells: DataGridRef[\"damage\"];\n    /**\n     * Gets the screen space bounds of the requested item.\n     */\n    getBounds: DataGridRef[\"getBounds\"];\n    /**\n     * Triggers the data grid to focus itself or the correct accessibility element.\n     */\n    focus: DataGridRef[\"focus\"];\n    /**\n     * Generic API for emitting events as if they had been triggered via user interaction.\n     */\n    emit: (eventName: EmitEvents) => Promise<void>;\n    /**\n     * Scrolls to the desired cell or location in the grid.\n     */\n    scrollTo: ScrollToFn;\n}\n\nconst loadingCell: GridCell = {\n    kind: GridCellKind.Loading,\n    allowOverlay: false,\n};\n\nconst emptyGridSelection: GridSelection = {\n    columns: CompactSelection.empty(),\n    rows: CompactSelection.empty(),\n    current: undefined,\n};\n\nconst DataEditorImpl: React.ForwardRefRenderFunction<DataEditorRef, DataEditorProps> = (p, forwardedRef) => {\n    const [gridSelectionInner, setGridSelectionInner] = React.useState<GridSelection>(emptyGridSelection);\n    const [overlay, setOverlay] =\n        React.useState<{\n            target: Rectangle;\n            content: GridCell;\n            theme: Theme;\n            initialValue: string | undefined;\n            cell: Item;\n            highlight: boolean;\n            forceEditMode: boolean;\n        }>();\n    const searchInputRef = React.useRef<HTMLInputElement | null>(null);\n    const canvasRef = React.useRef<HTMLCanvasElement | null>(null);\n    const [mouseState, setMouseState] = React.useState<MouseState>();\n    const scrollRef = React.useRef<HTMLDivElement | null>(null);\n    const lastSent = React.useRef<[number, number]>();\n\n    const {\n        rowMarkers = \"none\",\n        rowHeight = 34,\n        headerHeight = 36,\n        rowMarkerWidth: rowMarkerWidthRaw,\n        imageEditorOverride,\n        getRowThemeOverride,\n        markdownDivCreateNode,\n    } = p;\n\n    const {\n        width,\n        height,\n        columns: columnsIn,\n        rows,\n        getCellContent,\n        onCellClicked,\n        onCellActivated,\n        onFinishedEditing,\n        coercePasteValue,\n        drawHeader: drawHeaderIn,\n        onHeaderClicked,\n        spanRangeBehavior = \"default\",\n        onGroupHeaderClicked,\n        onCellContextMenu,\n        className,\n        theme,\n        onHeaderContextMenu,\n        getCellsForSelection: getCellsForSelectionIn,\n        onGroupHeaderContextMenu,\n        onGroupHeaderRenamed,\n        onCellEdited,\n        onCellsEdited,\n        onKeyDown: onKeyDownIn,\n        onKeyUp: onKeyUpIn,\n        keybindings: keybindingsIn,\n        onRowAppended,\n        onColumnMoved,\n        validateCell: validateCellIn,\n        highlightRegions: highlightRegionsIn,\n        drawCell,\n        rangeSelect = \"rect\",\n        columnSelect = \"multi\",\n        rowSelect = \"multi\",\n        rangeSelectionBlending = \"exclusive\",\n        columnSelectionBlending = \"exclusive\",\n        rowSelectionBlending = \"exclusive\",\n        onDelete: onDeleteIn,\n        onDragStart,\n        onMouseMove,\n        onPaste,\n        groupHeaderHeight = headerHeight,\n        freezeColumns = 0,\n        rowSelectionMode = \"auto\",\n        rowMarkerStartIndex = 1,\n        onHeaderMenuClick,\n        getGroupDetails,\n        onSearchClose: onSearchCloseIn,\n        onItemHovered,\n        onSelectionCleared,\n        showSearch: showSearchIn,\n        onVisibleRegionChanged,\n        gridSelection: gridSelectionOuter,\n        onGridSelectionChange,\n        minColumnWidth: minColumnWidthIn = 50,\n        maxColumnWidth: maxColumnWidthIn = 500,\n        maxColumnAutoWidth: maxColumnAutoWidthIn,\n        provideEditor,\n        trailingRowOptions,\n        scrollOffsetX,\n        scrollOffsetY,\n        verticalBorder,\n        onDragOverCell,\n        onDrop,\n        onColumnResize: onColumnResizeIn,\n        onColumnResizeEnd: onColumnResizeEndIn,\n        onColumnResizeStart: onColumnResizeStartIn,\n        customRenderers: additionalRenderers,\n        fillHandle,\n        drawFocusRing,\n        experimental,\n        fixedShadowX,\n        fixedShadowY,\n        headerIcons,\n        imageWindowLoader,\n        initialSize,\n        isDraggable,\n        onDragLeave,\n        onRowMoved,\n        overscrollX,\n        overscrollY,\n        preventDiagonalScrolling,\n        rightElement,\n        rightElementProps,\n        showMinimap,\n        smoothScrollX,\n        smoothScrollY,\n        scrollToEnd,\n    } = p;\n\n    const minColumnWidth = Math.max(minColumnWidthIn, 20);\n    const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);\n    const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn ?? maxColumnWidth, minColumnWidth);\n\n    const keybindings = React.useMemo(() => {\n        return keybindingsIn === undefined\n            ? keybindingDefaults\n            : {\n                  ...keybindingDefaults,\n                  ...keybindingsIn,\n              };\n    }, [keybindingsIn]);\n\n    const rowMarkerWidth = rowMarkerWidthRaw ?? (rows > 10_000 ? 48 : rows > 1000 ? 44 : rows > 100 ? 36 : 32);\n    const hasRowMarkers = rowMarkers !== \"none\";\n    const rowMarkerOffset = hasRowMarkers ? 1 : 0;\n    const showTrailingBlankRow = onRowAppended !== undefined;\n    const lastRowSticky = trailingRowOptions?.sticky === true;\n\n    const [showSearchInner, setShowSearchInner] = React.useState(false);\n    const showSearch = showSearchIn ?? showSearchInner;\n\n    const onSearchClose = React.useCallback(() => {\n        if (onSearchCloseIn !== undefined) {\n            onSearchCloseIn();\n        } else {\n            setShowSearchInner(false);\n        }\n    }, [onSearchCloseIn]);\n\n    const gridSelectionOuterMangled: GridSelection | undefined = React.useMemo((): GridSelection | undefined => {\n        return gridSelectionOuter === undefined ? undefined : shiftSelection(gridSelectionOuter, rowMarkerOffset);\n    }, [gridSelectionOuter, rowMarkerOffset]);\n    const gridSelection = gridSelectionOuterMangled ?? gridSelectionInner;\n\n    const abortControllerRef = React.useRef(new AbortController());\n    React.useEffect(() => {\n        return () => {\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            abortControllerRef?.current.abort();\n        };\n    }, []);\n\n    const [getCellsForSelection, getCellsForSeletionDirect] = useCellsForSelection(\n        getCellsForSelectionIn,\n        getCellContent,\n        rowMarkerOffset,\n        abortControllerRef.current\n    );\n\n    const validateCell = React.useCallback<NonNullable<typeof validateCellIn>>(\n        (cell, newValue, prevValue) => {\n            if (validateCellIn === undefined) return true;\n            const item: Item = [cell[0] - rowMarkerOffset, cell[1]];\n            return validateCellIn?.(item, newValue, prevValue);\n        },\n        [rowMarkerOffset, validateCellIn]\n    );\n\n    const expectedExternalGridSelection = React.useRef<GridSelection | undefined>(gridSelectionOuter);\n    const setGridSelection = React.useCallback(\n        (newVal: GridSelection, expand: boolean): void => {\n            if (expand) {\n                newVal = expandSelection(\n                    newVal,\n                    getCellsForSelection,\n                    rowMarkerOffset,\n                    spanRangeBehavior,\n                    abortControllerRef.current\n                );\n            }\n            if (onGridSelectionChange !== undefined) {\n                expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);\n                onGridSelectionChange(expectedExternalGridSelection.current);\n            } else {\n                setGridSelectionInner(newVal);\n            }\n        },\n        [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]\n    );\n\n    const onColumnResize = whenDefined(\n        onColumnResizeIn,\n        React.useCallback<NonNullable<typeof onColumnResizeIn>>(\n            (_, w, ind, wg) => {\n                onColumnResizeIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n            },\n            [onColumnResizeIn, rowMarkerOffset, columnsIn]\n        )\n    );\n\n    const onColumnResizeEnd = whenDefined(\n        onColumnResizeEndIn,\n        React.useCallback<NonNullable<typeof onColumnResizeEndIn>>(\n            (_, w, ind, wg) => {\n                onColumnResizeEndIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n            },\n            [onColumnResizeEndIn, rowMarkerOffset, columnsIn]\n        )\n    );\n\n    const onColumnResizeStart = whenDefined(\n        onColumnResizeStartIn,\n        React.useCallback<NonNullable<typeof onColumnResizeStartIn>>(\n            (_, w, ind, wg) => {\n                onColumnResizeStartIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n            },\n            [onColumnResizeStartIn, rowMarkerOffset, columnsIn]\n        )\n    );\n\n    const drawHeader = whenDefined(\n        drawHeaderIn,\n        React.useCallback<NonNullable<typeof drawHeaderIn>>(\n            args => {\n                return drawHeaderIn?.({ ...args, columnIndex: args.columnIndex - rowMarkerOffset }) ?? false;\n            },\n            [drawHeaderIn, rowMarkerOffset]\n        )\n    );\n\n    const onDelete = React.useCallback<NonNullable<DataEditorProps[\"onDelete\"]>>(\n        sel => {\n            if (onDeleteIn !== undefined) {\n                const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));\n                if (typeof result === \"boolean\") {\n                    return result;\n                }\n                return shiftSelection(result, rowMarkerOffset);\n            }\n            return true;\n        },\n        [onDeleteIn, rowMarkerOffset]\n    );\n\n    const [setCurrent, setSelectedRows, setSelectedColumns] = useSelectionBehavior(\n        gridSelection,\n        setGridSelection,\n        rangeSelectionBlending,\n        columnSelectionBlending,\n        rowSelectionBlending,\n        rangeSelect\n    );\n\n    const mergedTheme = React.useMemo(() => {\n        return { ...getDataEditorTheme(), ...theme };\n    }, [theme]);\n\n    const [clientSize, setClientSize] = React.useState<readonly [number, number, number]>([10, 10, 0]);\n\n    const getCellRenderer: <T extends InnerGridCell>(cell: T) => CellRenderer<T> | undefined = React.useCallback(\n        <T extends InnerGridCell>(cell: T) => {\n            if (cell.kind !== GridCellKind.Custom) {\n                return CellRenderers[cell.kind] as unknown as CellRenderer<T>;\n            }\n            return additionalRenderers?.find(x => x.isMatch(cell)) as CellRenderer<T>;\n        },\n        [additionalRenderers]\n    );\n\n    const columns = useColumnSizer(\n        columnsIn,\n        rows,\n        getCellsForSeletionDirect,\n        clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2],\n        minColumnWidth,\n        maxColumnAutoWidth,\n        mergedTheme,\n        getCellRenderer,\n        abortControllerRef.current\n    );\n\n    const enableGroups = React.useMemo(() => {\n        return columns.some(c => c.group !== undefined);\n    }, [columns]);\n\n    const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n\n    const numSelectedRows = gridSelection.rows.length;\n    const rowMarkerHeader =\n        rowMarkers === \"none\"\n            ? \"\"\n            : numSelectedRows === 0\n            ? headerCellUnheckedMarker\n            : numSelectedRows === rows\n            ? headerCellCheckedMarker\n            : headerCellIndeterminateMarker;\n\n    const mangledCols = React.useMemo(() => {\n        if (rowMarkers === \"none\") return columns;\n        return [\n            {\n                title: rowMarkerHeader,\n                width: rowMarkerWidth,\n                icon: undefined,\n                hasMenu: false,\n                style: \"normal\" as const,\n            },\n            ...columns,\n        ];\n    }, [columns, rowMarkerWidth, rowMarkers, rowMarkerHeader]);\n\n    const [visibleRegionY, visibleRegionTy] = React.useMemo(() => {\n        return [\n            scrollOffsetY !== undefined && typeof rowHeight === \"number\" ? Math.floor(scrollOffsetY / rowHeight) : 0,\n            scrollOffsetY !== undefined && typeof rowHeight === \"number\" ? -(scrollOffsetY % rowHeight) : 0,\n        ];\n    }, [scrollOffsetY, rowHeight]);\n\n    type VisibleRegion = Rectangle & {\n        /** value in px */\n        tx?: number;\n        /** value in px */\n        ty?: number;\n        extras?: {\n            selected?: Item;\n            freezeRegion?: Rectangle;\n        };\n    };\n\n    const visibleRegionRef = React.useRef<VisibleRegion>({\n        height: 1,\n        width: 1,\n        x: 0,\n        y: 0,\n    });\n    const visibleRegionInput = React.useMemo<VisibleRegion>(\n        () => ({\n            x: visibleRegionRef.current.x,\n            y: visibleRegionY,\n            width: visibleRegionRef.current.width ?? 1,\n            height: visibleRegionRef.current.height ?? 1,\n            // tx: 'TODO',\n            ty: visibleRegionTy,\n        }),\n        [visibleRegionTy, visibleRegionY]\n    );\n\n    const hasJustScrolled = React.useRef(false);\n\n    const [visibleRegion, setVisibleRegion, empty] = useStateWithReactiveInput<VisibleRegion>(visibleRegionInput);\n    visibleRegionRef.current = visibleRegion;\n\n    const vScrollReady = (visibleRegion.height ?? 1) > 1;\n    React.useLayoutEffect(() => {\n        if (scrollOffsetY !== undefined && scrollRef.current !== null && vScrollReady) {\n            scrollRef.current.scrollTop = scrollOffsetY;\n            if (scrollRef.current.scrollTop !== scrollOffsetY) {\n                empty();\n            }\n            hasJustScrolled.current = true;\n        }\n    }, [scrollOffsetY, vScrollReady, empty]);\n\n    const hScrollReady = (visibleRegion.width ?? 1) > 1;\n    React.useLayoutEffect(() => {\n        if (scrollOffsetX !== undefined && scrollRef.current !== null && hScrollReady) {\n            scrollRef.current.scrollLeft = scrollOffsetX;\n            if (scrollRef.current.scrollLeft !== scrollOffsetX) {\n                empty();\n            }\n            hasJustScrolled.current = true;\n        }\n    }, [scrollOffsetX, hScrollReady, empty]);\n\n    const cellXOffset = visibleRegion.x + rowMarkerOffset;\n    const cellYOffset = visibleRegion.y;\n\n    const gridRef = React.useRef<DataGridRef | null>(null);\n\n    const focus = React.useCallback((immediate?: boolean) => {\n        if (immediate === true) {\n            gridRef.current?.focus();\n        } else {\n            window.requestAnimationFrame(() => {\n                gridRef.current?.focus();\n            });\n        }\n    }, []);\n\n    const mangledRows = showTrailingBlankRow ? rows + 1 : rows;\n\n    const mangledOnCellsEdited = React.useCallback<NonNullable<typeof onCellsEdited>>(\n        (items: readonly EditListItem[]) => {\n            const mangledItems =\n                rowMarkerOffset === 0\n                    ? items\n                    : items.map(x => ({\n                          ...x,\n                          location: [x.location[0] - rowMarkerOffset, x.location[1]] as const,\n                      }));\n            const r = onCellsEdited?.(mangledItems);\n\n            if (r !== true) {\n                for (const i of mangledItems) onCellEdited?.(i.location, i.value);\n            }\n\n            return r;\n        },\n        [onCellEdited, onCellsEdited, rowMarkerOffset]\n    );\n\n    const highlightRegions = React.useMemo(() => {\n        if (highlightRegionsIn === undefined) return undefined;\n        if (rowMarkerOffset === 0) return highlightRegionsIn;\n\n        return highlightRegionsIn\n            .map(r => {\n                const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;\n                if (maxWidth <= 0) return undefined;\n                return {\n                    color: r.color,\n                    range: {\n                        ...r.range,\n                        x: r.range.x + rowMarkerOffset,\n                        width: Math.min(maxWidth, r.range.width),\n                    },\n                    style: r.style,\n                };\n            })\n            .filter(x => x !== undefined) as typeof highlightRegionsIn;\n    }, [highlightRegionsIn, mangledCols.length, rowMarkerOffset]);\n\n    const mangledColsRef = React.useRef(mangledCols);\n    mangledColsRef.current = mangledCols;\n    const getMangledCellContent = React.useCallback(\n        ([col, row]: Item): InnerGridCell => {\n            const isTrailing = showTrailingBlankRow && row === mangledRows - 1;\n            const isRowMarkerCol = col === 0 && hasRowMarkers;\n            if (isRowMarkerCol) {\n                if (isTrailing) {\n                    return loadingCell;\n                }\n                return {\n                    kind: InnerGridCellKind.Marker,\n                    allowOverlay: false,\n                    checked: gridSelection?.rows.hasIndex(row) === true,\n                    markerKind: rowMarkers === \"clickable-number\" ? \"number\" : rowMarkers,\n                    row: rowMarkerStartIndex + row,\n                    drawHandle: onRowMoved !== undefined,\n                };\n            } else if (isTrailing) {\n                //If the grid is empty, we will return text\n                const isFirst = col === rowMarkerOffset;\n\n                const maybeFirstColumnHint = isFirst ? trailingRowOptions?.hint ?? \"\" : \"\";\n                const c = mangledColsRef.current[col];\n\n                if (c?.trailingRowOptions?.disabled === true) {\n                    return loadingCell;\n                } else {\n                    const hint = c?.trailingRowOptions?.hint ?? maybeFirstColumnHint;\n                    const icon = c?.trailingRowOptions?.addIcon ?? trailingRowOptions?.addIcon;\n                    return {\n                        kind: InnerGridCellKind.NewRow,\n                        hint,\n                        allowOverlay: false,\n                        icon,\n                    };\n                }\n            } else {\n                const outerCol = col - rowMarkerOffset;\n                if (experimental?.strict === true) {\n                    const vr = visibleRegionRef.current;\n                    const isOutsideMainArea =\n                        vr.x > outerCol || outerCol > vr.x + vr.width || vr.y > row || row > vr.y + vr.height;\n                    const isSelected = outerCol === vr.extras?.selected?.[0] && row === vr.extras?.selected[1];\n                    const isOutsideFreezeArea =\n                        vr.extras?.freezeRegion === undefined ||\n                        vr.extras.freezeRegion.x > outerCol ||\n                        outerCol > vr.extras.freezeRegion.x + vr.extras.freezeRegion.width ||\n                        vr.extras.freezeRegion.y > row ||\n                        row > vr.extras.freezeRegion.y + vr.extras.freezeRegion.height;\n                    if (isOutsideMainArea && !isSelected && isOutsideFreezeArea) {\n                        return {\n                            kind: GridCellKind.Loading,\n                            allowOverlay: false,\n                        };\n                    }\n                }\n                let result = getCellContent([outerCol, row]);\n                if (rowMarkerOffset !== 0 && result.span !== undefined) {\n                    result = {\n                        ...result,\n                        span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset],\n                    };\n                }\n                return result;\n            }\n        },\n        [\n            showTrailingBlankRow,\n            mangledRows,\n            hasRowMarkers,\n            gridSelection?.rows,\n            onRowMoved,\n            rowMarkers,\n            rowMarkerOffset,\n            trailingRowOptions?.hint,\n            trailingRowOptions?.addIcon,\n            experimental?.strict,\n            getCellContent,\n            rowMarkerStartIndex,\n        ]\n    );\n\n    const mangledGetGroupDetails = React.useCallback<NonNullable<DataEditorProps[\"getGroupDetails\"]>>(\n        group => {\n            let result = getGroupDetails?.(group) ?? { name: group };\n            if (onGroupHeaderRenamed !== undefined && group !== \"\") {\n                result = {\n                    icon: result.icon,\n                    name: result.name,\n                    overrideTheme: result.overrideTheme,\n                    actions: [\n                        ...(result.actions ?? []),\n                        {\n                            title: \"Rename\",\n                            icon: \"renameIcon\",\n                            onClick: e =>\n                                setRenameGroup({\n                                    group: result.name,\n                                    bounds: e.bounds,\n                                }),\n                        },\n                    ],\n                };\n            }\n            return result;\n        },\n        [getGroupDetails, onGroupHeaderRenamed]\n    );\n\n    const setOverlaySimple = React.useCallback(\n        (val: Omit<NonNullable<typeof overlay>, \"theme\">) => {\n            const [col, row] = val.cell;\n            const column = mangledCols[col];\n            const groupTheme =\n                column?.group !== undefined ? mangledGetGroupDetails(column.group)?.overrideTheme : undefined;\n            const colTheme = column?.themeOverride;\n            const rowTheme = getRowThemeOverride?.(row);\n\n            setOverlay({\n                ...val,\n                theme: { ...mergedTheme, ...groupTheme, ...colTheme, ...rowTheme, ...val.content.themeOverride },\n            });\n        },\n        [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]\n    );\n\n    const reselect = React.useCallback(\n        (bounds: Rectangle, fromKeyboard: boolean, initialValue?: string) => {\n            if (gridSelection.current === undefined) return;\n\n            const [col, row] = gridSelection.current.cell;\n            const c = getMangledCellContent([col, row]);\n            if (c.kind !== GridCellKind.Boolean && c.allowOverlay) {\n                let content = c;\n                if (initialValue !== undefined) {\n                    switch (content.kind) {\n                        case GridCellKind.Number: {\n                            const d = maybe(() => (initialValue === \"-\" ? -0 : Number.parseFloat(initialValue)), 0);\n                            content = {\n                                ...content,\n                                data: Number.isNaN(d) ? 0 : d,\n                            };\n                            break;\n                        }\n                        case GridCellKind.Text:\n                        case GridCellKind.Markdown:\n                        case GridCellKind.Uri:\n                            content = {\n                                ...content,\n                                data: initialValue,\n                            };\n                            break;\n                    }\n                }\n\n                setOverlaySimple({\n                    target: bounds,\n                    content,\n                    initialValue,\n                    cell: [col, row],\n                    highlight: initialValue === undefined,\n                    forceEditMode: initialValue !== undefined,\n                });\n            } else if (c.kind === GridCellKind.Boolean && fromKeyboard && c.readonly !== true) {\n                mangledOnCellsEdited([\n                    {\n                        location: gridSelection.current.cell,\n                        value: {\n                            ...c,\n                            data: toggleBoolean(c.data),\n                        },\n                    },\n                ]);\n                gridRef.current?.damage([{ cell: gridSelection.current.cell }]);\n            }\n        },\n        [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]\n    );\n\n    const focusOnRowFromTrailingBlankRow = React.useCallback(\n        (col: number, row: number) => {\n            const bounds = gridRef.current?.getBounds(col, row);\n            if (bounds === undefined || scrollRef.current === null) {\n                return;\n            }\n\n            const content = getMangledCellContent([col, row]);\n            if (!content.allowOverlay) {\n                return;\n            }\n\n            setOverlaySimple({\n                target: bounds,\n                content,\n                initialValue: undefined,\n                highlight: true,\n                cell: [col, row],\n                forceEditMode: true,\n            });\n        },\n        [getMangledCellContent, setOverlaySimple]\n    );\n\n    const scrollTo = React.useCallback<ScrollToFn>(\n        (col, row, dir = \"both\", paddingX = 0, paddingY = 0, options = undefined): void => {\n            if (scrollRef.current !== null) {\n                const grid = gridRef.current;\n                const canvas = canvasRef.current;\n\n                const trueCol = typeof col !== \"number\" ? (col.unit === \"cell\" ? col.amount : undefined) : col;\n                const trueRow = typeof row !== \"number\" ? (row.unit === \"cell\" ? row.amount : undefined) : row;\n                const desiredX = typeof col !== \"number\" && col.unit === \"px\" ? col.amount : undefined;\n                const desiredY = typeof row !== \"number\" && row.unit === \"px\" ? row.amount : undefined;\n                if (grid !== null && canvas !== null) {\n                    let targetRect: Rectangle = {\n                        x: 0,\n                        y: 0,\n                        width: 0,\n                        height: 0,\n                    };\n\n                    let scrollX = 0;\n                    let scrollY = 0;\n\n                    if (trueCol !== undefined || trueRow !== undefined) {\n                        targetRect = grid.getBounds((trueCol ?? 0) + rowMarkerOffset, trueRow ?? 0) ?? targetRect;\n                        if (targetRect.width === 0 || targetRect.height === 0) return;\n                    }\n\n                    const scrollBounds = canvas.getBoundingClientRect();\n\n                    if (desiredX !== undefined) {\n                        targetRect = {\n                            ...targetRect,\n                            x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,\n                            width: 1,\n                        };\n                    }\n                    if (desiredY !== undefined) {\n                        targetRect = {\n                            ...targetRect,\n                            y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,\n                            height: 1,\n                        };\n                    }\n\n                    if (targetRect !== undefined) {\n                        const bounds = {\n                            x: targetRect.x - paddingX,\n                            y: targetRect.y - paddingY,\n                            width: targetRect.width + 2 * paddingX,\n                            height: targetRect.height + 2 * paddingY,\n                        };\n\n                        let frozenWidth = 0;\n                        for (let i = 0; i < freezeColumns; i++) {\n                            frozenWidth += columns[i].width;\n                        }\n                        let trailingRowHeight = 0;\n                        if (lastRowSticky) {\n                            trailingRowHeight = typeof rowHeight === \"number\" ? rowHeight : rowHeight(rows);\n                        }\n\n                        let sLeft = frozenWidth + scrollBounds.left + rowMarkerOffset * rowMarkerWidth;\n                        let sRight = scrollBounds.right;\n                        let sTop = scrollBounds.top + totalHeaderHeight;\n                        let sBottom = scrollBounds.bottom - trailingRowHeight;\n\n                        const minx = targetRect.width + paddingX * 2;\n                        switch (options?.hAlign) {\n                            case \"start\":\n                                sRight = sLeft + minx;\n                                break;\n                            case \"end\":\n                                sLeft = sRight - minx;\n                                break;\n                            case \"center\":\n                                sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;\n                                sRight = sLeft + minx;\n                                break;\n                        }\n\n                        const miny = targetRect.height + paddingY * 2;\n                        switch (options?.vAlign) {\n                            case \"start\":\n                                sBottom = sTop + miny;\n                                break;\n                            case \"end\":\n                                sTop = sBottom - miny;\n                                break;\n                            case \"center\":\n                                sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;\n                                sBottom = sTop + miny;\n                                break;\n                        }\n\n                        if (sLeft > bounds.x) {\n                            scrollX = bounds.x - sLeft;\n                        } else if (sRight < bounds.x + bounds.width) {\n                            scrollX = bounds.x + bounds.width - sRight;\n                        }\n\n                        if (sTop > bounds.y) {\n                            scrollY = bounds.y - sTop;\n                        } else if (sBottom < bounds.y + bounds.height) {\n                            scrollY = bounds.y + bounds.height - sBottom;\n                        }\n\n                        if (dir === \"vertical\" || col < freezeColumns) {\n                            scrollX = 0;\n                        } else if (dir === \"horizontal\") {\n                            scrollY = 0;\n                        }\n\n                        if (scrollX !== 0 || scrollY !== 0) {\n                            scrollRef.current.scrollTo(\n                                scrollX + scrollRef.current.scrollLeft,\n                                scrollY + scrollRef.current.scrollTop\n                            );\n                        }\n                    }\n                }\n            }\n        },\n        [rowMarkerOffset, rowMarkerWidth, totalHeaderHeight, lastRowSticky, freezeColumns, columns, rowHeight, rows]\n    );\n\n    const focusCallback = React.useRef(focusOnRowFromTrailingBlankRow);\n    const getCellContentRef = React.useRef(getCellContent);\n    const rowsRef = React.useRef(rows);\n    focusCallback.current = focusOnRowFromTrailingBlankRow;\n    getCellContentRef.current = getCellContent;\n    rowsRef.current = rows;\n    const appendRow = React.useCallback(\n        async (col: number): Promise<void> => {\n            const c = mangledCols[col];\n            if (c?.trailingRowOptions?.disabled === true) {\n                return;\n            }\n            const appendResult = onRowAppended?.();\n\n            let r: \"top\" | \"bottom\" | number | undefined = undefined;\n            let bottom = true;\n            if (appendResult !== undefined) {\n                r = await appendResult;\n                if (r === \"top\") bottom = false;\n                if (typeof r === \"number\") bottom = false;\n            }\n\n            let backoff = 0;\n            const doFocus = () => {\n                if (rowsRef.current <= rows) {\n                    if (backoff < 500) {\n                        window.setTimeout(doFocus, backoff);\n                    }\n                    backoff = 50 + backoff * 2;\n                    return;\n                }\n\n                const row = typeof r === \"number\" ? r : bottom ? rows : 0;\n                scrollTo(col - rowMarkerOffset, row);\n                setCurrent(\n                    {\n                        cell: [col, row],\n                        range: {\n                            x: col,\n                            y: row,\n                            width: 1,\n                            height: 1,\n                        },\n                    },\n                    false,\n                    false,\n                    \"edit\"\n                );\n\n                const cell = getCellContentRef.current([col - rowMarkerOffset, row]);\n                if (cell.allowOverlay && isReadWriteCell(cell) && cell.readonly !== true) {\n                    // wait for scroll to have a chance to process\n                    window.setTimeout(() => {\n                        focusCallback.current(col, row);\n                    }, 0);\n                }\n            };\n            // Queue up to allow the consumer to react to the event and let us check if they did\n            doFocus();\n        },\n        [mangledCols, onRowAppended, rowMarkerOffset, rows, scrollTo, setCurrent]\n    );\n\n    const getCustomNewRowTargetColumn = React.useCallback(\n        (col: number): number | undefined => {\n            const customTargetColumn =\n                columns[col]?.trailingRowOptions?.targetColumn ?? trailingRowOptions?.targetColumn;\n\n            if (typeof customTargetColumn === \"number\") {\n                const customTargetOffset = hasRowMarkers ? 1 : 0;\n                return customTargetColumn + customTargetOffset;\n            }\n\n            if (typeof customTargetColumn === \"object\") {\n                const maybeIndex = columnsIn.indexOf(customTargetColumn);\n                if (maybeIndex >= 0) {\n                    const customTargetOffset = hasRowMarkers ? 1 : 0;\n                    return maybeIndex + customTargetOffset;\n                }\n            }\n\n            return undefined;\n        },\n        [columns, columnsIn, hasRowMarkers, trailingRowOptions?.targetColumn]\n    );\n\n    const lastSelectedRowRef = React.useRef<number>();\n    const lastSelectedColRef = React.useRef<number>();\n\n    const themeForCell = React.useCallback(\n        (cell: InnerGridCell, pos: Item): Theme => {\n            const [col, row] = pos;\n            return {\n                ...mergedTheme,\n                ...mangledCols[col]?.themeOverride,\n                ...getRowThemeOverride?.(row),\n                ...cell.themeOverride,\n            };\n        },\n        [getRowThemeOverride, mangledCols, mergedTheme]\n    );\n\n    const handleSelect = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;\n            const isMultiRow = isMultiKey && rowSelect === \"multi\";\n            const isMultiCol = isMultiKey && columnSelect === \"multi\";\n            const [col, row] = args.location;\n            const selectedColumns = gridSelection.columns;\n            const selectedRows = gridSelection.rows;\n            const [cellCol, cellRow] = gridSelection.current?.cell ?? [];\n            // eslint-disable-next-line unicorn/prefer-switch\n            if (args.kind === \"cell\") {\n                lastSelectedColRef.current = undefined;\n\n                lastMouseSelectLocation.current = [col, row];\n\n                if (col === 0 && hasRowMarkers) {\n                    if (\n                        (showTrailingBlankRow === true && row === rows) ||\n                        rowMarkers === \"number\" ||\n                        rowSelect === \"none\"\n                    )\n                        return;\n\n                    const markerCell = getMangledCellContent(args.location);\n                    if (markerCell.kind !== InnerGridCellKind.Marker) {\n                        return;\n                    }\n\n                    if (onRowMoved !== undefined) {\n                        const renderer = getCellRenderer(markerCell);\n                        assert(renderer?.kind === InnerGridCellKind.Marker);\n                        const postClick = renderer?.onClick?.({\n                            ...args,\n                            cell: markerCell,\n                            posX: args.localEventX,\n                            posY: args.localEventY,\n                            bounds: args.bounds,\n                            theme: themeForCell(markerCell, args.location),\n                            preventDefault: () => undefined,\n                        }) as MarkerCell | undefined;\n                        if (postClick === undefined || postClick.checked === markerCell.checked) return;\n                    }\n\n                    setOverlay(undefined);\n                    focus();\n                    const isSelected = selectedRows.hasIndex(row);\n\n                    const lastHighlighted = lastSelectedRowRef.current;\n                    if (\n                        rowSelect === \"multi\" &&\n                        (args.shiftKey || args.isLongTouch === true) &&\n                        lastHighlighted !== undefined &&\n                        selectedRows.hasIndex(lastHighlighted)\n                    ) {\n                        const newSlice: Slice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];\n\n                        if (isMultiRow || rowSelectionMode === \"multi\") {\n                            setSelectedRows(undefined, newSlice, true);\n                        } else {\n                            setSelectedRows(CompactSelection.fromSingleSelection(newSlice), undefined, isMultiRow);\n                        }\n                    } else if (isMultiRow || args.isTouch || rowSelectionMode === \"multi\") {\n                        if (isSelected) {\n                            setSelectedRows(selectedRows.remove(row), undefined, true);\n                        } else {\n                            setSelectedRows(undefined, row, true);\n                            lastSelectedRowRef.current = row;\n                        }\n                    } else if (isSelected && selectedRows.length === 1) {\n                        setSelectedRows(CompactSelection.empty(), undefined, isMultiKey);\n                    } else {\n                        setSelectedRows(CompactSelection.fromSingleSelection(row), undefined, isMultiKey);\n                        lastSelectedRowRef.current = row;\n                    }\n                } else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {\n                    const customTargetColumn = getCustomNewRowTargetColumn(col);\n                    void appendRow(customTargetColumn ?? col);\n                } else {\n                    if (cellCol !== col || cellRow !== row) {\n                        const cell = getMangledCellContent(args.location);\n                        const renderer = getCellRenderer(cell);\n\n                        if (renderer?.onSelect !== undefined) {\n                            let prevented = false;\n                            renderer.onSelect({\n                                ...args,\n                                cell,\n                                posX: args.localEventX,\n                                posY: args.localEventY,\n                                bounds: args.bounds,\n                                preventDefault: () => (prevented = true),\n                                theme: themeForCell(cell, args.location),\n                            });\n                            if (prevented) {\n                                return;\n                            }\n                        }\n                        const isLastStickyRow = lastRowSticky && row === rows;\n\n                        const startedFromLastSticky =\n                            lastRowSticky && gridSelection !== undefined && gridSelection.current?.cell[1] === rows;\n\n                        if (\n                            (args.shiftKey || args.isLongTouch === true) &&\n                            cellCol !== undefined &&\n                            cellRow !== undefined &&\n                            gridSelection.current !== undefined &&\n                            !startedFromLastSticky\n                        ) {\n                            if (isLastStickyRow) {\n                                // If we're making a selection and shift click in to the last sticky row,\n                                // just drop the event. Don't kill the selection.\n                                return;\n                            }\n\n                            const left = Math.min(col, cellCol);\n                            const right = Math.max(col, cellCol);\n                            const top = Math.min(row, cellRow);\n                            const bottom = Math.max(row, cellRow);\n                            setCurrent(\n                                {\n                                    ...gridSelection.current,\n                                    range: {\n                                        x: left,\n                                        y: top,\n                                        width: right - left + 1,\n                                        height: bottom - top + 1,\n                                    },\n                                },\n                                true,\n                                isMultiKey,\n                                \"click\"\n                            );\n                            lastSelectedRowRef.current = undefined;\n                            focus();\n                        } else {\n                            setCurrent(\n                                {\n                                    cell: [col, row],\n                                    range: { x: col, y: row, width: 1, height: 1 },\n                                },\n                                true,\n                                isMultiKey,\n                                \"click\"\n                            );\n                            lastSelectedRowRef.current = undefined;\n                            setOverlay(undefined);\n                            focus();\n                        }\n                    }\n                }\n            } else if (args.kind === \"header\") {\n                lastMouseSelectLocation.current = [col, row];\n                setOverlay(undefined);\n                if (hasRowMarkers && col === 0) {\n                    lastSelectedRowRef.current = undefined;\n                    lastSelectedColRef.current = undefined;\n                    if (rowSelect === \"multi\") {\n                        if (selectedRows.length !== rows) {\n                            setSelectedRows(CompactSelection.fromSingleSelection([0, rows]), undefined, isMultiKey);\n                        } else {\n                            setSelectedRows(CompactSelection.empty(), undefined, isMultiKey);\n                        }\n                        focus();\n                    }\n                } else {\n                    const lastCol = lastSelectedColRef.current;\n                    if (\n                        columnSelect === \"multi\" &&\n                        (args.shiftKey || args.isLongTouch === true) &&\n                        lastCol !== undefined &&\n                        selectedColumns.hasIndex(lastCol)\n                    ) {\n                        const newSlice: Slice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];\n\n                        if (isMultiCol) {\n                            setSelectedColumns(undefined, newSlice, isMultiKey);\n                        } else {\n                            setSelectedColumns(CompactSelection.fromSingleSelection(newSlice), undefined, isMultiKey);\n                        }\n                    } else if (isMultiCol) {\n                        if (selectedColumns.hasIndex(col)) {\n                            setSelectedColumns(selectedColumns.remove(col), undefined, isMultiKey);\n                        } else {\n                            setSelectedColumns(undefined, col, isMultiKey);\n                        }\n                        lastSelectedColRef.current = col;\n                    } else if (columnSelect !== \"none\") {\n                        setSelectedColumns(CompactSelection.fromSingleSelection(col), undefined, isMultiKey);\n                        lastSelectedColRef.current = col;\n                    }\n                    lastSelectedRowRef.current = undefined;\n                    focus();\n                }\n            } else if (args.kind === groupHeaderKind) {\n                lastMouseSelectLocation.current = [col, row];\n            } else if (args.kind === outOfBoundsKind) {\n                setGridSelection(emptyGridSelection, false);\n                setOverlay(undefined);\n                focus();\n                onSelectionCleared?.();\n                lastSelectedRowRef.current = undefined;\n                lastSelectedColRef.current = undefined;\n            }\n        },\n        [\n            appendRow,\n            columnSelect,\n            focus,\n            getCellRenderer,\n            getCustomNewRowTargetColumn,\n            getMangledCellContent,\n            gridSelection,\n            hasRowMarkers,\n            lastRowSticky,\n            onSelectionCleared,\n            onRowMoved,\n            rowMarkerOffset,\n            rowMarkers,\n            rowSelect,\n            rowSelectionMode,\n            rows,\n            setCurrent,\n            setGridSelection,\n            setSelectedColumns,\n            setSelectedRows,\n            showTrailingBlankRow,\n            themeForCell,\n        ]\n    );\n\n    const lastMouseSelectLocation = React.useRef<[number, number]>();\n    const touchDownArgs = React.useRef(visibleRegion);\n    const mouseDownData =\n        React.useRef<{\n            wasDoubleClick: boolean;\n            time: number;\n            location: Item;\n        }>();\n    const onMouseDown = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            isPrevented.current = false;\n            touchDownArgs.current = visibleRegionRef.current;\n            if (args.button !== 0) {\n                mouseDownData.current = undefined;\n                return;\n            }\n\n            const time = performance.now();\n            const wasDoubleClick = time - (mouseDownData.current?.time ?? -1000) < 250;\n            mouseDownData.current = {\n                wasDoubleClick,\n                time,\n                location: args.location,\n            };\n\n            const fh = args.kind === \"cell\" && args.isFillHandle;\n\n            if (!fh && args.kind !== \"cell\" && args.isEdge) return;\n\n            setMouseState({\n                previousSelection: gridSelection,\n                fillHandle: fh,\n            });\n            lastMouseSelectLocation.current = undefined;\n\n            if (!args.isTouch) {\n                handleSelect(args);\n            }\n        },\n        [gridSelection, handleSelect]\n    );\n\n    const [renameGroup, setRenameGroup] =\n        React.useState<{\n            group: string;\n            bounds: Rectangle;\n        }>();\n\n    const handleGroupHeaderSelection = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            if (args.kind !== groupHeaderKind || columnSelect !== \"multi\") {\n                return;\n            }\n            const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;\n            const [col] = args.location;\n            const selectedColumns = gridSelection.columns;\n\n            if (col < rowMarkerOffset) return;\n\n            const needle = mangledCols[col];\n            let start = col;\n            let end = col;\n            for (let i = col - 1; i >= rowMarkerOffset; i--) {\n                if (!isGroupEqual(needle.group, mangledCols[i].group)) break;\n                start--;\n            }\n\n            for (let i = col + 1; i < mangledCols.length; i++) {\n                if (!isGroupEqual(needle.group, mangledCols[i].group)) break;\n                end++;\n            }\n\n            focus();\n\n            if (isMultiKey) {\n                if (selectedColumns.hasAll([start, end + 1])) {\n                    let newVal = selectedColumns;\n                    for (let index = start; index <= end; index++) {\n                        newVal = newVal.remove(index);\n                    }\n                    setSelectedColumns(newVal, undefined, isMultiKey);\n                } else {\n                    setSelectedColumns(undefined, [start, end + 1], isMultiKey);\n                }\n            } else {\n                setSelectedColumns(CompactSelection.fromSingleSelection([start, end + 1]), undefined, isMultiKey);\n            }\n        },\n        [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]\n    );\n\n    const fillDown = React.useCallback(\n        (reverse: boolean) => {\n            if (gridSelection.current === undefined) return;\n            const v: EditListItem[] = [];\n            const r = gridSelection.current.range;\n            for (let x = 0; x < r.width; x++) {\n                const fillCol = x + r.x;\n                const fillVal = getMangledCellContent([fillCol, reverse ? r.y + r.height - 1 : r.y]);\n                if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;\n                for (let y = 1; y < r.height; y++) {\n                    const fillRow = reverse ? r.y + r.height - (y + 1) : y + r.y;\n                    const target = [fillCol, fillRow] as const;\n                    v.push({\n                        location: target,\n                        value: { ...fillVal },\n                    });\n                }\n            }\n\n            mangledOnCellsEdited(v);\n\n            gridRef.current?.damage(\n                v.map(c => ({\n                    cell: c.location,\n                }))\n            );\n        },\n        [getMangledCellContent, gridSelection, mangledOnCellsEdited]\n    );\n\n    const isPrevented = React.useRef(false);\n    const onContextMenu = React.useCallback(\n        (args: GridMouseEventArgs, preventDefault: () => void) => {\n            const clickLocation = args.location[0] - rowMarkerOffset;\n            if (args.kind === \"header\") {\n                onHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n            }\n\n            if (args.kind === groupHeaderKind) {\n                if (clickLocation < 0) {\n                    return;\n                }\n                onGroupHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n            }\n\n            if (args.kind === \"cell\") {\n                onCellContextMenu?.([clickLocation, args.location[1]], {\n                    ...args,\n                    preventDefault,\n                });\n            }\n        },\n        [onCellContextMenu, onGroupHeaderContextMenu, onHeaderContextMenu, rowMarkerOffset]\n    );\n\n    const normalSizeColumn = React.useCallback(\n        async (col: number): Promise<void> => {\n            if (\n                mouseDownData.current?.wasDoubleClick === true &&\n                getCellsForSelection !== undefined &&\n                onColumnResize !== undefined\n            ) {\n                const start = visibleRegionRef.current.y;\n                const end = visibleRegionRef.current.height;\n                let cells = getCellsForSelection(\n                    {\n                        x: col,\n                        y: start,\n                        width: 1,\n                        height: Math.min(end, rows - start),\n                    },\n                    abortControllerRef.current.signal\n                );\n                if (typeof cells !== \"object\") {\n                    cells = await cells();\n                }\n                const inputCol = columns[col - rowMarkerOffset];\n                const offscreen = document.createElement(\"canvas\");\n                const ctx = offscreen.getContext(\"2d\", { alpha: false });\n                if (ctx !== null) {\n                    ctx.font = `${mergedTheme.baseFontStyle} ${mergedTheme.fontFamily}`;\n                    const newCol = measureColumn(\n                        ctx,\n                        mergedTheme,\n                        inputCol,\n                        0,\n                        cells,\n                        minColumnWidth,\n                        maxColumnWidth,\n                        false,\n                        getCellRenderer\n                    );\n                    onColumnResize?.(inputCol, newCol.width, col, newCol.width);\n                }\n            }\n        },\n        [\n            columns,\n            getCellsForSelection,\n            maxColumnWidth,\n            mergedTheme,\n            minColumnWidth,\n            onColumnResize,\n            rowMarkerOffset,\n            rows,\n            getCellRenderer,\n        ]\n    );\n\n    const [scrollDir, setScrollDir] = React.useState<GridMouseEventArgs[\"scrollEdge\"]>();\n\n    const onMouseUp = React.useCallback(\n        (args: GridMouseEventArgs, isOutside: boolean) => {\n            const mouse = mouseState;\n            setMouseState(undefined);\n            setScrollDir(undefined);\n\n            if (isOutside) return;\n\n            const [col, row] = args.location;\n            const [lastMouseDownCol, lastMouseDownRow] = lastMouseSelectLocation.current ?? [];\n\n            const preventDefault = () => {\n                isPrevented.current = true;\n            };\n\n            const handleMaybeClick = (a: GridMouseCellEventArgs): boolean => {\n                if (lastMouseDownCol === col && lastMouseDownRow === row) {\n                    onCellClicked?.([col - rowMarkerOffset, row], {\n                        ...a,\n                        preventDefault,\n                    });\n                }\n                if (mouse?.fillHandle === true && gridSelection.current !== undefined) {\n                    fillDown(gridSelection.current.cell[1] !== gridSelection.current.range.y);\n                } else if (!isPrevented.current) {\n                    const c = getMangledCellContent(args.location);\n                    const r = getCellRenderer(c);\n                    if (r !== undefined && r.onClick !== undefined) {\n                        const newVal = r.onClick({\n                            ...a,\n                            cell: c,\n                            posX: a.localEventX,\n                            posY: a.localEventY,\n                            bounds: a.bounds,\n                            theme: themeForCell(c, args.location),\n                            preventDefault,\n                        });\n                        if (newVal !== undefined && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {\n                            mangledOnCellsEdited([{ location: a.location, value: newVal }]);\n                            gridRef.current?.damage([\n                                {\n                                    cell: a.location,\n                                },\n                            ]);\n                        }\n                    }\n                    if (\n                        !isPrevented.current &&\n                        mouse?.previousSelection?.current?.cell !== undefined &&\n                        gridSelection.current !== undefined\n                    ) {\n                        const [selectedCol, selectedRow] = gridSelection.current.cell;\n                        const [prevCol, prevRow] = mouse.previousSelection.current.cell;\n                        if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {\n                            onCellActivated?.([col - rowMarkerOffset, row]);\n                            reselect(a.bounds, false);\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            };\n\n            const clickLocation = args.location[0] - rowMarkerOffset;\n            if (args.isTouch) {\n                const vr = visibleRegionRef.current;\n                const touchVr = touchDownArgs.current;\n                if (vr.x !== touchVr.x || vr.y !== touchVr.y) {\n                    // we scrolled, abort\n                    return;\n                }\n                // take care of context menus first if long pressed item is already selected\n                if (args.isLongTouch === true) {\n                    if (\n                        args.kind === \"cell\" &&\n                        gridSelection?.current?.cell[0] === col &&\n                        gridSelection?.current?.cell[1] === row\n                    ) {\n                        onCellContextMenu?.([clickLocation, args.location[1]], {\n                            ...args,\n                            preventDefault,\n                        });\n                        return;\n                    } else if (args.kind === \"header\" && gridSelection.columns.hasIndex(col)) {\n                        onHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n                        return;\n                    } else if (args.kind === groupHeaderKind) {\n                        if (clickLocation < 0) {\n                            return;\n                        }\n\n                        onGroupHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n                        return;\n                    }\n                }\n                if (args.kind === \"cell\") {\n                    // click that cell\n                    if (!handleMaybeClick(args)) {\n                        handleSelect(args);\n                    }\n                } else if (args.kind === groupHeaderKind) {\n                    onGroupHeaderClicked?.(clickLocation, { ...args, preventDefault });\n                } else {\n                    handleSelect(args);\n                }\n                return;\n            }\n\n            if (args.kind === \"header\") {\n                if (clickLocation < 0) {\n                    return;\n                }\n\n                if (args.isEdge) {\n                    void normalSizeColumn(col);\n                } else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {\n                    onHeaderClicked?.(clickLocation, { ...args, preventDefault });\n                }\n            }\n\n            if (args.kind === groupHeaderKind) {\n                if (clickLocation < 0) {\n                    return;\n                }\n\n                if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {\n                    onGroupHeaderClicked?.(clickLocation, { ...args, preventDefault });\n                    if (!isPrevented.current) {\n                        handleGroupHeaderSelection(args);\n                    }\n                }\n            }\n\n            if (args.kind === \"cell\" && args.button === 0) {\n                handleMaybeClick(args);\n            }\n\n            lastMouseSelectLocation.current = undefined;\n        },\n        [\n            mouseState,\n            rowMarkerOffset,\n            gridSelection,\n            onCellClicked,\n            fillDown,\n            getMangledCellContent,\n            getCellRenderer,\n            themeForCell,\n            mangledOnCellsEdited,\n            onCellActivated,\n            reselect,\n            onCellContextMenu,\n            onHeaderContextMenu,\n            onGroupHeaderContextMenu,\n            handleSelect,\n            onGroupHeaderClicked,\n            normalSizeColumn,\n            onHeaderClicked,\n            handleGroupHeaderSelection,\n        ]\n    );\n\n    const onMouseMoveImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            const a: GridMouseEventArgs = {\n                ...args,\n                location: [args.location[0] - rowMarkerOffset, args.location[1]] as any,\n            };\n            onMouseMove?.(a);\n            setScrollDir(cv => {\n                if (args.scrollEdge[0] === cv?.[0] && args.scrollEdge[1] === cv[1]) return cv;\n                return mouseState === undefined || (mouseDownData.current?.location[0] ?? 0) < rowMarkerOffset\n                    ? undefined\n                    : args.scrollEdge;\n            });\n        },\n        [mouseState, onMouseMove, rowMarkerOffset]\n    );\n\n    useAutoscroll(scrollDir, scrollRef);\n\n    const onHeaderMenuClickInner = React.useCallback(\n        (col: number, screenPosition: Rectangle) => {\n            onHeaderMenuClick?.(col - rowMarkerOffset, screenPosition);\n        },\n        [onHeaderMenuClick, rowMarkerOffset]\n    );\n\n    const currentCell = gridSelection?.current?.cell;\n    const onVisibleRegionChangedImpl = React.useCallback(\n        (\n            region: Rectangle,\n            clientWidth: number,\n            clientHeight: number,\n            rightElWidth: number,\n            tx?: number,\n            ty?: number\n        ) => {\n            let selected = currentCell;\n            if (selected !== undefined) {\n                selected = [selected[0] - rowMarkerOffset, selected[1]];\n            }\n            const newRegion = {\n                x: region.x - rowMarkerOffset,\n                y: region.y,\n                width: region.width,\n                height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,\n                tx,\n                ty,\n                extras: {\n                    selected,\n                    freezeRegion:\n                        freezeColumns === 0\n                            ? undefined\n                            : {\n                                  x: 0,\n                                  y: region.y,\n                                  width: freezeColumns,\n                                  height: region.height,\n                              },\n                },\n            };\n            setClientSize([clientWidth, clientHeight, rightElWidth]);\n            setVisibleRegion(newRegion);\n            onVisibleRegionChanged?.(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);\n        },\n        [\n            currentCell,\n            rowMarkerOffset,\n            showTrailingBlankRow,\n            rows,\n            freezeColumns,\n            setVisibleRegion,\n            onVisibleRegionChanged,\n        ]\n    );\n\n    const onColumnMovedImpl = whenDefined(\n        onColumnMoved,\n        React.useCallback(\n            (startIndex: number, endIndex: number) => {\n                onColumnMoved?.(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);\n                if (columnSelect !== \"none\") {\n                    setSelectedColumns(CompactSelection.fromSingleSelection(endIndex), undefined, true);\n                }\n            },\n            [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]\n        )\n    );\n\n    const isActivelyDragging = React.useRef(false);\n    const onDragStartImpl = React.useCallback(\n        (args: GridDragEventArgs) => {\n            if (args.location[0] === 0 && rowMarkerOffset > 0) {\n                args.preventDefault();\n                return;\n            }\n            onDragStart?.({\n                ...args,\n                location: [args.location[0] - rowMarkerOffset, args.location[1]] as any,\n            });\n\n            if (!args.defaultPrevented()) {\n                isActivelyDragging.current = true;\n            }\n            setMouseState(undefined);\n        },\n        [onDragStart, rowMarkerOffset]\n    );\n\n    const onDragEnd = React.useCallback(() => {\n        isActivelyDragging.current = false;\n    }, []);\n\n    const onItemHoveredImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            if (\n                mouseState !== undefined &&\n                gridSelection.current !== undefined &&\n                !isActivelyDragging.current &&\n                (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")\n            ) {\n                const [selectedCol, selectedRow] = gridSelection.current.cell;\n                // eslint-disable-next-line prefer-const\n                let [col, row] = args.location;\n\n                if (row < 0) {\n                    row = visibleRegionRef.current.y;\n                }\n\n                const landedOnLastStickyRow = lastRowSticky && row === rows;\n                const startedFromLastStickyRow = lastRowSticky && selectedRow === rows;\n                if (landedOnLastStickyRow || startedFromLastStickyRow) return;\n\n                col = Math.max(col, rowMarkerOffset);\n\n                const deltaX = col - selectedCol;\n                const deltaY = row - selectedRow;\n\n                const newRange: Rectangle = {\n                    x: deltaX >= 0 ? selectedCol : col,\n                    y: deltaY >= 0 ? selectedRow : row,\n                    width: Math.abs(deltaX) + 1,\n                    height: Math.abs(deltaY) + 1,\n                };\n\n                setCurrent(\n                    {\n                        ...gridSelection.current,\n                        range: newRange,\n                    },\n                    true,\n                    false,\n                    \"drag\"\n                );\n            }\n\n            onItemHovered?.({ ...args, location: [args.location[0] - rowMarkerOffset, args.location[1]] as any });\n        },\n        [mouseState, gridSelection, rangeSelect, onItemHovered, rowMarkerOffset, lastRowSticky, rows, setCurrent]\n    );\n\n    // 1 === move one\n    // 2 === move to end\n    const adjustSelection = React.useCallback(\n        (direction: [0 | 1 | -1 | 2 | -2, 0 | 1 | -1 | 2 | -2]) => {\n            if (gridSelection.current === undefined) return;\n\n            const [x, y] = direction;\n            const [col, row] = gridSelection.current.cell;\n            const old = gridSelection.current.range;\n            let left = old.x;\n            let right = old.x + old.width;\n            let top = old.y;\n            let bottom = old.y + old.height;\n\n            // take care of vertical first in case new spans come in\n            if (y !== 0) {\n                switch (y) {\n                    case 2: {\n                        // go to end\n                        bottom = rows;\n                        top = row;\n                        scrollTo(0, bottom, \"vertical\");\n\n                        break;\n                    }\n                    case -2: {\n                        // go to start\n                        top = 0;\n                        bottom = row + 1;\n                        scrollTo(0, top, \"vertical\");\n\n                        break;\n                    }\n                    case 1: {\n                        // motion down\n                        if (top < row) {\n                            top++;\n                            scrollTo(0, top, \"vertical\");\n                        } else {\n                            bottom = Math.min(rows, bottom + 1);\n                            scrollTo(0, bottom, \"vertical\");\n                        }\n\n                        break;\n                    }\n                    case -1: {\n                        // motion up\n                        if (bottom > row + 1) {\n                            bottom--;\n                            scrollTo(0, bottom, \"vertical\");\n                        } else {\n                            top = Math.max(0, top - 1);\n                            scrollTo(0, top, \"vertical\");\n                        }\n\n                        break;\n                    }\n                    default: {\n                        assertNever(y);\n                    }\n                }\n            }\n\n            if (x !== 0) {\n                if (x === 2) {\n                    right = mangledCols.length;\n                    left = col;\n                    scrollTo(right - 1 - rowMarkerOffset, 0, \"horizontal\");\n                } else if (x === -2) {\n                    left = rowMarkerOffset;\n                    right = col + 1;\n                    scrollTo(left - rowMarkerOffset, 0, \"horizontal\");\n                } else {\n                    let disallowed: number[] = [];\n                    if (getCellsForSelection !== undefined) {\n                        const cells = getCellsForSelection(\n                            {\n                                x: left,\n                                y: top,\n                                width: right - left - rowMarkerOffset,\n                                height: bottom - top,\n                            },\n                            abortControllerRef.current.signal\n                        );\n\n                        if (typeof cells === \"object\") {\n                            disallowed = getSpanStops(cells);\n                        }\n                    }\n                    if (x === 1) {\n                        // motion right\n                        let done = false;\n                        if (left < col) {\n                            if (disallowed.length > 0) {\n                                const target = range(left + 1, col + 1).find(\n                                    n => !disallowed.includes(n - rowMarkerOffset)\n                                );\n                                if (target !== undefined) {\n                                    left = target;\n                                    done = true;\n                                }\n                            } else {\n                                left++;\n                                done = true;\n                            }\n                            if (done) scrollTo(left, 0, \"horizontal\");\n                        }\n                        if (!done) {\n                            right = Math.min(mangledCols.length, right + 1);\n                            scrollTo(right - 1 - rowMarkerOffset, 0, \"horizontal\");\n                        }\n                    } else if (x === -1) {\n                        // motion left\n                        let done = false;\n                        if (right > col + 1) {\n                            if (disallowed.length > 0) {\n                                const target = range(right - 1, col, -1).find(\n                                    n => !disallowed.includes(n - rowMarkerOffset)\n                                );\n                                if (target !== undefined) {\n                                    right = target;\n                                    done = true;\n                                }\n                            } else {\n                                right--;\n                                done = true;\n                            }\n                            if (done) scrollTo(right - rowMarkerOffset, 0, \"horizontal\");\n                        }\n                        if (!done) {\n                            left = Math.max(rowMarkerOffset, left - 1);\n                            scrollTo(left - rowMarkerOffset, 0, \"horizontal\");\n                        }\n                    } else {\n                        assertNever(x);\n                    }\n                }\n            }\n\n            setCurrent(\n                {\n                    cell: gridSelection.current.cell,\n                    range: {\n                        x: left,\n                        y: top,\n                        width: right - left,\n                        height: bottom - top,\n                    },\n                },\n                true,\n                false,\n                \"keyboard-select\"\n            );\n        },\n        [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]\n    );\n\n    const updateSelectedCell = React.useCallback(\n        (col: number, row: number, fromEditingTrailingRow: boolean, freeMove: boolean): boolean => {\n            const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);\n            col = clamp(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);\n            row = clamp(row, 0, rowMax);\n\n            if (col === currentCell?.[0] && row === currentCell?.[1]) return false;\n            if (freeMove && gridSelection.current !== undefined) {\n                const newStack = [...gridSelection.current.rangeStack];\n                if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {\n                    newStack.push(gridSelection.current.range);\n                }\n                setGridSelection(\n                    {\n                        ...gridSelection,\n                        current: {\n                            cell: [col, row],\n                            range: { x: col, y: row, width: 1, height: 1 },\n                            rangeStack: newStack,\n                        },\n                    },\n                    true\n                );\n            } else {\n                setCurrent(\n                    {\n                        cell: [col, row],\n                        range: { x: col, y: row, width: 1, height: 1 },\n                    },\n                    true,\n                    false,\n                    \"keyboard-nav\"\n                );\n            }\n\n            if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {\n                lastSent.current = undefined;\n            }\n\n            scrollTo(col - rowMarkerOffset, row);\n\n            return true;\n        },\n        [\n            mangledRows,\n            rowMarkerOffset,\n            columns.length,\n            currentCell,\n            gridSelection,\n            scrollTo,\n            setGridSelection,\n            setCurrent,\n        ]\n    );\n\n    const onFinishEditing = React.useCallback(\n        (newValue: GridCell | undefined, movement: readonly [-1 | 0 | 1, -1 | 0 | 1]) => {\n            if (overlay?.cell !== undefined && newValue !== undefined && isEditableGridCell(newValue)) {\n                mangledOnCellsEdited([{ location: overlay.cell, value: newValue }]);\n                window.requestAnimationFrame(() => {\n                    gridRef.current?.damage([\n                        {\n                            cell: overlay.cell,\n                        },\n                    ]);\n                });\n            }\n            focus(true);\n            setOverlay(undefined);\n\n            const [movX, movY] = movement;\n            if (gridSelection.current !== undefined && (movX !== 0 || movY !== 0)) {\n                const isEditingTrailingRow =\n                    gridSelection.current.cell[1] === mangledRows - 1 && newValue !== undefined;\n                updateSelectedCell(\n                    clamp(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1),\n                    clamp(gridSelection.current.cell[1] + movY, 0, mangledRows - 1),\n                    isEditingTrailingRow,\n                    false\n                );\n            }\n            onFinishedEditing?.(newValue, movement);\n        },\n        [\n            overlay?.cell,\n            focus,\n            gridSelection,\n            onFinishedEditing,\n            mangledOnCellsEdited,\n            mangledRows,\n            updateSelectedCell,\n            mangledCols.length,\n        ]\n    );\n\n    const overlayID = React.useMemo(() => {\n        return `gdg-overlay-${idCounter++}`;\n    }, []);\n\n    const onKeyDown = React.useCallback(\n        (event: GridKeyEventArgs) => {\n            const fn = async () => {\n                let cancelled = false;\n                if (onKeyDownIn !== undefined) {\n                    onKeyDownIn({\n                        ...event,\n                        cancel: () => {\n                            cancelled = true;\n                        },\n                    });\n                }\n\n                if (cancelled) return;\n\n                const cancel = () => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                };\n\n                const overlayOpen = overlay !== undefined;\n                const { altKey, shiftKey, metaKey, ctrlKey, key, bounds } = event;\n                const isOSX = browserIsOSX.value;\n                const isPrimaryKey = isOSX ? metaKey : ctrlKey;\n                const isDeleteKey = key === \"Delete\" || (isOSX && key === \"Backspace\");\n                const vr = visibleRegionRef.current;\n                const selectedColumns = gridSelection.columns;\n                const selectedRows = gridSelection.rows;\n\n                if (key === \"Escape\") {\n                    if (overlayOpen) {\n                        setOverlay(undefined);\n                    } else if (keybindings.clear) {\n                        setGridSelection(emptyGridSelection, false);\n                        onSelectionCleared?.();\n                    }\n                    return;\n                } else if (isHotkey(\"primary+a\", event) && keybindings.selectAll) {\n                    if (!overlayOpen) {\n                        setGridSelection(\n                            {\n                                columns: CompactSelection.empty(),\n                                rows: CompactSelection.empty(),\n                                current: {\n                                    cell: gridSelection.current?.cell ?? [rowMarkerOffset, 0],\n                                    range: {\n                                        x: rowMarkerOffset,\n                                        y: 0,\n                                        width: columnsIn.length,\n                                        height: rows,\n                                    },\n                                    rangeStack: [],\n                                },\n                            },\n                            false\n                        );\n                    } else {\n                        const el = document.getElementById(overlayID);\n                        if (el !== null) {\n                            const s = window.getSelection();\n                            const r = document.createRange();\n                            r.selectNodeContents(el);\n                            s?.removeAllRanges();\n                            s?.addRange(r);\n                        }\n                    }\n                    cancel();\n                    return;\n                } else if (isHotkey(\"primary+f\", event) && keybindings.search) {\n                    cancel();\n                    searchInputRef?.current?.focus({ preventScroll: true });\n                    setShowSearchInner(true);\n                }\n\n                function deleteRange(r: Rectangle) {\n                    focus();\n                    const editList: EditListItem[] = [];\n                    for (let x = r.x; x < r.x + r.width; x++) {\n                        for (let y = r.y; y < r.y + r.height; y++) {\n                            const cellValue = getCellContent([x - rowMarkerOffset, y]);\n                            if (!cellValue.allowOverlay && cellValue.kind !== GridCellKind.Boolean) continue;\n                            let newVal: InnerGridCell | undefined = undefined;\n                            if (cellValue.kind === GridCellKind.Custom) {\n                                const editor = provideEditor?.(cellValue);\n                                if (isObjectEditorCallbackResult(editor)) {\n                                    newVal = editor?.deletedValue?.(cellValue);\n                                }\n                            } else if (\n                                (isEditableGridCell(cellValue) && cellValue.allowOverlay) ||\n                                cellValue.kind === GridCellKind.Boolean\n                            ) {\n                                const toDelete = getCellRenderer(cellValue);\n                                newVal = toDelete?.onDelete?.(cellValue);\n                            }\n                            if (newVal !== undefined && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {\n                                editList.push({ location: [x, y], value: newVal });\n                            }\n                        }\n                    }\n                    mangledOnCellsEdited(editList);\n                    gridRef.current?.damage(editList.map(x => ({ cell: x.location })));\n                }\n\n                if (isDeleteKey) {\n                    const callbackResult = onDelete?.(gridSelection) ?? true;\n                    cancel();\n                    if (callbackResult !== false) {\n                        const toDelete = callbackResult === true ? gridSelection : callbackResult;\n\n                        // delete order:\n                        // 1) primary range\n                        // 2) secondary ranges\n                        // 3) columns\n                        // 4) rows\n\n                        if (toDelete.current !== undefined) {\n                            deleteRange(toDelete.current.range);\n                            for (const r of toDelete.current.rangeStack) {\n                                deleteRange(r);\n                            }\n                        }\n\n                        for (const r of toDelete.rows) {\n                            deleteRange({\n                                x: rowMarkerOffset,\n                                y: r,\n                                width: mangledCols.length - rowMarkerOffset,\n                                height: 1,\n                            });\n                        }\n\n                        for (const col of toDelete.columns) {\n                            deleteRange({\n                                x: col,\n                                y: 0,\n                                width: 1,\n                                height: rows,\n                            });\n                        }\n                    }\n                    return;\n                }\n\n                if (gridSelection.current === undefined) return;\n                let [col, row] = gridSelection.current.cell;\n                let freeMove = false;\n\n                if (keybindings.selectColumn && isHotkey(\"ctrl+ \", event) && columnSelect !== \"none\") {\n                    if (selectedColumns.hasIndex(col)) {\n                        setSelectedColumns(selectedColumns.remove(col), undefined, true);\n                    } else {\n                        if (columnSelect === \"single\") {\n                            setSelectedColumns(CompactSelection.fromSingleSelection(col), undefined, true);\n                        } else {\n                            setSelectedColumns(undefined, col, true);\n                        }\n                    }\n                } else if (keybindings.selectRow && isHotkey(\"shift+ \", event) && rowSelect !== \"none\") {\n                    if (selectedRows.hasIndex(row)) {\n                        setSelectedRows(selectedRows.remove(row), undefined, true);\n                    } else {\n                        if (rowSelect === \"single\") {\n                            setSelectedRows(CompactSelection.fromSingleSelection(row), undefined, true);\n                        } else {\n                            setSelectedRows(undefined, row, true);\n                        }\n                    }\n                } else if (\n                    (isHotkey(\"Enter\", event) || isHotkey(\" \", event) || isHotkey(\"shift+Enter\", event)) &&\n                    bounds !== undefined\n                ) {\n                    if (overlayOpen) {\n                        setOverlay(undefined);\n                        if (isHotkey(\"Enter\", event)) {\n                            row++;\n                        } else if (isHotkey(\"shift+Enter\", event)) {\n                            row--;\n                        }\n                    } else if (row === rows && showTrailingBlankRow) {\n                        window.setTimeout(() => {\n                            const customTargetColumn = getCustomNewRowTargetColumn(col);\n                            void appendRow(customTargetColumn ?? col);\n                        }, 0);\n                    } else {\n                        onCellActivated?.([col - rowMarkerOffset, row]);\n                        reselect(bounds, true);\n                        cancel();\n                    }\n                } else if (\n                    keybindings.downFill &&\n                    isHotkey(\"primary+_68\", event) &&\n                    gridSelection.current.range.height > 1\n                ) {\n                    // ctrl/cmd + d\n                    fillDown(false);\n                    cancel();\n                } else if (\n                    keybindings.rightFill &&\n                    isHotkey(\"primary+_82\", event) &&\n                    gridSelection.current.range.width > 1\n                ) {\n                    // ctrl/cmd + r\n                    const editList: EditListItem[] = [];\n                    const r = gridSelection.current.range;\n                    for (let y = 0; y < r.height; y++) {\n                        const fillRow = y + r.y;\n                        const fillVal = getMangledCellContent([r.x, fillRow]);\n                        if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;\n                        for (let x = 1; x < r.width; x++) {\n                            const fillCol = x + r.x;\n                            const target = [fillCol, fillRow] as const;\n                            editList.push({\n                                location: target,\n                                value: { ...fillVal },\n                            });\n                        }\n                    }\n                    mangledOnCellsEdited(editList);\n                    gridRef.current?.damage(\n                        editList.map(c => ({\n                            cell: c.location,\n                        }))\n                    );\n                    cancel();\n                } else if (keybindings.pageDown && isHotkey(\"PageDown\", event)) {\n                    row += Math.max(1, visibleRegionRef.current.height - 4); // partial cell accounting\n                    cancel();\n                } else if (keybindings.pageUp && isHotkey(\"PageUp\", event)) {\n                    row -= Math.max(1, visibleRegionRef.current.height - 4); // partial cell accounting\n                    cancel();\n                } else if (keybindings.first && isHotkey(\"primary+Home\", event)) {\n                    setOverlay(undefined);\n                    row = 0;\n                    col = 0;\n                } else if (keybindings.last && isHotkey(\"primary+End\", event)) {\n                    setOverlay(undefined);\n                    row = Number.MAX_SAFE_INTEGER;\n                    col = Number.MAX_SAFE_INTEGER;\n                } else if (keybindings.first && isHotkey(\"primary+shift+Home\", event)) {\n                    setOverlay(undefined);\n                    adjustSelection([-2, -2]);\n                } else if (keybindings.last && isHotkey(\"primary+shift+End\", event)) {\n                    setOverlay(undefined);\n                    adjustSelection([2, 2]);\n                    // eslint-disable-next-line unicorn/prefer-switch\n                } else if (key === \"ArrowDown\") {\n                    if (ctrlKey && altKey) {\n                        return;\n                    }\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([0, isPrimaryKey && !altKey ? 2 : 1]);\n                    } else {\n                        if (altKey && !isPrimaryKey) {\n                            freeMove = true;\n                        }\n                        if (isPrimaryKey && !altKey) {\n                            row = rows - 1;\n                        } else {\n                            row += 1;\n                        }\n                    }\n                } else if (key === \"ArrowUp\" || key === \"Home\") {\n                    const asPrimary = key === \"Home\" || isPrimaryKey;\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([0, asPrimary && !altKey ? -2 : -1]);\n                    } else {\n                        if (altKey && !asPrimary) {\n                            freeMove = true;\n                        }\n                        row += asPrimary && !altKey ? Number.MIN_SAFE_INTEGER : -1;\n                    }\n                } else if (key === \"ArrowRight\" || key === \"End\") {\n                    const asPrimary = key === \"End\" || isPrimaryKey;\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([asPrimary && !altKey ? 2 : 1, 0]);\n                    } else {\n                        if (altKey && !asPrimary) {\n                            freeMove = true;\n                        }\n                        col += asPrimary && !altKey ? Number.MAX_SAFE_INTEGER : 1;\n                    }\n                } else if (key === \"ArrowLeft\") {\n                    setOverlay(undefined);\n                    if (shiftKey && (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n                        // ctrl + alt is used as a screen reader command, let's not nuke it.\n                        adjustSelection([isPrimaryKey && !altKey ? -2 : -1, 0]);\n                    } else {\n                        if (altKey && !isPrimaryKey) {\n                            freeMove = true;\n                        }\n                        col += isPrimaryKey && !altKey ? Number.MIN_SAFE_INTEGER : -1;\n                    }\n                } else if (key === \"Tab\") {\n                    setOverlay(undefined);\n                    if (shiftKey) {\n                        col--;\n                    } else {\n                        col++;\n                    }\n                } else if (\n                    !metaKey &&\n                    !ctrlKey &&\n                    gridSelection.current !== undefined &&\n                    key.length === 1 &&\n                    /[ -~]/g.test(key) &&\n                    bounds !== undefined &&\n                    isReadWriteCell(getCellContent([col - rowMarkerOffset, Math.max(0, row - 1)]))\n                ) {\n                    if (\n                        (!lastRowSticky || row !== rows) &&\n                        (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)\n                    ) {\n                        return;\n                    }\n                    reselect(bounds, true, key);\n                    cancel();\n                }\n\n                const moved = updateSelectedCell(col, row, false, freeMove);\n                if (moved) {\n                    cancel();\n                }\n            };\n            void fn();\n        },\n        [\n            onKeyDownIn,\n            overlay,\n            gridSelection,\n            keybindings.selectAll,\n            keybindings.search,\n            keybindings.selectColumn,\n            keybindings.selectRow,\n            keybindings.downFill,\n            keybindings.rightFill,\n            keybindings.pageDown,\n            keybindings.pageUp,\n            keybindings.first,\n            keybindings.last,\n            keybindings.clear,\n            columnSelect,\n            rowSelect,\n            getCellContent,\n            rowMarkerOffset,\n            updateSelectedCell,\n            setGridSelection,\n            onSelectionCleared,\n            columnsIn.length,\n            rows,\n            overlayID,\n            focus,\n            mangledOnCellsEdited,\n            provideEditor,\n            getCellRenderer,\n            onDelete,\n            mangledCols.length,\n            setSelectedColumns,\n            setSelectedRows,\n            showTrailingBlankRow,\n            getCustomNewRowTargetColumn,\n            appendRow,\n            onCellActivated,\n            reselect,\n            fillDown,\n            getMangledCellContent,\n            adjustSelection,\n            rangeSelect,\n            lastRowSticky,\n        ]\n    );\n\n    const onPasteInternal = React.useCallback(\n        async (e?: ClipboardEvent) => {\n            if (!keybindings.paste) return;\n            function pasteToCell(inner: InnerGridCell, target: Item, toPaste: string): EditListItem | undefined {\n                if (!isInnerOnlyCell(inner) && isReadWriteCell(inner) && inner.readonly !== true) {\n                    const coerced = coercePasteValue?.(toPaste, inner);\n                    if (coerced !== undefined && isEditableGridCell(coerced)) {\n                        if (process.env.NODE_ENV !== \"production\" && coerced.kind !== inner.kind) {\n                            // eslint-disable-next-line no-console\n                            console.warn(\"Coercion should not change cell kind.\");\n                        }\n                        return {\n                            location: target,\n                            value: coerced,\n                        };\n                    }\n                    const r = getCellRenderer(inner);\n                    if (r === undefined) return undefined;\n                    if (r.kind === GridCellKind.Custom) {\n                        assert(inner.kind === GridCellKind.Custom);\n                        const newVal = r.onPaste?.(toPaste, inner);\n                        if (newVal === undefined) return undefined;\n                        return {\n                            location: target,\n                            value: {\n                                ...inner,\n                                data: newVal,\n                            },\n                        };\n                    } else {\n                        const newVal = r.onPaste?.(toPaste, inner);\n                        if (newVal === undefined) return undefined;\n                        assert(newVal.kind === inner.kind);\n                        return {\n                            location: target,\n                            value: newVal,\n                        };\n                    }\n                }\n                return undefined;\n            }\n\n            const selectedColumns = gridSelection.columns;\n            const selectedRows = gridSelection.rows;\n            const focused =\n                scrollRef.current?.contains(document.activeElement) === true ||\n                canvasRef.current?.contains(document.activeElement) === true;\n\n            let target = gridSelection.current?.cell;\n            if (target === undefined && selectedColumns.length === 1) {\n                target = [selectedColumns.first() ?? 0, 0];\n            }\n            if (target === undefined && selectedRows.length === 1) {\n                target = [rowMarkerOffset, selectedRows.first() ?? 0];\n            }\n\n            if (focused && target !== undefined) {\n                let data: string[][] | undefined;\n                let text: string | undefined;\n\n                const textPlain = \"text/plain\";\n                const textHtml = \"text/html\";\n\n                if (navigator.clipboard.read !== undefined) {\n                    const clipboardContent = await navigator.clipboard.read();\n\n                    for (const item of clipboardContent) {\n                        if (item.types.includes(textHtml)) {\n                            const htmlBlob = await item.getType(textHtml);\n                            const html = await htmlBlob.text();\n                            const fragment = document.createElement(\"html\");\n                            fragment.innerHTML = html;\n                            const el = fragment.querySelector(\"table\");\n                            if (el !== null) {\n                                data = decodeHTML(el);\n                                break;\n                            }\n                        }\n                        if (item.types.includes(textPlain)) {\n                            // eslint-disable-next-line unicorn/no-await-expression-member\n                            text = await (await item.getType(textPlain)).text();\n                        }\n                    }\n                } else if (navigator.clipboard.readText !== undefined) {\n                    text = await navigator.clipboard.readText();\n                } else if (e !== undefined && e?.clipboardData !== null) {\n                    if (e.clipboardData.types.includes(textHtml)) {\n                        const html = e.clipboardData.getData(textHtml);\n                        const fragment = document.createElement(\"html\");\n                        fragment.innerHTML = html;\n                        const el = fragment.querySelector(\"table\");\n                        if (el !== null) {\n                            data = decodeHTML(el);\n                        }\n                    }\n                    if (data === undefined && e.clipboardData.types.includes(textPlain)) {\n                        text = e.clipboardData.getData(textPlain);\n                    }\n                } else {\n                    return; // I didn't want to read that paste value anyway\n                }\n\n                const [gridCol, gridRow] = target;\n\n                const editList: EditListItem[] = [];\n                do {\n                    if (onPaste === undefined) {\n                        const cellData = getMangledCellContent(target);\n                        const newVal = pasteToCell(\n                            cellData,\n                            target,\n                            text ?? data?.map(r => r.join(\"\\t\")).join(\"\\t\") ?? \"\"\n                        );\n                        if (newVal !== undefined) {\n                            editList.push(newVal);\n                        }\n                        break;\n                    }\n\n                    if (data === undefined) {\n                        if (text === undefined) return;\n                        data = unquote(text);\n                    }\n\n                    if (\n                        onPaste === false ||\n                        (typeof onPaste === \"function\" &&\n                            onPaste?.([target[0] - rowMarkerOffset, target[1]], data) !== true)\n                    ) {\n                        return;\n                    }\n\n                    for (const [row, dataRow] of data.entries()) {\n                        if (row + gridRow >= rows) break;\n                        for (const [col, dataItem] of dataRow.entries()) {\n                            const index = [col + gridCol, row + gridRow] as const;\n                            const cellData = getMangledCellContent(index);\n                            const newVal = pasteToCell(cellData, index, dataItem);\n                            if (newVal !== undefined) {\n                                editList.push(newVal);\n                            }\n                        }\n                    }\n                    // eslint-disable-next-line no-constant-condition\n                } while (false);\n\n                mangledOnCellsEdited(editList);\n\n                gridRef.current?.damage(\n                    editList.map(c => ({\n                        cell: c.location,\n                    }))\n                );\n            }\n        },\n        [\n            coercePasteValue,\n            getCellRenderer,\n            getMangledCellContent,\n            gridSelection,\n            keybindings.paste,\n            mangledOnCellsEdited,\n            onPaste,\n            rowMarkerOffset,\n            rows,\n        ]\n    );\n\n    useEventListener(\"paste\", onPasteInternal, window, false, true);\n\n    // While this function is async, we deeply prefer not to await if we don't have to. This will lead to unpacking\n    // promises in rather awkward ways when possible to avoid awaiting. We have to use fallback copy mechanisms when\n    // an await has happened.\n    const onCopy = React.useCallback(\n        async (e?: ClipboardEvent, ignoreFocus?: boolean) => {\n            if (!keybindings.copy) return;\n            const focused =\n                ignoreFocus === true ||\n                scrollRef.current?.contains(document.activeElement) === true ||\n                canvasRef.current?.contains(document.activeElement) === true;\n\n            const selectedColumns = gridSelection.columns;\n            const selectedRows = gridSelection.rows;\n\n            if (focused && getCellsForSelection !== undefined) {\n                if (gridSelection.current !== undefined) {\n                    let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);\n                    if (typeof thunk !== \"object\") {\n                        thunk = await thunk();\n                    }\n                    copyToClipboard(\n                        thunk,\n                        range(\n                            gridSelection.current.range.x - rowMarkerOffset,\n                            gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset\n                        ),\n                        e\n                    );\n                } else if (selectedRows !== undefined && selectedRows.length > 0) {\n                    const toCopy = [...selectedRows];\n                    const cells = toCopy.map(rowIndex => {\n                        const thunk = getCellsForSelection(\n                            {\n                                x: rowMarkerOffset,\n                                y: rowIndex,\n                                width: columnsIn.length - rowMarkerOffset,\n                                height: 1,\n                            },\n                            abortControllerRef.current.signal\n                        );\n                        if (typeof thunk === \"object\") {\n                            return thunk[0];\n                        }\n                        return thunk().then(v => v[0]);\n                    });\n                    if (cells.some(x => x instanceof Promise)) {\n                        const settled = await Promise.all(cells);\n                        copyToClipboard(settled, range(columnsIn.length), e);\n                    } else {\n                        copyToClipboard(cells as (readonly GridCell[])[], range(columnsIn.length), e);\n                    }\n                } else if (selectedColumns.length > 0) {\n                    const results: (readonly (readonly GridCell[])[])[] = [];\n                    const cols: number[] = [];\n                    for (const col of selectedColumns) {\n                        let thunk = getCellsForSelection(\n                            {\n                                x: col,\n                                y: 0,\n                                width: 1,\n                                height: rows,\n                            },\n                            abortControllerRef.current.signal\n                        );\n                        if (typeof thunk !== \"object\") {\n                            thunk = await thunk();\n                        }\n                        results.push(thunk);\n                        cols.push(col - rowMarkerOffset);\n                    }\n                    if (results.length === 1) {\n                        copyToClipboard(results[0], cols, e);\n                    } else {\n                        // FIXME: this is dumb\n                        const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));\n                        copyToClipboard(toCopy, cols, e);\n                    }\n                }\n            }\n        },\n        [columnsIn.length, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows]\n    );\n\n    useEventListener(\"copy\", onCopy, window, false, false);\n\n    const onSearchResultsChanged = React.useCallback(\n        (results: readonly Item[], navIndex: number) => {\n            if (results.length === 0 || navIndex === -1) return;\n\n            const [col, row] = results[navIndex];\n            if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {\n                return;\n            }\n            lastSent.current = [col, row];\n            updateSelectedCell(col, row, false, false);\n        },\n        [updateSelectedCell]\n    );\n\n    // this effects purpose in life is to scroll the newly selected cell into view when and ONLY when that cell\n    // is from an external gridSelection change. Also note we want the unmangled out selection because scrollTo\n    // expects unmangled indexes\n    const [outCol, outRow] = gridSelectionOuter?.current?.cell ?? [];\n    const scrollToRef = React.useRef(scrollTo);\n    scrollToRef.current = scrollTo;\n    React.useEffect(() => {\n        if (\n            outCol !== undefined &&\n            outRow !== undefined &&\n            (outCol !== expectedExternalGridSelection.current?.current?.cell[0] ||\n                outRow !== expectedExternalGridSelection.current?.current?.cell[1])\n        ) {\n            scrollToRef.current(outCol, outRow);\n        }\n    }, [outCol, outRow]);\n\n    const disabledRows = React.useMemo(() => {\n        if (showTrailingBlankRow === true && trailingRowOptions?.tint === true) {\n            return CompactSelection.fromSingleSelection(mangledRows - 1);\n        }\n        return CompactSelection.empty();\n    }, [mangledRows, showTrailingBlankRow, trailingRowOptions?.tint]);\n\n    const mangledVerticalBorder = React.useCallback(\n        (col: number) => {\n            return typeof verticalBorder === \"boolean\"\n                ? verticalBorder\n                : verticalBorder?.(col - rowMarkerOffset) ?? true;\n        },\n        [rowMarkerOffset, verticalBorder]\n    );\n\n    const renameGroupNode = React.useMemo(() => {\n        if (renameGroup === undefined || canvasRef.current === null) return null;\n        const { bounds, group } = renameGroup;\n        const canvasBounds = canvasRef.current.getBoundingClientRect();\n        return (\n            <GroupRename\n                bounds={bounds}\n                group={group}\n                canvasBounds={canvasBounds}\n                onClose={() => setRenameGroup(undefined)}\n                onFinish={newVal => {\n                    setRenameGroup(undefined);\n                    onGroupHeaderRenamed?.(group, newVal);\n                }}\n            />\n        );\n    }, [onGroupHeaderRenamed, renameGroup]);\n\n    const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));\n\n    React.useImperativeHandle(\n        forwardedRef,\n        () => ({\n            appendRow: (col: number) => appendRow(col + rowMarkerOffset),\n            updateCells: damageList => {\n                if (rowMarkerOffset !== 0) {\n                    damageList = damageList.map(x => ({ cell: [x.cell[0] + rowMarkerOffset, x.cell[1]] }));\n                }\n                return gridRef.current?.damage(damageList);\n            },\n            getBounds: (col, row) => {\n                return gridRef.current?.getBounds(col + rowMarkerOffset, row);\n            },\n            focus: () => gridRef.current?.focus(),\n            emit: async e => {\n                switch (e) {\n                    case \"delete\":\n                        onKeyDown({\n                            bounds: undefined,\n                            cancel: () => undefined,\n                            stopPropagation: () => undefined,\n                            preventDefault: () => undefined,\n                            ctrlKey: false,\n                            key: \"Delete\",\n                            keyCode: 46,\n                            metaKey: false,\n                            shiftKey: false,\n                            altKey: false,\n                            rawEvent: undefined,\n                        });\n                        break;\n                    case \"fill-right\":\n                        onKeyDown({\n                            bounds: undefined,\n                            cancel: () => undefined,\n                            stopPropagation: () => undefined,\n                            preventDefault: () => undefined,\n                            ctrlKey: true,\n                            key: \"r\",\n                            keyCode: 82,\n                            metaKey: false,\n                            shiftKey: false,\n                            altKey: false,\n                            rawEvent: undefined,\n                        });\n                        break;\n                    case \"fill-down\":\n                        onKeyDown({\n                            bounds: undefined,\n                            cancel: () => undefined,\n                            stopPropagation: () => undefined,\n                            preventDefault: () => undefined,\n                            ctrlKey: true,\n                            key: \"d\",\n                            keyCode: 68,\n                            metaKey: false,\n                            shiftKey: false,\n                            altKey: false,\n                            rawEvent: undefined,\n                        });\n                        break;\n                    case \"copy\":\n                        await onCopy(undefined, true);\n                        break;\n                    case \"paste\":\n                        await onPasteInternal();\n                        break;\n                }\n            },\n            scrollTo,\n        }),\n        [appendRow, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]\n    );\n\n    const [selCol, selRow] = currentCell ?? [];\n    const onCellFocused = React.useCallback(\n        (cell: Item) => {\n            const [col, row] = cell;\n\n            if (row === -1) {\n                if (columnSelect !== \"none\") {\n                    setSelectedColumns(CompactSelection.fromSingleSelection(col), undefined, false);\n                    focus();\n                }\n                return;\n            }\n\n            if (selCol === col && selRow === row) return;\n            setCurrent(\n                {\n                    cell,\n                    range: { x: col, y: row, width: 1, height: 1 },\n                },\n                true,\n                false,\n                \"keyboard-nav\"\n            );\n            scrollTo(col, row);\n        },\n        [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]\n    );\n\n    const [isFocused, setIsFocused] = React.useState(false);\n    const setIsFocusedDebounced = React.useRef(\n        debounce((val: boolean) => {\n            setIsFocused(val);\n        }, 5)\n    );\n\n    const onCanvasFocused = React.useCallback(() => {\n        setIsFocusedDebounced.current(true);\n\n        // check for mouse state, don't do anything if the user is clicked to focus.\n        if (\n            gridSelection.current === undefined &&\n            gridSelection.columns.length === 0 &&\n            gridSelection.rows.length === 0 &&\n            mouseState === undefined\n        ) {\n            setCurrent(\n                {\n                    cell: [rowMarkerOffset, cellYOffset],\n                    range: {\n                        x: rowMarkerOffset,\n                        y: cellYOffset,\n                        width: 1,\n                        height: 1,\n                    },\n                },\n                true,\n                false,\n                \"keyboard-select\"\n            );\n        }\n    }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);\n\n    const onFocusOut = React.useCallback(() => {\n        setIsFocusedDebounced.current(false);\n    }, []);\n\n    const [idealWidth, idealHeight] = React.useMemo(() => {\n        let h: number;\n        const scrollbarWidth = experimental?.scrollbarWidthOverride ?? getScrollBarWidth();\n        const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);\n        if (typeof rowHeight === \"number\") {\n            h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;\n        } else {\n            let avg = 0;\n            const toAverage = Math.min(rowsCountWithTrailingRow, 10);\n            for (let i = 0; i < toAverage; i++) {\n                avg += rowHeight(i);\n            }\n            avg = Math.floor(avg / toAverage);\n\n            h = totalHeaderHeight + rowsCountWithTrailingRow * avg;\n        }\n        h += scrollbarWidth;\n\n        const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;\n\n        // We need to set a reasonable cap here as some browsers will just ignore huge values\n        // rather than treat them as huge values.\n        return [`${Math.min(100_000, w)}px`, `${Math.min(100_000, h)}px`];\n    }, [mangledCols, experimental?.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);\n\n    return (\n        <ThemeContext.Provider value={mergedTheme}>\n            <DataEditorContainer\n                style={makeCSSStyle(mergedTheme)}\n                className={className}\n                inWidth={width ?? idealWidth}\n                inHeight={height ?? idealHeight}>\n                <DataGridSearch\n                    fillHandle={fillHandle}\n                    drawFocusRing={drawFocusRing}\n                    experimental={experimental}\n                    fixedShadowX={fixedShadowX}\n                    fixedShadowY={fixedShadowY}\n                    getRowThemeOverride={p.getRowThemeOverride}\n                    headerIcons={headerIcons}\n                    imageWindowLoader={imageWindowLoader}\n                    initialSize={initialSize}\n                    isDraggable={isDraggable}\n                    onDragLeave={onDragLeave}\n                    onRowMoved={onRowMoved}\n                    overscrollX={overscrollX}\n                    overscrollY={overscrollY}\n                    preventDiagonalScrolling={preventDiagonalScrolling}\n                    rightElement={rightElement}\n                    rightElementProps={rightElementProps}\n                    showMinimap={showMinimap}\n                    smoothScrollX={smoothScrollX}\n                    smoothScrollY={smoothScrollY}\n                    className={className}\n                    enableGroups={enableGroups}\n                    onCanvasFocused={onCanvasFocused}\n                    onCanvasBlur={onFocusOut}\n                    canvasRef={canvasRef}\n                    onContextMenu={onContextMenu}\n                    theme={mergedTheme}\n                    cellXOffset={cellXOffset}\n                    cellYOffset={cellYOffset}\n                    accessibilityHeight={visibleRegion.height}\n                    onDragEnd={onDragEnd}\n                    columns={mangledCols}\n                    drawCustomCell={drawCell}\n                    drawHeader={drawHeader}\n                    disabledRows={disabledRows}\n                    freezeColumns={mangledFreezeColumns}\n                    lockColumns={rowMarkerOffset}\n                    firstColAccessible={rowMarkerOffset === 0}\n                    getCellContent={getMangledCellContent}\n                    minColumnWidth={minColumnWidth}\n                    maxColumnWidth={maxColumnWidth}\n                    searchInputRef={searchInputRef}\n                    showSearch={showSearch}\n                    onSearchClose={onSearchClose}\n                    highlightRegions={highlightRegions}\n                    getCellsForSelection={getCellsForSelection}\n                    getGroupDetails={mangledGetGroupDetails}\n                    headerHeight={headerHeight}\n                    isFocused={isFocused}\n                    groupHeaderHeight={enableGroups ? groupHeaderHeight : 0}\n                    trailingRowType={\n                        !showTrailingBlankRow ? \"none\" : trailingRowOptions?.sticky === true ? \"sticky\" : \"appended\"\n                    }\n                    onColumnResize={onColumnResize}\n                    onColumnResizeEnd={onColumnResizeEnd}\n                    onColumnResizeStart={onColumnResizeStart}\n                    onCellFocused={onCellFocused}\n                    onColumnMoved={onColumnMovedImpl}\n                    onDragStart={onDragStartImpl}\n                    onHeaderMenuClick={onHeaderMenuClickInner}\n                    onItemHovered={onItemHoveredImpl}\n                    isFilling={mouseState?.fillHandle === true}\n                    onMouseMove={onMouseMoveImpl}\n                    onKeyDown={onKeyDown}\n                    onKeyUp={onKeyUpIn}\n                    onMouseDown={onMouseDown}\n                    onMouseUp={onMouseUp}\n                    onDragOverCell={onDragOverCell}\n                    onDrop={onDrop}\n                    onSearchResultsChanged={onSearchResultsChanged}\n                    onVisibleRegionChanged={onVisibleRegionChangedImpl}\n                    clientSize={[clientSize[0], clientSize[1]]}\n                    rowHeight={rowHeight}\n                    rows={mangledRows}\n                    scrollRef={scrollRef}\n                    selection={gridSelection}\n                    translateX={visibleRegion.tx}\n                    translateY={visibleRegion.ty}\n                    verticalBorder={mangledVerticalBorder}\n                    gridRef={gridRef}\n                    getCellRenderer={getCellRenderer}\n                    scrollToEnd={scrollToEnd}\n                />\n                {renameGroupNode}\n                {overlay !== undefined && (\n                    <DataGridOverlayEditor\n                        {...overlay}\n                        validateCell={validateCell}\n                        id={overlayID}\n                        getCellRenderer={getCellRenderer}\n                        className={experimental?.isSubGrid === true ? \"click-outside-ignore\" : undefined}\n                        provideEditor={provideEditor}\n                        imageEditorOverride={imageEditorOverride}\n                        onFinishEditing={onFinishEditing}\n                        markdownDivCreateNode={markdownDivCreateNode}\n                    />\n                )}\n            </DataEditorContainer>\n        </ThemeContext.Provider>\n    );\n};\n\n/**\n * The primary component of Glide Data Grid.\n * @category DataEditor\n * @param {DataEditorProps} props\n */\nexport const DataEditor = React.forwardRef(DataEditorImpl);\n","export function proveType<T>(_val: T) {\n    // do nothing, just prove the compiler thinks the types match\n}\n\nfunction panic(message: string = \"This should not happen\"): never {\n    throw new Error(message);\n}\n\nexport function assert(fact: boolean, message: string = \"Assertion failed\"): asserts fact {\n    if (fact) return;\n    return panic(message);\n}\n\nexport function assertNever(_never: never): never {\n    return panic(\"Hell froze over\");\n}\nexport function maybe<T>(fn: () => T, defaultValue: T) {\n    try {\n        return fn();\n    } catch {\n        return defaultValue;\n    }\n}\n\n// The following code is licensed under the MIT license to Luke Edwards\n// Original license and code can be found here: https://github.com/lukeed/dequal/blob/master/license\n// I have merely \"ported\" it to be TS (any any any) and directly included it for convenience.\nconst has = Object.prototype.hasOwnProperty;\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function deepEqual(foo: any, bar: any): boolean {\n    let ctor: any, len: number;\n    if (foo === bar) return true;\n\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n        if (ctor === Date) return foo.getTime() === bar.getTime();\n        if (ctor === RegExp) return foo.toString() === bar.toString();\n\n        if (ctor === Array) {\n            if ((len = foo.length) === bar.length) {\n                while (len-- && deepEqual(foo[len], bar[len]));\n            }\n            return len === -1;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (!ctor || typeof foo === \"object\") {\n            len = 0;\n            // eslint-disable-next-line guard-for-in\n            for (ctor in foo) {\n                if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n                if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor])) return false;\n            }\n            return Object.keys(bar).length === len;\n        }\n    }\n\n    return foo !== foo && bar !== bar;\n}\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nimport { makeCSSStyle, Theme, ThemeContext } from \"../common/styles\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport {\n    EditableGridCell,\n    GridCell,\n    isEditableGridCell,\n    isInnerOnlyCell,\n    isObjectEditorCallbackResult,\n    Item,\n    ProvideEditorCallback,\n    ProvideEditorCallbackResult,\n    Rectangle,\n    ValidatedGridCell,\n} from \"../data-grid/data-grid-types\";\nimport { DataGridOverlayEditorStyle } from \"./data-grid-overlay-editor-style\";\nimport type { OverlayImageEditorProps } from \"./private/image-overlay-editor\";\nimport { useStayOnScreen } from \"./use-stay-on-screen\";\n\ntype ImageEditorType = React.ComponentType<OverlayImageEditorProps>;\n\ninterface DataGridOverlayEditorProps {\n    readonly target: Rectangle;\n    readonly cell: Item;\n    readonly content: GridCell;\n    readonly className?: string;\n    readonly id: string;\n    readonly initialValue?: string;\n    readonly theme: Theme;\n    readonly onFinishEditing: (newCell: GridCell | undefined, movement: readonly [-1 | 0 | 1, -1 | 0 | 1]) => void;\n    readonly forceEditMode: boolean;\n    readonly highlight: boolean;\n    readonly imageEditorOverride?: ImageEditorType;\n    readonly getCellRenderer: GetCellRendererCallback;\n    readonly markdownDivCreateNode?: (content: string) => DocumentFragment;\n    readonly provideEditor?: ProvideEditorCallback<GridCell>;\n    readonly validateCell?: (\n        cell: Item,\n        newValue: EditableGridCell,\n        prevValue: GridCell\n    ) => boolean | ValidatedGridCell;\n}\n\nconst DataGridOverlayEditor: React.FunctionComponent<DataGridOverlayEditorProps> = p => {\n    const {\n        target,\n        content,\n        onFinishEditing: onFinishEditingIn,\n        forceEditMode,\n        initialValue,\n        imageEditorOverride,\n        markdownDivCreateNode,\n        highlight,\n        className,\n        theme,\n        id,\n        cell,\n        validateCell,\n        getCellRenderer,\n        provideEditor,\n    } = p;\n\n    const [tempValue, setTempValueRaw] = React.useState<GridCell | undefined>(forceEditMode ? content : undefined);\n    const lastValueRef = React.useRef(tempValue ?? content);\n    lastValueRef.current = tempValue ?? content;\n\n    const [isValid, setIsValid] = React.useState(() => {\n        if (validateCell === undefined) return true;\n        return !(isEditableGridCell(content) && validateCell?.(cell, content, lastValueRef.current) === false);\n    });\n\n    const onFinishEditing = React.useCallback<typeof onFinishEditingIn>(\n        (newCell, movement) => {\n            onFinishEditingIn(isValid ? newCell : undefined, movement);\n        },\n        [isValid, onFinishEditingIn]\n    );\n\n    const setTempValue = React.useCallback(\n        (newVal: GridCell | undefined) => {\n            if (validateCell !== undefined && newVal !== undefined && isEditableGridCell(newVal)) {\n                const validResult = validateCell(cell, newVal, lastValueRef.current);\n                if (validResult === false) {\n                    setIsValid(false);\n                } else if (typeof validResult === \"object\") {\n                    newVal = validResult;\n                    setIsValid(true);\n                } else {\n                    setIsValid(true);\n                }\n            }\n            setTempValueRaw(newVal);\n        },\n        [cell, validateCell]\n    );\n\n    const finished = React.useRef(false);\n    const customMotion = React.useRef<[-1 | 0 | 1, -1 | 0 | 1] | undefined>(undefined);\n\n    const onClickOutside = React.useCallback(() => {\n        onFinishEditing(tempValue, [0, 0]);\n        finished.current = true;\n    }, [tempValue, onFinishEditing]);\n\n    const onEditorFinished = React.useCallback(\n        (newValue: GridCell | undefined) => {\n            onFinishEditing(newValue, customMotion.current ?? [0, 0]);\n            finished.current = true;\n        },\n        [onFinishEditing]\n    );\n\n    const onKeyDown = React.useCallback(\n        async (event: React.KeyboardEvent) => {\n            let save = false;\n            if (event.key === \"Escape\") {\n                event.stopPropagation();\n                event.preventDefault();\n                customMotion.current = [0, 0];\n            } else if (event.key === \"Enter\" && !event.shiftKey) {\n                event.stopPropagation();\n                event.preventDefault();\n                customMotion.current = [0, 1];\n                save = true;\n            } else if (event.key === \"Tab\") {\n                event.stopPropagation();\n                event.preventDefault();\n                customMotion.current = [event.shiftKey ? -1 : 1, 0];\n                save = true;\n            }\n\n            window.setTimeout(() => {\n                if (!finished.current && customMotion.current !== undefined) {\n                    onFinishEditing(save ? tempValue : undefined, customMotion.current);\n                    finished.current = true;\n                }\n            }, 0);\n        },\n        [onFinishEditing, tempValue]\n    );\n\n    const targetValue = tempValue ?? content;\n\n    const [editorProvider, useLabel] = React.useMemo((): [ProvideEditorCallbackResult<GridCell>, boolean] | [] => {\n        if (isInnerOnlyCell(content)) return [];\n        const external = provideEditor?.(content);\n        if (external !== undefined) return [external, false];\n        return [getCellRenderer(content)?.provideEditor?.(content), false];\n    }, [content, getCellRenderer, provideEditor]);\n\n    const { ref, style: stayOnScreenStyle } = useStayOnScreen();\n\n    let pad = true;\n    let editor: React.ReactNode;\n    let style = true;\n    let styleOverride: React.CSSProperties | undefined;\n\n    if (editorProvider !== undefined) {\n        pad = editorProvider.disablePadding !== true;\n        style = editorProvider.disableStyling !== true;\n        const isObjectEditor = isObjectEditorCallbackResult(editorProvider);\n        if (isObjectEditor) {\n            styleOverride = editorProvider.styleOverride;\n        }\n        const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;\n        editor = (\n            <CustomEditor\n                isHighlighted={highlight}\n                onChange={setTempValue}\n                value={targetValue}\n                initialValue={initialValue}\n                onFinishedEditing={onEditorFinished}\n                validatedSelection={isEditableGridCell(targetValue) ? targetValue.selectionRange : undefined}\n                forceEditMode={forceEditMode}\n                target={target}\n                imageEditorOverride={imageEditorOverride}\n                markdownDivCreateNode={markdownDivCreateNode}\n                isValid={isValid}\n            />\n        );\n    }\n\n    styleOverride = { ...styleOverride, ...stayOnScreenStyle };\n\n    // Consider imperatively creating and adding the element to the dom?\n    const portalElement = document.getElementById(\"portal\");\n    if (portalElement === null) {\n        // eslint-disable-next-line no-console\n        console.error(\n            'Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id=\"portal\" />` as the last child of your `<body>`.'\n        );\n        return null;\n    }\n\n    let classWrap = style ? \"gdg-style\" : \"gdg-unstyle\";\n    if (!isValid) {\n        classWrap += \" invalid\";\n    }\n\n    if (pad) {\n        classWrap += \" pad\";\n    }\n\n    return createPortal(\n        <ThemeContext.Provider value={theme}>\n            <ClickOutsideContainer style={makeCSSStyle(theme)} className={className} onClickOutside={onClickOutside}>\n                <DataGridOverlayEditorStyle\n                    ref={ref}\n                    id={id}\n                    className={classWrap}\n                    style={styleOverride}\n                    as={useLabel === true ? \"label\" : undefined}\n                    targetX={target.x}\n                    targetY={target.y}\n                    targetWidth={target.width}\n                    targetHeight={target.height}>\n                    <div className=\"clip-region\" onKeyDown={onKeyDown}>\n                        {editor}\n                    </div>\n                </DataGridOverlayEditorStyle>\n            </ClickOutsideContainer>\n        </ThemeContext.Provider>,\n        portalElement\n    );\n};\n\nexport default DataGridOverlayEditor;\n","import * as React from \"react\";\ninterface Props extends React.HTMLAttributes<HTMLDivElement> {\n    onClickOutside: () => void;\n}\n\nexport default class ClickOutsideContainer extends React.PureComponent<Props> {\n    private wrapperRef = React.createRef<HTMLDivElement>();\n\n    public componentDidMount() {\n        document.addEventListener(\"mousedown\", this.clickOutside, true);\n        document.addEventListener(\"contextmenu\", this.clickOutside, true);\n    }\n\n    public componentWillUnmount() {\n        document.removeEventListener(\"mousedown\", this.clickOutside);\n        document.removeEventListener(\"contextmenu\", this.clickOutside);\n    }\n\n    private clickOutside = (event: MouseEvent) => {\n        if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target as Node | null)) {\n            let node = event.target as Element | null;\n            while (node !== null) {\n                if (node.classList.contains(\"click-outside-ignore\")) {\n                    return;\n                }\n\n                node = node.parentElement;\n            }\n            this.props.onClickOutside();\n        }\n    };\n\n    public render(): React.ReactNode {\n        const { onClickOutside, ...rest } = this.props;\n        return (\n            <div {...rest} ref={this.wrapperRef}>\n                {this.props.children}\n            </div>\n        );\n    }\n}\n","import React from \"react\";\n\n// theme variable precidence\n\n/** @category Theme */\nexport function makeCSSStyle(theme: Theme): Record<string, string> {\n    return {\n        \"--gdg-accent-color\": theme.accentColor,\n        \"--gdg-accent-fg\": theme.accentFg,\n        \"--gdg-accent-light\": theme.accentLight,\n        \"--gdg-text-dark\": theme.textDark,\n        \"--gdg-text-medium\": theme.textMedium,\n        \"--gdg-text-light\": theme.textLight,\n        \"--gdg-text-bubble\": theme.textBubble,\n        \"--gdg-bg-icon-header\": theme.bgIconHeader,\n        \"--gdg-fg-icon-header\": theme.fgIconHeader,\n        \"--gdg-text-header\": theme.textHeader,\n        \"--gdg-text-group-header\": theme.textGroupHeader ?? theme.textHeader,\n        \"--gdg-text-header-selected\": theme.textHeaderSelected,\n        \"--gdg-bg-cell\": theme.bgCell,\n        \"--gdg-bg-cell-medium\": theme.bgCellMedium,\n        \"--gdg-bg-header\": theme.bgHeader,\n        \"--gdg-bg-header-has-focus\": theme.bgHeaderHasFocus,\n        \"--gdg-bg-header-hovered\": theme.bgHeaderHovered,\n        \"--gdg-bg-bubble\": theme.bgBubble,\n        \"--gdg-bg-bubble-selected\": theme.bgBubbleSelected,\n        \"--gdg-bg-search-result\": theme.bgSearchResult,\n        \"--gdg-border-color\": theme.borderColor,\n        \"--gdg-horizontal-border-color\": theme.horizontalBorderColor ?? theme.borderColor,\n        \"--gdg-drilldown-border\": theme.drilldownBorder,\n        \"--gdg-link-color\": theme.linkColor,\n        \"--gdg-cell-horizontal-padding\": `${theme.cellHorizontalPadding}px`,\n        \"--gdg-cell-vertical-padding\": `${theme.cellVerticalPadding}px`,\n        \"--gdg-header-font-style\": theme.headerFontStyle,\n        \"--gdg-base-font-style\": theme.baseFontStyle,\n        \"--gdg-font-family\": theme.fontFamily,\n        \"--gdg-editor-font-size\": theme.editorFontSize,\n    };\n}\n\n/** @category Theme */\nexport interface Theme {\n    accentColor: string;\n    accentFg: string;\n    accentLight: string;\n    textDark: string;\n    textMedium: string;\n    textLight: string;\n    textBubble: string;\n    bgIconHeader: string;\n    fgIconHeader: string;\n    textHeader: string;\n    textGroupHeader?: string;\n    textHeaderSelected: string;\n    bgCell: string;\n    bgCellMedium: string;\n    bgHeader: string;\n    bgHeaderHasFocus: string;\n    bgHeaderHovered: string;\n    bgBubble: string;\n    bgBubbleSelected: string;\n    bgSearchResult: string;\n    borderColor: string;\n    horizontalBorderColor?: string;\n    headerBottomBorderColor?: string;\n    drilldownBorder: string;\n    linkColor: string;\n    cellHorizontalPadding: number;\n    cellVerticalPadding: number;\n    headerFontStyle: string;\n    baseFontStyle: string;\n    fontFamily: string;\n    editorFontSize: string;\n    lineHeight: number;\n}\n\nconst dataEditorBaseTheme: Theme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n\n    bgSearchResult: \"#fff9e3\",\n\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n\n    linkColor: \"#4F5DFF\",\n\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4, //unitless scaler depends on your font\n};\n\n/** @category Theme */\nexport function getDataEditorTheme(): Theme {\n    return dataEditorBaseTheme;\n}\n\n/** @category Theme */\nexport const ThemeContext = React.createContext<Theme>(dataEditorBaseTheme);\n/** @category Hooks */\nexport function useTheme(): Theme {\n    return React.useContext(ThemeContext);\n}\n","import type { Theme } from \"../common/styles\";\nimport { assertNever, proveType } from \"../common/support\";\nimport has from \"lodash/has.js\";\nimport type React from \"react\";\nimport type { CSSProperties } from \"react\";\nimport type { SpriteManager } from \"./data-grid-sprites\";\nimport type { OverlayImageEditorProps } from \"../data-grid-overlay-editor/private/image-overlay-editor\";\n\n// Thoughts:\n// rows/columns are called out as selected, but when selected they must also be added\n// to the range. Handling delete events may have different desired outcomes depending on\n// how the range came to be selected. The rows/columns properties retain this essential\n// information.\n/** @category Selection */\nexport interface GridSelection {\n    readonly current?: {\n        readonly cell: Item;\n        readonly range: Readonly<Rectangle>;\n        readonly rangeStack: readonly Readonly<Rectangle>[]; // lowest to highest, does not include range\n    };\n    readonly columns: CompactSelection;\n    readonly rows: CompactSelection;\n}\n\n/** @category Types */\nexport type ImageEditorType = React.ComponentType<OverlayImageEditorProps>;\n\n/** @category Types */\nexport type GridMouseEventArgs =\n    | GridMouseCellEventArgs\n    | GridMouseHeaderEventArgs\n    | GridMouseOutOfBoundsEventArgs\n    | GridMouseGroupHeaderEventArgs;\n\ninterface PreventableEvent {\n    preventDefault: () => void;\n}\n/** @category Types */\nexport interface CellClickedEventArgs extends GridMouseCellEventArgs, PreventableEvent {}\n\n/** @category Types */\nexport interface HeaderClickedEventArgs extends GridMouseHeaderEventArgs, PreventableEvent {}\n\n/** @category Types */\nexport interface GroupHeaderClickedEventArgs extends GridMouseGroupHeaderEventArgs, PreventableEvent {}\n\n/** @category Types */\nexport interface ImageWindowLoader {\n    setWindow(newWindow: Rectangle, freezeCols: number): void;\n    loadOrGetImage(url: string, col: number, row: number): HTMLImageElement | ImageBitmap | undefined;\n    setCallback(imageLoaded: (locations: readonly Item[]) => void): void;\n}\n\n/** @category Types */\nexport const BooleanEmpty = null;\n/** @category Types */\nexport const BooleanIndeterminate = undefined;\n\n/** @category Types */\nexport type BooleanEmpty = null;\n/** @category Types */\nexport type BooleanIndeterminate = undefined;\n\ninterface PositionableMouseEventArgs {\n    readonly localEventX: number;\n    readonly localEventY: number;\n}\n\n/** @category Types */\nexport interface BaseGridMouseEventArgs {\n    readonly shiftKey: boolean;\n    readonly ctrlKey: boolean;\n    readonly metaKey: boolean;\n    readonly isTouch: boolean;\n    readonly isLongTouch?: boolean;\n    readonly isEdge: boolean;\n    readonly button: number;\n    readonly scrollEdge: readonly [xDir: -1 | 0 | 1, yDir: -1 | 0 | 1];\n}\n\n/** @category Types */\nexport interface GridMouseCellEventArgs extends BaseGridMouseEventArgs, PositionableMouseEventArgs {\n    readonly kind: \"cell\";\n    readonly location: Item;\n    readonly bounds: Rectangle;\n    readonly isFillHandle: boolean;\n}\n\n/** @category Types */\nexport const headerKind = \"header\" as const;\n/** @category Types */\nexport interface GridMouseHeaderEventArgs extends BaseGridMouseEventArgs, PositionableMouseEventArgs {\n    readonly kind: typeof headerKind;\n    readonly location: readonly [number, -1];\n    readonly bounds: Rectangle;\n    readonly group: string;\n}\n\n/** @category Types */\nexport const groupHeaderKind = \"group-header\" as const;\n/** @category Types */\nexport interface GridMouseGroupHeaderEventArgs extends BaseGridMouseEventArgs, PositionableMouseEventArgs {\n    readonly kind: typeof groupHeaderKind;\n    readonly location: readonly [number, -2];\n    readonly bounds: Rectangle;\n    readonly group: string;\n}\n\n/** @category Types */\nexport const outOfBoundsKind = \"out-of-bounds\" as const;\n/** @category Types */\nexport interface GridMouseOutOfBoundsEventArgs extends BaseGridMouseEventArgs {\n    readonly kind: typeof outOfBoundsKind;\n    readonly location: Item;\n    readonly direction: readonly [-1 | 0 | 1, -1 | 0 | 1];\n}\n\n/** @category Types */\nexport interface GridKeyEventArgs {\n    readonly bounds: Rectangle | undefined;\n    readonly key: string;\n    readonly keyCode: number;\n    readonly altKey: boolean;\n    readonly shiftKey: boolean;\n    readonly ctrlKey: boolean;\n    readonly metaKey: boolean;\n    readonly cancel: () => void;\n    readonly stopPropagation: () => void;\n    readonly preventDefault: () => void;\n    readonly rawEvent: React.KeyboardEvent<HTMLElement> | undefined;\n}\n\ninterface DragHandler {\n    readonly setData: (mime: string, payload: string) => void;\n    readonly setDragImage: (image: Element, x: number, y: number) => void;\n    readonly preventDefault: () => void;\n    readonly defaultPrevented: () => boolean;\n}\n\n/** @category Types */\nexport type GridDragEventArgs = GridMouseEventArgs & DragHandler;\n\n/** @category Types */\nexport type TrailingRowType = \"sticky\" | \"appended\" | \"none\";\n\n/** @category Types */\nexport type DrawCustomCellCallback = (args: {\n    ctx: CanvasRenderingContext2D;\n    cell: GridCell;\n    theme: Theme;\n    rect: Rectangle;\n    col: number;\n    row: number;\n    hoverAmount: number;\n    hoverX: number | undefined;\n    hoverY: number | undefined;\n    highlighted: boolean;\n    imageLoader: ImageWindowLoader;\n    requestAnimationFrame: () => void;\n}) => boolean;\n\n/** @category Types */\nexport type DrawHeaderCallback = (args: {\n    ctx: CanvasRenderingContext2D;\n    column: GridColumn;\n    columnIndex: number;\n    theme: Theme;\n    rect: Rectangle;\n    hoverAmount: number;\n    isSelected: boolean;\n    isHovered: boolean;\n    hasSelectedCell: boolean;\n    spriteManager: SpriteManager;\n    menuBounds: Rectangle;\n}) => boolean;\n\n/** @category Cells */\nexport enum GridCellKind {\n    Uri = \"uri\",\n    Text = \"text\",\n    Image = \"image\",\n    RowID = \"row-id\",\n    Number = \"number\",\n    Bubble = \"bubble\",\n    Boolean = \"boolean\",\n    Loading = \"loading\",\n    Markdown = \"markdown\",\n    Drilldown = \"drilldown\",\n    Protected = \"protected\",\n    Custom = \"custom\",\n}\n\n/** @category Columns */\nexport enum GridColumnIcon {\n    HeaderRowID = \"headerRowID\",\n    HeaderCode = \"headerCode\",\n    HeaderNumber = \"headerNumber\",\n    HeaderString = \"headerString\",\n    HeaderBoolean = \"headerBoolean\",\n    HeaderAudioUri = \"headerAudioUri\",\n    HeaderVideoUri = \"headerVideoUri\",\n    HeaderEmoji = \"headerEmoji\",\n    HeaderImage = \"headerImage\",\n    HeaderUri = \"headerUri\",\n    HeaderPhone = \"headerPhone\",\n    HeaderMarkdown = \"headerMarkdown\",\n    HeaderDate = \"headerDate\",\n    HeaderTime = \"headerTime\",\n    HeaderEmail = \"headerEmail\",\n    HeaderReference = \"headerReference\",\n    HeaderIfThenElse = \"headerIfThenElse\",\n    HeaderSingleValue = \"headerSingleValue\",\n    HeaderLookup = \"headerLookup\",\n    HeaderTextTemplate = \"headerTextTemplate\",\n    HeaderMath = \"headerMath\",\n    HeaderRollup = \"headerRollup\",\n    HeaderJoinStrings = \"headerJoinStrings\",\n    HeaderSplitString = \"headerSplitString\",\n    HeaderGeoDistance = \"headerGeoDistance\",\n    HeaderArray = \"headerArray\",\n    RowOwnerOverlay = \"rowOwnerOverlay\",\n    ProtectedColumnOverlay = \"protectedColumnOverlay\",\n}\n\n/** @category Types */\nexport type CellArray = readonly (readonly GridCell[])[];\n\n/** @category Types */\nexport type Item = readonly [col: number, row: number];\n\n/** @category Types */\nexport const headerCellCheckboxPrefix = \"___gdg_header_cell_\";\n/** @category Types */\nexport const headerCellCheckedMarker = headerCellCheckboxPrefix + \"checked\";\n/** @category Types */\nexport const headerCellUnheckedMarker = headerCellCheckboxPrefix + \"unchecked\";\n/** @category Types */\nexport const headerCellIndeterminateMarker = headerCellCheckboxPrefix + \"indeterminate\";\n\ninterface BaseGridColumn {\n    readonly title: string;\n    readonly group?: string;\n    readonly icon?: GridColumnIcon | string;\n    readonly overlayIcon?: GridColumnIcon | string;\n    readonly hasMenu?: boolean;\n    readonly grow?: number;\n    readonly style?: \"normal\" | \"highlight\";\n    readonly themeOverride?: Partial<Theme>;\n    readonly trailingRowOptions?: {\n        readonly hint?: string;\n        readonly addIcon?: string;\n        readonly targetColumn?: number | GridColumn;\n        readonly themeOverride?: Partial<Theme>;\n        readonly disabled?: boolean;\n    };\n}\n\n/** @category Columns */\nexport function isSizedGridColumn(c: GridColumn): c is SizedGridColumn {\n    return \"width\" in c && typeof c.width === \"number\";\n}\n\n/** @category Columns */\nexport interface SizedGridColumn extends BaseGridColumn {\n    readonly width: number;\n    readonly id?: string;\n}\n\n/** @category Columns */\nexport interface AutoGridColumn extends BaseGridColumn {\n    readonly id: string;\n}\n\n/** @category Types */\nexport async function resolveCellsThunk(thunk: GetCellsThunk | CellArray): Promise<CellArray> {\n    if (typeof thunk === \"object\") return thunk;\n    return await thunk();\n}\n\n/** @category Types */\nexport type GetCellsThunk = () => Promise<CellArray>;\n\n/** @category Columns */\nexport type GridColumn = SizedGridColumn | AutoGridColumn;\n\n/** @category Columns */\nexport type InnerGridColumn = SizedGridColumn & { growOffset?: number };\n\n// export type SizedGridColumn = Omit<GridColumn, \"width\"> & { readonly width: number };\n\n/** @category Cells */\nexport type ReadWriteGridCell = TextCell | NumberCell | MarkdownCell | UriCell | CustomCell | BooleanCell;\n\n/** @category Cells */\nexport type EditableGridCell = TextCell | ImageCell | BooleanCell | MarkdownCell | UriCell | NumberCell | CustomCell;\n\n/** @category Cells */\nexport type EditableGridCellKind = EditableGridCell[\"kind\"];\n\n// All EditableGridCells are inherently ValidatedGridCells, and this is more specific and thus more useful.\n/** @category Cells */\nexport function isEditableGridCell(cell: GridCell): cell is ValidatedGridCell {\n    if (\n        cell.kind === GridCellKind.Loading ||\n        cell.kind === GridCellKind.Bubble ||\n        cell.kind === GridCellKind.RowID ||\n        cell.kind === GridCellKind.Protected ||\n        cell.kind === GridCellKind.Drilldown\n    ) {\n        return false;\n    }\n\n    proveType<EditableGridCell>(cell);\n    return true;\n}\n\n/** @category Cells */\nexport function isTextEditableGridCell(cell: GridCell): cell is ReadWriteGridCell {\n    if (\n        cell.kind === GridCellKind.Loading ||\n        cell.kind === GridCellKind.Bubble ||\n        cell.kind === GridCellKind.RowID ||\n        cell.kind === GridCellKind.Protected ||\n        cell.kind === GridCellKind.Drilldown ||\n        cell.kind === GridCellKind.Boolean ||\n        cell.kind === GridCellKind.Image ||\n        cell.kind === GridCellKind.Custom\n    ) {\n        return false;\n    }\n\n    proveType<ReadWriteGridCell>(cell);\n    return true;\n}\n\n/** @category Cells */\nexport function isInnerOnlyCell(cell: InnerGridCell): cell is InnerOnlyGridCell {\n    return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;\n}\n\n/** @category Cells */\nexport function isReadWriteCell(cell: GridCell): cell is ReadWriteGridCell {\n    if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image) return false;\n\n    if (\n        cell.kind === GridCellKind.Text ||\n        cell.kind === GridCellKind.Number ||\n        cell.kind === GridCellKind.Markdown ||\n        cell.kind === GridCellKind.Uri ||\n        cell.kind === GridCellKind.Custom ||\n        cell.kind === GridCellKind.Boolean\n    ) {\n        return cell.readonly !== true;\n    }\n    assertNever(cell);\n}\n\n/** @category Cells */\nexport type GridCell =\n    | EditableGridCell\n    | BubbleCell\n    | RowIDCell\n    | LoadingCell\n    | ProtectedCell\n    | DrilldownCell\n    | CustomCell;\n\ntype InnerOnlyGridCell = NewRowCell | MarkerCell;\n/** @category Cells */\nexport type InnerGridCell = GridCell | InnerOnlyGridCell;\n\n/** @category Cells */\nexport type CellList = readonly Item[];\n\n/** @category Types */\nexport interface Rectangle {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/** @category Cells */\nexport interface BaseGridCell {\n    readonly allowOverlay: boolean;\n    readonly lastUpdated?: number;\n    readonly style?: \"normal\" | \"faded\";\n    readonly themeOverride?: Partial<Theme>;\n    readonly span?: readonly [start: number, end: number];\n    readonly contentAlign?: \"left\" | \"right\" | \"center\";\n    readonly cursor?: CSSProperties[\"cursor\"];\n}\n\n/** @category Cells */\nexport interface LoadingCell extends BaseGridCell {\n    readonly kind: GridCellKind.Loading;\n}\n\n/** @category Cells */\nexport interface ProtectedCell extends BaseGridCell {\n    readonly kind: GridCellKind.Protected;\n}\n\n/** @category Cells */\nexport interface TextCell extends BaseGridCell {\n    readonly kind: GridCellKind.Text;\n    readonly displayData: string;\n    readonly data: string;\n    readonly readonly?: boolean;\n    readonly allowWrapping?: boolean;\n}\n\n/** @category Cells */\nexport interface NumberCell extends BaseGridCell {\n    readonly kind: GridCellKind.Number;\n    readonly displayData: string;\n    readonly data: number | undefined;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface ImageCell extends BaseGridCell {\n    readonly kind: GridCellKind.Image;\n    readonly data: string[];\n    readonly rounding?: number;\n    readonly displayData?: string[]; // used for small images for faster scrolling\n    readonly allowAdd: boolean;\n}\n\n/** @category Cells */\nexport interface BubbleCell extends BaseGridCell {\n    readonly kind: GridCellKind.Bubble;\n    readonly data: string[];\n}\n\n/** @category Renderers */\nexport type SelectionRange = number | readonly [number, number];\n\n/** @category Renderers */\nexport type ProvideEditorComponent<T extends InnerGridCell> = React.FunctionComponent<{\n    readonly onChange: (newValue: T) => void;\n    readonly onFinishedEditing: (newValue?: T) => void;\n    readonly isHighlighted: boolean;\n    readonly value: T;\n    readonly initialValue?: string;\n    readonly validatedSelection?: SelectionRange;\n    readonly imageEditorOverride?: ImageEditorType;\n    readonly markdownDivCreateNode?: (content: string) => DocumentFragment;\n    readonly target: Rectangle;\n    readonly forceEditMode: boolean;\n    readonly isValid?: boolean;\n}>;\n\ntype ObjectEditorCallbackResult<T extends InnerGridCell> = {\n    editor: ProvideEditorComponent<T>;\n    deletedValue?: (toDelete: T) => T;\n    styleOverride?: CSSProperties;\n    disablePadding?: boolean;\n    disableStyling?: boolean;\n};\n\n/** @category Renderers */\nexport type ProvideEditorCallbackResult<T extends InnerGridCell> =\n    | (ProvideEditorComponent<T> & {\n          disablePadding?: boolean;\n          disableStyling?: boolean;\n      })\n    | ObjectEditorCallbackResult<T>\n    | undefined;\n\n/** @category Renderers */\nexport function isObjectEditorCallbackResult<T extends InnerGridCell>(\n    obj: ProvideEditorCallbackResult<T>\n): obj is ObjectEditorCallbackResult<T> {\n    return has(obj, \"editor\");\n}\n\n/** @category Renderers */\nexport type ProvideEditorCallback<T extends InnerGridCell> = (cell: T) => ProvideEditorCallbackResult<T>;\n\n/** @category Cells */\nexport type ValidatedGridCell = EditableGridCell & {\n    selectionRange?: SelectionRange;\n};\n\n/** @category Cells */\nexport interface CustomCell<T extends {} = {}> extends BaseGridCell {\n    readonly kind: GridCellKind.Custom;\n    readonly data: T;\n    readonly copyData: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface DrilldownCellData {\n    readonly text: string;\n    readonly img?: string;\n}\n\n/** @category Cells */\nexport interface DrilldownCell extends BaseGridCell {\n    readonly kind: GridCellKind.Drilldown;\n    readonly data: readonly DrilldownCellData[];\n}\n\n/** @category Cells */\nexport interface BooleanCell extends BaseGridCell {\n    readonly kind: GridCellKind.Boolean;\n    readonly data: boolean | BooleanEmpty | BooleanIndeterminate;\n    readonly readonly?: boolean;\n    readonly allowOverlay: false;\n}\n\n// Can be written more concisely, not easier to read if more concise.\n/** @category Cells */\nexport function booleanCellIsEditable(cell: BooleanCell): boolean {\n    return !(cell.readonly ?? false);\n}\n\n/** @category Cells */\nexport interface RowIDCell extends BaseGridCell {\n    readonly kind: GridCellKind.RowID;\n    readonly data: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface MarkdownCell extends BaseGridCell {\n    readonly kind: GridCellKind.Markdown;\n    readonly data: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport interface UriCell extends BaseGridCell {\n    readonly kind: GridCellKind.Uri;\n    readonly data: string;\n    readonly readonly?: boolean;\n}\n\n/** @category Cells */\nexport enum InnerGridCellKind {\n    NewRow = \"new-row\",\n    Marker = \"marker\",\n}\n\n/** @category Cells */\nexport interface NewRowCell extends BaseGridCell {\n    readonly kind: InnerGridCellKind.NewRow;\n    readonly hint: string;\n    readonly allowOverlay: false;\n    readonly icon?: string;\n}\n\n/** @category Cells */\nexport interface MarkerCell extends BaseGridCell {\n    readonly kind: InnerGridCellKind.Marker;\n    readonly allowOverlay: false;\n    readonly row: number;\n    readonly drawHandle: boolean;\n    readonly checked: boolean;\n    readonly markerKind: \"checkbox\" | \"number\" | \"both\";\n}\n\n/** @category Selection */\nexport type Slice = [start: number, end: number];\n/** @category Selection */\nexport type CompactSelectionRanges = readonly Slice[];\n\nfunction mergeRanges(input: CompactSelectionRanges) {\n    if (input.length === 0) {\n        return [];\n    }\n    const ranges = [...input];\n\n    const stack: [number, number][] = [];\n\n    ranges.sort(function (a, b) {\n        return a[0] - b[0];\n    });\n\n    stack.push([...ranges[0]]);\n\n    for (const range of ranges.slice(1)) {\n        const top = stack[stack.length - 1];\n\n        if (top[1] < range[0]) {\n            stack.push([...range]);\n        } else if (top[1] < range[1]) {\n            top[1] = range[1];\n        }\n    }\n\n    return stack;\n}\n\nlet emptyCompactSelection: CompactSelection | undefined;\n\n/** @category Selection */\nexport class CompactSelection {\n    private constructor(private readonly items: CompactSelectionRanges) {}\n\n    static empty = (): CompactSelection => {\n        return emptyCompactSelection ?? (emptyCompactSelection = new CompactSelection([]));\n    };\n\n    static fromSingleSelection = (selection: number | Slice) => {\n        return CompactSelection.empty().add(selection);\n    };\n\n    offset = (amount: number): CompactSelection => {\n        if (amount === 0) return this;\n        const newItems = this.items.map(x => [x[0] + amount, x[1] + amount] as Slice);\n        return new CompactSelection(newItems);\n    };\n\n    add = (selection: number | Slice): CompactSelection => {\n        const slice: Slice = typeof selection === \"number\" ? [selection, selection + 1] : selection;\n\n        const newItems = mergeRanges([...this.items, slice]);\n\n        return new CompactSelection(newItems);\n    };\n\n    remove = (selection: number | Slice): CompactSelection => {\n        const items = [...this.items];\n\n        const selMin = typeof selection === \"number\" ? selection : selection[0];\n        const selMax = typeof selection === \"number\" ? selection + 1 : selection[1];\n\n        for (const [i, slice] of items.entries()) {\n            const [start, end] = slice;\n            // Remove part of slice that intersects removed selection.\n            if (start <= selMax && selMin <= end) {\n                const toAdd: Slice[] = [];\n                if (start < selMin) {\n                    toAdd.push([start, selMin]);\n                }\n                if (selMax < end) {\n                    toAdd.push([selMax, end]);\n                }\n                items.splice(i, 1, ...toAdd);\n            }\n        }\n        return new CompactSelection(items);\n    };\n\n    first = (): number | undefined => {\n        if (this.items.length === 0) return undefined;\n        return this.items[0][0];\n    };\n\n    last = (): number | undefined => {\n        if (this.items.length === 0) return undefined;\n        return this.items.slice(-1)[0][1] - 1;\n    };\n\n    hasIndex = (index: number): boolean => {\n        for (let i = 0; i < this.items.length; i++) {\n            const [start, end] = this.items[i];\n            if (index >= start && index < end) return true;\n        }\n        return false;\n    };\n\n    hasAll = (index: Slice): boolean => {\n        for (let x = index[0]; x < index[1]; x++) {\n            if (!this.hasIndex(x)) return false;\n        }\n        return true;\n    };\n\n    some = (predicate: (index: number) => boolean): boolean => {\n        for (const i of this) {\n            if (predicate(i)) return true;\n        }\n        return false;\n    };\n\n    equals = (other: CompactSelection): boolean => {\n        if (other === this) return true;\n\n        if (other.items.length !== this.items.length) return false;\n\n        for (let i = 0; i < this.items.length; i++) {\n            const left = other.items[i];\n            const right = this.items[i];\n\n            if (left[0] !== right[0] || left[1] !== right[1]) return false;\n        }\n\n        return true;\n    };\n\n    // Really old JS wont have access to the iterator and babel will stop people using it\n    // when trying to support browsers so old we don't support them anyway. What goes on\n    // between an engineer and their bundler in the privacy of their CI server is none of\n    // my business anyway.\n    toArray = (): number[] => {\n        const result: number[] = [];\n        for (const [start, end] of this.items) {\n            for (let x = start; x < end; x++) {\n                result.push(x);\n            }\n        }\n        return result;\n    };\n\n    get length(): number {\n        let len = 0;\n        for (const [start, end] of this.items) {\n            len += end - start;\n        }\n\n        return len;\n    }\n\n    *[Symbol.iterator]() {\n        for (const [start, end] of this.items) {\n            for (let x = start; x < end; x++) {\n                yield x;\n            }\n        }\n    }\n}\n","import { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetX: number;\n    targetY: number;\n    targetWidth: number;\n    targetHeight: number;\n}\nexport const DataGridOverlayEditorStyle = styled.div<Props>`\n    position: absolute;\n\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    box-sizing: border-box;\n\n    --overlay-top: ${p => p.targetY}px;\n\n    left: ${p => p.targetX - 1}px;\n    top: ${p => p.targetY - 1}px;\n    min-width: ${p => p.targetWidth + 2}px;\n    min-height: ${p => p.targetHeight + 2}px;\n    width: max-content;\n    max-width: 400px;\n    max-height: calc(100vh - ${p => p.targetY + 10}px);\n\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n\n    @keyframes glide_fade_in {\n        from {\n            opacity: 0%;\n        }\n\n        to {\n            opacity: 100%;\n        }\n    }\n\n    &.gdg-style {\n        border-radius: 2px;\n        background-color: var(--gdg-bg-cell);\n\n        box-shadow: 0 0 0 1px var(--gdg-accent-color), 0px 0px 1px rgba(62, 65, 86, 0.4),\n            0px 6px 12px rgba(62, 65, 86, 0.15);\n\n        animation: glide_fade_in 60ms 1;\n    }\n\n    &.pad {\n        padding: ${p => Math.max(0, (p.targetHeight - 28) / 2)}px 8.5px 3px;\n    }\n\n    .clip-region {\n        display: flex;\n        flex-direction: column;\n        overflow-y: auto;\n        overflow-x: hidden;\n        border-radius: 2px;\n        flex-grow: 1;\n\n        .gdg-growing-entry {\n            height: 100%;\n        }\n\n        & input.gdg-input {\n            width: 100%;\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n\n        & textarea.gdg-input {\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n    }\n\n    text-align: start;\n`;\n","import * as React from \"react\";\n\nfunction useRefState(): [HTMLElement | undefined, React.RefCallback<HTMLElement | null>] {\n    const [refState, setRefState] = React.useState<HTMLElement | null>();\n    return [refState ?? undefined, setRefState];\n}\n\ninterface StayOnScreen {\n    ref: React.RefCallback<HTMLElement | null>;\n    style: React.CSSProperties;\n}\n\nexport function useStayOnScreen(): StayOnScreen {\n    const [ref, setRef] = useRefState();\n    const [xOffset, setXOffset] = React.useState(0);\n    const [isIntersecting, setIsIntersecting] = React.useState(true);\n\n    React.useLayoutEffect(() => {\n        if (ref === undefined) return;\n        if (!(\"IntersectionObserver\" in window)) return;\n\n        const observer = new IntersectionObserver(\n            ents => {\n                if (ents.length === 0) return;\n                setIsIntersecting(ents[0].isIntersecting);\n            },\n            { threshold: 1 }\n        );\n        observer.observe(ref);\n\n        return () => observer.disconnect();\n    }, [ref]);\n\n    React.useEffect(() => {\n        if (isIntersecting || ref === undefined) return;\n\n        let rafHandle: number | undefined;\n        const fn = () => {\n            const { right: refRight } = ref.getBoundingClientRect();\n\n            setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));\n            rafHandle = requestAnimationFrame(fn);\n        };\n\n        rafHandle = requestAnimationFrame(fn);\n        return () => {\n            if (rafHandle !== undefined) {\n                cancelAnimationFrame(rafHandle);\n            }\n        };\n    }, [ref, isIntersecting]);\n\n    const style = React.useMemo(() => {\n        return { transform: `translateX(${xOffset}px)` };\n    }, [xOffset]);\n\n    return {\n        ref: setRef,\n        style,\n    };\n}\n","/* eslint-disable unicorn/consistent-destructuring */\nimport * as React from \"react\";\nimport { CellArray, GetCellsThunk, GridCellKind, Item, Rectangle } from \"../data-grid/data-grid-types\";\nimport ScrollingDataGrid, { ScrollingDataGridProps } from \"../scrolling-data-grid/scrolling-data-grid\";\nimport { SearchWrapper } from \"./data-grid-search-style\";\nimport { assert } from \"../common/support\";\n\n// icons\nconst upArrow = (\n    <svg className=\"button-icon\" viewBox=\"0 0 512 512\">\n        <path\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"48\"\n            d=\"M112 244l144-144 144 144M256 120v292\"\n        />\n    </svg>\n);\nconst downArrow = (\n    <svg className=\"button-icon\" viewBox=\"0 0 512 512\">\n        <path\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"48\"\n            d=\"M112 268l144 144 144-144M256 392V100\"\n        />\n    </svg>\n);\n\nconst closeX = (\n    <svg className=\"button-icon\" viewBox=\"0 0 512 512\">\n        <path\n            fill=\"none\"\n            stroke=\"currentColor\"\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"32\"\n            d=\"M368 368L144 144M368 144L144 368\"\n        />\n    </svg>\n);\n\nexport interface DataGridSearchProps extends Omit<ScrollingDataGridProps, \"prelightCells\"> {\n    readonly getCellsForSelection?: (selection: Rectangle, abortSignal: AbortSignal) => GetCellsThunk | CellArray;\n    readonly onSearchResultsChanged?: (results: readonly Item[], navIndex: number) => void;\n    /**\n     * Controls the visibility of the search overlay.\n     * @group Search\n     */\n    readonly showSearch?: boolean;\n    /**\n     * Emitted when the search window close event is triggered.\n     * @group Search\n     */\n    readonly onSearchClose?: () => void;\n    readonly searchInputRef: React.MutableRefObject<HTMLInputElement | null>;\n}\n\nconst targetSearchTimeMS = 10;\n\nconst DataGridSearch: React.FunctionComponent<DataGridSearchProps> = p => {\n    const {\n        canvasRef,\n        cellYOffset,\n        rows,\n        columns,\n        searchInputRef,\n        getCellsForSelection,\n        onSearchResultsChanged,\n        showSearch = false,\n        onSearchClose,\n    } = p;\n\n    const [searchID] = React.useState(() => \"search-box-\" + Math.round(Math.random() * 1000));\n\n    const [searchString, setSearchString] = React.useState(\"\");\n    const [searchStatus, setSearchStatus] =\n        React.useState<{\n            rowsSearched: number;\n            results: number;\n            selectedIndex: number;\n        }>();\n\n    const searchStatusRef = React.useRef(searchStatus);\n    searchStatusRef.current = searchStatus;\n\n    const abortControllerRef = React.useRef(new AbortController());\n    const searchHandle = React.useRef<number>();\n    const [searchResults, setSearchResults] = React.useState<readonly Item[]>([]);\n\n    const cancelSearch = React.useCallback(() => {\n        if (searchHandle.current !== undefined) {\n            window.cancelAnimationFrame(searchHandle.current);\n            searchHandle.current = undefined;\n            abortControllerRef.current.abort();\n        }\n    }, []);\n\n    const cellYOffsetRef = React.useRef(cellYOffset);\n    cellYOffsetRef.current = cellYOffset;\n    const beginSearch = React.useCallback(\n        (str: string) => {\n            const regex = new RegExp(str.replace(/([$()*+.?[\\\\\\]^{|}-])/g, \"\\\\$1\"), \"i\");\n\n            let startY = cellYOffsetRef.current;\n\n            // Lets assume we can do 10 rows at a time\n            // This is usually very safe and limits the damage for bad\n            // performing sheets.\n            let searchStride = Math.min(10, rows);\n\n            let rowsSearched = 0;\n\n            setSearchStatus(undefined);\n            setSearchResults([]);\n\n            const runningResult: [number, number][] = [];\n\n            const tick = async () => {\n                if (getCellsForSelection === undefined) return;\n                const tStart = performance.now();\n                const rowsLeft = rows - rowsSearched;\n                let data = getCellsForSelection(\n                    {\n                        x: 0,\n                        y: startY,\n                        width: columns.length,\n                        height: Math.min(searchStride, rowsLeft, rows - startY),\n                    },\n                    abortControllerRef.current.signal\n                );\n\n                if (typeof data === \"function\") {\n                    data = await data();\n                }\n\n                let added = false;\n                for (const [row, d] of data.entries()) {\n                    for (const [col, cell] of d.entries()) {\n                        let testString: string | undefined;\n                        switch (cell.kind) {\n                            case GridCellKind.Text:\n                            case GridCellKind.Number:\n                                testString = cell.displayData;\n                                break;\n                            case GridCellKind.Uri:\n                            case GridCellKind.Markdown:\n                                testString = cell.data;\n                                break;\n                            case GridCellKind.Boolean:\n                                testString = typeof cell.data === \"boolean\" ? cell.data.toString() : undefined;\n                                break;\n                            case GridCellKind.Image:\n                            case GridCellKind.Bubble:\n                                // I know its lazy, but unless someone is actually\n                                // searching for the whale emoji, this is pretty side effect\n                                // free. And ya know... it's nice and easy to do...\n                                testString = cell.data.join(\"\");\n                                break;\n                            case GridCellKind.Custom:\n                                testString = cell.copyData;\n                                break;\n                        }\n\n                        if (testString !== undefined && regex.test(testString)) {\n                            runningResult.push([col, row + startY]);\n                            added = true;\n                        }\n                    }\n                }\n\n                const tEnd = performance.now();\n\n                if (added) {\n                    setSearchResults([...runningResult]);\n                }\n\n                rowsSearched += data.length;\n                assert(rowsSearched <= rows);\n\n                const selectedIndex = searchStatusRef.current?.selectedIndex ?? -1;\n                setSearchStatus({\n                    results: runningResult.length,\n                    rowsSearched,\n                    selectedIndex,\n                });\n                onSearchResultsChanged?.(runningResult, selectedIndex);\n\n                if (startY + searchStride >= rows) {\n                    startY = 0;\n                } else {\n                    startY += searchStride;\n                }\n\n                const tElapsed = tEnd - tStart;\n                const rounded = Math.max(tElapsed, 1);\n\n                const scalar = targetSearchTimeMS / rounded;\n                searchStride = Math.ceil(searchStride * scalar);\n\n                if (rowsSearched < rows && runningResult.length < 1000) {\n                    searchHandle.current = window.requestAnimationFrame(tick);\n                }\n            };\n\n            cancelSearch();\n            searchHandle.current = window.requestAnimationFrame(tick);\n        },\n        [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]\n    );\n\n    const onClose = React.useCallback(() => {\n        onSearchClose?.();\n        setSearchStatus(undefined);\n        setSearchResults([]);\n        onSearchResultsChanged?.([], -1);\n        cancelSearch();\n        canvasRef?.current?.focus();\n    }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);\n\n    const onSearchChange = React.useCallback(\n        (event: React.ChangeEvent<HTMLInputElement>) => {\n            setSearchString(event.target.value);\n            if (event.target.value === \"\") {\n                setSearchStatus(undefined);\n                setSearchResults([]);\n                cancelSearch();\n            } else {\n                beginSearch(event.target.value);\n            }\n        },\n        [beginSearch, cancelSearch]\n    );\n\n    React.useEffect(() => {\n        if (showSearch && searchInputRef.current !== null) {\n            setSearchString(\"\");\n            searchInputRef.current.focus({ preventScroll: true });\n        }\n    }, [showSearch, searchInputRef]);\n\n    const onNext = React.useCallback(\n        (ev?: React.MouseEvent) => {\n            ev?.stopPropagation?.();\n            if (searchStatus === undefined) return;\n            const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;\n            setSearchStatus({\n                ...searchStatus,\n                selectedIndex: newIndex,\n            });\n            onSearchResultsChanged?.(searchResults, newIndex);\n        },\n        [searchStatus, onSearchResultsChanged, searchResults]\n    );\n\n    const onPrev = React.useCallback(\n        (ev?: React.MouseEvent) => {\n            ev?.stopPropagation?.();\n            if (searchStatus === undefined) return;\n            let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;\n            if (newIndex < 0) newIndex += searchStatus.results;\n            setSearchStatus({\n                ...searchStatus,\n                selectedIndex: newIndex,\n            });\n            onSearchResultsChanged?.(searchResults, newIndex);\n        },\n        [onSearchResultsChanged, searchResults, searchStatus]\n    );\n\n    const onSearchKeyDown = React.useCallback(\n        (event: React.KeyboardEvent<HTMLInputElement>) => {\n            if (((event.ctrlKey || event.metaKey) && event.nativeEvent.code === \"KeyF\") || event.key === \"Escape\") {\n                onClose();\n                event.stopPropagation();\n                event.preventDefault();\n            } else if (event.key === \"Enter\") {\n                if (event.shiftKey) {\n                    onPrev();\n                } else {\n                    onNext();\n                }\n            }\n        },\n        [onClose, onNext, onPrev]\n    );\n\n    // cancel search if the component is unmounted\n    React.useEffect(() => {\n        return () => {\n            cancelSearch();\n        };\n    }, [cancelSearch]);\n\n    const searchbox = React.useMemo(() => {\n        let resultString: string | undefined;\n        if (searchStatus !== undefined) {\n            resultString =\n                searchStatus.results >= 1000\n                    ? `over 1000`\n                    : `${searchStatus.results} result${searchStatus.results !== 1 ? \"s\" : \"\"}`;\n            if (searchStatus.selectedIndex >= 0) {\n                resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;\n            }\n        }\n\n        const cancelEvent = (ev: React.MouseEvent) => {\n            ev.stopPropagation();\n        };\n\n        const rowsSearchedProgress = Math.floor(((searchStatus?.rowsSearched ?? 0) / rows) * 100);\n        const progressStyle: React.CSSProperties = {\n            width: `${rowsSearchedProgress}%`,\n        };\n\n        return (\n            <SearchWrapper\n                showSearch={showSearch}\n                onMouseDown={cancelEvent}\n                onMouseMove={cancelEvent}\n                onMouseUp={cancelEvent}\n                onClick={cancelEvent}>\n                <div className=\"search-bar-inner\">\n                    <input\n                        id={searchID}\n                        aria-hidden={!showSearch}\n                        data-testid=\"search-input\"\n                        ref={searchInputRef}\n                        onChange={onSearchChange}\n                        value={searchString}\n                        tabIndex={showSearch ? undefined : -1}\n                        onKeyDownCapture={onSearchKeyDown}\n                    />\n                    <button\n                        aria-label=\"Previous Result\"\n                        aria-hidden={!showSearch}\n                        tabIndex={showSearch ? undefined : -1}\n                        onClick={onPrev}\n                        disabled={(searchStatus?.results ?? 0) === 0}>\n                        {upArrow}\n                    </button>\n                    <button\n                        aria-label=\"Next Result\"\n                        aria-hidden={!showSearch}\n                        tabIndex={showSearch ? undefined : -1}\n                        onClick={onNext}\n                        disabled={(searchStatus?.results ?? 0) === 0}>\n                        {downArrow}\n                    </button>\n                    {onSearchClose !== undefined && (\n                        <button\n                            aria-label=\"Close Search\"\n                            aria-hidden={!showSearch}\n                            data-testid=\"search-close-button\"\n                            tabIndex={showSearch ? undefined : -1}\n                            onClick={onClose}>\n                            {closeX}\n                        </button>\n                    )}\n                </div>\n                {searchStatus !== undefined ? (\n                    <>\n                        <div className=\"search-status\">\n                            <div data-testid=\"search-result-area\">{resultString}</div>\n                        </div>\n                        <div className=\"search-progress\" style={progressStyle} />\n                    </>\n                ) : (\n                    <div className=\"search-status\">\n                        <label htmlFor={searchID}>Type to search</label>\n                    </div>\n                )}\n            </SearchWrapper>\n        );\n    }, [\n        onClose,\n        onNext,\n        onPrev,\n        onSearchChange,\n        onSearchClose,\n        onSearchKeyDown,\n        rows,\n        searchStatus,\n        searchString,\n        showSearch,\n        searchID,\n        searchInputRef,\n    ]);\n\n    return (\n        <>\n            <ScrollingDataGrid\n                prelightCells={searchResults}\n                accessibilityHeight={p.accessibilityHeight}\n                canvasRef={p.canvasRef}\n                cellXOffset={p.cellXOffset}\n                cellYOffset={p.cellYOffset}\n                className={p.className}\n                clientSize={p.clientSize}\n                columns={p.columns}\n                disabledRows={p.disabledRows}\n                enableGroups={p.enableGroups}\n                fillHandle={p.fillHandle}\n                firstColAccessible={p.firstColAccessible}\n                fixedShadowX={p.fixedShadowX}\n                fixedShadowY={p.fixedShadowY}\n                freezeColumns={p.freezeColumns}\n                getCellContent={p.getCellContent}\n                getCellRenderer={p.getCellRenderer}\n                getGroupDetails={p.getGroupDetails}\n                getRowThemeOverride={p.getRowThemeOverride}\n                groupHeaderHeight={p.groupHeaderHeight}\n                headerHeight={p.headerHeight}\n                highlightRegions={p.highlightRegions}\n                imageWindowLoader={p.imageWindowLoader}\n                initialSize={p.initialSize}\n                isFilling={p.isFilling}\n                isFocused={p.isFocused}\n                lockColumns={p.lockColumns}\n                maxColumnWidth={p.maxColumnWidth}\n                minColumnWidth={p.minColumnWidth}\n                onHeaderMenuClick={p.onHeaderMenuClick}\n                onMouseMove={p.onMouseMove}\n                onVisibleRegionChanged={p.onVisibleRegionChanged}\n                overscrollX={p.overscrollX}\n                overscrollY={p.overscrollY}\n                preventDiagonalScrolling={p.preventDiagonalScrolling}\n                rightElement={p.rightElement}\n                rightElementProps={p.rightElementProps}\n                rowHeight={p.rowHeight}\n                rows={p.rows}\n                scrollRef={p.scrollRef}\n                selection={p.selection}\n                showMinimap={p.showMinimap}\n                theme={p.theme}\n                trailingRowType={p.trailingRowType}\n                translateX={p.translateX}\n                translateY={p.translateY}\n                verticalBorder={p.verticalBorder}\n                drawCustomCell={p.drawCustomCell}\n                drawFocusRing={p.drawFocusRing}\n                drawHeader={p.drawHeader}\n                experimental={p.experimental}\n                gridRef={p.gridRef}\n                headerIcons={p.headerIcons}\n                isDraggable={p.isDraggable}\n                onCanvasBlur={p.onCanvasBlur}\n                onCanvasFocused={p.onCanvasFocused}\n                onCellFocused={p.onCellFocused}\n                onColumnMoved={p.onColumnMoved}\n                onColumnResize={p.onColumnResize}\n                onColumnResizeEnd={p.onColumnResizeEnd}\n                onColumnResizeStart={p.onColumnResizeStart}\n                onContextMenu={p.onContextMenu}\n                onDragEnd={p.onDragEnd}\n                onDragLeave={p.onDragLeave}\n                onDragOverCell={p.onDragOverCell}\n                onDragStart={p.onDragStart}\n                onDrop={p.onDrop}\n                onItemHovered={p.onItemHovered}\n                onKeyDown={p.onKeyDown}\n                onKeyUp={p.onKeyUp}\n                onMouseDown={p.onMouseDown}\n                onMouseUp={p.onMouseUp}\n                onRowMoved={p.onRowMoved}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n                scrollToEnd={p.scrollToEnd}\n            />\n            {searchbox}\n        </>\n    );\n};\n\nexport default DataGridSearch;\n","import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport DataGridDnd, { DataGridDndProps } from \"../data-grid-dnd/data-grid-dnd\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\nimport { InfiniteScroller } from \"./infinite-scroller\";\nimport clamp from \"lodash/clamp.js\";\n\ntype Props = Omit<DataGridDndProps, \"width\" | \"height\" | \"eventTargetRef\">;\n\nexport interface ScrollingDataGridProps extends Props {\n    readonly className: string | undefined;\n    readonly onVisibleRegionChanged:\n        | ((\n              range: Rectangle,\n              clientWidth: number,\n              clientHeight: number,\n              rightElWidth: number,\n              tx: number,\n              ty: number\n          ) => void)\n        | undefined;\n    /**\n     * Causes the grid to scroll to the end when flipped to true\n     * @deprecated Use {@link DataEditorRef.scrollTo} instead\n     * @group Deprecated\n     */\n    readonly scrollToEnd: boolean | undefined;\n    readonly scrollRef: React.MutableRefObject<HTMLDivElement | null> | undefined;\n\n    /**\n     * The overscroll properties are used to allow the grid to scroll past the logical end of the content by a fixed\n     * number of pixels. This is useful particularly on the X axis if you allow for resizing columns as it can make\n     * resizing the final column significantly easier.\n     *\n     * @group Advanced\n     */\n    readonly overscrollX: number | undefined;\n    /** {@inheritDoc overscrollX}\n     * @group Advanced\n     */\n    readonly overscrollY: number | undefined;\n    /**\n     * Provides an initial size for the grid which can prevent a flicker on load if the initial size is known prior to\n     * layout.\n     *\n     * @group Advanced\n     */\n    readonly initialSize: readonly [width: number, height: number] | undefined;\n    /**\n     * Set to true to prevent any diagonal scrolling.\n     * @group Advanced\n     */\n    readonly preventDiagonalScrolling: boolean | undefined;\n\n    /**\n     * If `rightElementProps.sticky` is set to true the right element will be visible at all times, otherwise the user\n     * will need to scroll to the end to reveal it.\n     *\n     * If `rightElementProps.fill` is set, the right elements container will fill to consume all remaining space (if\n     * any) at the end of the grid. This does not play nice with growing columns.\n     *\n     * @group Advanced\n     */\n    readonly rightElementProps:\n        | {\n              readonly sticky?: boolean;\n              readonly fill?: boolean;\n          }\n        | undefined;\n    /**\n     * The right element is a DOM node which can be inserted at the end of the horizontal scroll region. This can be\n     * used to create a right handle panel, make a big add button, or display messages.\n     * @group Advanced\n     */\n    readonly rightElement: React.ReactNode | undefined;\n    /**\n     * Enables/disables the interactive minimap.\n     * @defaultValue false\n     * @group Advanced\n     */\n    readonly showMinimap: boolean | undefined;\n    readonly clientSize: readonly [number, number];\n}\n\nconst MinimapStyle = styled.div`\n    position: absolute;\n    right: 44px;\n    bottom: 44px;\n    background-color: var(--gdg-bg-cell);\n    background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n    border-radius: 4px;\n    z-index: 1;\n    box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n\n    overflow: hidden;\n\n    .header {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 4px;\n        background-color: var(--gdg-bg-header);\n        box-shadow: 0 0 0 1px var(--gdg-border-color);\n    }\n\n    .locationMarker {\n        position: absolute;\n\n        border: 1px solid var(--gdg-accent-color);\n        background-color: var(--gdg-accent-light);\n    }\n`;\n\nconst GridScroller: React.FunctionComponent<ScrollingDataGridProps> = p => {\n    const {\n        columns,\n        rows,\n        rowHeight,\n        headerHeight,\n        groupHeaderHeight,\n        enableGroups,\n        freezeColumns,\n        experimental,\n        clientSize,\n        className,\n        onVisibleRegionChanged,\n        scrollToEnd,\n        scrollRef,\n        preventDiagonalScrolling,\n        rightElement,\n        rightElementProps,\n        overscrollX,\n        overscrollY,\n        showMinimap = false,\n        initialSize,\n        smoothScrollX = false,\n        smoothScrollY = false,\n        isDraggable,\n    } = p;\n    const { paddingRight, paddingBottom } = experimental ?? {};\n\n    const [clientWidth, clientHeight] = clientSize;\n    const last = React.useRef<Rectangle | undefined>();\n    const lastX = React.useRef<number | undefined>();\n    const lastY = React.useRef<number | undefined>();\n    const lastSize = React.useRef<readonly [number, number] | undefined>();\n\n    const width = React.useMemo(() => {\n        let r = Math.max(0, overscrollX ?? 0);\n        for (const c of columns) {\n            r += c.width;\n        }\n        return r;\n    }, [columns, overscrollX]);\n\n    let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n    if (typeof rowHeight === \"number\") {\n        height += rows * rowHeight;\n    } else {\n        for (let r = 0; r < rows; r++) {\n            height += rowHeight(r);\n        }\n    }\n    if (overscrollY !== undefined) {\n        height += overscrollY;\n    }\n\n    const lastArgs = React.useRef<Rectangle & { paddingRight: number }>();\n\n    const processArgs = React.useCallback(() => {\n        if (lastArgs.current === undefined) return;\n        const args = { ...lastArgs.current };\n\n        let x = 0;\n        let tx = args.x < 0 ? -args.x : 0;\n        let cellRight = 0;\n        let cellX = 0;\n\n        args.x = args.x < 0 ? 0 : args.x;\n\n        let stickyColWidth = 0;\n        for (let i = 0; i < freezeColumns; i++) {\n            stickyColWidth += columns[i].width;\n        }\n\n        for (const c of columns) {\n            const cx = x - stickyColWidth;\n            if (args.x >= cx + c.width) {\n                x += c.width;\n                cellX++;\n                cellRight++;\n            } else if (args.x > cx) {\n                x += c.width;\n                if (smoothScrollX) {\n                    tx += cx - args.x;\n                } else {\n                    cellX++;\n                }\n                cellRight++;\n            } else if (args.x + args.width > cx) {\n                x += c.width;\n                cellRight++;\n            } else {\n                break;\n            }\n        }\n\n        let ty = 0;\n        let cellY = 0;\n        let cellBottom = 0;\n        if (typeof rowHeight === \"number\") {\n            if (smoothScrollY) {\n                cellY = Math.floor(args.y / rowHeight);\n                ty = cellY * rowHeight - args.y;\n            } else {\n                cellY = Math.ceil(args.y / rowHeight);\n            }\n            cellBottom = Math.ceil(args.height / rowHeight) + cellY;\n            if (ty < 0) cellBottom++;\n        } else {\n            let y = 0;\n            for (let row = 0; row < rows; row++) {\n                const rh = rowHeight(row);\n                const cy = y + (smoothScrollY ? 0 : rh / 2);\n                if (args.y >= y + rh) {\n                    y += rh;\n                    cellY++;\n                    cellBottom++;\n                } else if (args.y > cy) {\n                    y += rh;\n                    if (smoothScrollY) {\n                        ty += cy - args.y;\n                    } else {\n                        cellY++;\n                    }\n                    cellBottom++;\n                } else if (args.y + args.height > rh / 2 + y) {\n                    y += rh;\n                    cellBottom++;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        const rect: Rectangle = {\n            x: cellX,\n            y: cellY,\n            width: cellRight - cellX,\n            height: cellBottom - cellY,\n        };\n\n        const oldRect = last.current;\n\n        if (\n            oldRect === undefined ||\n            oldRect.y !== rect.y ||\n            oldRect.x !== rect.x ||\n            oldRect.height !== rect.height ||\n            oldRect.width !== rect.width ||\n            lastX.current !== tx ||\n            lastY.current !== ty ||\n            args.width !== lastSize.current?.[0] ||\n            args.height !== lastSize.current?.[1]\n        ) {\n            onVisibleRegionChanged?.(\n                {\n                    x: cellX,\n                    y: cellY,\n                    width: cellRight - cellX,\n                    height: cellBottom - cellY,\n                },\n                args.width,\n                args.height,\n                args.paddingRight ?? 0,\n                tx,\n                ty\n            );\n            last.current = rect;\n            lastX.current = tx;\n            lastY.current = ty;\n            lastSize.current = [args.width, args.height];\n        }\n    }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\n\n    const onScrollUpdate = React.useCallback(\n        (args: Rectangle & { paddingRight: number }) => {\n            lastArgs.current = args;\n            processArgs();\n        },\n        [processArgs]\n    );\n\n    React.useEffect(() => {\n        processArgs();\n    }, [processArgs]);\n\n    const scroller = scrollRef?.current ?? undefined;\n    const aspect = clamp(width / height, 2 / 3, 1.5);\n    const maxSize = 200;\n    const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);\n    const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;\n    const hRatio = w / width;\n    const vRatio = h / height;\n    const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);\n    const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);\n    const left = ((scroller?.scrollLeft ?? 0) / (width - clientWidth)) * (w - vWidth);\n    const top = ((scroller?.scrollTop ?? 0) / (height - clientHeight)) * (h - vHeight);\n\n    const minimap: React.ReactNode = React.useMemo(() => {\n        if (!showMinimap || vWidth === 0 || vHeight === 0) return undefined;\n\n        const handleMouse = (e: React.MouseEvent) => {\n            if (scroller === undefined) return;\n            const bounds = e.currentTarget.getBoundingClientRect();\n            const x = e.clientX - bounds.x - vWidth / 2;\n            const y = e.clientY - bounds.y - vHeight / 2;\n\n            const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));\n            const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));\n\n            scroller.scrollTo({\n                left: newScrollLeft,\n                top: newScrollTop,\n                behavior: e.type === \"mousemove\" ? \"auto\" : \"smooth\",\n            });\n        };\n\n        return (\n            <MinimapStyle\n                style={{ width: w, height: h }}\n                data-testid=\"minimap-container\"\n                onMouseMove={e => {\n                    if (e.buttons !== 1) return;\n                    handleMouse(e);\n                }}\n                onClick={handleMouse}>\n                <div className=\"header\" />\n                <div\n                    className=\"locationMarker\"\n                    onDragStart={e => e.preventDefault()}\n                    style={{\n                        left,\n                        top,\n                        width: vWidth,\n                        height: vHeight,\n                        borderRadius: Math.min(vWidth, vHeight * 0.2, 9),\n                    }}></div>\n            </MinimapStyle>\n        );\n    }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);\n\n    return (\n        <InfiniteScroller\n            scrollRef={scrollRef}\n            minimap={minimap}\n            className={className}\n            preventDiagonalScrolling={preventDiagonalScrolling}\n            draggable={isDraggable === true || typeof isDraggable === \"string\"}\n            scrollWidth={width + (paddingRight ?? 0)}\n            scrollHeight={height + (paddingBottom ?? 0)}\n            clientHeight={clientHeight}\n            rightElement={rightElement}\n            paddingBottom={paddingBottom}\n            paddingRight={paddingRight}\n            rightElementProps={rightElementProps}\n            update={onScrollUpdate}\n            initialSize={initialSize}\n            scrollToEnd={scrollToEnd}>\n            <DataGridDnd\n                eventTargetRef={scrollRef}\n                width={clientWidth}\n                height={clientHeight}\n                accessibilityHeight={p.accessibilityHeight}\n                canvasRef={p.canvasRef}\n                cellXOffset={p.cellXOffset}\n                cellYOffset={p.cellYOffset}\n                columns={p.columns}\n                disabledRows={p.disabledRows}\n                enableGroups={p.enableGroups}\n                fillHandle={p.fillHandle}\n                firstColAccessible={p.firstColAccessible}\n                fixedShadowX={p.fixedShadowX}\n                fixedShadowY={p.fixedShadowY}\n                freezeColumns={p.freezeColumns}\n                getCellContent={p.getCellContent}\n                getCellRenderer={p.getCellRenderer}\n                getGroupDetails={p.getGroupDetails}\n                getRowThemeOverride={p.getRowThemeOverride}\n                groupHeaderHeight={p.groupHeaderHeight}\n                headerHeight={p.headerHeight}\n                highlightRegions={p.highlightRegions}\n                imageWindowLoader={p.imageWindowLoader}\n                isFilling={p.isFilling}\n                isFocused={p.isFocused}\n                lockColumns={p.lockColumns}\n                maxColumnWidth={p.maxColumnWidth}\n                minColumnWidth={p.minColumnWidth}\n                onHeaderMenuClick={p.onHeaderMenuClick}\n                onMouseMove={p.onMouseMove}\n                prelightCells={p.prelightCells}\n                rowHeight={p.rowHeight}\n                rows={p.rows}\n                selection={p.selection}\n                theme={p.theme}\n                trailingRowType={p.trailingRowType}\n                translateX={p.translateX}\n                translateY={p.translateY}\n                verticalBorder={p.verticalBorder}\n                drawCustomCell={p.drawCustomCell}\n                drawFocusRing={p.drawFocusRing}\n                drawHeader={p.drawHeader}\n                experimental={p.experimental}\n                gridRef={p.gridRef}\n                headerIcons={p.headerIcons}\n                isDraggable={p.isDraggable}\n                onCanvasBlur={p.onCanvasBlur}\n                onCanvasFocused={p.onCanvasFocused}\n                onCellFocused={p.onCellFocused}\n                onColumnMoved={p.onColumnMoved}\n                onColumnResize={p.onColumnResize}\n                onColumnResizeEnd={p.onColumnResizeEnd}\n                onColumnResizeStart={p.onColumnResizeStart}\n                onContextMenu={p.onContextMenu}\n                onDragEnd={p.onDragEnd}\n                onDragLeave={p.onDragLeave}\n                onDragOverCell={p.onDragOverCell}\n                onDragStart={p.onDragStart}\n                onDrop={p.onDrop}\n                onItemHovered={p.onItemHovered}\n                onKeyDown={p.onKeyDown}\n                onKeyUp={p.onKeyUp}\n                onMouseDown={p.onMouseDown}\n                onMouseUp={p.onMouseUp}\n                onRowMoved={p.onRowMoved}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n            />\n        </InfiniteScroller>\n    );\n};\n\nexport default GridScroller;\n","/* eslint-disable unicorn/consistent-destructuring */\nimport clamp from \"lodash/clamp.js\";\nimport * as React from \"react\";\nimport DataGrid, { DataGridProps, DataGridRef } from \"../data-grid/data-grid\";\nimport type { GridColumn, GridMouseEventArgs, InnerGridColumn, Rectangle } from \"../data-grid/data-grid-types\";\n\ntype Props = Omit<DataGridProps, \"dragAndDropState\" | \"isResizing\" | \"isDragging\" | \"onMouseMoveRaw\" | \"allowResize\">;\n\nexport interface DataGridDndProps extends Props {\n    /**\n     * Called whenever a row re-order operation is completed. Setting the callback enables re-ordering by dragging the\n     * first column of a row.\n     * @group Drag and Drop\n     */\n    readonly onRowMoved?: (startIndex: number, endIndex: number) => void;\n    /**\n     * Called when the user finishes moving a column. `startIndex` is the index of the column that was moved, and\n     * `endIndex` is the index at which it should end up. Note that you have to effect the move of the column, and pass\n     * the reordered columns back in the `columns` property.\n     * @group Drag and Drop\n     */\n    readonly onColumnMoved?: (startIndex: number, endIndex: number) => void;\n\n    /**\n     * Called when the user is resizing a column. `newSize` is the new size of the column. Note that you have change\n     * the size of the column in the `GridColumn` and pass it back to the grid in the `columns` property.\n     * @group Drag and Drop\n     * @param column The `GridColumn` being resized\n     * @param newSize The new size of the grid column\n     * @param colIndex The index of the column\n     * @param newSizeWithGrow The new size of the column including any addition pixels added by the grow parameter\n     */\n    readonly onColumnResize?: (column: GridColumn, newSize: number, colIndex: number, newSizeWithGrow: number) => void;\n    /**\n     * Called when the user starts resizing a column. `newSize` is the new size of the column.\n     * @group Drag and Drop\n     * @param column The `GridColumn` being resized\n     * @param newSize The new size of the grid column\n     * @param colIndex The index of the column\n     * @param newSizeWithGrow The new size of the column including any addition pixels added by the grow parameter\n     */\n    readonly onColumnResizeStart?: (\n        column: GridColumn,\n        newSize: number,\n        colIndex: number,\n        newSizeWithGrow: number\n    ) => void;\n    /**\n     * Called when the user finishes resizing a column. `newSize` is the new size of the column.\n     * @group Drag and Drop\n     * @param column The `GridColumn` being resized\n     * @param newSize The new size of the grid column\n     * @param colIndex The index of the column\n     * @param newSizeWithGrow The new size of the column including any addition pixels added by the grow parameter\n     */\n    readonly onColumnResizeEnd?: (\n        column: GridColumn,\n        newSize: number,\n        colIndex: number,\n        newSizeWithGrow: number\n    ) => void;\n\n    readonly gridRef?: React.MutableRefObject<DataGridRef | null>;\n    readonly maxColumnWidth: number;\n    readonly minColumnWidth: number;\n    readonly lockColumns: number;\n}\n\n// Dear Past Jason,\n// Wtf does this function do? If you remember in the future come back and add a comment\n// -- Future-Past Jason\nfunction offsetColumnSize(column: InnerGridColumn, width: number, min: number, max: number): number {\n    return clamp(Math.round(width - (column.growOffset ?? 0)), Math.ceil(min), Math.floor(max));\n}\n\nconst DataGridDnd: React.FunctionComponent<DataGridDndProps> = p => {\n    const [resizeColStartX, setResizeColStartX] = React.useState<number>();\n    const [resizeCol, setResizeCol] = React.useState<number>();\n\n    const [dragCol, setDragCol] = React.useState<number>();\n    const [dropCol, setDropCol] = React.useState<number>();\n    const [dragColActive, setDragColActive] = React.useState(false);\n    const [dragStartX, setDragStartX] = React.useState<number>();\n\n    const [dragRow, setDragRow] = React.useState<number>();\n    const [dropRow, setDropRow] = React.useState<number>();\n    const [dragRowActive, setDragRowActive] = React.useState(false);\n    const [dragStartY, setDragStartY] = React.useState<number>();\n\n    const {\n        onHeaderMenuClick,\n        getCellContent,\n        onColumnMoved,\n        onColumnResize,\n        onColumnResizeStart,\n        onColumnResizeEnd,\n        gridRef,\n        maxColumnWidth,\n        minColumnWidth,\n        onRowMoved,\n        lockColumns,\n        onMouseDown,\n        onMouseUp,\n        onItemHovered,\n        onDragStart,\n    } = p;\n\n    const canResize = (onColumnResize ?? onColumnResizeEnd ?? onColumnResizeStart) !== undefined;\n\n    const { columns, selection } = p;\n    const selectedColumns = selection.columns;\n\n    const onItemHoveredImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            const [col, row] = args.location;\n            if (dragCol !== undefined && dropCol !== col && col >= lockColumns) {\n                setDragColActive(true);\n                setDropCol(col);\n            } else if (dragRow !== undefined && row !== undefined) {\n                setDragRowActive(true);\n                setDropRow(Math.max(0, row));\n            } else {\n                onItemHovered?.(args);\n            }\n        },\n        [dragCol, dragRow, dropCol, onItemHovered, lockColumns]\n    );\n\n    const canDragCol = onColumnMoved !== undefined;\n    const onMouseDownImpl = React.useCallback(\n        (args: GridMouseEventArgs) => {\n            if (args.button === 0) {\n                const [col, row] = args.location;\n                if (args.kind === \"out-of-bounds\" && args.isEdge && canResize) {\n                    const bounds = gridRef?.current?.getBounds(columns.length - 1, -1);\n                    if (bounds !== undefined) {\n                        setResizeColStartX(bounds.x);\n                        setResizeCol(columns.length - 1);\n                    }\n                } else if (args.kind === \"header\" && col >= lockColumns) {\n                    if (args.isEdge && canResize) {\n                        setResizeColStartX(args.bounds.x);\n                        setResizeCol(col);\n                        onColumnResizeStart?.(\n                            columns[col],\n                            args.bounds.width,\n                            col,\n                            args.bounds.width + (columns[col].growOffset ?? 0)\n                        );\n                    } else if (args.kind === \"header\" && canDragCol) {\n                        setDragStartX(args.bounds.x);\n                        setDragCol(col);\n                    }\n                } else if (\n                    args.kind === \"cell\" &&\n                    lockColumns > 0 &&\n                    col === 0 &&\n                    row !== undefined &&\n                    onRowMoved !== undefined\n                ) {\n                    setDragStartY(args.bounds.y);\n                    setDragRow(row);\n                }\n            }\n            onMouseDown?.(args);\n        },\n        [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart]\n    );\n\n    const onHeaderMenuClickMangled = React.useCallback(\n        (col: number, screenPosition: Rectangle) => {\n            if (dragColActive || dragRowActive) return;\n            onHeaderMenuClick?.(col, screenPosition);\n        },\n        [dragColActive, dragRowActive, onHeaderMenuClick]\n    );\n\n    const lastResizeWidthRef = React.useRef(-1);\n\n    const clearAll = React.useCallback(() => {\n        lastResizeWidthRef.current = -1;\n        setDragRow(undefined);\n        setDropRow(undefined);\n        setDragStartY(undefined);\n        setDragRowActive(false);\n        setDragCol(undefined);\n        setDropCol(undefined);\n        setDragStartX(undefined);\n        setDragColActive(false);\n        setResizeCol(undefined);\n        setResizeColStartX(undefined);\n    }, []);\n\n    const onMouseUpImpl = React.useCallback(\n        (args: GridMouseEventArgs, isOutside: boolean) => {\n            if (args.button === 0) {\n                if (resizeCol !== undefined) {\n                    // if the column is in selection, the selection may contain extra cols, so lets just re-send the last\n                    // resize event to all those columns.\n                    if (selectedColumns?.hasIndex(resizeCol) === true) {\n                        for (const c of selectedColumns) {\n                            if (c === resizeCol) continue;\n                            const col = columns[c];\n                            const newSize = offsetColumnSize(\n                                col,\n                                lastResizeWidthRef.current,\n                                minColumnWidth,\n                                maxColumnWidth\n                            );\n                            onColumnResize?.(col, newSize, c, newSize + (col.growOffset ?? 0));\n                        }\n                    }\n\n                    const ns = offsetColumnSize(\n                        columns[resizeCol],\n                        lastResizeWidthRef.current,\n                        minColumnWidth,\n                        maxColumnWidth\n                    );\n                    onColumnResizeEnd?.(columns[resizeCol], ns, resizeCol, ns + (columns[resizeCol].growOffset ?? 0));\n                    for (const c of selectedColumns) {\n                        if (c === resizeCol) continue;\n                        const col = columns[c];\n                        const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                        onColumnResizeEnd?.(col, s, c, s + (col.growOffset ?? 0));\n                    }\n                }\n\n                clearAll();\n                if (dragCol !== undefined && dropCol !== undefined) {\n                    onColumnMoved?.(dragCol, dropCol);\n                }\n                if (dragRow !== undefined && dropRow !== undefined) {\n                    onRowMoved?.(dragRow, dropRow);\n                }\n            }\n            onMouseUp?.(args, isOutside);\n        },\n        [\n            onMouseUp,\n            resizeCol,\n            dragCol,\n            dropCol,\n            dragRow,\n            dropRow,\n            selectedColumns,\n            onColumnResizeEnd,\n            columns,\n            minColumnWidth,\n            maxColumnWidth,\n            onColumnResize,\n            onColumnMoved,\n            onRowMoved,\n            clearAll,\n        ]\n    );\n\n    const dragOffset = React.useMemo(() => {\n        if (dragCol === undefined || dropCol === undefined) return undefined;\n        if (dragCol === dropCol) return undefined;\n\n        return {\n            src: dragCol,\n            dest: dropCol,\n        };\n    }, [dragCol, dropCol]);\n\n    const onMouseMove = React.useCallback(\n        (event: MouseEvent) => {\n            if (dragCol !== undefined && dragStartX !== undefined) {\n                const diff = Math.abs(event.clientX - dragStartX);\n                if (diff > 20) {\n                    setDragColActive(true);\n                }\n            } else if (dragRow !== undefined && dragStartY !== undefined) {\n                const diff = Math.abs(event.clientY - dragStartY);\n                if (diff > 20) {\n                    setDragRowActive(true);\n                }\n            } else if (resizeCol !== undefined && resizeColStartX !== undefined) {\n                const column = columns[resizeCol];\n                const newWidth = event.clientX - resizeColStartX;\n                const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);\n                onColumnResize?.(column, ns, resizeCol, ns + (column.growOffset ?? 0));\n                lastResizeWidthRef.current = newWidth;\n\n                if (selectedColumns?.first() === resizeCol) {\n                    for (const c of selectedColumns) {\n                        if (c === resizeCol) continue;\n                        const col = columns[c];\n                        const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                        onColumnResize?.(col, s, c, s + (col.growOffset ?? 0));\n                    }\n                }\n            }\n        },\n        [\n            dragCol,\n            dragStartX,\n            dragRow,\n            dragStartY,\n            resizeCol,\n            resizeColStartX,\n            columns,\n            minColumnWidth,\n            maxColumnWidth,\n            onColumnResize,\n            selectedColumns,\n        ]\n    );\n\n    const getMangledCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            if (dragRow === undefined || dropRow === undefined) return getCellContent(cell);\n\n            // eslint-disable-next-line prefer-const\n            let [col, row] = cell;\n            if (row === dropRow) {\n                row = dragRow;\n            } else {\n                if (row > dropRow) row -= 1;\n                if (row >= dragRow) row += 1;\n            }\n\n            return getCellContent([col, row]);\n        },\n        [dragRow, dropRow, getCellContent]\n    );\n\n    const onDragStartImpl = React.useCallback<NonNullable<DataGridDndProps[\"onDragStart\"]>>(\n        args => {\n            onDragStart?.(args);\n            if (!args.defaultPrevented()) {\n                clearAll();\n            }\n        },\n        [clearAll, onDragStart]\n    );\n\n    return (\n        <DataGrid\n            accessibilityHeight={p.accessibilityHeight}\n            canvasRef={p.canvasRef}\n            cellXOffset={p.cellXOffset}\n            cellYOffset={p.cellYOffset}\n            columns={p.columns}\n            disabledRows={p.disabledRows}\n            drawCustomCell={p.drawCustomCell}\n            drawFocusRing={p.drawFocusRing}\n            drawHeader={p.drawHeader}\n            enableGroups={p.enableGroups}\n            eventTargetRef={p.eventTargetRef}\n            experimental={p.experimental}\n            fillHandle={p.fillHandle}\n            firstColAccessible={p.firstColAccessible}\n            fixedShadowX={p.fixedShadowX}\n            fixedShadowY={p.fixedShadowY}\n            freezeColumns={p.freezeColumns}\n            getCellRenderer={p.getCellRenderer}\n            getGroupDetails={p.getGroupDetails}\n            getRowThemeOverride={p.getRowThemeOverride}\n            groupHeaderHeight={p.groupHeaderHeight}\n            headerHeight={p.headerHeight}\n            headerIcons={p.headerIcons}\n            height={p.height}\n            highlightRegions={p.highlightRegions}\n            imageWindowLoader={p.imageWindowLoader}\n            isDraggable={p.isDraggable}\n            isFilling={p.isFilling}\n            isFocused={p.isFocused}\n            onCanvasBlur={p.onCanvasBlur}\n            onCanvasFocused={p.onCanvasFocused}\n            onCellFocused={p.onCellFocused}\n            onContextMenu={p.onContextMenu}\n            onDragEnd={p.onDragEnd}\n            onDragLeave={p.onDragLeave}\n            onDragOverCell={p.onDragOverCell}\n            onDrop={p.onDrop}\n            onKeyDown={p.onKeyDown}\n            onKeyUp={p.onKeyUp}\n            onMouseMove={p.onMouseMove}\n            prelightCells={p.prelightCells}\n            rowHeight={p.rowHeight}\n            rows={p.rows}\n            selection={p.selection}\n            smoothScrollX={p.smoothScrollX}\n            smoothScrollY={p.smoothScrollY}\n            theme={p.theme}\n            trailingRowType={p.trailingRowType}\n            translateX={p.translateX}\n            translateY={p.translateY}\n            verticalBorder={p.verticalBorder}\n            width={p.width}\n            getCellContent={getMangledCellContent}\n            isResizing={resizeCol !== undefined}\n            onHeaderMenuClick={onHeaderMenuClickMangled}\n            isDragging={dragColActive}\n            onItemHovered={onItemHoveredImpl}\n            onDragStart={onDragStartImpl}\n            onMouseDown={onMouseDownImpl}\n            allowResize={onColumnResize !== undefined}\n            onMouseUp={onMouseUpImpl}\n            dragAndDropState={dragOffset}\n            onMouseMoveRaw={onMouseMove}\n            ref={gridRef}\n        />\n    );\n};\n\nexport default DataGridDnd;\n","import * as React from \"react\";\nimport type { Theme } from \"../common/styles\";\nimport ImageWindowLoaderImpl from \"../common/image-window-loader\";\nimport {\n    computeBounds,\n    getColumnIndexForX,\n    getEffectiveColumns,\n    getRowIndexForY,\n    getStickyWidth,\n    useMappedColumns,\n} from \"./data-grid-lib\";\nimport {\n    GridCellKind,\n    Rectangle,\n    GridSelection,\n    GridMouseEventArgs,\n    GridDragEventArgs,\n    GridKeyEventArgs,\n    InnerGridCell,\n    InnerGridCellKind,\n    CompactSelection,\n    DrawCustomCellCallback,\n    CellList,\n    Item,\n    DrawHeaderCallback,\n    isReadWriteCell,\n    isInnerOnlyCell,\n    booleanCellIsEditable,\n    InnerGridColumn,\n    TrailingRowType,\n    groupHeaderKind,\n    headerKind,\n    outOfBoundsKind,\n    ImageWindowLoader,\n} from \"./data-grid-types\";\nimport { SpriteManager, SpriteMap } from \"./data-grid-sprites\";\nimport { useDebouncedMemo, useEventListener } from \"../common/utils\";\nimport clamp from \"lodash/clamp.js\";\nimport makeRange from \"lodash/range.js\";\nimport {\n    BlitData,\n    drawCell,\n    drawGrid,\n    DrawGridArg,\n    drawHeader,\n    getActionBoundsForGroup,\n    getHeaderMenuBounds,\n    GetRowThemeCallback,\n    GroupDetailsCallback,\n    Highlight,\n    pointInRect,\n} from \"./data-grid-render\";\nimport { AnimationManager, StepCallback } from \"./animation-manager\";\nimport { browserIsFirefox, browserIsSafari } from \"../common/browser-detect\";\nimport { useAnimationQueue } from \"./use-animation-queue\";\nimport { assert } from \"../common/support\";\nimport type { CellRenderer, GetCellRendererCallback } from \"./cells/cell-types\";\n\nexport interface DataGridProps {\n    readonly width: number;\n    readonly height: number;\n\n    readonly cellXOffset: number;\n    readonly cellYOffset: number;\n\n    readonly translateX: number | undefined;\n    readonly translateY: number | undefined;\n\n    readonly accessibilityHeight: number;\n\n    readonly freezeColumns: number;\n    readonly trailingRowType: TrailingRowType;\n    readonly firstColAccessible: boolean;\n\n    /**\n     * Enables or disables the overlay shadow when scrolling horizontally\n     * @group Style\n     */\n    readonly fixedShadowX: boolean | undefined;\n    /**\n     * Enables or disables the overlay shadow when scrolling vertical\n     * @group Style\n     */\n    readonly fixedShadowY: boolean | undefined;\n\n    readonly allowResize: boolean | undefined;\n    readonly isResizing: boolean;\n    readonly isDragging: boolean;\n    readonly isFilling: boolean;\n    readonly isFocused: boolean;\n\n    readonly columns: readonly InnerGridColumn[];\n    /**\n     * The number of rows in the grid.\n     * @group Data\n     */\n    readonly rows: number;\n\n    readonly headerHeight: number;\n    readonly groupHeaderHeight: number;\n    readonly enableGroups: boolean;\n    readonly rowHeight: number | ((index: number) => number);\n\n    readonly canvasRef: React.MutableRefObject<HTMLCanvasElement | null> | undefined;\n\n    readonly eventTargetRef: React.MutableRefObject<HTMLDivElement | null> | undefined;\n\n    readonly getCellContent: (cell: Item) => InnerGridCell;\n    /**\n     * Provides additional details about groups to extend group functionality.\n     * @group Data\n     */\n    readonly getGroupDetails: GroupDetailsCallback | undefined;\n    /**\n     * Provides per row theme overrides.\n     * @group Style\n     */\n    readonly getRowThemeOverride: GetRowThemeCallback | undefined;\n    /**\n     * Emitted when a header menu disclosure indicator is clicked.\n     * @group Events\n     */\n    readonly onHeaderMenuClick: ((col: number, screenPosition: Rectangle) => void) | undefined;\n\n    readonly selection: GridSelection;\n    readonly prelightCells: readonly Item[] | undefined;\n    /**\n     * Highlight regions provide hints to users about relations between cells and selections.\n     * @group Selection\n     */\n    readonly highlightRegions: readonly Highlight[] | undefined;\n\n    /**\n     * Enabled/disables the fill handle.\n     * @defaultValue false\n     * @group Editing\n     */\n    readonly fillHandle: boolean | undefined;\n\n    readonly disabledRows: CompactSelection | undefined;\n    /**\n     * Allows passing a custom image window loader.\n     * @group Advanced\n     */\n    readonly imageWindowLoader: ImageWindowLoader | undefined;\n\n    /**\n     * Emitted when an item is hovered.\n     * @group Events\n     */\n    readonly onItemHovered: (args: GridMouseEventArgs) => void;\n    readonly onMouseMove: (args: GridMouseEventArgs) => void;\n    readonly onMouseDown: (args: GridMouseEventArgs) => void;\n    readonly onMouseUp: (args: GridMouseEventArgs, isOutside: boolean) => void;\n    readonly onContextMenu: (args: GridMouseEventArgs, preventDefault: () => void) => void;\n\n    readonly onCanvasFocused: () => void;\n    readonly onCanvasBlur: () => void;\n    readonly onCellFocused: (args: Item) => void;\n\n    readonly onMouseMoveRaw: (event: MouseEvent) => void;\n\n    /**\n     * Emitted when the canvas receives a key down event.\n     * @group Events\n     */\n    readonly onKeyDown: (event: GridKeyEventArgs) => void;\n    /**\n     * Emitted when the canvas receives a key up event.\n     * @group Events\n     */\n    readonly onKeyUp: ((event: GridKeyEventArgs) => void) | undefined;\n\n    readonly verticalBorder: (col: number) => boolean;\n\n    /**\n     * Determines what can be dragged using HTML drag and drop\n     * @group Drag and Drop\n     */\n    readonly isDraggable: boolean | \"cell\" | \"header\" | undefined;\n    /**\n     * If `isDraggable` is set, the grid becomes HTML draggable, and `onDragStart` will be called when dragging starts.\n     * You can use this to build a UI where the user can drag the Grid around.\n     * @group Drag and Drop\n     */\n    readonly onDragStart: (args: GridDragEventArgs) => void;\n    readonly onDragEnd: () => void;\n\n    /** @group Drag and Drop */\n    readonly onDragOverCell: ((cell: Item, dataTransfer: DataTransfer | null) => void) | undefined;\n    /** @group Drag and Drop */\n    readonly onDragLeave: (() => void) | undefined;\n\n    /**\n     * Called when a HTML Drag and Drop event is ended on the data grid.\n     * @group Drag and Drop\n     */\n    readonly onDrop: ((cell: Item, dataTransfer: DataTransfer | null) => void) | undefined;\n\n    readonly drawCustomCell: DrawCustomCellCallback | undefined;\n    /**\n     * Overrides the rendering of a header. The grid will call this for every header it needs to render. Header\n     * rendering is not as well optimized because they do not redraw as often, but very heavy drawing methods can\n     * negatively impact horizontal scrolling performance.\n     *\n     * It is possible to return `false` after rendering just a background and the regular foreground rendering\n     * will happen.\n     * @group Drawing\n     * @returns `false` if default header rendering should still happen, `true` to cancel rendering.\n     */\n    readonly drawHeader: DrawHeaderCallback | undefined;\n    /**\n     * Controls the drawing of the focus ring.\n     * @defaultValue true\n     * @group Style\n     */\n    readonly drawFocusRing: boolean | undefined;\n\n    readonly dragAndDropState:\n        | {\n              src: number;\n              dest: number;\n          }\n        | undefined;\n\n    /**\n     * Experimental features\n     * @group Advanced\n     * @experimental\n     */\n    readonly experimental:\n        | {\n              readonly paddingRight?: number;\n              readonly paddingBottom?: number;\n              readonly enableFirefoxRescaling?: boolean;\n              readonly isSubGrid?: boolean;\n              readonly strict?: boolean;\n              readonly scrollbarWidthOverride?: number;\n              readonly hyperWrapping?: boolean;\n              readonly renderStrategy?: \"single-buffer\" | \"double-buffer\" | \"direct\";\n          }\n        | undefined;\n\n    /**\n     * Additional header icons for use by `GridColumn`.\n     *\n     * Providing custom header icons to the data grid must be done with a somewhat non-standard mechanism to allow\n     * theming and scaling. The `headerIcons` property takes a dictionary which maps icon names to functions which can\n     * take a foreground and background color and returns back a string representation of an svg. The svg should contain\n     * a header similar to this `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">` and\n     * interpolate the fg/bg colors into the string.\n     *\n     * We recognize this process is not fantastic from a graphics workflow standpoint, improvements are very welcome\n     * here.\n     *\n     * @group Style\n     */\n    readonly headerIcons: SpriteMap | undefined;\n\n    /** Controls smooth scrolling in the data grid. If smooth scrolling is not enabled the grid will always be cell\n     * aligned.\n     * @defaultValue `false`\n     * @group Style\n     */\n    readonly smoothScrollX: boolean | undefined;\n    /** Controls smooth scrolling in the data grid. If smooth scrolling is not enabled the grid will always be cell\n     * aligned.\n     * @defaultValue `false`\n     * @group Style\n     */\n    readonly smoothScrollY: boolean | undefined;\n\n    readonly theme: Theme;\n\n    readonly getCellRenderer: <T extends InnerGridCell>(cell: T) => CellRenderer<T> | undefined;\n}\n\ntype DamageUpdateList = readonly {\n    cell: Item;\n    // newValue: GridCell,\n}[];\n\nexport interface DataGridRef {\n    focus: () => void;\n    getBounds: (col: number, row?: number) => Rectangle | undefined;\n    damage: (cells: DamageUpdateList) => void;\n}\n\nconst getRowData = (cell: InnerGridCell, getCellRenderer?: GetCellRendererCallback) => {\n    if (cell.kind === GridCellKind.Custom) return cell.copyData;\n    const r = getCellRenderer?.(cell);\n    return r?.getAccessibilityString(cell) ?? \"\";\n};\n\nconst DataGrid: React.ForwardRefRenderFunction<DataGridRef, DataGridProps> = (p, forwardedRef) => {\n    const {\n        width,\n        height,\n        accessibilityHeight,\n        columns,\n        cellXOffset: cellXOffsetReal,\n        cellYOffset,\n        headerHeight,\n        fillHandle = false,\n        groupHeaderHeight,\n        rowHeight,\n        rows,\n        getCellContent,\n        getRowThemeOverride,\n        onHeaderMenuClick,\n        enableGroups,\n        isFilling,\n        onCanvasFocused,\n        onCanvasBlur,\n        isFocused,\n        selection,\n        freezeColumns,\n        onContextMenu,\n        trailingRowType: trailingRowType,\n        fixedShadowX = true,\n        fixedShadowY = true,\n        drawFocusRing = true,\n        onMouseDown,\n        onMouseUp,\n        onMouseMoveRaw,\n        onMouseMove,\n        onItemHovered,\n        dragAndDropState,\n        firstColAccessible,\n        onKeyDown,\n        onKeyUp,\n        highlightRegions,\n        canvasRef,\n        onDragStart,\n        onDragEnd,\n        eventTargetRef,\n        isResizing,\n        isDragging,\n        isDraggable = false,\n        allowResize,\n        disabledRows,\n        getGroupDetails,\n        theme,\n        prelightCells,\n        headerIcons,\n        verticalBorder,\n        drawHeader: drawHeaderCallback,\n        drawCustomCell,\n        onCellFocused,\n        onDragOverCell,\n        onDrop,\n        onDragLeave,\n        imageWindowLoader,\n        smoothScrollX = false,\n        smoothScrollY = false,\n        experimental,\n        getCellRenderer,\n    } = p;\n    const translateX = p.translateX ?? 0;\n    const translateY = p.translateY ?? 0;\n    const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));\n\n    const ref = React.useRef<HTMLCanvasElement | null>(null);\n    const imageWindowLoaderInternal = React.useMemo<ImageWindowLoader>(() => new ImageWindowLoaderImpl(), []);\n    const imageLoader = imageWindowLoader ?? imageWindowLoaderInternal;\n    const damageRegion = React.useRef<readonly Item[] | undefined>();\n    const [scrolling, setScrolling] = React.useState<boolean>(false);\n    const hoverValues = React.useRef<readonly { item: Item; hoverAmount: number }[]>([]);\n    const lastBlitData = React.useRef<BlitData | undefined>();\n    const [hoveredItemInfo, setHoveredItemInfo] = React.useState<[Item, readonly [number, number]] | undefined>();\n    const [hoveredOnEdge, setHoveredOnEdge] = React.useState<boolean>();\n    const overlayRef = React.useRef<HTMLCanvasElement | null>(null);\n\n    const [lastWasTouch, setLastWasTouch] = React.useState(false);\n    const lastWasTouchRef = React.useRef(lastWasTouch);\n    lastWasTouchRef.current = lastWasTouch;\n\n    const spriteManager = React.useMemo(\n        () =>\n            new SpriteManager(headerIcons, () => {\n                lastArgsRef.current = undefined;\n                lastDrawRef.current();\n            }),\n        [headerIcons]\n    );\n    const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;\n\n    const scrollingStopRef = React.useRef(-1);\n    const disableFirefoxRescaling = experimental?.enableFirefoxRescaling !== true;\n    React.useLayoutEffect(() => {\n        if (!browserIsFirefox.value || window.devicePixelRatio === 1 || disableFirefoxRescaling) return;\n        // We don't want to go into scroll mode for a single repaint\n        if (scrollingStopRef.current !== -1) {\n            setScrolling(true);\n        }\n        window.clearTimeout(scrollingStopRef.current);\n        scrollingStopRef.current = window.setTimeout(() => {\n            setScrolling(false);\n            scrollingStopRef.current = -1;\n        }, 200);\n    }, [cellYOffset, cellXOffset, translateX, translateY, disableFirefoxRescaling]);\n\n    const mappedColumns = useMappedColumns(columns, freezeColumns);\n\n    // row: -1 === columnHeader, -2 === groupHeader\n    const getBoundsForItem = React.useCallback(\n        (canvas: HTMLCanvasElement, col: number, row: number): Rectangle | undefined => {\n            const rect = canvas.getBoundingClientRect();\n\n            if (col >= mappedColumns.length || row >= rows) {\n                return undefined;\n            }\n\n            const scale = rect.width / width;\n\n            const result = computeBounds(\n                col,\n                row,\n                width,\n                height,\n                groupHeaderHeight,\n                totalHeaderHeight,\n                cellXOffset,\n                cellYOffset,\n                translateX,\n                translateY,\n                rows,\n                freezeColumns,\n                trailingRowType === \"sticky\",\n                mappedColumns,\n                rowHeight\n            );\n\n            if (scale !== 1) {\n                result.x *= scale;\n                result.y *= scale;\n                result.width *= scale;\n                result.height *= scale;\n            }\n\n            result.x += rect.x;\n            result.y += rect.y;\n\n            return result;\n        },\n        [\n            width,\n            height,\n            groupHeaderHeight,\n            totalHeaderHeight,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            rows,\n            freezeColumns,\n            trailingRowType,\n            mappedColumns,\n            rowHeight,\n        ]\n    );\n\n    const getMouseArgsForPosition = React.useCallback(\n        (canvas: HTMLCanvasElement, posX: number, posY: number, ev?: MouseEvent | TouchEvent): GridMouseEventArgs => {\n            const rect = canvas.getBoundingClientRect();\n            const scale = rect.width / width;\n            const x = (posX - rect.left) / scale;\n            const y = (posY - rect.top) / scale;\n            const edgeDetectionBuffer = 5;\n\n            const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, undefined, translateX);\n\n            let button = 0;\n            if (ev instanceof MouseEvent) {\n                button = ev.button;\n            }\n\n            // -1 === off right edge\n            const col = getColumnIndexForX(x, effectiveCols, translateX);\n\n            // -1: header or above\n            // undefined: offbottom\n            const row = getRowIndexForY(\n                y,\n                height,\n                enableGroups,\n                headerHeight,\n                groupHeaderHeight,\n                rows,\n                rowHeight,\n                cellYOffset,\n                translateY,\n                trailingRowType === \"sticky\"\n            );\n\n            const shiftKey = ev?.shiftKey === true;\n            const ctrlKey = ev?.ctrlKey === true;\n            const metaKey = ev?.metaKey === true;\n            const isTouch = ev !== undefined && !(ev instanceof MouseEvent);\n\n            const edgeSize = 20;\n            const scrollEdge: GridMouseEventArgs[\"scrollEdge\"] = [\n                Math.abs(x) < edgeSize ? -1 : Math.abs(rect.width - x) < edgeSize ? 1 : 0,\n                Math.abs(y) < edgeSize ? -1 : Math.abs(rect.height - y) < edgeSize ? 1 : 0,\n            ];\n\n            let result: GridMouseEventArgs;\n            if (col === -1 || y < 0 || x < 0 || row === undefined || x > width || y > height) {\n                const horizontal = x > width ? -1 : x < 0 ? 1 : 0;\n                const vertical = y > height ? 1 : y < 0 ? -1 : 0;\n\n                let isEdge = false;\n                if (col === -1 && row === -1) {\n                    const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);\n                    assert(b !== undefined);\n                    isEdge = posX < b.x + b.width + edgeDetectionBuffer;\n                }\n\n                result = {\n                    kind: outOfBoundsKind,\n                    location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row ?? rows - 1],\n                    direction: [horizontal, vertical],\n                    shiftKey,\n                    ctrlKey,\n                    metaKey,\n                    isEdge,\n                    isTouch,\n                    button,\n                    scrollEdge,\n                };\n            } else if (row <= -1) {\n                let bounds = getBoundsForItem(canvas, col, row);\n                assert(bounds !== undefined);\n                let isEdge = bounds !== undefined && bounds.x + bounds.width - posX <= edgeDetectionBuffer;\n\n                const previousCol = col - 1;\n                if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {\n                    isEdge = true;\n                    bounds = getBoundsForItem(canvas, previousCol, row);\n                    assert(bounds !== undefined);\n                    result = {\n                        kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,\n                        location: [previousCol, row] as any,\n                        bounds: bounds,\n                        group: mappedColumns[previousCol].group ?? \"\",\n                        isEdge,\n                        shiftKey,\n                        ctrlKey,\n                        metaKey,\n                        isTouch,\n                        localEventX: posX - bounds.x,\n                        localEventY: posY - bounds.y,\n                        button,\n                        scrollEdge,\n                    };\n                } else {\n                    result = {\n                        kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,\n                        group: mappedColumns[col].group ?? \"\",\n                        location: [col, row] as any,\n                        bounds: bounds,\n                        isEdge,\n                        shiftKey,\n                        ctrlKey,\n                        metaKey,\n                        isTouch,\n                        localEventX: posX - bounds.x,\n                        localEventY: posY - bounds.y,\n                        button,\n                        scrollEdge,\n                    };\n                }\n            } else {\n                const bounds = getBoundsForItem(canvas, col, row);\n                assert(bounds !== undefined);\n                const isEdge = bounds !== undefined && bounds.x + bounds.width - posX < edgeDetectionBuffer;\n                const isFillHandle =\n                    fillHandle &&\n                    bounds !== undefined &&\n                    bounds.x + bounds.width - posX < 6 &&\n                    bounds.y + bounds.height - posY < 6;\n                result = {\n                    kind: \"cell\",\n                    location: [col, row],\n                    bounds: bounds,\n                    isEdge,\n                    shiftKey,\n                    ctrlKey,\n                    isFillHandle,\n                    metaKey,\n                    isTouch,\n                    localEventX: posX - bounds.x,\n                    localEventY: posY - bounds.y,\n                    button,\n                    scrollEdge,\n                };\n            }\n            return result;\n        },\n        [\n            mappedColumns,\n            cellXOffset,\n            width,\n            translateX,\n            height,\n            enableGroups,\n            headerHeight,\n            groupHeaderHeight,\n            rows,\n            rowHeight,\n            cellYOffset,\n            translateY,\n            trailingRowType,\n            getBoundsForItem,\n            fillHandle,\n        ]\n    );\n\n    function isSameItem(item: GridMouseEventArgs | undefined, other: GridMouseEventArgs | undefined) {\n        if (item === other) return true;\n        return (\n            item?.kind === other?.kind &&\n            item?.location[0] === other?.location[0] &&\n            item?.location[1] === other?.location[1]\n        );\n    }\n\n    const [hoveredItem] = hoveredItemInfo ?? [];\n\n    const enqueueRef = React.useRef((_item: Item) => {\n        // do nothing\n    });\n    const hoverInfoRef = React.useRef(hoveredItemInfo);\n    hoverInfoRef.current = hoveredItemInfo;\n\n    const [bufferA, bufferB] = React.useMemo(() => {\n        return [document.createElement(\"canvas\"), document.createElement(\"canvas\")];\n    }, []);\n\n    const lastArgsRef = React.useRef<DrawGridArg>();\n    const draw = React.useCallback(() => {\n        const canvas = ref.current;\n        const overlay = overlayRef.current;\n        if (canvas === null || overlay === null) return;\n\n        const last = lastArgsRef.current;\n        const current = {\n            canvas,\n            bufferA,\n            bufferB,\n            headerCanvas: overlay,\n            width,\n            height,\n            cellXOffset,\n            cellYOffset,\n            translateX: Math.round(translateX),\n            translateY: Math.round(translateY),\n            mappedColumns,\n            enableGroups,\n            freezeColumns,\n            dragAndDropState,\n            theme,\n            headerHeight,\n            groupHeaderHeight,\n            disabledRows: disabledRows ?? CompactSelection.empty(),\n            rowHeight,\n            verticalBorder,\n            isResizing,\n            isFocused,\n            selection,\n            fillHandle,\n            lastRowSticky: trailingRowType,\n            rows,\n            drawFocus: drawFocusRing,\n            getCellContent,\n            getGroupDetails: getGroupDetails ?? (name => ({ name })),\n            getRowThemeOverride,\n            drawCustomCell,\n            drawHeaderCallback,\n            prelightCells,\n            highlightRegions,\n            imageLoader,\n            lastBlitData,\n            damage: damageRegion.current,\n            hoverValues: hoverValues.current,\n            hoverInfo: hoverInfoRef.current,\n            spriteManager,\n            scrolling,\n            hyperWrapping: experimental?.hyperWrapping ?? false,\n            touchMode: lastWasTouch,\n            enqueue: enqueueRef.current,\n            renderStrategy: experimental?.renderStrategy ?? (browserIsSafari.value ? \"double-buffer\" : \"single-buffer\"),\n            getCellRenderer,\n        };\n\n        // This confusing bit of code due to some poor design. Long story short, the damage property is only used\n        // with what is effectively the \"last args\" for the last normal draw anyway. We don't want the drawing code\n        // to look at this and go \"shit dawg, nothing changed\" so we force it to draw frash, but the damage restricts\n        // the draw anyway.\n        //\n        // Dear future Jason, I'm sorry. It was expedient, it worked, and had almost zero perf overhead. THe universe\n        // basically made me do it. What choice did I have?\n        if (current.damage === undefined) {\n            lastArgsRef.current = current;\n            drawGrid(current, last);\n        } else {\n            drawGrid(current, undefined);\n        }\n    }, [\n        bufferA,\n        bufferB,\n        width,\n        height,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mappedColumns,\n        enableGroups,\n        freezeColumns,\n        dragAndDropState,\n        theme,\n        headerHeight,\n        groupHeaderHeight,\n        disabledRows,\n        rowHeight,\n        verticalBorder,\n        isResizing,\n        isFocused,\n        selection,\n        fillHandle,\n        trailingRowType,\n        rows,\n        drawFocusRing,\n        getCellContent,\n        getGroupDetails,\n        getRowThemeOverride,\n        drawCustomCell,\n        drawHeaderCallback,\n        prelightCells,\n        highlightRegions,\n        imageLoader,\n        spriteManager,\n        scrolling,\n        experimental?.hyperWrapping,\n        experimental?.renderStrategy,\n        lastWasTouch,\n        getCellRenderer,\n    ]);\n\n    const lastDrawRef = React.useRef(draw);\n    React.useLayoutEffect(() => {\n        draw();\n        lastDrawRef.current = draw;\n    }, [draw]);\n\n    React.useLayoutEffect(() => {\n        const fn = async () => {\n            if (document?.fonts?.ready === undefined) return;\n            await document.fonts.ready;\n            lastArgsRef.current = undefined;\n            lastDrawRef.current();\n        };\n        void fn();\n    }, []);\n\n    const damageInternal = React.useCallback((locations: CellList) => {\n        damageRegion.current = locations;\n        lastDrawRef.current();\n        damageRegion.current = undefined;\n    }, []);\n\n    const enqueue = useAnimationQueue(damageInternal);\n    enqueueRef.current = enqueue;\n\n    const damage = React.useCallback(\n        (cells: DamageUpdateList) => {\n            damageInternal(cells.map(x => x.cell));\n        },\n        [damageInternal]\n    );\n\n    imageLoader.setCallback(damageInternal);\n\n    const [overFill, setOverFill] = React.useState(false);\n\n    const [hCol, hRow] = hoveredItem ?? [];\n    const headerHovered = hCol !== undefined && hRow === -1;\n    const groupHeaderHovered = hCol !== undefined && hRow === -2;\n    let clickableInnerCellHovered = false;\n    let editableBoolHovered = false;\n    let cursorOverride: React.CSSProperties[\"cursor\"] | undefined;\n    if (hCol !== undefined && hRow !== undefined && hRow > -1) {\n        const cell = getCellContent([hCol, hRow]);\n        clickableInnerCellHovered =\n            cell.kind === InnerGridCellKind.NewRow ||\n            (cell.kind === InnerGridCellKind.Marker && cell.markerKind !== \"number\");\n        editableBoolHovered = cell.kind === GridCellKind.Boolean && booleanCellIsEditable(cell);\n        cursorOverride = cell.cursor;\n    }\n    const canDrag = hoveredOnEdge ?? false;\n    const cursor = isDragging\n        ? \"grabbing\"\n        : canDrag || isResizing\n        ? \"col-resize\"\n        : overFill || isFilling\n        ? \"crosshair\"\n        : cursorOverride !== undefined\n        ? cursorOverride\n        : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered\n        ? \"pointer\"\n        : \"default\";\n    const style = React.useMemo(\n        () => ({\n            // width,\n            // height,\n            contain: \"strict\",\n            display: \"block\",\n            cursor,\n        }),\n        [cursor]\n    );\n\n    const lastSetCursor = React.useRef<typeof cursor>(\"default\");\n    const target = eventTargetRef?.current;\n    if (target !== null && target !== undefined && lastSetCursor.current !== style.cursor) {\n        // because we have an event target we need to set its cursor instead.\n        target.style.cursor = lastSetCursor.current = style.cursor;\n    }\n\n    const groupHeaderActionForEvent = React.useCallback(\n        (group: string, bounds: Rectangle, localEventX: number, localEventY: number) => {\n            if (getGroupDetails === undefined) return undefined;\n            const groupDesc = getGroupDetails(group);\n            if (groupDesc.actions !== undefined) {\n                const boxes = getActionBoundsForGroup(bounds, groupDesc.actions);\n                for (const [i, box] of boxes.entries()) {\n                    if (pointInRect(box, localEventX + bounds.x, localEventY + box.y)) {\n                        return groupDesc.actions[i];\n                    }\n                }\n            }\n            return undefined;\n        },\n        [getGroupDetails]\n    );\n\n    const isOverHeaderMenu = React.useCallback(\n        (canvas: HTMLCanvasElement, col: number, clientX: number, clientY: number) => {\n            const header = columns[col];\n\n            if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge ?? false)) {\n                const headerBounds = getBoundsForItem(canvas, col, -1);\n                assert(headerBounds !== undefined);\n                const menuBounds = getHeaderMenuBounds(\n                    headerBounds.x,\n                    headerBounds.y,\n                    headerBounds.width,\n                    headerBounds.height\n                );\n                if (\n                    clientX > menuBounds.x &&\n                    clientX < menuBounds.x + menuBounds.width &&\n                    clientY > menuBounds.y &&\n                    clientY < menuBounds.y + menuBounds.height\n                ) {\n                    return headerBounds;\n                }\n            }\n            return undefined;\n        },\n        [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]\n    );\n\n    const downTime = React.useRef(0);\n    const downPosition = React.useRef<Item>();\n    const onMouseDownImpl = React.useCallback(\n        (ev: MouseEvent | TouchEvent) => {\n            const canvas = ref.current;\n            const eventTarget = eventTargetRef?.current;\n            if (canvas === null || (ev.target !== canvas && ev.target !== eventTarget)) return;\n\n            let clientX: number;\n            let clientY: number;\n            if (ev instanceof MouseEvent) {\n                clientX = ev.clientX;\n                clientY = ev.clientY;\n            } else {\n                clientX = ev.touches[0].clientX;\n                clientY = ev.touches[0].clientY;\n            }\n            if (ev.target === eventTarget && eventTarget !== null) {\n                const bounds = eventTarget.getBoundingClientRect();\n                if (clientX > bounds.left + eventTarget.clientWidth) return;\n                if (clientY > bounds.top + eventTarget.clientHeight) return;\n            }\n\n            const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);\n            downPosition.current = args.location;\n\n            if (args.isTouch) {\n                downTime.current = Date.now();\n            }\n            if (lastWasTouchRef.current !== args.isTouch) {\n                setLastWasTouch(args.isTouch);\n            }\n\n            if (\n                args.kind === headerKind &&\n                isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== undefined\n            ) {\n                return;\n            } else if (args.kind === groupHeaderKind) {\n                const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);\n                if (action !== undefined) {\n                    return;\n                }\n            }\n\n            onMouseDown?.(args);\n            if (!args.isTouch && isDraggable !== true && isDraggable !== args.kind) {\n                // preventing default in touch events stops scroll\n                ev.preventDefault();\n            }\n        },\n        [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]\n    );\n    useEventListener(\"touchstart\", onMouseDownImpl, window, false);\n    useEventListener(\"mousedown\", onMouseDownImpl, window, false);\n\n    const onMouseUpImpl = React.useCallback(\n        (ev: MouseEvent | TouchEvent) => {\n            const canvas = ref.current;\n            if (onMouseUp === undefined || canvas === null) return;\n            const eventTarget = eventTargetRef?.current;\n\n            const isOutside = ev.target !== canvas && ev.target !== eventTarget;\n\n            let clientX: number;\n            let clientY: number;\n            if (ev instanceof MouseEvent) {\n                clientX = ev.clientX;\n                clientY = ev.clientY;\n            } else {\n                clientX = ev.changedTouches[0].clientX;\n                clientY = ev.changedTouches[0].clientY;\n            }\n\n            let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);\n\n            if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {\n                args = {\n                    ...args,\n                    isLongTouch: true,\n                };\n            }\n\n            if (lastWasTouchRef.current !== args.isTouch) {\n                setLastWasTouch(args.isTouch);\n            }\n\n            if (!isOutside && ev.cancelable) {\n                ev.preventDefault();\n            }\n\n            if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY)) {\n                const [col] = args.location;\n                const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);\n                if (headerBounds !== undefined) {\n                    if (args.button === 0 && downPosition.current?.[0] === col && downPosition.current?.[1] === -1) {\n                        onHeaderMenuClick?.(col, headerBounds);\n                    } else {\n                        // force outside so that click will not process\n                        onMouseUp(args, true);\n                    }\n                    return;\n                }\n            } else if (args.kind === groupHeaderKind) {\n                const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);\n                if (action !== undefined) {\n                    if (args.button === 0) {\n                        action.onClick(args);\n                    }\n                    return;\n                }\n            }\n\n            onMouseUp(args, isOutside);\n        },\n        [\n            onMouseUp,\n            eventTargetRef,\n            getMouseArgsForPosition,\n            isOverHeaderMenu,\n            onHeaderMenuClick,\n            groupHeaderActionForEvent,\n        ]\n    );\n    useEventListener(\"mouseup\", onMouseUpImpl, window, false);\n    useEventListener(\"touchend\", onMouseUpImpl, window, false);\n\n    const onContextMenuImpl = React.useCallback(\n        (ev: MouseEvent) => {\n            const canvas = ref.current;\n            if (canvas === null || onContextMenu === undefined) return;\n            const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);\n            onContextMenu(args, () => {\n                if (ev.cancelable) ev.preventDefault();\n            });\n        },\n        [getMouseArgsForPosition, onContextMenu]\n    );\n    useEventListener(\"contextmenu\", onContextMenuImpl, eventTargetRef?.current ?? null, false);\n\n    const onAnimationFrame = React.useCallback<StepCallback>(values => {\n        damageRegion.current = values.map(x => x.item);\n        hoverValues.current = values;\n        lastDrawRef.current();\n        damageRegion.current = undefined;\n    }, []);\n\n    const animManagerValue = React.useMemo(() => new AnimationManager(onAnimationFrame), [onAnimationFrame]);\n    const animationManager = React.useRef(animManagerValue);\n    animationManager.current = animManagerValue;\n    React.useLayoutEffect(() => {\n        const am = animationManager.current;\n        if (hoveredItem === undefined || hoveredItem[1] < 0) {\n            am.setHovered(hoveredItem);\n            return;\n        }\n        const cell = getCellContent(hoveredItem as [number, number]);\n        const r = getCellRenderer(cell);\n        am.setHovered(\n            (r === undefined && cell.kind === GridCellKind.Custom) || r?.needsHover === true ? hoveredItem : undefined\n        );\n    }, [getCellContent, getCellRenderer, hoveredItem]);\n\n    const hoveredRef = React.useRef<GridMouseEventArgs>();\n    const onMouseMoveImpl = React.useCallback(\n        (ev: MouseEvent) => {\n            const canvas = ref.current;\n            if (canvas === null) return;\n\n            const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);\n            if (!isSameItem(args, hoveredRef.current)) {\n                onItemHovered?.(args);\n                setHoveredItemInfo(\n                    args.kind === outOfBoundsKind ? undefined : [args.location, [args.localEventX, args.localEventY]]\n                );\n                hoveredRef.current = args;\n            } else if (args.kind === \"cell\" || args.kind === headerKind || args.kind === groupHeaderKind) {\n                const newInfo: typeof hoverInfoRef.current = [args.location, [args.localEventX, args.localEventY]];\n                setHoveredItemInfo(newInfo);\n                hoverInfoRef.current = newInfo;\n\n                if (args.kind === \"cell\") {\n                    const toCheck = getCellContent(args.location);\n                    if (toCheck.kind === GridCellKind.Custom || getCellRenderer(toCheck)?.needsHoverPosition === true) {\n                        damageInternal([args.location]);\n                    }\n                } else if (args.kind === groupHeaderKind) {\n                    damageInternal([args.location]);\n                }\n            }\n\n            setHoveredOnEdge(args.kind === headerKind && args.isEdge && allowResize === true);\n\n            if (fillHandle && selection.current !== undefined) {\n                const [col, row] = selection.current.cell;\n                const sb = getBoundsForItem(canvas, col, row);\n                const x = ev.clientX;\n                const y = ev.clientY;\n                assert(sb !== undefined);\n                setOverFill(\n                    x >= sb.x + sb.width - 6 &&\n                        x <= sb.x + sb.width &&\n                        y >= sb.y + sb.height - 6 &&\n                        y <= sb.y + sb.height\n                );\n            } else {\n                setOverFill(false);\n            }\n\n            onMouseMoveRaw?.(ev);\n            onMouseMove(args);\n        },\n        [\n            getMouseArgsForPosition,\n            allowResize,\n            fillHandle,\n            selection,\n            onMouseMoveRaw,\n            onMouseMove,\n            onItemHovered,\n            getCellContent,\n            getCellRenderer,\n            damageInternal,\n            getBoundsForItem,\n        ]\n    );\n    useEventListener(\"mousemove\", onMouseMoveImpl, window, true);\n\n    const onKeyDownImpl = React.useCallback(\n        (event: React.KeyboardEvent<HTMLCanvasElement>) => {\n            const canvas = ref.current;\n            if (canvas === null) return;\n\n            let bounds: Rectangle | undefined;\n            if (selection.current !== undefined) {\n                bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);\n            }\n\n            onKeyDown?.({\n                bounds,\n                stopPropagation: () => event.stopPropagation(),\n                preventDefault: () => event.preventDefault(),\n                cancel: () => undefined,\n                ctrlKey: event.ctrlKey,\n                metaKey: event.metaKey,\n                shiftKey: event.shiftKey,\n                altKey: event.altKey,\n                key: event.key,\n                keyCode: event.keyCode,\n                rawEvent: event,\n            });\n        },\n        [onKeyDown, selection, getBoundsForItem]\n    );\n\n    const onKeyUpImpl = React.useCallback(\n        (event: React.KeyboardEvent<HTMLCanvasElement>) => {\n            const canvas = ref.current;\n            if (canvas === null) return;\n\n            let bounds: Rectangle | undefined;\n            if (selection.current !== undefined) {\n                bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);\n            }\n\n            onKeyUp?.({\n                bounds,\n                stopPropagation: () => event.stopPropagation(),\n                preventDefault: () => event.preventDefault(),\n                cancel: () => undefined,\n                ctrlKey: event.ctrlKey,\n                metaKey: event.metaKey,\n                shiftKey: event.shiftKey,\n                altKey: event.altKey,\n                key: event.key,\n                keyCode: event.keyCode,\n                rawEvent: event,\n            });\n        },\n        [onKeyUp, selection, getBoundsForItem]\n    );\n\n    const refImpl = React.useCallback(\n        (instance: HTMLCanvasElement | null) => {\n            ref.current = instance;\n            if (canvasRef !== undefined) {\n                canvasRef.current = instance;\n            }\n        },\n        [canvasRef]\n    );\n\n    const onDragStartImpl = React.useCallback(\n        (event: DragEvent) => {\n            const canvas = ref.current;\n            if (canvas === null || isDraggable === false || isResizing) {\n                event.preventDefault();\n                return;\n            }\n\n            let dragMime: string | undefined;\n            let dragData: string | undefined;\n\n            const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n\n            if (isDraggable !== true && args.kind !== isDraggable) {\n                event.preventDefault();\n                return;\n            }\n\n            const setData = (mime: string, payload: string) => {\n                dragMime = mime;\n                dragData = payload;\n            };\n\n            let dragImage: Element | undefined;\n            let dragImageX: number | undefined;\n            let dragImageY: number | undefined;\n            const setDragImage = (image: Element, x: number, y: number) => {\n                dragImage = image;\n                dragImageX = x;\n                dragImageY = y;\n            };\n\n            let prevented = false;\n\n            onDragStart?.({\n                ...args,\n                setData,\n                setDragImage,\n                preventDefault: () => (prevented = true),\n                defaultPrevented: () => prevented,\n            });\n            if (!prevented && dragMime !== undefined && dragData !== undefined && event.dataTransfer !== null) {\n                event.dataTransfer.setData(dragMime, dragData);\n                event.dataTransfer.effectAllowed = \"copyLink\";\n\n                if (dragImage !== undefined && dragImageX !== undefined && dragImageY !== undefined) {\n                    event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);\n                } else {\n                    const [col, row] = args.location;\n                    if (row !== undefined) {\n                        const offscreen = document.createElement(\"canvas\");\n                        const boundsForDragTarget = getBoundsForItem(canvas, col, row);\n\n                        assert(boundsForDragTarget !== undefined);\n                        offscreen.width = boundsForDragTarget.width;\n                        offscreen.height = boundsForDragTarget.height;\n\n                        const ctx = offscreen.getContext(\"2d\");\n                        if (ctx !== null) {\n                            ctx.textBaseline = \"middle\";\n                            if (row === -1) {\n                                ctx.font = `${theme.headerFontStyle} ${theme.fontFamily}`;\n                                ctx.fillStyle = theme.bgHeader;\n                                ctx.fillRect(0, 0, offscreen.width, offscreen.height);\n                                drawHeader(\n                                    ctx,\n                                    0,\n                                    0,\n                                    boundsForDragTarget.width,\n                                    boundsForDragTarget.height,\n                                    mappedColumns[col],\n                                    false,\n                                    theme,\n                                    false,\n                                    false,\n                                    0,\n                                    spriteManager,\n                                    drawHeaderCallback,\n                                    false\n                                );\n                            } else {\n                                ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n                                ctx.fillStyle = theme.bgCell;\n                                ctx.fillRect(0, 0, offscreen.width, offscreen.height);\n                                drawCell(\n                                    ctx,\n                                    row,\n                                    getCellContent([col, row]),\n                                    0,\n                                    0,\n                                    0,\n                                    boundsForDragTarget.width,\n                                    boundsForDragTarget.height,\n                                    false,\n                                    theme,\n                                    drawCustomCell,\n                                    imageLoader,\n                                    spriteManager,\n                                    1,\n                                    undefined,\n                                    false,\n                                    0,\n                                    undefined,\n                                    undefined,\n                                    getCellRenderer\n                                );\n                            }\n                        }\n\n                        offscreen.style.left = \"-100%\";\n                        offscreen.style.position = \"absolute\";\n\n                        document.body.append(offscreen);\n\n                        event.dataTransfer.setDragImage(\n                            offscreen,\n                            boundsForDragTarget.width / 2,\n                            boundsForDragTarget.height / 2\n                        );\n\n                        window.setTimeout(() => {\n                            offscreen.remove();\n                        }, 0);\n                    }\n                }\n            } else {\n                event.preventDefault();\n            }\n        },\n        [\n            isDraggable,\n            isResizing,\n            getMouseArgsForPosition,\n            onDragStart,\n            getBoundsForItem,\n            theme,\n            mappedColumns,\n            spriteManager,\n            drawHeaderCallback,\n            getCellContent,\n            drawCustomCell,\n            imageLoader,\n            getCellRenderer,\n        ]\n    );\n    useEventListener(\"dragstart\", onDragStartImpl, eventTargetRef?.current ?? null, false, false);\n\n    const activeDropTarget = React.useRef<Item | undefined>();\n\n    const onDragOverImpl = React.useCallback(\n        (event: DragEvent) => {\n            const canvas = ref.current;\n            if (onDrop !== undefined) {\n                // Need to preventDefault to allow drop\n                event.preventDefault();\n            }\n\n            if (canvas === null || onDragOverCell === undefined) {\n                return;\n            }\n\n            const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n\n            const [rawCol, row] = args.location;\n            const col = rawCol - (firstColAccessible ? 0 : 1);\n            const [activeCol, activeRow] = activeDropTarget.current ?? [];\n\n            if (activeCol !== col || activeRow !== row) {\n                activeDropTarget.current = [col, row];\n                onDragOverCell([col, row], event.dataTransfer);\n            }\n        },\n        [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]\n    );\n    useEventListener(\"dragover\", onDragOverImpl, eventTargetRef?.current ?? null, false, false);\n\n    const onDragEndImpl = React.useCallback(() => {\n        activeDropTarget.current = undefined;\n        onDragEnd?.();\n    }, [onDragEnd]);\n    useEventListener(\"dragend\", onDragEndImpl, eventTargetRef?.current ?? null, false, false);\n\n    const onDropImpl = React.useCallback(\n        (event: DragEvent) => {\n            const canvas = ref.current;\n            if (canvas === null || onDrop === undefined) {\n                return;\n            }\n\n            // Default can mess up sometimes.\n            event.preventDefault();\n\n            const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n\n            const [rawCol, row] = args.location;\n            const col = rawCol - (firstColAccessible ? 0 : 1);\n\n            onDrop([col, row], event.dataTransfer);\n        },\n        [firstColAccessible, getMouseArgsForPosition, onDrop]\n    );\n    useEventListener(\"drop\", onDropImpl, eventTargetRef?.current ?? null, false, false);\n\n    const onDragLeaveImpl = React.useCallback(() => {\n        onDragLeave?.();\n    }, [onDragLeave]);\n    useEventListener(\"dragleave\", onDragLeaveImpl, eventTargetRef?.current ?? null, false, false);\n\n    const selectionRef = React.useRef(selection);\n    selectionRef.current = selection;\n    const focusRef = React.useRef<HTMLElement | null>(null);\n    const focusElement = React.useCallback(\n        (el: HTMLElement | null) => {\n            // We don't want to steal the focus if we don't currently own the focus.\n            if (ref.current === null || !ref.current.contains(document.activeElement)) return;\n            if (el === null && selectionRef.current.current !== undefined) {\n                canvasRef?.current?.focus({\n                    preventScroll: true,\n                });\n            } else if (el !== null) {\n                el.focus({\n                    preventScroll: true,\n                });\n            }\n            focusRef.current = el;\n        },\n        [canvasRef]\n    );\n\n    React.useImperativeHandle(\n        forwardedRef,\n        () => ({\n            focus: () => {\n                const el = focusRef.current;\n                // The element in the ref may have been removed however our callback method ref\n                // won't see the removal so bad things happen. Checking to see if the element is\n                // no longer attached is enough to resolve the problem. In the future this\n                // should be replaced with something much more robust.\n                if (el === null || !document.contains(el)) {\n                    canvasRef?.current?.focus({\n                        preventScroll: true,\n                    });\n                } else {\n                    el.focus({\n                        preventScroll: true,\n                    });\n                }\n            },\n            getBounds: (col: number, row?: number) => {\n                if (canvasRef === undefined || canvasRef.current === null) {\n                    return undefined;\n                }\n\n                return getBoundsForItem(canvasRef.current, col, row ?? -1);\n            },\n            damage,\n        }),\n        [canvasRef, damage, getBoundsForItem]\n    );\n\n    const lastFocusedSubdomNode = React.useRef<Item>();\n\n    const accessibilityTree = useDebouncedMemo(\n        () => {\n            if (width < 50) return null;\n            let effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);\n            const colOffset = firstColAccessible ? 0 : -1;\n            if (!firstColAccessible && effectiveCols[0]?.sourceIndex === 0) {\n                effectiveCols = effectiveCols.slice(1);\n            }\n\n            const [fCol, fRow] = selection.current?.cell ?? [];\n            const range = selection.current?.range;\n\n            const visibleCols = effectiveCols.map(c => c.sourceIndex);\n            const visibleRows = makeRange(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));\n\n            // Maintain focus within grid if we own it but focused cell is outside visible viewport\n            // and not rendered.\n            if (\n                fCol !== undefined &&\n                fRow !== undefined &&\n                !(visibleCols.includes(fCol) && visibleRows.includes(fRow))\n            ) {\n                focusElement(null);\n            }\n\n            return (\n                <table\n                    key=\"access-tree\"\n                    role=\"grid\"\n                    aria-rowcount={rows + 1}\n                    aria-multiselectable=\"true\"\n                    aria-colcount={mappedColumns.length + colOffset}>\n                    <thead role=\"rowgroup\">\n                        <tr role=\"row\" aria-rowindex={1}>\n                            {effectiveCols.map(c => (\n                                <th\n                                    role=\"columnheader\"\n                                    aria-selected={selection.columns.hasIndex(c.sourceIndex)}\n                                    aria-colindex={c.sourceIndex + 1 + colOffset}\n                                    tabIndex={-1}\n                                    onFocus={e => {\n                                        if (e.target === focusRef.current) return;\n                                        return onCellFocused?.([c.sourceIndex, -1]);\n                                    }}\n                                    key={c.sourceIndex}>\n                                    {c.title}\n                                </th>\n                            ))}\n                        </tr>\n                    </thead>\n                    <tbody role=\"rowgroup\">\n                        {visibleRows.map(row => (\n                            <tr\n                                role=\"row\"\n                                aria-selected={selection.rows.hasIndex(row)}\n                                key={row}\n                                aria-rowindex={row + 2}>\n                                {effectiveCols.map(c => {\n                                    const col = c.sourceIndex;\n                                    const key = `${col},${row}`;\n                                    const focused = fCol === col && fRow === row;\n                                    const selected =\n                                        range !== undefined &&\n                                        col >= range.x &&\n                                        col < range.x + range.width &&\n                                        row >= range.y &&\n                                        row < range.y + range.height;\n                                    const id = `glide-cell-${col}-${row}`;\n                                    const cellContent = getCellContent([col, row]);\n                                    return (\n                                        <td\n                                            key={key}\n                                            role=\"gridcell\"\n                                            aria-colindex={col + 1 + colOffset}\n                                            aria-selected={selected}\n                                            aria-readonly={\n                                                isInnerOnlyCell(cellContent) || !isReadWriteCell(cellContent)\n                                            }\n                                            id={id}\n                                            data-testid={id}\n                                            onClick={() => {\n                                                const canvas = canvasRef?.current;\n                                                if (canvas === null || canvas === undefined) return;\n                                                return onKeyDown?.({\n                                                    bounds: getBoundsForItem(canvas, col, row),\n                                                    cancel: () => undefined,\n                                                    preventDefault: () => undefined,\n                                                    stopPropagation: () => undefined,\n                                                    ctrlKey: false,\n                                                    key: \"Enter\",\n                                                    keyCode: 13,\n                                                    metaKey: false,\n                                                    shiftKey: false,\n                                                    altKey: false,\n                                                    rawEvent: undefined,\n                                                });\n                                            }}\n                                            onFocusCapture={e => {\n                                                if (\n                                                    e.target === focusRef.current ||\n                                                    (lastFocusedSubdomNode.current?.[0] === col &&\n                                                        lastFocusedSubdomNode.current?.[1] === row)\n                                                )\n                                                    return;\n                                                lastFocusedSubdomNode.current = [col, row];\n                                                return onCellFocused?.([col, row]);\n                                            }}\n                                            ref={focused ? focusElement : undefined}\n                                            tabIndex={-1}>\n                                            {getRowData(cellContent, getCellRenderer)}\n                                        </td>\n                                    );\n                                })}\n                            </tr>\n                        ))}\n                    </tbody>\n                </table>\n            );\n        },\n        [\n            width,\n            mappedColumns,\n            cellXOffset,\n            dragAndDropState,\n            translateX,\n            rows,\n            cellYOffset,\n            accessibilityHeight,\n            selection,\n            focusElement,\n            getCellContent,\n            canvasRef,\n            onKeyDown,\n            getBoundsForItem,\n            onCellFocused,\n        ],\n        200\n    );\n\n    const stickyX = fixedShadowX ? getStickyWidth(mappedColumns, dragAndDropState) : 0;\n    const opacityX =\n        freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : clamp(-translateX / 100, 0, 1);\n\n    const absoluteOffsetY = -cellYOffset * 32 + translateY;\n    const opacityY = !fixedShadowY ? 0 : clamp(-absoluteOffsetY / 100, 0, 1);\n\n    const stickyShadow = React.useMemo(() => {\n        if (!opacityX && !opacityY) {\n            return null;\n        }\n\n        const styleX: React.CSSProperties = {\n            position: \"absolute\",\n            top: 0,\n            left: stickyX,\n            width: width - stickyX,\n            height: height,\n            opacity: opacityX,\n            pointerEvents: \"none\",\n            transition: !smoothScrollX ? \"opacity 0.2s\" : undefined,\n            boxShadow: \"inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)\",\n        };\n\n        const styleY: React.CSSProperties = {\n            position: \"absolute\",\n            top: totalHeaderHeight,\n            left: 0,\n            width: width,\n            height: height,\n            opacity: opacityY,\n            pointerEvents: \"none\",\n            transition: !smoothScrollY ? \"opacity 0.2s\" : undefined,\n            boxShadow: \"inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)\",\n        };\n\n        return (\n            <>\n                {opacityX > 0 && <div id=\"shadow-x\" style={styleX} />}\n                {opacityY > 0 && <div id=\"shadow-y\" style={styleY} />}\n            </>\n        );\n    }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);\n\n    const overlayStyle = React.useMemo<React.CSSProperties>(\n        () => ({\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n        }),\n        []\n    );\n\n    return (\n        <>\n            <canvas\n                data-testid=\"data-grid-canvas\"\n                tabIndex={0}\n                onKeyDown={onKeyDownImpl}\n                onKeyUp={onKeyUpImpl}\n                onFocus={onCanvasFocused}\n                onBlur={onCanvasBlur}\n                ref={refImpl}\n                style={style}>\n                {accessibilityTree}\n            </canvas>\n            <canvas ref={overlayRef} style={overlayStyle} />\n            {stickyShadow}\n        </>\n    );\n};\n\nexport default React.memo(React.forwardRef(DataGrid));\n","import type { ImageWindowLoader, Item, Rectangle } from \"../data-grid/data-grid-types\";\nimport throttle from \"lodash/throttle.js\";\n\ninterface LoadResult {\n    img: HTMLImageElement | undefined;\n    cancel: () => void;\n    url: string;\n    cells: number[];\n}\n\nconst rowShift = 1 << 16;\n\nconst imgPool: HTMLImageElement[] = [];\n\nfunction packColRowToNumber(col: number, row: number) {\n    return row * rowShift + col;\n}\n\nfunction unpackCol(packed: number): number {\n    return packed % rowShift;\n}\n\nfunction unpackRow(packed: number, col: number): number {\n    return (packed - col) / rowShift;\n}\n\nfunction unpackNumberToColRow(packed: number): [number, number] {\n    const col = unpackCol(packed);\n    const row = unpackRow(packed, col);\n    return [col, row];\n}\n\nclass ImageWindowLoaderImpl implements ImageWindowLoader {\n    private imageLoaded: (locations: readonly Item[]) => void = () => undefined;\n    private loadedLocations: [number, number][] = [];\n\n    private visibleWindow: Rectangle = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n    };\n\n    private freezeCols: number = 0;\n\n    private isInWindow = (packed: number) => {\n        const col = unpackCol(packed);\n        const row = unpackRow(packed, col);\n        const w = this.visibleWindow;\n        if (col < this.freezeCols && row >= w.y && row <= w.y + w.height) return true;\n        return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;\n    };\n\n    private cache: Record<string, LoadResult> = {};\n\n    public setCallback(imageLoaded: (locations: readonly Item[]) => void) {\n        this.imageLoaded = imageLoaded;\n    }\n\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    private sendLoaded = throttle(() => {\n        this.imageLoaded(this.loadedLocations);\n        this.loadedLocations = [];\n    }, 20);\n\n    private clearOutOfWindow = () => {\n        const keys = Object.keys(this.cache);\n        for (const key of keys) {\n            const obj = this.cache[key];\n\n            let keep = false;\n            for (let j = 0; j < obj.cells.length; j++) {\n                const packed = obj.cells[j];\n                if (this.isInWindow(packed)) {\n                    keep = true;\n                    break;\n                }\n            }\n\n            if (keep) {\n                obj.cells = obj.cells.filter(this.isInWindow);\n            } else {\n                obj.cancel();\n                delete this.cache[key];\n            }\n        }\n    };\n\n    public setWindow(newWindow: Rectangle, freezeCols: number): void {\n        if (\n            this.visibleWindow.x === newWindow.x &&\n            this.visibleWindow.y === newWindow.y &&\n            this.visibleWindow.width === newWindow.width &&\n            this.visibleWindow.height === newWindow.height &&\n            this.freezeCols === freezeCols\n        )\n            return;\n        this.visibleWindow = newWindow;\n        this.freezeCols = freezeCols;\n        this.clearOutOfWindow();\n    }\n\n    private loadImage(url: string, col: number, row: number, key: string) {\n        let loaded = false;\n        const img = imgPool.pop() ?? new Image();\n\n        let canceled = false;\n        const result: LoadResult = {\n            img: undefined,\n            cells: [packColRowToNumber(col, row)],\n            url,\n            cancel: () => {\n                if (canceled) return;\n                canceled = true;\n                if (imgPool.length < 12) {\n                    imgPool.unshift(img); // never retain more than 12\n                } else if (!loaded) {\n                    img.src = \"\";\n                }\n            },\n        };\n\n        const loadPromise = new Promise(r => img.addEventListener(\"load\", () => r(null)));\n        // use request animation time to avoid paying src set costs during draw calls\n        requestAnimationFrame(async () => {\n            try {\n                img.src = url;\n                await loadPromise;\n                await img.decode();\n                const toWrite = this.cache[key];\n                if (toWrite !== undefined && !canceled) {\n                    toWrite.img = img;\n                    for (const packed of toWrite.cells) {\n                        this.loadedLocations.push(unpackNumberToColRow(packed));\n                    }\n                    loaded = true;\n                    this.sendLoaded();\n                }\n            } catch {\n                result.cancel();\n            }\n        });\n        this.cache[key] = result;\n    }\n\n    public loadOrGetImage(url: string, col: number, row: number): HTMLImageElement | ImageBitmap | undefined {\n        const key = url;\n\n        const current = this.cache[key];\n        if (current !== undefined) {\n            const packed = packColRowToNumber(col, row);\n            if (!current.cells.includes(packed)) {\n                current.cells.push(packed);\n            }\n            return current.img;\n        } else {\n            this.loadImage(url, col, row, key);\n        }\n        return undefined;\n    }\n}\n\nexport default ImageWindowLoaderImpl;\n","import * as React from \"react\";\nimport debounce from \"lodash/debounce.js\";\n\nexport function useEventListener<K extends keyof HTMLElementEventMap>(\n    eventName: K,\n    handler: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,\n    element: HTMLElement | Window | null,\n    passive: boolean,\n    capture = false\n) {\n    // Create a ref that stores handler\n    const savedHandler = React.useRef<(this: HTMLElement, ev: HTMLElementEventMap[K]) => any>();\n\n    // Update ref.current value if handler changes.\n    // This allows our effect below to always get latest handler ...\n    // ... without us needing to pass it in effect deps array ...\n    // ... and potentially cause effect to re-run every render.\n    savedHandler.current = handler;\n    React.useEffect(\n        () => {\n            // Make sure element supports addEventListener\n            if (element === null || element.addEventListener === undefined) return;\n            const el = element as HTMLElement;\n\n            // Create event listener that calls handler function stored in ref\n            const eventListener = (event: HTMLElementEventMap[K]) => {\n                savedHandler.current?.call(el, event);\n            };\n\n            el.addEventListener(eventName, eventListener, { passive, capture });\n\n            // Remove event listener on cleanup\n            return () => {\n                el.removeEventListener(eventName, eventListener, { capture });\n            };\n        },\n        [eventName, element, passive, capture] // Re-run if eventName or element changes\n    );\n}\n\nexport function whenDefined<T>(obj: any, result: T) {\n    return obj === undefined ? undefined : result;\n}\n\nconst PI = Math.PI;\nexport function degreesToRadians(degrees: number) {\n    return (degrees * PI) / 180;\n}\n\nexport interface SpriteProps {\n    fgColor: string;\n    bgColor: string;\n}\n\nexport const EditPencil: React.FunctionComponent<Partial<SpriteProps>> = (props: Partial<SpriteProps>) => {\n    const fg = props.fgColor ?? \"currentColor\";\n    return (\n        <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path\n                d=\"M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929\"\n                stroke={fg}\n                strokeWidth=\"1.5\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                fill=\"none\"\n                vectorEffect=\"non-scaling-stroke\"\n            />\n            <path\n                d=\"M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z\"\n                stroke={fg}\n                strokeWidth=\"1.5\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                fill=\"none\"\n                vectorEffect=\"non-scaling-stroke\"\n            />\n        </svg>\n    );\n};\n\nexport const Checkmark: React.FunctionComponent<Partial<SpriteProps>> = (props: Partial<SpriteProps>) => {\n    const fg = props.fgColor ?? \"currentColor\";\n\n    return (\n        <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n            <path\n                d=\"M19 6L10.3802 17L5.34071 11.8758\"\n                vectorEffect=\"non-scaling-stroke\"\n                stroke={fg}\n                strokeWidth=\"1.5\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n            />\n        </svg>\n    );\n};\n\nexport function useDebouncedMemo<T>(factory: () => T, deps: React.DependencyList | undefined, time: number): T {\n    const [state, setState] = React.useState(factory);\n\n    const mountedRef = React.useRef(true);\n    React.useEffect(\n        () => () => {\n            mountedRef.current = false;\n        },\n        []\n    );\n\n    const debouncedSetState = React.useRef<typeof setState>(\n        debounce(x => {\n            if (mountedRef.current) {\n                setState(x);\n            }\n        }, time)\n    );\n\n    React.useLayoutEffect(() => {\n        if (mountedRef.current) {\n            debouncedSetState.current(() => factory());\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n\n    return state;\n}\n\n// Shamelessly inline direction to avoid conflicts with 1.0 and 2.0.\nconst rtlRange = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst ltrRange =\n    \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\" +\n    \"\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C\" +\n    \"\\uFE00-\\uFE6F\\uFEFD-\\uFFFF\";\n\n/* eslint-disable no-misleading-character-class */\nconst rtl = new RegExp(\"^[^\" + ltrRange + \"]*[\" + rtlRange + \"]\");\nconst ltr = new RegExp(\"^[^\" + rtlRange + \"]*[\" + ltrRange + \"]\");\n/* eslint-enable no-misleading-character-class */\n\nexport function direction(value: string): \"rtl\" | \"ltr\" | \"neutral\" {\n    return rtl.test(value) ? \"rtl\" : ltr.test(value) ? \"ltr\" : \"neutral\";\n}\n\nlet scrollbarWidthCache: number | undefined = undefined;\nexport function getScrollBarWidth(): number {\n    if (scrollbarWidthCache !== undefined) return scrollbarWidthCache;\n    const inner = document.createElement(\"p\");\n    inner.style.width = \"100%\";\n    inner.style.height = \"200px\";\n\n    const outer = document.createElement(\"div\");\n    outer.id = \"testScrollbar\";\n\n    outer.style.position = \"absolute\";\n    outer.style.top = \"0px\";\n    outer.style.left = \"0px\";\n    outer.style.visibility = \"hidden\";\n    outer.style.width = \"200px\";\n    outer.style.height = \"150px\";\n    outer.style.overflow = \"hidden\";\n    outer.append(inner);\n\n    document.body.append(outer);\n    const w1 = inner.offsetWidth;\n    outer.style.overflow = \"scroll\";\n    let w2 = inner.offsetWidth;\n    if (w1 === w2) {\n        w2 = outer.clientWidth;\n    }\n\n    outer.remove();\n\n    scrollbarWidthCache = w1 - w2;\n    return scrollbarWidthCache;\n}\n\n// Dear future reader,\n// This dumb hook is to make sure if the inputState changes, that effectively behaves like an instant \"setState\" call.\n// This is useful in a wide variety of situations. I'm too dumb to know if this is a good idea or a really dumb one.\n// I can't tell. It's like poes law but for code.\n//\n// I'm sorry.\nconst empty = Symbol();\nexport function useStateWithReactiveInput<T>(inputState: T): [T, React.Dispatch<React.SetStateAction<T>>, () => void] {\n    // When [0] is not empty we will return it, [1] is always the last value we saw\n    const inputStateRef = React.useRef<[T | typeof empty, T]>([empty, inputState]);\n    if (inputStateRef.current[1] !== inputState) {\n        // it changed, we must use thee!\n        inputStateRef.current[0] = inputState;\n    }\n    inputStateRef.current[1] = inputState;\n\n    const [state, setState] = React.useState(inputState);\n    // crimes against humanity here\n    const [, forceRender] = React.useState<{} | undefined>();\n    const setStateOuter = React.useCallback<typeof setState>(nv => {\n        // this takes care of the case where the inputState was set, then setState gets called again but back to what\n        // the state was before the inputState changed. Since the useState effect wont trigger a render in this case\n        // we need to be very naughty and force it to see the change. Technically this may not be needed some chunk of\n        // the time (in fact most of it) but checking for it is likely to be more expensive than just over-doing it\n        const s = inputStateRef.current[0];\n        if (s !== empty) {\n            nv = typeof nv === \"function\" ? (nv as (pv: T) => T)(s) : nv;\n            if (nv === s) return; // they are setting it to what the inputState is anyway so we can just do nothing\n        }\n        if (s !== empty) forceRender({});\n        setState(pv => {\n            if (typeof nv === \"function\") {\n                return (nv as (pv: T) => T)(s === empty ? pv : s);\n            }\n            return nv;\n        });\n        inputStateRef.current[0] = empty;\n    }, []);\n\n    const onEmpty = React.useCallback(() => {\n        inputStateRef.current[0] = empty;\n        forceRender({});\n    }, []);\n\n    return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];\n}\n","/* eslint-disable unicorn/no-for-loop */\nimport type { Theme } from \"../common/styles\";\nimport {\n    DrilldownCellData,\n    Item,\n    GridSelection,\n    InnerGridCell,\n    SizedGridColumn,\n    Rectangle,\n    BaseGridCell,\n    BooleanEmpty,\n    BooleanIndeterminate,\n} from \"./data-grid-types\";\nimport { degreesToRadians, direction } from \"../common/utils\";\nimport React from \"react\";\nimport type { BaseDrawArgs, PrepResult } from \"./cells/cell-types\";\nimport { assertNever } from \"../common/support\";\nimport { split as splitText, clearCache } from \"canvas-hypertxt\";\n\nexport interface MappedGridColumn extends SizedGridColumn {\n    sourceIndex: number;\n    sticky: boolean;\n}\n\nexport function useMappedColumns(\n    columns: readonly SizedGridColumn[],\n    freezeColumns: number\n): readonly MappedGridColumn[] {\n    return React.useMemo(\n        () =>\n            columns.map((c, i) => ({\n                ...c,\n                sourceIndex: i,\n                sticky: i < freezeColumns,\n            })),\n        [columns, freezeColumns]\n    );\n}\n\nexport function isGroupEqual(left: string | undefined, right: string | undefined): boolean {\n    return (left ?? \"\") === (right ?? \"\");\n}\n\nexport function cellIsSelected(location: Item, cell: InnerGridCell, selection: GridSelection): boolean {\n    if (selection?.current === undefined) return false;\n\n    const [col, row] = selection.current.cell;\n    const [cellCol, cellRow] = location;\n    if (cellRow !== row) return false;\n\n    if (cell.span === undefined) {\n        return col === cellCol;\n    }\n\n    return col >= cell.span[0] && col <= cell.span[1];\n}\n\nfunction cellIsInRect(location: Item, cell: InnerGridCell, rect: Rectangle): boolean {\n    const startX = rect.x;\n    const endX = rect.x + rect.width - 1;\n    const startY = rect.y;\n    const endY = rect.y + rect.height - 1;\n\n    const [cellCol, cellRow] = location;\n    if (cellRow < startY || cellRow > endY) return false;\n\n    if (cell.span === undefined) {\n        return cellCol >= startX && cellCol <= endX;\n    }\n\n    const [spanStart, spanEnd] = cell.span;\n    return (\n        (spanStart >= startX && spanStart <= endX) ||\n        (spanEnd >= startX && spanStart <= endX) ||\n        (spanStart < startX && spanEnd > endX)\n    );\n}\n\nexport function cellIsInRange(location: Item, cell: InnerGridCell, selection: GridSelection): number {\n    let result = 0;\n    if (selection.current === undefined) return result;\n\n    if (cellIsInRect(location, cell, selection.current.range)) result++;\n    for (const r of selection.current.rangeStack) {\n        if (cellIsInRect(location, cell, r)) {\n            result++;\n        }\n    }\n    return result;\n}\n\nfunction remapForDnDState(\n    columns: readonly MappedGridColumn[],\n    dndState?: {\n        src: number;\n        dest: number;\n    }\n) {\n    let mappedCols = columns;\n    if (dndState !== undefined) {\n        let writable = [...columns];\n        const temp = mappedCols[dndState.src];\n        if (dndState.src > dndState.dest) {\n            writable.splice(dndState.src, 1);\n            writable.splice(dndState.dest, 0, temp);\n        } else {\n            writable.splice(dndState.dest + 1, 0, temp);\n            writable.splice(dndState.src, 1);\n        }\n        writable = writable.map((c, i) => ({\n            ...c,\n            sticky: columns[i].sticky,\n        }));\n        mappedCols = writable;\n    }\n    return mappedCols;\n}\n\nexport function getStickyWidth(\n    columns: readonly MappedGridColumn[],\n    dndState?: {\n        src: number;\n        dest: number;\n    }\n): number {\n    let result = 0;\n    const remapped = remapForDnDState(columns, dndState);\n    for (let i = 0; i < remapped.length; i++) {\n        const c = remapped[i];\n        if (c.sticky) result += c.width;\n        else break;\n    }\n\n    return result;\n}\n\nexport function getEffectiveColumns(\n    columns: readonly MappedGridColumn[],\n    cellXOffset: number,\n    width: number,\n    dndState?: {\n        src: number;\n        dest: number;\n    },\n    tx?: number\n): readonly MappedGridColumn[] {\n    const mappedCols = remapForDnDState(columns, dndState);\n\n    const sticky: MappedGridColumn[] = [];\n    for (const c of mappedCols) {\n        if (c.sticky) {\n            sticky.push(c);\n        } else {\n            break;\n        }\n    }\n    if (sticky.length > 0) {\n        for (const c of sticky) {\n            width -= c.width;\n        }\n    }\n    let endIndex = cellXOffset;\n    let curX = tx ?? 0;\n\n    while (curX <= width && endIndex < mappedCols.length) {\n        curX += mappedCols[endIndex].width;\n        endIndex++;\n    }\n\n    for (let i = cellXOffset; i < endIndex; i++) {\n        const c = mappedCols[i];\n        if (!c.sticky) {\n            sticky.push(c);\n        }\n    }\n\n    return sticky;\n}\n\nexport function getColumnIndexForX(\n    targetX: number,\n    effectiveColumns: readonly MappedGridColumn[],\n    translateX?: number\n): number {\n    let x = 0;\n    for (const c of effectiveColumns) {\n        const cx = c.sticky ? x : x + (translateX ?? 0);\n        if (targetX <= cx + c.width) {\n            return c.sourceIndex;\n        }\n        x += c.width;\n    }\n    return -1;\n}\n\nexport function getRowIndexForY(\n    targetY: number,\n    height: number,\n    hasGroups: boolean,\n    headerHeight: number,\n    groupHeaderHeight: number,\n    rows: number,\n    rowHeight: number | ((index: number) => number),\n    cellYOffset: number,\n    translateY: number,\n    lastRowSticky: boolean\n): number | undefined {\n    const totalHeaderHeight = headerHeight + groupHeaderHeight;\n    if (hasGroups && targetY <= groupHeaderHeight) return -2;\n    if (targetY <= totalHeaderHeight) return -1;\n\n    const lastRowHeight = typeof rowHeight === \"number\" ? rowHeight : rowHeight(rows - 1);\n    if (lastRowSticky && targetY > height - lastRowHeight) {\n        return rows - 1;\n    }\n\n    const effectiveRows = rows - (lastRowSticky ? 1 : 0);\n\n    const ty = targetY - (translateY ?? 0);\n    if (typeof rowHeight === \"number\") {\n        const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;\n        if (target >= effectiveRows) return undefined;\n        return target;\n    } else {\n        let curY = totalHeaderHeight;\n        for (let i = cellYOffset; i < effectiveRows; i++) {\n            const rh = rowHeight(i);\n            if (ty <= curY + rh) return i;\n            curY += rh;\n        }\n        return undefined;\n    }\n}\n\nlet metricsSize = 0;\nlet metricsCache: Record<string, TextMetrics | undefined> = {};\nconst isSSR = typeof window === \"undefined\";\n\nasync function clearCacheOnLoad() {\n    if (isSSR || document?.fonts?.ready === undefined) return;\n    await document.fonts.ready;\n    metricsSize = 0;\n    metricsCache = {};\n    clearCache();\n}\n\nvoid clearCacheOnLoad();\n\nfunction makeCacheKey(s: string, ctx: CanvasRenderingContext2D, baseline: \"alphabetic\" | \"middle\", font?: string) {\n    return `${s}_${font ?? ctx.font}_${baseline}`;\n}\n\n/** @category Drawing */\nexport function measureTextCached(s: string, ctx: CanvasRenderingContext2D, font?: string): TextMetrics {\n    const key = makeCacheKey(s, ctx, \"middle\", font);\n    let metrics = metricsCache[key];\n    if (metrics === undefined) {\n        metrics = ctx.measureText(s);\n        metricsCache[key] = metrics;\n        metricsSize++;\n    }\n\n    if (metricsSize > 10_000) {\n        metricsCache = {};\n        metricsSize = 0;\n    }\n\n    return metrics;\n}\n\n/** @category Drawing */\nexport function getMiddleCenterBias(ctx: CanvasRenderingContext2D, font: string | Theme): number {\n    if (typeof font !== \"string\") {\n        font = `${font.baseFontStyle} ${font.fontFamily}`;\n    }\n    return getMiddleCenterBiasInner(ctx, font);\n}\n\nfunction loadMetric(ctx: CanvasRenderingContext2D, baseline: \"alphabetic\" | \"middle\") {\n    const sample = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    ctx.save();\n    ctx.textBaseline = baseline;\n    const result = ctx.measureText(sample);\n\n    ctx.restore();\n\n    return result;\n}\n\nconst biasCache: { key: string; val: number }[] = [];\n\nfunction getMiddleCenterBiasInner(ctx: CanvasRenderingContext2D, font: string): number {\n    for (const x of biasCache) {\n        if (x.key === font) return x.val;\n    }\n\n    const alphabeticMetrics = loadMetric(ctx, \"alphabetic\");\n    const middleMetrics = loadMetric(ctx, \"middle\");\n\n    const bias =\n        -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) +\n        alphabeticMetrics.actualBoundingBoxAscent / 2;\n\n    biasCache.push({\n        key: font,\n        val: bias,\n    });\n\n    return bias;\n}\n\n/** @category Drawing */\nexport function drawWithLastUpdate(\n    args: BaseDrawArgs,\n    lastUpdate: number | undefined,\n    frameTime: number,\n    lastPrep: PrepResult | undefined,\n    draw: () => void\n) {\n    const { ctx, rect, theme } = args;\n    let progress = Number.MAX_SAFE_INTEGER;\n    const animTime = 500;\n    if (lastUpdate !== undefined) {\n        progress = frameTime - lastUpdate;\n\n        if (progress < animTime) {\n            const fade = 1 - progress / animTime;\n            ctx.globalAlpha = fade;\n            ctx.fillStyle = theme.bgSearchResult;\n            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);\n            ctx.globalAlpha = 1;\n            if (lastPrep !== undefined) {\n                lastPrep.fillStyle = theme.bgSearchResult;\n            }\n        }\n    }\n\n    draw();\n\n    return progress < animTime;\n}\n\nexport function prepTextCell(\n    args: BaseDrawArgs,\n    lastPrep: PrepResult | undefined,\n    overrideColor?: string\n): Partial<PrepResult> {\n    const { ctx, theme } = args;\n    const result: Partial<PrepResult> = lastPrep ?? {};\n\n    const newFill = overrideColor ?? theme.textDark;\n    if (newFill !== result.fillStyle) {\n        ctx.fillStyle = newFill;\n        result.fillStyle = newFill;\n    }\n    return result;\n}\n\n/** @category Drawing */\nexport function drawTextCellExternal(args: BaseDrawArgs, data: string, contentAlign?: BaseGridCell[\"contentAlign\"]) {\n    const { rect, ctx, theme } = args;\n\n    ctx.fillStyle = theme.textDark;\n    drawTextCell(\n        {\n            ctx: ctx,\n            rect,\n            theme: theme,\n        },\n        data,\n        contentAlign\n    );\n}\n\nfunction drawSingleTextLine(\n    ctx: CanvasRenderingContext2D,\n    data: string,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    bias: number,\n    theme: Theme,\n    contentAlign?: BaseGridCell[\"contentAlign\"]\n) {\n    if (contentAlign === \"right\") {\n        ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);\n    } else if (contentAlign === \"center\") {\n        ctx.fillText(data, x + w / 2, y + h / 2 + bias);\n    } else {\n        ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);\n    }\n}\n\n/** @category Drawing */\nexport function drawTextCell(\n    args: Pick<BaseDrawArgs, \"rect\" | \"ctx\" | \"theme\">,\n    data: string,\n    contentAlign?: BaseGridCell[\"contentAlign\"],\n    allowWrapping?: boolean,\n    hyperWrapping?: boolean\n) {\n    const { ctx, rect, theme } = args;\n\n    const { x, y, width: w, height: h } = rect;\n\n    allowWrapping = allowWrapping ?? false;\n\n    if (!allowWrapping) {\n        if (data.includes(\"\\n\")) {\n            // new lines are rare and split is relatively expensive compared to the search\n            // it pays off to not do the split contantly.\n            data = data.split(/\\r?\\n/)[0];\n        }\n        const max = w / 4; // no need to round, slice will just truncate this\n        if (data.length > max) {\n            data = data.slice(0, max);\n        }\n    }\n\n    const bias = getMiddleCenterBias(ctx, theme);\n\n    const isRtl = direction(data) === \"rtl\";\n\n    if (contentAlign === undefined && isRtl) {\n        contentAlign = \"right\";\n    }\n\n    if (isRtl) {\n        ctx.direction = \"rtl\";\n    }\n\n    if (data.length > 0) {\n        let changed = false;\n        if (contentAlign === \"right\") {\n            // Use right alignment as default for RTL text\n            ctx.textAlign = \"right\";\n            changed = true;\n        } else if (contentAlign !== undefined && contentAlign !== \"left\") {\n            // Since default is start (=left), only apply if alignment is center or right\n            ctx.textAlign = contentAlign;\n            changed = true;\n        }\n\n        if (!allowWrapping) {\n            drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);\n        } else {\n            const fontStyle = `${theme.fontFamily} ${theme.baseFontStyle}`;\n            const split = splitText(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping ?? false);\n\n            const textMetrics = measureTextCached(\"ABCi09jgqpy\", ctx, fontStyle); // do not question the magic string\n            const emHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;\n            const lineHeight = theme.lineHeight * emHeight;\n\n            const actualHeight = emHeight + lineHeight * (split.length - 1);\n            const mustClip = actualHeight + theme.cellVerticalPadding > h;\n\n            if (mustClip) {\n                // well now we have to clip because we might render outside the cell vertically\n                ctx.save();\n                ctx.rect(x, y, w, h);\n                ctx.clip();\n            }\n\n            const optimalY = y + h / 2 - actualHeight / 2;\n            let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);\n            for (const line of split) {\n                drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);\n                drawY += lineHeight;\n                if (drawY > y + h) break;\n            }\n            if (mustClip) {\n                ctx.restore();\n            }\n        }\n\n        if (changed) {\n            // Reset alignment to default\n            ctx.textAlign = \"start\";\n        }\n\n        if (isRtl) {\n            ctx.direction = \"inherit\";\n        }\n    }\n}\n\nexport function drawNewRowCell(args: BaseDrawArgs, data: string, icon?: string) {\n    const { ctx, rect, hoverAmount, theme, spriteManager } = args;\n    const { x, y, width: w, height: h } = rect;\n    ctx.beginPath();\n    ctx.globalAlpha = hoverAmount;\n    ctx.rect(x, y, w, h);\n    ctx.fillStyle = theme.bgHeaderHovered;\n    ctx.fill();\n    ctx.globalAlpha = 1;\n    ctx.beginPath();\n\n    const alwaysShowIcon = data !== \"\";\n\n    let textX = 0;\n\n    if (icon !== undefined) {\n        const padding = 8;\n        const size = h - padding;\n        const px = x + padding / 2;\n        const py = y + padding / 2;\n\n        spriteManager.drawSprite(icon, \"normal\", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);\n        textX = size;\n    } else {\n        textX = 24;\n        const finalLineSize = 12;\n        const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;\n        const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;\n\n        const padPlus = theme.cellHorizontalPadding + 4;\n        if (lineSize > 0) {\n            ctx.moveTo(x + padPlus + xTranslate, y + h / 2);\n            ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);\n            ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);\n            ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);\n            ctx.lineWidth = 2;\n            ctx.strokeStyle = theme.bgIconHeader;\n            ctx.lineCap = \"round\";\n            ctx.stroke();\n        }\n    }\n\n    ctx.fillStyle = theme.textMedium;\n    ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + getMiddleCenterBias(ctx, theme));\n    ctx.beginPath();\n}\n\nexport function drawCheckbox(\n    ctx: CanvasRenderingContext2D,\n    theme: Theme,\n    checked: boolean | BooleanEmpty | BooleanIndeterminate,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    highlighted: boolean,\n    hoverX: number = -20,\n    hoverY: number = -20\n) {\n    const centerX = x + width / 2;\n    const centerY = y + height / 2;\n\n    const hovered = Math.abs(hoverX - width / 2) < 10 && Math.abs(hoverY - height / 2) < 10;\n\n    switch (checked) {\n        case true: {\n            ctx.beginPath();\n            roundedRect(ctx, centerX - 9, centerY - 9, 18, 18, 4);\n\n            ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;\n            ctx.fill();\n\n            ctx.beginPath();\n            ctx.moveTo(centerX - 8 + 3.650_05, centerY - 8 + 7.849_95);\n            ctx.lineTo(centerX - 8 + 6.375_87, centerY - 8 + 10.7304);\n            ctx.lineTo(centerX - 8 + 11.9999, centerY - 8 + 4.749_95);\n\n            ctx.strokeStyle = theme.bgCell;\n            ctx.lineJoin = \"round\";\n            ctx.lineCap = \"round\";\n            ctx.lineWidth = 1.9;\n            ctx.stroke();\n            break;\n        }\n\n        case BooleanEmpty:\n        case false: {\n            ctx.beginPath();\n            roundedRect(ctx, centerX - 8.5, centerY - 8.5, 17, 17, 4);\n\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;\n            ctx.stroke();\n            break;\n        }\n\n        case BooleanIndeterminate: {\n            ctx.beginPath();\n            roundedRect(ctx, centerX - 8.5, centerY - 8.5, 17, 17, 4);\n\n            ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;\n            ctx.fill();\n\n            ctx.beginPath();\n            ctx.moveTo(centerX - 4, centerY);\n            ctx.lineTo(centerX + 4, centerY);\n            ctx.strokeStyle = theme.bgCell;\n            ctx.lineCap = \"round\";\n            ctx.lineWidth = 1.9;\n            ctx.stroke();\n            break;\n        }\n\n        default:\n            assertNever(checked);\n    }\n}\n\nexport function prepMarkerRowCell(args: BaseDrawArgs, lastPrep: PrepResult | undefined): Partial<PrepResult> {\n    const { ctx, theme } = args;\n    const newFont = `9px ${theme.fontFamily}`;\n    const result: Partial<PrepResult> = lastPrep ?? {};\n    if (result?.font !== newFont) {\n        ctx.font = newFont;\n        result.font = newFont;\n    }\n    result.deprep = deprepMarkerRowCell;\n    ctx.textAlign = \"center\";\n    return result;\n}\n\nexport function deprepMarkerRowCell(args: Pick<BaseDrawArgs, \"ctx\">) {\n    const { ctx } = args;\n    ctx.textAlign = \"start\";\n}\n\nexport function drawMarkerRowCell(\n    args: BaseDrawArgs,\n    index: number,\n    checked: boolean,\n    markerKind: \"checkbox\" | \"both\" | \"number\",\n    drawHandle: boolean\n) {\n    const { ctx, rect, hoverAmount, theme } = args;\n    const { x, y, width, height } = rect;\n    const checkedboxAlpha = checked ? 1 : hoverAmount;\n    if (markerKind !== \"number\" && checkedboxAlpha > 0) {\n        ctx.globalAlpha = checkedboxAlpha;\n        const offsetAmount = 7 * (checked ? hoverAmount : 1);\n        drawCheckbox(\n            ctx,\n            theme,\n            checked,\n            drawHandle ? x + offsetAmount : x,\n            y,\n            drawHandle ? width - offsetAmount : width,\n            height,\n            true\n        );\n        if (drawHandle) {\n            ctx.globalAlpha = hoverAmount;\n            ctx.beginPath();\n            for (const xOffset of [3, 6]) {\n                for (const yOffset of [-5, -1, 3]) {\n                    ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);\n                }\n            }\n\n            ctx.fillStyle = theme.textLight;\n            ctx.fill();\n            ctx.beginPath();\n        }\n        ctx.globalAlpha = 1;\n    }\n    if (markerKind === \"number\" || (markerKind === \"both\" && !checked)) {\n        const text = index.toString();\n\n        const start = x + width / 2;\n        if (markerKind === \"both\" && hoverAmount !== 0) {\n            ctx.globalAlpha = 1 - hoverAmount;\n        }\n        ctx.fillStyle = theme.textLight;\n        ctx.fillText(text, start, y + height / 2 + getMiddleCenterBias(ctx, `9px ${theme.fontFamily}`));\n        if (hoverAmount !== 0) {\n            ctx.globalAlpha = 1;\n        }\n    }\n}\n\nexport function drawProtectedCell(args: BaseDrawArgs) {\n    const { ctx, theme, rect } = args;\n    const { x, y, height: h } = rect;\n\n    ctx.beginPath();\n\n    const radius = 2.5;\n    let xStart = x + theme.cellHorizontalPadding + radius;\n    const center = y + h / 2;\n    const p = Math.cos(degreesToRadians(30)) * radius;\n    const q = Math.sin(degreesToRadians(30)) * radius;\n\n    for (let i = 0; i < 12; i++) {\n        ctx.moveTo(xStart, center - radius);\n        ctx.lineTo(xStart, center + radius);\n\n        ctx.moveTo(xStart + p, center - q);\n        ctx.lineTo(xStart - p, center + q);\n\n        ctx.moveTo(xStart - p, center - q);\n        ctx.lineTo(xStart + p, center + q);\n        xStart += 8;\n    }\n    ctx.lineWidth = 1.1;\n    ctx.lineCap = \"square\";\n    ctx.strokeStyle = theme.textLight;\n    ctx.stroke();\n}\n\ninterface CornerRadius {\n    tl: number;\n    tr: number;\n    bl: number;\n    br: number;\n}\n\nfunction roundedRect(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number | CornerRadius\n) {\n    if (typeof radius === \"number\") {\n        radius = { tl: radius, tr: radius, br: radius, bl: radius };\n    }\n\n    // restrict radius to a reasonable max\n    radius = {\n        tl: Math.min(radius.tl, height / 2, width / 2),\n        tr: Math.min(radius.tr, height / 2, width / 2),\n        bl: Math.min(radius.bl, height / 2, width / 2),\n        br: Math.min(radius.br, height / 2, width / 2),\n    };\n\n    ctx.moveTo(x + radius.tl, y);\n    ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);\n    ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);\n    ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);\n    ctx.arcTo(x, y, x + radius.tl, y, radius.tl);\n}\n\nexport function drawBoolean(args: BaseDrawArgs, data: boolean | BooleanEmpty | BooleanIndeterminate, canEdit: boolean) {\n    if (!canEdit && data === BooleanEmpty) {\n        return;\n    }\n\n    const { ctx, hoverAmount, theme, rect, highlighted, hoverX, hoverY } = args;\n    const { x, y, width: w, height: h } = rect;\n\n    const hoverEffect = 0.35;\n\n    let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;\n    if (data === BooleanEmpty) {\n        alpha *= hoverAmount;\n    }\n    if (alpha === 0) {\n        return;\n    }\n    ctx.globalAlpha = alpha;\n\n    drawCheckbox(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY);\n\n    ctx.globalAlpha = 1;\n}\n\nconst itemMargin = 4;\n\nexport function drawBubbles(args: BaseDrawArgs, data: readonly string[]) {\n    const { rect, theme, ctx, highlighted } = args;\n    const { x, y, width: w, height: h } = rect;\n    const bubbleHeight = 20;\n    const bubblePad = 8;\n    const bubbleMargin = itemMargin;\n    let renderX = x + theme.cellHorizontalPadding;\n\n    const renderBoxes: { x: number; width: number }[] = [];\n    for (const s of data) {\n        if (renderX > x + w) break;\n        const textWidth = measureTextCached(s, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;\n        renderBoxes.push({\n            x: renderX,\n            width: textWidth,\n        });\n\n        renderX += textWidth + bubblePad * 2 + bubbleMargin;\n    }\n\n    ctx.beginPath();\n    for (const rectInfo of renderBoxes) {\n        roundedRect(\n            ctx,\n            rectInfo.x,\n            y + (h - bubbleHeight) / 2,\n            rectInfo.width + bubblePad * 2,\n            bubbleHeight,\n            bubbleHeight / 2\n        );\n    }\n    ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;\n    ctx.fill();\n\n    for (const [i, rectInfo] of renderBoxes.entries()) {\n        ctx.beginPath();\n        ctx.fillStyle = theme.textBubble;\n        ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + getMiddleCenterBias(ctx, theme));\n    }\n}\n\nconst drilldownCache: {\n    [key: string]: HTMLCanvasElement;\n} = {};\n\nfunction getAndCacheDrilldownBorder(\n    bgCell: string,\n    border: string\n): {\n    el: HTMLCanvasElement;\n    height: number;\n    width: number;\n    middleWidth: number;\n    sideWidth: number;\n} | null {\n    const dpr = Math.ceil(window.devicePixelRatio);\n    const targetHeight = 24;\n    const shadowBlur = 5;\n    const middleWidth = 4;\n\n    const innerHeight = (targetHeight + shadowBlur * 2) * dpr; // 68\n    const innerWidth = innerHeight + middleWidth * dpr; // 76\n    const sideWidth = innerHeight / 2;\n\n    const key = `${bgCell},${border},${dpr}`;\n    if (drilldownCache[key] !== undefined) {\n        return {\n            el: drilldownCache[key],\n            height: innerHeight,\n            width: innerWidth,\n            middleWidth: middleWidth * dpr,\n            sideWidth,\n        };\n    }\n\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\"); // alpha needed\n\n    if (ctx === null) return null;\n\n    canvas.width = innerWidth;\n    canvas.height = innerHeight;\n\n    ctx.scale(dpr, dpr);\n\n    drilldownCache[key] = canvas;\n\n    ctx.beginPath();\n    roundedRect(ctx, shadowBlur, shadowBlur, targetHeight + middleWidth, targetHeight, 6);\n\n    ctx.shadowColor = \"rgba(24, 25, 34, 0.4)\";\n    ctx.shadowBlur = 1;\n    ctx.fillStyle = bgCell;\n    ctx.fill();\n\n    ctx.shadowColor = \"rgba(24, 25, 34, 0.3)\";\n    ctx.shadowOffsetY = 1;\n    ctx.shadowBlur = 5;\n    ctx.fillStyle = bgCell;\n    ctx.fill();\n\n    ctx.shadowOffsetY = 0;\n    ctx.shadowBlur = 0;\n    ctx.shadowBlur = 0;\n\n    ctx.beginPath();\n    roundedRect(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetHeight + middleWidth, targetHeight, 6);\n\n    ctx.strokeStyle = border;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n\n    return { el: canvas, height: innerHeight, width: innerWidth, sideWidth, middleWidth: middleWidth * dpr };\n}\n\nexport function drawDrilldownCell(args: BaseDrawArgs, data: readonly DrilldownCellData[]) {\n    const { rect, theme, ctx, imageLoader, col, row } = args;\n    const { x, y, width: w, height: h } = rect;\n    const bubbleHeight = 24;\n    const bubblePad = 8;\n    const bubbleMargin = itemMargin;\n    let renderX = x + theme.cellHorizontalPadding;\n\n    const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder);\n\n    const renderBoxes: { x: number; width: number }[] = [];\n    for (const el of data) {\n        if (renderX > x + w) break;\n        const textWidth = measureTextCached(el.text, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;\n        let imgWidth = 0;\n        if (el.img !== undefined) {\n            const img = imageLoader.loadOrGetImage(el.img, col, row);\n            if (img !== undefined) {\n                imgWidth = bubbleHeight - 8 + 4;\n            }\n        }\n        const renderWidth = textWidth + imgWidth + bubblePad * 2;\n        renderBoxes.push({\n            x: renderX,\n            width: renderWidth,\n        });\n\n        renderX += renderWidth + bubbleMargin;\n    }\n\n    if (tileMap !== null) {\n        const { el, height, middleWidth, sideWidth, width } = tileMap;\n        for (const rectInfo of renderBoxes) {\n            const rx = Math.floor(rectInfo.x);\n            const rw = Math.floor(rectInfo.width);\n            ctx.imageSmoothingEnabled = false;\n            const maxSideWidth = Math.min(17, rw / 2 + 5);\n            ctx.drawImage(el, 0, 0, sideWidth, height, rx - 5, y + h / 2 - 17, maxSideWidth, 34);\n            if (rectInfo.width > 24)\n                ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + 12, y + h / 2 - 17, rw - 24, 34);\n            ctx.drawImage(\n                el,\n                width - sideWidth,\n                0,\n                sideWidth,\n                height,\n                rx + rw - (maxSideWidth - 5),\n                y + h / 2 - 17,\n                maxSideWidth,\n                34\n            );\n            ctx.imageSmoothingEnabled = true;\n        }\n    }\n\n    ctx.beginPath();\n\n    for (const [i, rectInfo] of renderBoxes.entries()) {\n        const d = data[i];\n        let drawX = rectInfo.x + bubblePad;\n\n        if (d.img !== undefined) {\n            const img = imageLoader.loadOrGetImage(d.img, col, row);\n            if (img !== undefined) {\n                const imgSize = bubbleHeight - 8;\n                let srcX = 0;\n                let srcY = 0;\n                let srcWidth = img.width;\n                let srcHeight = img.height;\n\n                if (srcWidth > srcHeight) {\n                    // landscape\n                    srcX += (srcWidth - srcHeight) / 2;\n                    srcWidth = srcHeight;\n                } else if (srcHeight > srcWidth) {\n                    //portrait\n                    srcY += (srcHeight - srcWidth) / 2;\n                    srcHeight = srcWidth;\n                }\n                ctx.beginPath();\n                roundedRect(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, 3);\n                ctx.save();\n                ctx.clip();\n                ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);\n                ctx.restore();\n\n                drawX += imgSize + 4;\n            }\n        }\n\n        ctx.beginPath();\n        ctx.fillStyle = theme.textBubble;\n        ctx.fillText(d.text, drawX, y + h / 2 + getMiddleCenterBias(ctx, theme));\n    }\n}\n\nexport function drawImage(args: BaseDrawArgs, data: readonly string[], rounding: number = 4) {\n    const { rect, col, row, theme, ctx, imageLoader } = args;\n    const { x, y, height: h } = rect;\n    let drawX = x + theme.cellHorizontalPadding;\n    for (const i of data) {\n        if (i.length === 0) continue;\n        const img = imageLoader.loadOrGetImage(i, col, row);\n\n        if (img !== undefined) {\n            const imgHeight = h - theme.cellVerticalPadding * 2;\n            const imgWidth = img.width * (imgHeight / img.height);\n            if (rounding > 0) {\n                roundedRect(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);\n                ctx.save();\n                ctx.clip();\n            }\n            ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);\n            if (rounding > 0) {\n                ctx.restore();\n            }\n\n            drawX += imgWidth + itemMargin;\n        }\n    }\n}\n\ninterface Point {\n    x: number;\n    y: number;\n    radius?: number;\n}\n\ninterface Vector {\n    nx: number;\n    ny: number;\n    len: number;\n    x: number;\n    y: number;\n    ang: number;\n}\n\nexport function roundedPoly(ctx: CanvasRenderingContext2D, points: Point[], radiusAll: number) {\n    // convert 2 points into vector form, polar form, and normalised\n    const asVec = function (p: Point, pp: Point): Vector {\n        const vx = pp.x - p.x;\n        const vy = pp.y - p.y;\n        const vlen = Math.sqrt(vx * vx + vy * vy);\n        const vnx = vx / vlen;\n        const vny = vy / vlen;\n        return {\n            x: vx,\n            y: pp.y - p.y,\n            len: vlen,\n            nx: vnx,\n            ny: vny,\n            ang: Math.atan2(vny, vnx),\n        };\n    };\n    let radius: number;\n    // const v1: Vector = {} as any;\n    // const v2: Vector = {} as any;\n    const len = points.length;\n    let p1 = points[len - 1];\n    // for each point\n    for (let i = 0; i < len; i++) {\n        let p2 = points[i % len];\n        const p3 = points[(i + 1) % len];\n        //-----------------------------------------\n        // Part 1\n        const v1 = asVec(p2, p1);\n        const v2 = asVec(p2, p3);\n        const sinA = v1.nx * v2.ny - v1.ny * v2.nx;\n        const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;\n        let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);\n        //-----------------------------------------\n        let radDirection = 1;\n        let drawDirection = false;\n        if (sinA90 < 0) {\n            if (angle < 0) {\n                angle = Math.PI + angle;\n            } else {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        } else {\n            if (angle > 0) {\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        radius = p2.radius !== undefined ? p2.radius : radiusAll;\n        //-----------------------------------------\n        // Part 2\n        const halfAngle = angle / 2;\n        //-----------------------------------------\n\n        //-----------------------------------------\n        // Part 3\n        let lenOut = Math.abs((Math.cos(halfAngle) * radius) / Math.sin(halfAngle));\n        //-----------------------------------------\n\n        //-----------------------------------------\n        // Special part A\n        let cRadius: number;\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        } else {\n            cRadius = radius;\n        }\n        //-----------------------------------------\n        // Part 4\n        let x = p2.x + v2.nx * lenOut;\n        let y = p2.y + v2.ny * lenOut;\n        //-----------------------------------------\n        // Part 5\n        x += -v2.ny * cRadius * radDirection;\n        y += v2.nx * cRadius * radDirection;\n        //-----------------------------------------\n        // Part 6\n        ctx.arc(\n            x,\n            y,\n            cRadius,\n            v1.ang + (Math.PI / 2) * radDirection,\n            v2.ang - (Math.PI / 2) * radDirection,\n            drawDirection\n        );\n        //-----------------------------------------\n        p1 = p2;\n        p2 = p3;\n    }\n    ctx.closePath();\n}\n\nexport function computeBounds(\n    col: number,\n    row: number,\n    width: number,\n    height: number,\n    groupHeaderHeight: number,\n    totalHeaderHeight: number,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    rows: number,\n    freezeColumns: number,\n    lastRowSticky: boolean,\n    mappedColumns: readonly MappedGridColumn[],\n    rowHeight: number | ((index: number) => number)\n): Rectangle {\n    const result: Rectangle = {\n        x: 0,\n        y: totalHeaderHeight + translateY,\n        width: 0,\n        height: 0,\n    };\n\n    const headerHeight = totalHeaderHeight - groupHeaderHeight;\n\n    if (col >= freezeColumns) {\n        const dir = cellXOffset > col ? -1 : 1;\n        const freezeWidth = getStickyWidth(mappedColumns);\n        result.x += freezeWidth + translateX;\n        for (let i = cellXOffset; i !== col; i += dir) {\n            result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;\n        }\n    } else {\n        for (let i = 0; i < col; i++) {\n            result.x += mappedColumns[i].width;\n        }\n    }\n    result.width = mappedColumns[col].width + 1;\n\n    if (row === -1) {\n        result.y = groupHeaderHeight;\n        result.height = headerHeight;\n    } else if (row === -2) {\n        result.y = 0;\n        result.height = groupHeaderHeight;\n\n        let start = col;\n        const group = mappedColumns[col].group;\n        const sticky = mappedColumns[col].sticky;\n        while (\n            start > 0 &&\n            isGroupEqual(mappedColumns[start - 1].group, group) &&\n            mappedColumns[start - 1].sticky === sticky\n        ) {\n            const c = mappedColumns[start - 1];\n            result.x -= c.width;\n            result.width += c.width;\n            start--;\n        }\n\n        let end = col;\n        while (\n            end + 1 < mappedColumns.length &&\n            isGroupEqual(mappedColumns[end + 1].group, group) &&\n            mappedColumns[end + 1].sticky === sticky\n        ) {\n            const c = mappedColumns[end + 1];\n            result.width += c.width;\n            end++;\n        }\n        if (!sticky) {\n            const freezeWidth = getStickyWidth(mappedColumns);\n            const clip = result.x - freezeWidth;\n            if (clip < 0) {\n                result.x -= clip;\n                result.width += clip;\n            }\n\n            if (result.x + result.width > width) {\n                result.width = width - result.x;\n            }\n        }\n    } else if (lastRowSticky && row === rows - 1) {\n        const stickyHeight = typeof rowHeight === \"number\" ? rowHeight : rowHeight(row);\n        result.y = height - stickyHeight;\n        result.height = stickyHeight;\n    } else {\n        const dir = cellYOffset > row ? -1 : 1;\n        if (typeof rowHeight === \"number\") {\n            const delta = row - cellYOffset;\n            result.y += delta * rowHeight;\n        } else {\n            for (let r = cellYOffset; r !== row; r += dir) {\n                result.y += rowHeight(r) * dir;\n            }\n        }\n        result.height = (typeof rowHeight === \"number\" ? rowHeight : rowHeight(row)) + 1;\n    }\n\n    return result;\n}\n","import type { SpriteProps } from \"../common/utils\";\n\nconst iconHead = `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">`;\nconst headerRowID = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n\n    return `\n    ${iconHead}<rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/><path d=\"M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z\" fill=\"${fg}\"/></svg>`;\n};\n\nconst headerCode = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}<rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"4\" fill=\"${bg}\"/><path d=\"m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z\" fill=\"${fg}\"/></svg>`;\n};\n\nconst headerNumber = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerString = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerBoolean = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path\n        d=\"M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z\"\n        fill=\"${bg}\"\n    />\n    <path\n        fill-rule=\"evenodd\"\n        clip-rule=\"evenodd\"\n        d=\"M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z\"\n        fill=\"${fg}\"\n    />\n</svg>`;\n};\n\nconst headerUri = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n<path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z\" fill=\"${fg}\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z\" fill=\"${fg}\"/>\n</svg>\n  `;\n};\n\nconst renameIcon = (props: SpriteProps) => {\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path stroke=\"${bg}\" stroke-width=\"2\" d=\"M12 3v14\"/>\n    <path stroke=\"${bg}\" stroke-width=\"2\" stroke-linecap=\"round\" d=\"M10 4h4m-4 12h4\"/>\n    <path d=\"M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z\" fill=\"${bg}\"/>\n  </svg>\n`;\n};\n\nconst headerAudioUri = headerUri;\n\nconst headerVideoUri = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerEmoji = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z\" fill=\"${fg}\"/>\n    <path d=\"M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z\" fill=\"${fg}\"/>\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z\" fill=\"${fg}\"/>\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z\" fill=\"${fg}\"/>\n    <path d=\"M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z\" fill=\"${fg}\"/>\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerImage = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path opacity=\".5\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerPhone = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path fill=\"${fg}\" d=\"M3 3h14v14H3z\"/>\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z\" fill=\"${bg}\"/>\n  </svg>`;\n};\n\nconst headerMarkdown = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerDate = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerTime = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z\" fill=\"${fg}\"/>\n    <path d=\"M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerEmail = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerReference = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"8\" width=\"10\" height=\"8\" rx=\"2\" fill=\"${bg}\"/>\n    <rect x=\"8\" y=\"4\" width=\"10\" height=\"8\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerIfThenElse = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path fill=\"${fg}\" d=\"M4 3h12v14H4z\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z\" fill=\"${bg}\"/>\n</svg>`;\n};\n\nconst headerSingleValue = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerLookup = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerTextTemplate = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path d=\"M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerMath = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z\" fill=\"${fg}\"/>\n  <path d=\"M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerRollup = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerJoinStrings = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path d=\"M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerSplitString = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z\" fill=\"${fg}\"/>\n  </svg>`;\n};\n\nconst headerGeoDistance = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst headerArray = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z\" fill=\"${fg}\"/>\n</svg>`;\n};\n\nconst rowOwnerOverlay = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    <svg width=\"18\" height=\"18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z\" fill=\"${bg}\" stroke=\"${fg}\" stroke-width=\"2\"/>\n  </svg>`;\n};\n\nconst protectedColumnOverlay = (props: SpriteProps) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    <svg width=\"18\" height=\"18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z\" fill=\"${bg}\" stroke=\"${fg}\" stroke-width=\"2\"/>\n  </svg>\n`;\n};\n\nexport const sprites = {\n    headerRowID,\n    headerNumber,\n    headerCode,\n    headerString,\n    headerBoolean,\n    headerAudioUri,\n    headerVideoUri,\n    headerEmoji,\n    headerImage,\n    headerUri,\n    headerPhone,\n    headerMarkdown,\n    headerDate,\n    headerTime,\n    headerEmail,\n    headerReference,\n    headerIfThenElse,\n    headerSingleValue,\n    headerLookup,\n    headerTextTemplate,\n    headerMath,\n    headerRollup,\n    headerJoinStrings,\n    headerSplitString,\n    headerGeoDistance,\n    headerArray,\n    rowOwnerOverlay,\n    protectedColumnOverlay,\n    renameIcon,\n};\n\nexport type HeaderIconMap = Readonly<typeof sprites>;\n","import type { Theme } from \"../common/styles\";\nimport { HeaderIconMap, sprites } from \"./sprites\";\n\ntype HeaderIcon = keyof HeaderIconMap;\ntype Sprite = HeaderIconMap[\"headerArray\"];\n\n/** @category Columns */\nexport type SpriteMap = Record<string | HeaderIcon, Sprite>;\n\n/** @category Columns */\nexport type SpriteVariant = \"normal\" | \"selected\" | \"special\";\n\nfunction getColors(variant: SpriteVariant, theme: Theme): readonly [string, string] {\n    if (variant === \"normal\") {\n        return [theme.bgIconHeader, theme.fgIconHeader];\n    } else if (variant === \"selected\") {\n        return [\"white\", theme.accentColor];\n    } else {\n        return [theme.accentColor, theme.bgHeader];\n    }\n}\n\n/** @category Columns */\nexport class SpriteManager {\n    private spriteMap: Map<string, HTMLCanvasElement> = new Map();\n    private headerIcons: SpriteMap;\n    private inFlight = 0;\n\n    constructor(headerIcons: SpriteMap | undefined, private onSettled: () => void) {\n        this.headerIcons = {\n            ...sprites,\n            ...headerIcons,\n        };\n    }\n\n    public drawSprite(\n        sprite: HeaderIcon | string,\n        variant: SpriteVariant,\n        ctx: CanvasRenderingContext2D,\n        x: number,\n        y: number,\n        size: number,\n        theme: Theme,\n        alpha: number = 1\n    ) {\n        const [bgColor, fgColor] = getColors(variant, theme);\n        const rSize = size * Math.ceil(window.devicePixelRatio);\n        const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;\n\n        let spriteCanvas = this.spriteMap.get(key);\n        if (spriteCanvas === undefined) {\n            const spriteCb = this.headerIcons[sprite];\n\n            if (spriteCb === undefined) return;\n\n            spriteCanvas = document.createElement(\"canvas\");\n            const spriteCtx = spriteCanvas.getContext(\"2d\");\n\n            if (spriteCtx === null) return;\n\n            const imgSource = new Image();\n            imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({ fgColor, bgColor }))}`;\n            this.spriteMap.set(key, spriteCanvas);\n            const promise: Promise<void> | undefined = imgSource.decode();\n\n            if (promise === undefined) return;\n\n            this.inFlight++;\n            promise\n                .then(() => {\n                    spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);\n                })\n                .finally(() => {\n                    this.inFlight--;\n                    if (this.inFlight === 0) {\n                        this.onSettled();\n                    }\n                });\n        } else {\n            if (alpha < 1) {\n                ctx.globalAlpha = alpha;\n            }\n            ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);\n            if (alpha < 1) {\n                ctx.globalAlpha = 1;\n            }\n        }\n    }\n}\n","/* eslint-disable unicorn/no-for-loop */\nimport {\n    GridSelection,\n    DrawHeaderCallback,\n    InnerGridCell,\n    Rectangle,\n    CompactSelection,\n    DrawCustomCellCallback,\n    GridColumnIcon,\n    Item,\n    CellList,\n    GridMouseGroupHeaderEventArgs,\n    headerCellCheckboxPrefix,\n    GridCellKind,\n    isInnerOnlyCell,\n    BooleanIndeterminate,\n    headerCellCheckedMarker,\n    headerCellUnheckedMarker,\n    TrailingRowType,\n    ImageWindowLoader,\n    GridCell,\n} from \"./data-grid-types\";\nimport groupBy from \"lodash/groupBy.js\";\nimport type { HoverValues } from \"./animation-manager\";\nimport {\n    getEffectiveColumns,\n    getStickyWidth,\n    MappedGridColumn,\n    roundedPoly,\n    drawWithLastUpdate,\n    isGroupEqual,\n    cellIsSelected,\n    cellIsInRange,\n    computeBounds,\n    getMiddleCenterBias,\n    drawCheckbox,\n} from \"./data-grid-lib\";\nimport type { SpriteManager, SpriteVariant } from \"./data-grid-sprites\";\nimport type { Theme } from \"../common/styles\";\nimport { blend, withAlpha } from \"./color-parser\";\nimport type { DrawArgs, GetCellRendererCallback, PrepResult } from \"./cells/cell-types\";\nimport { assert, deepEqual } from \"../common/support\";\n\n// Future optimization opportunities\n// - Create a cache of a buffer used to render the full view of a partially displayed column so that when\n//   scrolling horizontally you can simply blit the pre-drawn column instead of continually paying the draw\n//   cost as it slides into view.\n// - Blit headers on horizontal scroll\n// - Use webworker to load images, helpful with lots of large images\n// - Sprite map currently wastes a lot of canvas texture space\n// - Retain mode for drawing cells. Instead of drawing cells as we come across them, first build a data\n//   structure which contains all operations to perform, then sort them all by \"prep\" requirement, then do\n//   all like operations at once.\n\ntype HoverInfo = readonly [Item, Item];\n\nexport interface Highlight {\n    readonly color: string;\n    readonly range: Rectangle;\n    readonly style?: \"dashed\" | \"solid\" | \"no-outline\";\n}\n\ninterface GroupDetails {\n    readonly name: string;\n    readonly icon?: string;\n    readonly overrideTheme?: Partial<Theme>;\n    readonly actions?: readonly {\n        readonly title: string;\n        readonly onClick: (e: GridMouseGroupHeaderEventArgs) => void;\n        readonly icon: GridColumnIcon | string;\n    }[];\n}\n\nexport type GroupDetailsCallback = (groupName: string) => GroupDetails;\nexport type GetRowThemeCallback = (row: number) => Partial<Theme> | undefined;\n\nconst loadingCell: InnerGridCell = {\n    kind: GridCellKind.Loading,\n    allowOverlay: false,\n};\n\nexport interface BlitData {\n    readonly cellXOffset: number;\n    readonly cellYOffset: number;\n    readonly translateX: number;\n    readonly translateY: number;\n    readonly mustDrawFocusOnHeader: boolean;\n    readonly lastBuffer: \"a\" | \"b\" | undefined;\n}\n\ninterface DragAndDropState {\n    src: number;\n    dest: number;\n}\n\nexport function drawCell(\n    ctx: CanvasRenderingContext2D,\n    row: number,\n    cell: InnerGridCell,\n    col: number,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    highlighted: boolean,\n    theme: Theme,\n    drawCustomCell: DrawCustomCellCallback | undefined,\n    imageLoader: ImageWindowLoader,\n    spriteManager: SpriteManager,\n    hoverAmount: number,\n    hoverInfo: HoverInfo | undefined,\n    hyperWrapping: boolean,\n    frameTime: number,\n    lastPrep: PrepResult | undefined,\n    enqueue: ((item: Item) => void) | undefined,\n    getCellRenderer: GetCellRendererCallback\n): PrepResult | undefined {\n    let hoverX: number | undefined;\n    let hoverY: number | undefined;\n    if (hoverInfo !== undefined && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {\n        hoverX = hoverInfo[1][0];\n        hoverY = hoverInfo[1][1];\n    }\n    let result: PrepResult | undefined = undefined;\n    const args: DrawArgs<typeof cell> = {\n        ctx,\n        theme,\n        col,\n        row,\n        cell,\n        rect: { x, y, width: w, height: h },\n        highlighted,\n        hoverAmount,\n        hoverX,\n        hoverY,\n        imageLoader,\n        spriteManager,\n        hyperWrapping,\n        requestAnimationFrame: () => {\n            forceAnim = true;\n        },\n    };\n    let forceAnim = false;\n    const needsAnim = drawWithLastUpdate(args, cell.lastUpdated, frameTime, lastPrep, () => {\n        const drawn = isInnerOnlyCell(cell) ? false : drawCustomCell?.(args as DrawArgs<GridCell>) === true;\n        if (!drawn) {\n            const r = getCellRenderer(cell);\n            if (r !== undefined) {\n                if (lastPrep?.renderer !== r) {\n                    lastPrep?.deprep?.(args);\n                    lastPrep = undefined;\n                }\n                const partialPrepResult = r.drawPrep?.(args, lastPrep);\n                r.draw(args, cell);\n                result = {\n                    deprep: partialPrepResult?.deprep,\n                    fillStyle: partialPrepResult?.fillStyle,\n                    font: partialPrepResult?.font,\n                    renderer: r,\n                };\n            }\n        }\n    });\n    if (needsAnim || forceAnim) enqueue?.([col, row]);\n    return result;\n}\n\nfunction blitLastFrame(\n    ctx: CanvasRenderingContext2D,\n    canvas: HTMLCanvasElement,\n    last: BlitData,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    lastRowSticky: boolean,\n    width: number,\n    height: number,\n    rows: number,\n    totalHeaderHeight: number,\n    dpr: number,\n    mappedColumns: readonly MappedGridColumn[],\n    effectiveCols: readonly MappedGridColumn[],\n    getRowHeight: number | ((r: number) => number),\n    doubleBuffer: boolean\n) {\n    const drawRegions: Rectangle[] = [];\n    let blittedYOnly = false;\n\n    ctx.imageSmoothingEnabled = false;\n    const minY = Math.min(last.cellYOffset, cellYOffset);\n    const maxY = Math.max(last.cellYOffset, cellYOffset);\n    let deltaY = 0;\n    if (typeof getRowHeight === \"number\") {\n        deltaY += (maxY - minY) * getRowHeight;\n    } else {\n        for (let i = minY; i < maxY; i++) {\n            deltaY += getRowHeight(i);\n        }\n    }\n    if (cellYOffset > last.cellYOffset) {\n        deltaY = -deltaY;\n    }\n    deltaY += translateY - last.translateY;\n\n    const minX = Math.min(last.cellXOffset, cellXOffset);\n    const maxX = Math.max(last.cellXOffset, cellXOffset);\n    let deltaX = 0;\n    for (let i = minX; i < maxX; i++) {\n        deltaX += mappedColumns[i].width;\n    }\n    if (cellXOffset > last.cellXOffset) {\n        deltaX = -deltaX;\n    }\n    deltaX += translateX - last.translateX;\n\n    let stickyWidth = getStickyWidth(effectiveCols);\n    if (stickyWidth > 0) stickyWidth++;\n\n    if (deltaX !== 0 && deltaY !== 0) {\n        return {\n            regions: [],\n            yOnly: false,\n        };\n    }\n\n    const stickyRowHeight = lastRowSticky\n        ? typeof getRowHeight === \"number\"\n            ? getRowHeight\n            : getRowHeight(rows - 1)\n        : 0;\n\n    const blitWidth = width - stickyWidth - Math.abs(deltaX);\n    const blitHeight = height - totalHeaderHeight - stickyRowHeight - Math.abs(deltaY) - 1;\n\n    if (blitWidth > 150 && blitHeight > 150) {\n        blittedYOnly = deltaX === 0;\n\n        const args = {\n            sx: 0,\n            sy: 0,\n            sw: width * dpr,\n            sh: height * dpr,\n            dx: 0,\n            dy: 0,\n            dw: width * dpr,\n            dh: height * dpr,\n        };\n\n        // blit Y\n        if (deltaY > 0) {\n            // scrolling up\n            args.sy = (totalHeaderHeight + 1) * dpr;\n            args.sh = blitHeight * dpr;\n            args.dy = (deltaY + totalHeaderHeight + 1) * dpr;\n            args.dh = blitHeight * dpr;\n\n            drawRegions.push({\n                x: 0,\n                y: totalHeaderHeight,\n                width: width,\n                height: deltaY + 1,\n            });\n        } else if (deltaY < 0) {\n            // scrolling down\n            args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;\n            args.sh = blitHeight * dpr;\n            args.dy = (totalHeaderHeight + 1) * dpr;\n            args.dh = blitHeight * dpr;\n\n            drawRegions.push({\n                x: 0,\n                y: height + deltaY - stickyRowHeight,\n                width: width,\n                height: -deltaY + stickyRowHeight,\n            });\n        }\n\n        // blit X\n        if (deltaX > 0) {\n            // pixels moving right\n            args.sx = stickyWidth * dpr;\n            args.sw = blitWidth * dpr;\n            args.dx = (deltaX + stickyWidth) * dpr;\n            args.dw = blitWidth * dpr;\n\n            drawRegions.push({\n                x: stickyWidth - 1,\n                y: 0,\n                width: deltaX + 2, // extra width to account for first col not drawing a left side border\n                height: height,\n            });\n        } else if (deltaX < 0) {\n            // pixels moving left\n            args.sx = (stickyWidth - deltaX) * dpr;\n            args.sw = blitWidth * dpr;\n            args.dx = stickyWidth * dpr;\n            args.dw = blitWidth * dpr;\n\n            drawRegions.push({\n                x: width + deltaX,\n                y: 0,\n                width: -deltaX,\n                height: height,\n            });\n        }\n\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        if (deltaX !== 0 && deltaY === 0 && doubleBuffer) {\n            // When double buffering the freeze columns can be offset by a couple pixels vertically between the two\n            // buffers. We don't want to redraw them so we need to make sure to copy them.\n            ctx.drawImage(canvas, 0, 0, stickyWidth * dpr, height * dpr, 0, 0, stickyWidth * dpr, height * dpr);\n        }\n        ctx.drawImage(canvas, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);\n        ctx.scale(dpr, dpr);\n    }\n    ctx.imageSmoothingEnabled = true;\n\n    return {\n        regions: drawRegions,\n        yOnly: blittedYOnly,\n    };\n}\n\nfunction blitResizedCol(\n    // ctx: CanvasRenderingContext2D,\n    // canvas: HTMLCanvasElement,\n    last: BlitData,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    width: number,\n    height: number,\n    totalHeaderHeight: number,\n    // dpr: number,\n    effectiveCols: readonly MappedGridColumn[],\n    resizedIndex: number\n) {\n    const drawRegions: Rectangle[] = [];\n\n    // ctx.imageSmoothingEnabled = false;\n\n    if (\n        cellXOffset !== last.cellXOffset ||\n        cellYOffset !== last.cellYOffset ||\n        translateX !== last.translateX ||\n        translateY !== last.translateY\n    ) {\n        return drawRegions;\n    }\n\n    walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {\n        if (c.sourceIndex === resizedIndex) {\n            const x = Math.max(drawX, clipX) + 1;\n            drawRegions.push({\n                x,\n                y: 0,\n                width: width - x,\n                height,\n            });\n            return true;\n        }\n    });\n    return drawRegions;\n}\n\n// lines are effectively drawn on the top left edge of a cell.\nfunction drawGridLines(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    width: number,\n    height: number,\n    drawRegions: Rectangle[] | undefined,\n    spans: Rectangle[] | undefined,\n    groupHeaderHeight: number,\n    totalHeaderHeight: number,\n    getRowHeight: (row: number) => number,\n    getRowThemeOverride: GetRowThemeCallback | undefined,\n    verticalBorder: (col: number) => boolean,\n    trailingRowType: TrailingRowType,\n    rows: number,\n    theme: Theme,\n    verticalOnly: boolean = false\n) {\n    if (spans !== undefined) {\n        ctx.beginPath();\n        ctx.save();\n        ctx.rect(0, 0, width, height);\n        for (const span of spans) {\n            ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);\n        }\n        ctx.clip(\"evenodd\");\n    }\n    const hColor = theme.horizontalBorderColor ?? theme.borderColor;\n    const vColor = theme.borderColor;\n\n    let minX = 0;\n    let maxX = width;\n    let minY = 0;\n    let maxY = height;\n\n    if (drawRegions !== undefined && drawRegions.length > 0) {\n        minX = Number.MAX_SAFE_INTEGER;\n        minY = Number.MAX_SAFE_INTEGER;\n        maxX = Number.MIN_SAFE_INTEGER;\n        maxY = Number.MIN_SAFE_INTEGER;\n        for (const r of drawRegions) {\n            minX = Math.min(minX, r.x - 1);\n            maxX = Math.max(maxX, r.x + r.width + 1);\n            minY = Math.min(minY, r.y - 1);\n            maxY = Math.max(maxY, r.y + r.height + 1);\n        }\n    }\n\n    const toDraw: { x1: number; y1: number; x2: number; y2: number; color: string }[] = [];\n\n    ctx.beginPath();\n\n    // vertical lines\n    let x = 0.5;\n    for (let index = 0; index < effectiveCols.length; index++) {\n        const c = effectiveCols[index];\n        if (c.width === 0) continue;\n        x += c.width;\n        const tx = c.sticky ? x : x + translateX;\n        if (tx >= minX && tx <= maxX - 1 && verticalBorder(index + 1)) {\n            toDraw.push({\n                x1: tx,\n                y1: Math.max(groupHeaderHeight, minY),\n                x2: tx,\n                y2: Math.min(height, maxY),\n                color: vColor,\n            });\n        }\n    }\n\n    const stickyHeight = getRowHeight(rows - 1);\n    const stickyRowY = height - stickyHeight + 0.5;\n    const lastRowSticky = trailingRowType === \"sticky\";\n    if (lastRowSticky) {\n        toDraw.push({ x1: minX, y1: stickyRowY, x2: maxX, y2: stickyRowY, color: hColor });\n    }\n\n    if (verticalOnly !== true) {\n        // horizontal lines\n        let y = totalHeaderHeight + 0.5;\n        let row = cellYOffset;\n        const target = lastRowSticky ? height - stickyHeight : height;\n        while (y + translateY <= target) {\n            const ty = y + translateY;\n            // This shouldn't be needed it seems like... yet it is. We're not sure why.\n            if (ty >= minY && ty <= maxY - 1 && (!lastRowSticky || row !== rows - 1 || Math.abs(ty - stickyRowY) > 1)) {\n                const rowTheme = getRowThemeOverride?.(row);\n                toDraw.push({\n                    x1: minX,\n                    y1: ty,\n                    x2: maxX,\n                    y2: ty,\n                    color: rowTheme?.horizontalBorderColor ?? rowTheme?.borderColor ?? hColor,\n                });\n            }\n\n            y += getRowHeight(row);\n            row++;\n        }\n    }\n\n    const groups = groupBy(toDraw, line => line.color);\n    for (const g of Object.keys(groups)) {\n        ctx.strokeStyle = g;\n        for (const line of groups[g]) {\n            ctx.moveTo(line.x1, line.y1);\n            ctx.lineTo(line.x2, line.y2);\n        }\n        ctx.stroke();\n        ctx.beginPath();\n    }\n\n    if (spans !== undefined) {\n        ctx.restore();\n    }\n}\n\nexport function getActionBoundsForGroup(\n    box: Rectangle,\n    actions: NonNullable<GroupDetails[\"actions\"]>\n): readonly Rectangle[] {\n    const result: Rectangle[] = [];\n    let x = box.x + box.width - 26 * actions.length;\n    const y = box.y + box.height / 2 - 13;\n    const height = 26;\n    const width = 26;\n    for (let i = 0; i < actions.length; i++) {\n        result.push({\n            x,\n            y,\n            width,\n            height,\n        });\n        x += 26;\n    }\n    return result;\n}\n\nexport function pointInRect(rect: Rectangle, x: number, y: number): boolean {\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n}\n\nfunction drawGroups(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    width: number,\n    translateX: number,\n    groupHeaderHeight: number,\n    hovered: HoverInfo | undefined,\n    theme: Theme,\n    spriteManager: SpriteManager,\n    _hoverValues: HoverValues,\n    verticalBorder: (col: number) => boolean,\n    getGroupDetails: GroupDetailsCallback,\n    damage: CellList | undefined\n) {\n    const xPad = 8;\n    const [hCol, hRow] = hovered?.[0] ?? [];\n\n    let finalX = 0;\n    walkGroups(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {\n        if (damage !== undefined && !damage.some(d => d[1] === -2 && d[0] >= span[0] && d[0] <= span[1])) return;\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x, y, w, h);\n        ctx.clip();\n\n        const group = getGroupDetails(groupName);\n        const groupTheme = group?.overrideTheme === undefined ? theme : { ...theme, ...group.overrideTheme };\n        const isHovered = hRow === -2 && hCol !== undefined && hCol >= span[0] && hCol <= span[1];\n\n        const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;\n        if (fillColor !== theme.bgHeader) {\n            ctx.fillStyle = fillColor;\n            ctx.fill();\n        }\n\n        ctx.fillStyle = groupTheme.textGroupHeader ?? groupTheme.textHeader;\n        if (group !== undefined) {\n            let drawX = x;\n            if (group.icon !== undefined) {\n                spriteManager.drawSprite(\n                    group.icon,\n                    \"normal\",\n                    ctx,\n                    drawX + xPad,\n                    (groupHeaderHeight - 20) / 2,\n                    20,\n                    groupTheme\n                );\n                drawX += 26;\n            }\n            ctx.fillText(\n                group.name,\n                drawX + xPad,\n                groupHeaderHeight / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`)\n            );\n\n            if (group.actions !== undefined && isHovered) {\n                const actionBoxes = getActionBoundsForGroup({ x, y, width: w, height: h }, group.actions);\n\n                ctx.beginPath();\n                const fadeStartX = actionBoxes[0].x - 10;\n                const fadeWidth = x + w - fadeStartX;\n                ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);\n                const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);\n                const trans = withAlpha(fillColor, 0);\n                grad.addColorStop(0, trans);\n                grad.addColorStop(10 / fadeWidth, fillColor);\n                grad.addColorStop(1, fillColor);\n                ctx.fillStyle = grad;\n\n                ctx.fill();\n\n                ctx.globalAlpha = 0.6;\n\n                // eslint-disable-next-line prefer-const\n                const [mouseX, mouseY] = hovered?.[1] ?? [-1, -1];\n                for (let i = 0; i < group.actions.length; i++) {\n                    const action = group.actions[i];\n                    const box = actionBoxes[i];\n                    const actionHovered = pointInRect(box, mouseX + x, mouseY);\n                    if (actionHovered) {\n                        ctx.globalAlpha = 1;\n                    }\n                    spriteManager.drawSprite(\n                        action.icon,\n                        \"normal\",\n                        ctx,\n                        box.x + box.width / 2 - 10,\n                        box.y + box.height / 2 - 10,\n                        20,\n                        groupTheme\n                    );\n                    if (actionHovered) {\n                        ctx.globalAlpha = 0.6;\n                    }\n                }\n\n                ctx.globalAlpha = 1;\n            }\n        }\n\n        if (verticalBorder(span[0])) {\n            ctx.beginPath();\n            ctx.moveTo(x + 0.5, 0);\n            ctx.lineTo(x + 0.5, groupHeaderHeight);\n            ctx.strokeStyle = theme.borderColor;\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        }\n\n        ctx.restore();\n\n        finalX = x + w;\n    });\n\n    ctx.beginPath();\n    ctx.moveTo(finalX + 0.5, 0);\n    ctx.lineTo(finalX + 0.5, groupHeaderHeight);\n\n    ctx.moveTo(0, groupHeaderHeight + 0.5);\n    ctx.lineTo(width, groupHeaderHeight + 0.5);\n    ctx.strokeStyle = theme.borderColor;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n}\n\nconst menuButtonSize = 30;\nexport function getHeaderMenuBounds(x: number, y: number, width: number, height: number): Rectangle {\n    return {\n        x: x + width - menuButtonSize, // right align\n        y: Math.max(y, y + height / 2 - menuButtonSize / 2), // center vertically\n        width: menuButtonSize,\n        height: Math.min(menuButtonSize, height),\n    };\n}\n\nexport function drawHeader(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    c: MappedGridColumn,\n    selected: boolean,\n    theme: Theme,\n    isHovered: boolean,\n    hasSelectedCell: boolean,\n    hoverAmount: number,\n    spriteManager: SpriteManager,\n    drawHeaderCallback: DrawHeaderCallback | undefined,\n    touchMode: boolean\n) {\n    const isCheckboxHeader = c.title.startsWith(headerCellCheckboxPrefix);\n    const menuBounds = getHeaderMenuBounds(x, y, width, height);\n    if (drawHeaderCallback !== undefined) {\n        let passCol = c;\n        if (isCheckboxHeader) {\n            passCol = {\n                ...c,\n                title: \"\",\n            };\n        }\n        if (\n            drawHeaderCallback({\n                ctx,\n                theme,\n                rect: { x, y, width, height },\n                column: passCol,\n                columnIndex: passCol.sourceIndex,\n                isSelected: selected,\n                hoverAmount,\n                isHovered,\n                hasSelectedCell,\n                spriteManager,\n                menuBounds,\n            })\n        ) {\n            return;\n        }\n    }\n\n    if (isCheckboxHeader) {\n        let checked: boolean | BooleanIndeterminate = undefined;\n        if (c.title === headerCellCheckedMarker) checked = true;\n        if (c.title === headerCellUnheckedMarker) checked = false;\n        if (checked !== true) {\n            ctx.globalAlpha = hoverAmount;\n        }\n        drawCheckbox(ctx, theme, checked, x, y, width, height, false, undefined, undefined);\n        if (checked !== true) {\n            ctx.globalAlpha = 1;\n        }\n        return;\n    }\n\n    const xPad = 8;\n    const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;\n\n    const shouldDrawMenu = c.hasMenu === true && (isHovered || (touchMode && selected));\n\n    let drawX = x + xPad;\n    if (c.icon !== undefined) {\n        let variant: SpriteVariant = selected ? \"selected\" : \"normal\";\n        if (c.style === \"highlight\") {\n            variant = selected ? \"selected\" : \"special\";\n        }\n        spriteManager.drawSprite(c.icon, variant, ctx, drawX, y + (height - 20) / 2, 20, theme);\n\n        if (c.overlayIcon !== undefined) {\n            spriteManager.drawSprite(\n                c.overlayIcon,\n                selected ? \"selected\" : \"special\",\n                ctx,\n                drawX + 9,\n                y + ((height - 18) / 2 + 6),\n                18,\n                theme\n            );\n        }\n\n        drawX += 26;\n    }\n\n    if (shouldDrawMenu && c.hasMenu === true && width > 35) {\n        const fadeWidth = 35;\n        const fadeStart = width - fadeWidth;\n        const fadeEnd = width - fadeWidth * 0.7;\n\n        const fadeStartPercent = fadeStart / width;\n        const fadeEndPercent = fadeEnd / width;\n\n        const grad = ctx.createLinearGradient(x, 0, x + width, 0);\n        const trans = withAlpha(fillStyle, 0);\n\n        grad.addColorStop(0, fillStyle);\n        grad.addColorStop(fadeStartPercent, fillStyle);\n        grad.addColorStop(fadeEndPercent, trans);\n        grad.addColorStop(1, trans);\n        ctx.fillStyle = grad;\n    } else {\n        ctx.fillStyle = fillStyle;\n    }\n    ctx.fillText(\n        c.title,\n        drawX,\n        y + height / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`)\n    );\n\n    if (shouldDrawMenu && c.hasMenu === true) {\n        ctx.beginPath();\n        const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;\n        const triangleY = menuBounds.y + menuBounds.height / 2 - 3;\n        roundedPoly(\n            ctx,\n            [\n                {\n                    x: triangleX,\n                    y: triangleY,\n                },\n                {\n                    x: triangleX + 11,\n                    y: triangleY,\n                },\n                {\n                    x: triangleX + 5.5,\n                    y: triangleY + 6,\n                },\n            ],\n            1\n        );\n\n        ctx.fillStyle = fillStyle;\n        ctx.fill();\n    }\n}\n\nfunction drawGridHeaders(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    enableGroups: boolean,\n    hovered: HoverInfo | undefined,\n    width: number,\n    translateX: number,\n    headerHeight: number,\n    groupHeaderHeight: number,\n    dragAndDropState: DragAndDropState | undefined,\n    isResizing: boolean,\n    selection: GridSelection,\n    outerTheme: Theme,\n    spriteManager: SpriteManager,\n    hoverValues: HoverValues,\n    verticalBorder: (col: number) => boolean,\n    getGroupDetails: GroupDetailsCallback,\n    damage: CellList | undefined,\n    drawHeaderCallback: DrawHeaderCallback | undefined,\n    touchMode: boolean\n) {\n    const totalHeaderHeight = headerHeight + groupHeaderHeight;\n    if (totalHeaderHeight <= 0) return;\n\n    ctx.fillStyle = outerTheme.bgHeader;\n    ctx.fillRect(0, 0, width, totalHeaderHeight);\n\n    const [hCol, hRow] = hovered?.[0] ?? [];\n\n    const font = `${outerTheme.headerFontStyle} ${outerTheme.fontFamily}`;\n    // Assinging the context font too much can be expensive, it can be worth it to minimze this\n    ctx.font = font;\n    walkColumns(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {\n        if (damage !== undefined && !damage.some(d => d[1] === -1 && d[0] === c.sourceIndex)) return;\n        const diff = Math.max(0, clipX - x);\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);\n        ctx.clip();\n\n        const groupTheme = getGroupDetails(c.group ?? \"\").overrideTheme;\n        const theme =\n            c.themeOverride === undefined && groupTheme === undefined\n                ? outerTheme\n                : { ...outerTheme, ...groupTheme, ...c.themeOverride };\n\n        if (theme.bgHeader !== outerTheme.bgHeader) {\n            ctx.fillStyle = theme.bgHeader;\n            ctx.fill();\n        }\n\n        const f = `${theme.headerFontStyle} ${theme.fontFamily}`;\n        if (font !== f) {\n            ctx.font = f;\n        }\n        const selected = selection.columns.hasIndex(c.sourceIndex);\n        const noHover = dragAndDropState !== undefined || isResizing;\n        const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;\n        const hover = noHover\n            ? 0\n            : hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)?.hoverAmount ?? 0;\n\n        const hasSelectedCell = selection?.current !== undefined && selection.current.cell[0] === c.sourceIndex;\n\n        const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;\n\n        const y = enableGroups ? groupHeaderHeight : 0;\n        const xOffset = c.sourceIndex === 0 ? 0 : 1;\n\n        if (selected) {\n            ctx.fillStyle = bgFillStyle;\n            ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);\n        } else if (hasSelectedCell || hover > 0) {\n            ctx.beginPath();\n            ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);\n            if (hasSelectedCell) {\n                ctx.fillStyle = theme.bgHeaderHasFocus;\n                ctx.fill();\n            }\n            if (hover > 0) {\n                ctx.globalAlpha = hover;\n                ctx.fillStyle = theme.bgHeaderHovered;\n                ctx.fill();\n                ctx.globalAlpha = 1;\n            }\n        }\n\n        drawHeader(\n            ctx,\n            x,\n            y,\n            c.width,\n            headerHeight,\n            c,\n            selected,\n            theme,\n            hoveredBoolean,\n            hasSelectedCell,\n            hover,\n            spriteManager,\n            drawHeaderCallback,\n            touchMode\n        );\n        ctx.restore();\n    });\n\n    if (enableGroups) {\n        drawGroups(\n            ctx,\n            effectiveCols,\n            width,\n            translateX,\n            groupHeaderHeight,\n            hovered,\n            outerTheme,\n            spriteManager,\n            hoverValues,\n            verticalBorder,\n            getGroupDetails,\n            damage\n        );\n    }\n}\n\nfunction intersectRect(x1: number, y1: number, w1: number, h1: number, x2: number, y2: number, w2: number, h2: number) {\n    return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;\n}\n\nfunction clipDamage(\n    ctx: CanvasRenderingContext2D,\n    effectiveColumns: readonly MappedGridColumn[],\n    width: number,\n    height: number,\n    groupHeaderHeight: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    trailingRowType: TrailingRowType,\n    damage: CellList | undefined,\n    includeCells: boolean\n): void {\n    if (damage === undefined || damage.length === 0) return;\n\n    const stickyRowHeight = trailingRowType === \"sticky\" ? getRowHeight(rows - 1) : 0;\n\n    ctx.beginPath();\n\n    walkGroups(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {\n        for (let i = 0; i < damage.length; i++) {\n            const d = damage[i];\n            if (d[1] === -2 && d[0] >= span[0] && d[0] <= span[1]) {\n                ctx.rect(x, y, w, h);\n                break;\n            }\n        }\n    });\n\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (c, drawX, colDrawY, clipX, startRow) => {\n            const diff = Math.max(0, clipX - drawX);\n\n            const finalX = drawX + diff + 1;\n            const finalWidth = c.width - diff - 1;\n            for (let i = 0; i < damage.length; i++) {\n                const d = damage[i];\n                if (d[0] === c.sourceIndex && (d[1] === -1 || d[1] === undefined)) {\n                    ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);\n                    break;\n                }\n            }\n\n            if (!includeCells) return;\n\n            walkRowsInCol(\n                startRow,\n                colDrawY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (drawY, row, rh, isSticky) => {\n                    let isDamaged = false;\n                    for (let i = 0; i < damage.length; i++) {\n                        const d = damage[i];\n                        if (d[0] === c.sourceIndex && d[1] === row) {\n                            isDamaged = true;\n                            break;\n                        }\n                    }\n                    if (isDamaged) {\n                        const top = drawY + 1;\n                        const bottom = isSticky ? top + rh - 1 : Math.min(top + rh - 1, height - stickyRowHeight);\n                        const h = bottom - top;\n\n                        if (h > 0) {\n                            ctx.rect(finalX, top, finalWidth, h);\n                        }\n                    }\n                }\n            );\n        }\n    );\n    ctx.clip();\n}\n\nfunction getSpanBounds(\n    span: Item,\n    cellX: number,\n    cellY: number,\n    cellW: number,\n    cellH: number,\n    column: MappedGridColumn,\n    allColumns: readonly MappedGridColumn[]\n): [Rectangle | undefined, Rectangle | undefined] {\n    const [startCol, endCol] = span;\n\n    let frozenRect: Rectangle | undefined;\n    let contentRect: Rectangle | undefined;\n\n    const firstNonSticky = allColumns.find(x => !x.sticky)?.sourceIndex ?? 0;\n    if (endCol > firstNonSticky) {\n        const renderFromCol = Math.max(startCol, firstNonSticky);\n        let tempX = cellX;\n        let tempW = cellW;\n        for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {\n            tempX -= allColumns[x].width;\n            tempW += allColumns[x].width;\n        }\n        for (let x = column.sourceIndex + 1; x <= endCol; x++) {\n            tempW += allColumns[x].width;\n        }\n        contentRect = {\n            x: tempX,\n            y: cellY,\n            width: tempW,\n            height: cellH,\n        };\n    }\n\n    if (firstNonSticky > startCol) {\n        const renderToCol = Math.min(endCol, firstNonSticky - 1);\n        let tempX = cellX;\n        let tempW = cellW;\n        for (let x = column.sourceIndex - 1; x >= startCol; x--) {\n            tempX -= allColumns[x].width;\n            tempW += allColumns[x].width;\n        }\n        for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {\n            tempW += allColumns[x].width;\n        }\n        frozenRect = {\n            x: tempX,\n            y: cellY,\n            width: tempW,\n            height: cellH,\n        };\n    }\n\n    return [frozenRect, contentRect];\n}\n\n// preppable items:\n// - font\n// - fillStyle\n\n// Column draw loop prep cycle\n// - Prep item\n// - Prep sets props\n// - Prep returns list of cared about props\n// - Draw item\n// - Loop may set some items, if present in args list, set undefined\n// - Prep next item, giving previous result\n// - If next item type is different, de-prep\n// - Result per column\nfunction drawCells(\n    ctx: CanvasRenderingContext2D,\n    effectiveColumns: readonly MappedGridColumn[],\n    allColumns: readonly MappedGridColumn[],\n    height: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    getCellContent: (cell: Item) => InnerGridCell,\n    getGroupDetails: GroupDetailsCallback,\n    getRowThemeOverride: GetRowThemeCallback | undefined,\n    disabledRows: CompactSelection,\n    isFocused: boolean,\n    drawFocus: boolean,\n    trailingRowType: TrailingRowType,\n    drawRegions: readonly Rectangle[],\n    damage: CellList | undefined,\n    selection: GridSelection,\n    prelightCells: CellList | undefined,\n    highlightRegions: readonly Highlight[] | undefined,\n    drawCustomCell: DrawCustomCellCallback | undefined,\n    imageLoader: ImageWindowLoader,\n    spriteManager: SpriteManager,\n    hoverValues: HoverValues,\n    hoverInfo: HoverInfo | undefined,\n    hyperWrapping: boolean,\n    outerTheme: Theme,\n    enqueue: (item: Item) => void,\n    getCellRenderer: GetCellRendererCallback\n): Rectangle[] | undefined {\n    let toDraw = damage?.length ?? Number.MAX_SAFE_INTEGER;\n    const frameTime = performance.now();\n    let font = `${outerTheme.baseFontStyle} ${outerTheme.fontFamily}`;\n    ctx.font = font;\n    let result: Rectangle[] | undefined;\n    const handledSpans = new Set<string>();\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (c, drawX, colDrawStartY, clipX, startRow) => {\n            const diff = Math.max(0, clipX - drawX);\n\n            const colDrawX = drawX + diff;\n            const colDrawY = totalHeaderHeight + 1;\n            const colWidth = c.width - diff;\n            const colHeight = height - totalHeaderHeight - 1;\n            if (drawRegions.length > 0) {\n                let found = false;\n                for (let i = 0; i < drawRegions.length; i++) {\n                    const dr = drawRegions[i];\n                    if (intersectRect(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) return;\n            }\n\n            const reclip = () => {\n                ctx.save();\n                ctx.beginPath();\n                ctx.rect(colDrawX, colDrawY, colWidth, colHeight);\n                ctx.clip();\n            };\n\n            const colSelected = selection.columns.hasIndex(c.sourceIndex);\n\n            const groupTheme = getGroupDetails(c.group ?? \"\").overrideTheme;\n            const colTheme =\n                c.themeOverride === undefined && groupTheme === undefined\n                    ? outerTheme\n                    : { ...outerTheme, ...groupTheme, ...c.themeOverride };\n            const colFont = `${colTheme.baseFontStyle} ${colTheme.fontFamily}`;\n            if (colFont !== font) {\n                font = colFont;\n                ctx.font = colFont;\n            }\n            reclip();\n            let prepResult: PrepResult | undefined = undefined;\n\n            walkRowsInCol(\n                startRow,\n                colDrawStartY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (drawY, row, rh, isSticky, isTrailingRow) => {\n                    if (row < 0) return;\n                    // if (damage !== undefined && !damage.some(d => d[0] === c.sourceIndex && d[1] === row)) {\n                    //     return;\n                    // }\n                    // if (\n                    //     drawRegions.length > 0 &&\n                    //     !drawRegions.some(dr => intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height))\n                    // ) {\n                    //     return;\n                    // }\n\n                    // These are dumb versions of the above. I cannot for the life of believe that this matters but this is\n                    // the tightest part of the draw loop and the allocations above actually has a very measurable impact\n                    // on performance. For the love of all that is unholy please keep checking this again in the future.\n                    // As soon as this doesn't have any impact of note go back to the saner looking code. The smoke test\n                    // here is to scroll to the bottom of a test case first, then scroll back up while profiling and see\n                    // how many major GC collections you get. These allocate a lot of objects.\n                    if (damage !== undefined) {\n                        let found = false;\n                        for (let i = 0; i < damage.length; i++) {\n                            const d = damage[i];\n                            if (d[0] === c.sourceIndex && d[1] === row) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) return;\n                    }\n                    if (drawRegions.length > 0) {\n                        let found = false;\n                        for (let i = 0; i < drawRegions.length; i++) {\n                            const dr = drawRegions[i];\n                            if (intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) return;\n                    }\n\n                    const rowSelected = selection.rows.hasIndex(row);\n                    const rowDisabled = disabledRows.hasIndex(row);\n\n                    const cell: InnerGridCell = row < rows ? getCellContent([c.sourceIndex, row]) : loadingCell;\n\n                    let cellX = drawX;\n                    let cellWidth = c.width;\n                    let drawingSpan = false;\n                    let skipContents = false;\n                    if (cell.span !== undefined) {\n                        const [startCol, endCol] = cell.span;\n                        const spanKey = `${row},${startCol},${endCol},${c.sticky}`;\n                        if (!handledSpans.has(spanKey)) {\n                            const areas = getSpanBounds(cell.span, drawX, drawY, c.width, rh, c, allColumns);\n                            const area = c.sticky ? areas[0] : areas[1];\n                            if (!c.sticky && areas[0] !== undefined) {\n                                skipContents = true;\n                            }\n                            if (area !== undefined) {\n                                cellX = area.x;\n                                cellWidth = area.width;\n                                handledSpans.add(spanKey);\n                                ctx.restore();\n                                prepResult = undefined;\n                                ctx.save();\n                                ctx.beginPath();\n                                const d = Math.max(0, clipX - area.x);\n                                ctx.rect(area.x + d, drawY, area.width - d, rh);\n                                if (result === undefined) {\n                                    result = [];\n                                }\n                                result.push({\n                                    x: area.x + d,\n                                    y: drawY,\n                                    width: area.width - d,\n                                    height: rh,\n                                });\n                                ctx.clip();\n                                drawingSpan = true;\n                            }\n                        } else {\n                            toDraw--;\n                            return;\n                        }\n                    }\n\n                    const rowTheme = getRowThemeOverride?.(row);\n                    const trailingTheme =\n                        isTrailingRow && c.trailingRowOptions?.themeOverride !== undefined\n                            ? c.trailingRowOptions?.themeOverride\n                            : undefined;\n                    const theme =\n                        cell.themeOverride === undefined && rowTheme === undefined && trailingTheme === undefined\n                            ? colTheme\n                            : { ...colTheme, ...rowTheme, ...trailingTheme, ...cell.themeOverride };\n\n                    ctx.beginPath();\n\n                    const cellIndex = [c.sourceIndex, row] as const;\n                    const isSelected = cellIsSelected(cellIndex, cell, selection);\n                    let accentCount = cellIsInRange(cellIndex, cell, selection);\n                    const spanIsHighlighted =\n                        cell.span !== undefined &&\n                        selection.columns.some(\n                            index => cell.span !== undefined && index >= cell.span[0] && index <= cell.span[1]\n                        );\n                    if (isSelected && !isFocused && drawFocus) {\n                        accentCount = 0;\n                    } else if (isSelected) {\n                        accentCount = Math.max(accentCount, 1);\n                    }\n                    if (spanIsHighlighted) {\n                        accentCount++;\n                    }\n                    if (!isSelected) {\n                        if (rowSelected) accentCount++;\n                        if (colSelected && !isSticky) accentCount++;\n                    }\n\n                    const bgCell = cell.kind === GridCellKind.Protected ? theme.bgCellMedium : theme.bgCell;\n                    let fill: string | undefined;\n                    if (isSticky || bgCell !== outerTheme.bgCell) {\n                        fill = blend(bgCell, fill);\n                    }\n\n                    if (accentCount > 0 || rowDisabled) {\n                        if (rowDisabled) {\n                            fill = blend(theme.bgHeader, fill);\n                        }\n                        for (let i = 0; i < accentCount; i++) {\n                            fill = blend(theme.accentLight, fill);\n                        }\n                    } else {\n                        if (prelightCells?.some(pre => pre[0] === c.sourceIndex && pre[1] === row) === true) {\n                            fill = blend(theme.bgSearchResult, fill);\n                        }\n                    }\n\n                    if (highlightRegions !== undefined) {\n                        for (const region of highlightRegions) {\n                            const r = region.range;\n                            if (\n                                r.x <= c.sourceIndex &&\n                                c.sourceIndex < r.x + r.width &&\n                                r.y <= row &&\n                                row < r.y + r.height\n                            ) {\n                                fill = blend(region.color, fill);\n                            }\n                        }\n                    }\n\n                    if (fill !== undefined) {\n                        ctx.fillStyle = fill;\n                        if (prepResult !== undefined) {\n                            prepResult.fillStyle = fill;\n                        }\n                        ctx.fillRect(cellX, drawY, cellWidth, rh);\n                    }\n\n                    if (cell.style === \"faded\") {\n                        ctx.globalAlpha = 0.6;\n                    }\n\n                    const hoverValue = hoverValues.find(hv => hv.item[0] === c.sourceIndex && hv.item[1] === row);\n\n                    if (cellWidth > 10 && !skipContents) {\n                        const cellFont = `${theme.baseFontStyle} ${theme.fontFamily}`;\n                        if (cellFont !== font) {\n                            ctx.font = cellFont;\n                            font = cellFont;\n                        }\n                        prepResult = drawCell(\n                            ctx,\n                            row,\n                            cell,\n                            c.sourceIndex,\n                            cellX,\n                            drawY,\n                            cellWidth,\n                            rh,\n                            accentCount > 0,\n                            theme,\n                            drawCustomCell,\n                            imageLoader,\n                            spriteManager,\n                            hoverValue?.hoverAmount ?? 0,\n                            hoverInfo,\n                            hyperWrapping,\n                            frameTime,\n                            prepResult,\n                            enqueue,\n                            getCellRenderer\n                        );\n                    }\n\n                    if (cell.style === \"faded\") {\n                        ctx.globalAlpha = 1;\n                    }\n                    toDraw--;\n                    if (drawingSpan) {\n                        ctx.restore();\n                        prepResult?.deprep?.({ ctx });\n                        prepResult = undefined;\n                        reclip();\n                        font = colFont;\n                        ctx.font = colFont;\n                    }\n                    return toDraw <= 0;\n                }\n            );\n\n            ctx.restore();\n            return toDraw <= 0;\n        }\n    );\n    return result;\n}\n\nfunction drawBlanks(\n    ctx: CanvasRenderingContext2D,\n    effectiveColumns: readonly MappedGridColumn[],\n    allColumns: readonly MappedGridColumn[],\n    width: number,\n    height: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    getRowTheme: GetRowThemeCallback | undefined,\n    selectedRows: CompactSelection,\n    disabledRows: CompactSelection,\n    trailingRowType: TrailingRowType,\n    drawRegions: readonly Rectangle[],\n    damage: CellList | undefined,\n    theme: Theme\n): void {\n    if (\n        damage !== undefined ||\n        effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1]\n    )\n        return;\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (c, drawX, colDrawY, clipX, startRow) => {\n            if (c !== effectiveColumns[effectiveColumns.length - 1]) return;\n            drawX += c.width;\n            const x = Math.max(drawX, clipX);\n            if (x > width) return;\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(x, totalHeaderHeight + 1, 10_000, height - totalHeaderHeight - 1);\n            ctx.clip();\n\n            walkRowsInCol(\n                startRow,\n                colDrawY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (drawY, row, rh, isSticky) => {\n                    if (\n                        !isSticky &&\n                        drawRegions.length > 0 &&\n                        !drawRegions.some(dr =>\n                            intersectRect(drawX, drawY, 10_000, rh, dr.x, dr.y, dr.width, dr.height)\n                        )\n                    ) {\n                        return;\n                    }\n\n                    const rowSelected = selectedRows.hasIndex(row);\n                    const rowDisabled = disabledRows.hasIndex(row);\n\n                    ctx.beginPath();\n\n                    const rowTheme = getRowTheme?.(row);\n\n                    const blankTheme = rowTheme === undefined ? theme : { ...theme, ...rowTheme };\n\n                    if (blankTheme.bgCell !== theme.bgCell) {\n                        ctx.fillStyle = blankTheme.bgCell;\n                        ctx.fillRect(drawX, drawY, 10_000, rh);\n                    }\n                    if (rowDisabled) {\n                        ctx.fillStyle = blankTheme.bgHeader;\n                        ctx.fillRect(drawX, drawY, 10_000, rh);\n                    }\n                    if (rowSelected) {\n                        ctx.fillStyle = blankTheme.accentLight;\n                        ctx.fillRect(drawX, drawY, 10_000, rh);\n                    }\n                }\n            );\n\n            ctx.restore();\n        }\n    );\n}\n\nfunction overdrawStickyBoundaries(\n    ctx: CanvasRenderingContext2D,\n    effectiveCols: readonly MappedGridColumn[],\n    width: number,\n    height: number,\n    lastRowSticky: boolean,\n    rows: number,\n    verticalBorder: (col: number) => boolean,\n    getRowHeight: (row: number) => number,\n    theme: Theme\n) {\n    let drawFreezeBorder = false;\n    for (const c of effectiveCols) {\n        if (c.sticky) continue;\n        drawFreezeBorder = verticalBorder(c.sourceIndex);\n        break;\n    }\n    const hColor = theme.horizontalBorderColor ?? theme.borderColor;\n    const vColor = theme.borderColor;\n    const drawX = drawFreezeBorder ? getStickyWidth(effectiveCols) : 0;\n\n    if (drawX !== 0) {\n        ctx.beginPath();\n        ctx.moveTo(drawX + 0.5, 0);\n        ctx.lineTo(drawX + 0.5, height);\n        ctx.strokeStyle = blend(vColor, theme.bgCell);\n        ctx.stroke();\n    }\n\n    if (lastRowSticky) {\n        const h = getRowHeight(rows - 1);\n        ctx.beginPath();\n        ctx.moveTo(0, height - h + 0.5);\n        ctx.lineTo(width, height - h + 0.5);\n        ctx.strokeStyle = blend(hColor, theme.bgCell);\n        ctx.stroke();\n    }\n}\n\nfunction drawHighlightRings(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    cellXOffset: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    mappedColumns: readonly MappedGridColumn[],\n    freezeColumns: number,\n    headerHeight: number,\n    groupHeaderHeight: number,\n    rowHeight: number | ((index: number) => number),\n    lastRowSticky: boolean,\n    rows: number,\n    allHighlightRegions: readonly Highlight[] | undefined\n): (() => void) | undefined {\n    const highlightRegions = allHighlightRegions?.filter(x => x.style !== \"no-outline\");\n    if (highlightRegions === undefined || highlightRegions.length === 0) return undefined;\n    const drawRects = highlightRegions.map(h => {\n        const r = h.range;\n        const topLeftBounds = computeBounds(\n            r.x,\n            r.y,\n            width,\n            height,\n            groupHeaderHeight,\n            headerHeight + groupHeaderHeight,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            rows,\n            freezeColumns,\n            lastRowSticky,\n            mappedColumns,\n            rowHeight\n        );\n        if (r.width === 1 && r.height === 1) {\n            if (r.x < freezeColumns) {\n                return [{ color: h.color, style: h.style ?? \"dashed\", rect: topLeftBounds }, undefined];\n            }\n            return [undefined, { color: h.color, style: h.style ?? \"dashed\", rect: topLeftBounds }];\n        }\n\n        const bottomRightBounds = computeBounds(\n            r.x + r.width - 1,\n            r.y + r.height - 1,\n            width,\n            height,\n            groupHeaderHeight,\n            headerHeight + groupHeaderHeight,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            rows,\n            freezeColumns,\n            lastRowSticky,\n            mappedColumns,\n            rowHeight\n        );\n        if (r.x < freezeColumns && r.x + r.width >= freezeColumns) {\n            const freezeSectionRightBounds = computeBounds(\n                freezeColumns - 1,\n                r.y + r.height - 1,\n                width,\n                height,\n                groupHeaderHeight,\n                headerHeight + groupHeaderHeight,\n                cellXOffset,\n                cellYOffset,\n                translateX,\n                translateY,\n                rows,\n                freezeColumns,\n                lastRowSticky,\n                mappedColumns,\n                rowHeight\n            );\n            const unfreezeSectionleftBounds = computeBounds(\n                freezeColumns,\n                r.y + r.height - 1,\n                width,\n                height,\n                groupHeaderHeight,\n                headerHeight + groupHeaderHeight,\n                cellXOffset,\n                cellYOffset,\n                translateX,\n                translateY,\n                rows,\n                freezeColumns,\n                lastRowSticky,\n                mappedColumns,\n                rowHeight\n            );\n\n            return [\n                {\n                    color: h.color,\n                    style: h.style ?? \"dashed\",\n                    rect: {\n                        x: topLeftBounds.x,\n                        y: topLeftBounds.y,\n                        width: freezeSectionRightBounds.x + freezeSectionRightBounds.width - topLeftBounds.x,\n                        height: freezeSectionRightBounds.y + freezeSectionRightBounds.height - topLeftBounds.y,\n                    } as Rectangle,\n                },\n                {\n                    color: h.color,\n                    style: h.style ?? \"dashed\",\n                    rect: {\n                        x: unfreezeSectionleftBounds.x,\n                        y: unfreezeSectionleftBounds.y,\n                        width: bottomRightBounds.x + bottomRightBounds.width - unfreezeSectionleftBounds.x,\n                        height: bottomRightBounds.y + bottomRightBounds.height - unfreezeSectionleftBounds.y,\n                    } as Rectangle,\n                },\n            ];\n        } else {\n            return [\n                undefined,\n                {\n                    color: h.color,\n                    style: h.style ?? \"dashed\",\n                    rect: {\n                        x: topLeftBounds.x,\n                        y: topLeftBounds.y,\n                        width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,\n                        height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y,\n                    } as Rectangle,\n                },\n            ];\n        }\n    });\n\n    const stickyWidth = getStickyWidth(mappedColumns);\n\n    const drawCb = () => {\n        ctx.beginPath();\n        ctx.save();\n        let dashed = false;\n        const setDashed = (dash: boolean) => {\n            if (dashed === dash) return;\n            ctx.setLineDash(dash ? [5, 3] : []);\n            dashed = dash;\n        };\n\n        ctx.lineWidth = 1;\n        for (const dr of drawRects) {\n            const [s] = dr;\n            if (\n                s !== undefined &&\n                intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)\n            ) {\n                setDashed(s.style === \"dashed\");\n                ctx.strokeStyle = withAlpha(s.color, 1);\n                ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);\n            }\n        }\n        let clipped = false;\n        for (const dr of drawRects) {\n            const [, s] = dr;\n            if (\n                s !== undefined &&\n                intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)\n            ) {\n                setDashed(s.style === \"dashed\");\n                if (!clipped && s.rect.x < stickyWidth) {\n                    ctx.rect(stickyWidth, 0, width, height);\n                    ctx.clip();\n                    clipped = true;\n                }\n                ctx.strokeStyle = withAlpha(s.color, 1);\n                ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);\n            }\n        }\n        ctx.restore();\n    };\n\n    drawCb();\n    return drawCb;\n}\n\nfunction drawFocusRing(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    effectiveCols: readonly MappedGridColumn[],\n    allColumns: readonly MappedGridColumn[],\n    theme: Theme,\n    totalHeaderHeight: number,\n    selectedCell: GridSelection,\n    getRowHeight: (row: number) => number,\n    getCellContent: (cell: Item) => InnerGridCell,\n    trailingRowType: TrailingRowType,\n    fillHandle: boolean,\n    rows: number\n): (() => void) | undefined {\n    if (selectedCell.current === undefined || !effectiveCols.some(c => c.sourceIndex === selectedCell.current?.cell[0]))\n        return undefined;\n    const [targetCol, targetRow] = selectedCell.current.cell;\n    const cell = getCellContent(selectedCell.current.cell);\n    const targetColSpan = cell.span ?? [targetCol, targetCol];\n\n    const isStickyRow = trailingRowType === \"sticky\" && targetRow === rows - 1;\n    const stickRowHeight = trailingRowType === \"sticky\" && !isStickyRow ? getRowHeight(rows - 1) - 1 : 0;\n\n    let drawCb: (() => void) | undefined = undefined;\n\n    walkColumns(\n        effectiveCols,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (col, drawX, colDrawY, clipX, startRow) => {\n            if (col.sticky && targetCol > col.sourceIndex) return;\n            if (col.sourceIndex < targetColSpan[0] || col.sourceIndex > targetColSpan[1]) {\n                return;\n            }\n\n            walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh) => {\n                if (row !== targetRow) return;\n\n                let cellX = drawX;\n                let cellWidth = col.width;\n\n                if (cell.span !== undefined) {\n                    const areas = getSpanBounds(cell.span, drawX, drawY, col.width, rh, col, allColumns);\n                    const area = col.sticky ? areas[0] : areas[1];\n\n                    if (area !== undefined) {\n                        cellX = area.x;\n                        cellWidth = area.width;\n                    }\n                }\n\n                drawCb = () => {\n                    if (clipX > cellX && !col.sticky) {\n                        ctx.beginPath();\n                        ctx.rect(clipX, 0, width - clipX, height);\n                        ctx.clip();\n                    }\n                    ctx.beginPath();\n                    ctx.rect(cellX + 0.5, drawY + 0.5, cellWidth, rh);\n                    ctx.strokeStyle = col.themeOverride?.accentColor ?? theme.accentColor;\n                    ctx.lineWidth = 1;\n                    ctx.stroke();\n\n                    if (fillHandle) {\n                        ctx.beginPath();\n                        ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);\n                        ctx.fillStyle = col.themeOverride?.accentColor ?? theme.accentColor;\n                        ctx.fill();\n                    }\n                };\n                return true;\n            });\n\n            return true;\n        }\n    );\n\n    if (drawCb === undefined) return undefined;\n\n    const result = () => {\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);\n        ctx.clip();\n\n        drawCb?.();\n\n        ctx.restore();\n    };\n\n    result();\n\n    return result;\n}\n\nfunction getLastRow(\n    effectiveColumns: readonly MappedGridColumn[],\n    height: number,\n    totalHeaderHeight: number,\n    translateX: number,\n    translateY: number,\n    cellYOffset: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    trailingRowType: TrailingRowType\n): number {\n    let result = 0;\n    walkColumns(\n        effectiveColumns,\n        cellYOffset,\n        translateX,\n        translateY,\n        totalHeaderHeight,\n        (_c, __drawX, colDrawY, _clipX, startRow) => {\n            walkRowsInCol(\n                startRow,\n                colDrawY,\n                height,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                (_drawY, row, _rh, isSticky) => {\n                    if (!isSticky) {\n                        result = Math.max(row, result);\n                    }\n                }\n            );\n\n            return true;\n        }\n    );\n    return result;\n}\n\nexport interface DrawGridArg {\n    readonly canvas: HTMLCanvasElement;\n    readonly headerCanvas: HTMLCanvasElement;\n    readonly bufferA: HTMLCanvasElement;\n    readonly bufferB: HTMLCanvasElement;\n    readonly width: number;\n    readonly height: number;\n    readonly cellXOffset: number;\n    readonly cellYOffset: number;\n    readonly translateX: number;\n    readonly translateY: number;\n    readonly mappedColumns: readonly MappedGridColumn[];\n    readonly enableGroups: boolean;\n    readonly freezeColumns: number;\n    readonly dragAndDropState: DragAndDropState | undefined;\n    readonly theme: Theme;\n    readonly headerHeight: number;\n    readonly groupHeaderHeight: number;\n    readonly disabledRows: CompactSelection;\n    readonly rowHeight: number | ((index: number) => number);\n    readonly verticalBorder: (col: number) => boolean;\n    readonly isResizing: boolean;\n    readonly isFocused: boolean;\n    readonly drawFocus: boolean;\n    readonly selection: GridSelection;\n    readonly fillHandle: boolean;\n    readonly lastRowSticky: TrailingRowType;\n    readonly hyperWrapping: boolean;\n    readonly rows: number;\n    readonly getCellContent: (cell: Item) => InnerGridCell;\n    readonly getGroupDetails: GroupDetailsCallback;\n    readonly getRowThemeOverride: GetRowThemeCallback | undefined;\n    readonly drawCustomCell: DrawCustomCellCallback | undefined;\n    readonly drawHeaderCallback: DrawHeaderCallback | undefined;\n    readonly prelightCells: CellList | undefined;\n    readonly highlightRegions: readonly Highlight[] | undefined;\n    readonly imageLoader: ImageWindowLoader;\n    readonly lastBlitData: React.MutableRefObject<BlitData | undefined>;\n    readonly damage: CellList | undefined;\n    readonly hoverValues: HoverValues;\n    readonly hoverInfo: HoverInfo | undefined;\n    readonly spriteManager: SpriteManager;\n    readonly scrolling: boolean;\n    readonly touchMode: boolean;\n    readonly renderStrategy: \"single-buffer\" | \"double-buffer\" | \"direct\";\n    readonly enqueue: (item: Item) => void;\n    readonly getCellRenderer: GetCellRendererCallback;\n}\n\nfunction computeCanBlit(current: DrawGridArg, last: DrawGridArg | undefined): boolean | number {\n    if (last === undefined) return false;\n    if (\n        current.width !== last.width ||\n        current.height !== last.height ||\n        current.theme !== last.theme ||\n        current.headerHeight !== last.headerHeight ||\n        current.rowHeight !== last.rowHeight ||\n        current.rows !== last.rows ||\n        current.getRowThemeOverride !== last.getRowThemeOverride ||\n        current.isFocused !== last.isFocused ||\n        current.isResizing !== last.isResizing ||\n        current.verticalBorder !== last.verticalBorder ||\n        current.getCellContent !== last.getCellContent ||\n        current.highlightRegions !== last.highlightRegions ||\n        current.selection !== last.selection ||\n        current.dragAndDropState !== last.dragAndDropState ||\n        current.prelightCells !== last.prelightCells ||\n        current.touchMode !== last.touchMode ||\n        current.scrolling !== last.scrolling\n    ) {\n        return false;\n    }\n    if (current.mappedColumns !== last.mappedColumns) {\n        if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {\n            // The array is big, let's just redraw the damned thing rather than check these all. Or the number of cols\n            // changed in which case I dont want to figure out what happened.\n            return false;\n        }\n        // We want to know if only one column has resized. If this is the case we can do a special left/right sliding\n        // blit. Or just not redraw shit on the left.\n        let resized: number | undefined;\n        for (let i = 0; i < current.mappedColumns.length; i++) {\n            const curCol = current.mappedColumns[i];\n            const lastCol = last.mappedColumns[i];\n\n            if (deepEqual(curCol, lastCol)) continue;\n\n            // two columns changed, abort\n            if (resized !== undefined) return false;\n\n            if (curCol.width === lastCol.width) return false;\n\n            const { width, ...curRest } = curCol;\n            const { width: lastWidth, ...lastRest } = lastCol;\n\n            // more than width changed, abort\n            if (!deepEqual(curRest, lastRest)) return false;\n            resized = i;\n        }\n        if (resized === undefined) {\n            // we never found a changed column, cool, we can blit\n            return true;\n        }\n        return resized;\n    }\n    return true;\n}\n\nexport function drawGrid(arg: DrawGridArg, lastArg: DrawGridArg | undefined) {\n    const {\n        canvas,\n        headerCanvas,\n        width,\n        height,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mappedColumns,\n        enableGroups,\n        freezeColumns,\n        dragAndDropState,\n        theme,\n        drawFocus,\n        headerHeight,\n        groupHeaderHeight,\n        disabledRows,\n        rowHeight,\n        verticalBorder,\n        isResizing,\n        selection,\n        fillHandle,\n        lastRowSticky: trailingRowType,\n        rows,\n        getCellContent,\n        getGroupDetails,\n        getRowThemeOverride,\n        isFocused,\n        drawCustomCell,\n        drawHeaderCallback,\n        prelightCells,\n        highlightRegions,\n        imageLoader,\n        lastBlitData,\n        hoverValues,\n        hyperWrapping,\n        hoverInfo,\n        spriteManager,\n        scrolling,\n        touchMode,\n        enqueue,\n        getCellRenderer,\n        renderStrategy,\n        bufferA,\n        bufferB,\n    } = arg;\n    let { damage } = arg;\n    if (width === 0 || height === 0) return;\n    const doubleBuffer = renderStrategy === \"double-buffer\";\n    const dpr = scrolling ? 1 : Math.ceil(window.devicePixelRatio ?? 1);\n\n    const canBlit = renderStrategy !== \"direct\" && computeCanBlit(arg, lastArg);\n\n    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {\n        canvas.width = width * dpr;\n        canvas.height = height * dpr;\n\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n    }\n\n    const overlayCanvas = headerCanvas;\n    const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;\n\n    const overlayHeight = totalHeaderHeight + 1; // border\n    if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {\n        overlayCanvas.width = width * dpr;\n        overlayCanvas.height = overlayHeight * dpr;\n\n        overlayCanvas.style.width = width + \"px\";\n        overlayCanvas.style.height = overlayHeight + \"px\";\n    }\n\n    if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {\n        bufferA.width = width * dpr;\n        bufferA.height = height * dpr;\n    }\n\n    if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {\n        bufferB.width = width * dpr;\n        bufferB.height = height * dpr;\n    }\n\n    const last = lastBlitData.current;\n    if (\n        canBlit === true &&\n        cellXOffset === last?.cellXOffset &&\n        cellYOffset === last?.cellYOffset &&\n        translateX === last?.translateX &&\n        translateY === last?.translateY\n    )\n        return;\n\n    let mainCtx: CanvasRenderingContext2D | null = null;\n    if (doubleBuffer) {\n        mainCtx = canvas.getContext(\"2d\", {\n            alpha: false,\n        });\n    }\n    const overlayCtx = overlayCanvas.getContext(\"2d\", {\n        alpha: false,\n    });\n    let targetBuffer: HTMLCanvasElement;\n    if (!doubleBuffer) {\n        targetBuffer = canvas;\n    } else if (damage !== undefined) {\n        targetBuffer = last?.lastBuffer === \"b\" ? bufferB : bufferA;\n    } else {\n        targetBuffer = last?.lastBuffer === \"b\" ? bufferA : bufferB;\n    }\n    const targetCtx = targetBuffer.getContext(\"2d\", {\n        alpha: false,\n    });\n    const blitSource = doubleBuffer ? (targetBuffer === bufferA ? bufferB : bufferA) : canvas;\n\n    if (overlayCtx === null || targetCtx === null) return;\n\n    const getRowHeight = typeof rowHeight === \"number\" ? () => rowHeight : rowHeight;\n\n    overlayCtx.save();\n    overlayCtx.beginPath();\n    targetCtx.save();\n    targetCtx.beginPath();\n\n    overlayCtx.textBaseline = \"middle\";\n    targetCtx.textBaseline = \"middle\";\n\n    if (dpr !== 1) {\n        overlayCtx.scale(dpr, dpr);\n        targetCtx.scale(dpr, dpr);\n    }\n\n    const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);\n\n    let drawRegions: Rectangle[] = [];\n\n    const mustDrawFocusOnHeader = drawFocus && selection.current?.cell[1] === cellYOffset && translateY === 0;\n    const drawHeaderTexture = () => {\n        drawGridHeaders(\n            overlayCtx,\n            effectiveCols,\n            enableGroups,\n            hoverInfo,\n            width,\n            translateX,\n            headerHeight,\n            groupHeaderHeight,\n            dragAndDropState,\n            isResizing,\n            selection,\n            theme,\n            spriteManager,\n            hoverValues,\n            verticalBorder,\n            getGroupDetails,\n            damage,\n            drawHeaderCallback,\n            touchMode\n        );\n\n        drawGridLines(\n            overlayCtx,\n            effectiveCols,\n            cellYOffset,\n            translateX,\n            translateY,\n            width,\n            height,\n            undefined,\n            undefined,\n            groupHeaderHeight,\n            totalHeaderHeight,\n            getRowHeight,\n            getRowThemeOverride,\n            verticalBorder,\n            trailingRowType,\n            rows,\n            theme,\n            true\n        );\n\n        overlayCtx.beginPath();\n        overlayCtx.moveTo(0, overlayHeight - 0.5);\n        overlayCtx.lineTo(width, overlayHeight - 0.5);\n        overlayCtx.strokeStyle = blend(\n            theme.headerBottomBorderColor ?? theme.horizontalBorderColor ?? theme.borderColor,\n            theme.bgHeader\n        );\n        overlayCtx.stroke();\n\n        if (mustDrawFocusOnHeader) {\n            drawFocusRing(\n                overlayCtx,\n                width,\n                height,\n                cellYOffset,\n                translateX,\n                translateY,\n                effectiveCols,\n                mappedColumns,\n                theme,\n                totalHeaderHeight,\n                selection,\n                getRowHeight,\n                getCellContent,\n                trailingRowType,\n                fillHandle,\n                rows\n            );\n        }\n    };\n\n    // handle damage updates by directly drawing to the target to avoid large blits\n    if (damage !== undefined) {\n        let doHeaders = false;\n        damage = damage.filter(x => {\n            doHeaders = doHeaders || x[1] < 0;\n            return (\n                x[1] < 0 ||\n                intersectRect(cellXOffset, cellYOffset, effectiveCols.length, 300, x[0], x[1], 1, 1) ||\n                intersectRect(0, cellYOffset, freezeColumns, 300, x[0], x[1], 1, 1) ||\n                (trailingRowType && intersectRect(cellXOffset, rows - 1, effectiveCols.length, 1, x[0], x[1], 1, 1))\n            );\n        });\n\n        if (damage.length > 0) {\n            clipDamage(\n                targetCtx,\n                effectiveCols,\n                width,\n                height,\n                groupHeaderHeight,\n                totalHeaderHeight,\n                translateX,\n                translateY,\n                cellYOffset,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                damage,\n                true\n            );\n\n            targetCtx.fillStyle = theme.bgCell;\n            targetCtx.fillRect(0, totalHeaderHeight + 1, width, height - totalHeaderHeight - 1);\n\n            drawCells(\n                targetCtx,\n                effectiveCols,\n                mappedColumns,\n                height,\n                totalHeaderHeight,\n                translateX,\n                translateY,\n                cellYOffset,\n                rows,\n                getRowHeight,\n                getCellContent,\n                getGroupDetails,\n                getRowThemeOverride,\n                disabledRows,\n                isFocused,\n                drawFocus,\n                trailingRowType,\n                drawRegions,\n                damage,\n                selection,\n                prelightCells,\n                highlightRegions,\n                drawCustomCell,\n                imageLoader,\n                spriteManager,\n                hoverValues,\n                hoverInfo,\n                hyperWrapping,\n                theme,\n                enqueue,\n                getCellRenderer\n            );\n\n            if (\n                fillHandle &&\n                drawFocus &&\n                selection.current !== undefined &&\n                damage.some(x => x[0] === selection.current?.cell[0] && x[1] === selection.current?.cell[1])\n            ) {\n                drawFocusRing(\n                    targetCtx,\n                    width,\n                    height,\n                    cellYOffset,\n                    translateX,\n                    translateY,\n                    effectiveCols,\n                    mappedColumns,\n                    theme,\n                    totalHeaderHeight,\n                    selection,\n                    getRowHeight,\n                    getCellContent,\n                    trailingRowType,\n                    fillHandle,\n                    rows\n                );\n            }\n        }\n\n        if (doHeaders) {\n            clipDamage(\n                overlayCtx,\n                effectiveCols,\n                width,\n                totalHeaderHeight,\n                groupHeaderHeight,\n                totalHeaderHeight,\n                translateX,\n                translateY,\n                cellYOffset,\n                rows,\n                getRowHeight,\n                trailingRowType,\n                damage,\n                false\n            );\n            drawHeaderTexture();\n        }\n        targetCtx.restore();\n        overlayCtx.restore();\n\n        if (mainCtx !== null) {\n            mainCtx.fillStyle = theme.bgCell;\n            mainCtx.fillRect(0, 0, width, height);\n            mainCtx.drawImage(targetCtx.canvas, 0, 0);\n        }\n\n        return;\n    }\n\n    if (\n        canBlit !== true ||\n        cellXOffset !== last?.cellXOffset ||\n        translateX !== last?.translateX ||\n        mustDrawFocusOnHeader !== last?.mustDrawFocusOnHeader\n    ) {\n        drawHeaderTexture();\n    }\n\n    if (canBlit === true) {\n        assert(blitSource !== undefined && last !== undefined);\n        const { regions } = blitLastFrame(\n            targetCtx,\n            blitSource,\n            last,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            trailingRowType === \"sticky\",\n            width,\n            height,\n            rows,\n            totalHeaderHeight,\n            dpr,\n            mappedColumns,\n            effectiveCols,\n            rowHeight,\n            doubleBuffer\n        );\n        drawRegions = regions;\n    } else if (canBlit !== false) {\n        assert(last !== undefined);\n        const resizedCol = canBlit;\n        drawRegions = blitResizedCol(\n            last,\n            cellXOffset,\n            cellYOffset,\n            translateX,\n            translateY,\n            width,\n            height,\n            totalHeaderHeight,\n            effectiveCols,\n            resizedCol\n        );\n    }\n\n    overdrawStickyBoundaries(\n        targetCtx,\n        effectiveCols,\n        width,\n        height,\n        trailingRowType === \"sticky\",\n        rows,\n        verticalBorder,\n        getRowHeight,\n        theme\n    );\n\n    // the overdraw may have nuked out our focus ring right edge.\n    const focusRedraw = drawFocus\n        ? drawFocusRing(\n              targetCtx,\n              width,\n              height,\n              cellYOffset,\n              translateX,\n              translateY,\n              effectiveCols,\n              mappedColumns,\n              theme,\n              totalHeaderHeight,\n              selection,\n              getRowHeight,\n              getCellContent,\n              trailingRowType,\n              fillHandle,\n              rows\n          )\n        : undefined;\n\n    const highlightRedraw = drawHighlightRings(\n        targetCtx,\n        width,\n        height,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mappedColumns,\n        freezeColumns,\n        headerHeight,\n        groupHeaderHeight,\n        rowHeight,\n        trailingRowType === \"sticky\",\n        rows,\n        highlightRegions\n    );\n\n    targetCtx.fillStyle = theme.bgCell;\n    if (drawRegions.length > 0) {\n        targetCtx.beginPath();\n        for (const r of drawRegions) {\n            targetCtx.rect(r.x, r.y, r.width, r.height);\n        }\n        targetCtx.clip();\n        targetCtx.fill();\n        targetCtx.beginPath();\n    } else {\n        targetCtx.fillRect(0, 0, width, height);\n    }\n\n    const spans = drawCells(\n        targetCtx,\n        effectiveCols,\n        mappedColumns,\n        height,\n        totalHeaderHeight,\n        translateX,\n        translateY,\n        cellYOffset,\n        rows,\n        getRowHeight,\n        getCellContent,\n        getGroupDetails,\n        getRowThemeOverride,\n        disabledRows,\n        isFocused,\n        drawFocus,\n        trailingRowType,\n        drawRegions,\n        damage,\n        selection,\n        prelightCells,\n        highlightRegions,\n        drawCustomCell,\n        imageLoader,\n        spriteManager,\n        hoverValues,\n        hoverInfo,\n        hyperWrapping,\n        theme,\n        enqueue,\n        getCellRenderer\n    );\n\n    drawBlanks(\n        targetCtx,\n        effectiveCols,\n        mappedColumns,\n        width,\n        height,\n        totalHeaderHeight,\n        translateX,\n        translateY,\n        cellYOffset,\n        rows,\n        getRowHeight,\n        getRowThemeOverride,\n        selection.rows,\n        disabledRows,\n        trailingRowType,\n        drawRegions,\n        damage,\n        theme\n    );\n\n    drawGridLines(\n        targetCtx,\n        effectiveCols,\n        cellYOffset,\n        translateX,\n        translateY,\n        width,\n        height,\n        drawRegions,\n        spans,\n        groupHeaderHeight,\n        totalHeaderHeight,\n        getRowHeight,\n        getRowThemeOverride,\n        verticalBorder,\n        trailingRowType,\n        rows,\n        theme\n    );\n\n    focusRedraw?.();\n    highlightRedraw?.();\n\n    if (mainCtx !== null) {\n        mainCtx.fillStyle = theme.bgCell;\n        mainCtx.fillRect(0, 0, width, height);\n        mainCtx.drawImage(targetCtx.canvas, 0, 0);\n    }\n\n    const lastRowDrawn = getLastRow(\n        effectiveCols,\n        height,\n        totalHeaderHeight,\n        translateX,\n        translateY,\n        cellYOffset,\n        rows,\n        getRowHeight,\n        trailingRowType\n    );\n\n    imageLoader?.setWindow(\n        {\n            x: cellXOffset,\n            y: cellYOffset,\n            width: effectiveCols.length,\n            height: lastRowDrawn - cellYOffset,\n        },\n        freezeColumns\n    );\n\n    lastBlitData.current = {\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mustDrawFocusOnHeader,\n        lastBuffer: doubleBuffer ? (targetBuffer === bufferA ? \"a\" : \"b\") : undefined,\n    };\n\n    targetCtx.restore();\n    overlayCtx.restore();\n}\n\ntype WalkRowsCallback = (\n    drawY: number,\n    row: number,\n    rowHeight: number,\n    isSticky: boolean,\n    isTrailingRow: boolean\n) => boolean | void;\n\nfunction walkRowsInCol(\n    startRow: number,\n    drawY: number,\n    height: number,\n    rows: number,\n    getRowHeight: (row: number) => number,\n    trailingRowType: TrailingRowType,\n    cb: WalkRowsCallback\n): void {\n    let y = drawY;\n    let row = startRow;\n    let doSticky = trailingRowType === \"sticky\";\n    while (y < height || doSticky) {\n        const doingSticky = doSticky && y >= height;\n        if (doingSticky) {\n            doSticky = false;\n            row = rows - 1;\n        }\n        const rh = getRowHeight(row);\n\n        if (doingSticky) {\n            y = height - rh;\n        }\n\n        const isMovedStickyRow = doSticky && row === rows - 1;\n\n        if (!isMovedStickyRow && cb(y, row, rh, doingSticky, trailingRowType !== \"none\" && row === rows - 1) === true) {\n            break;\n        }\n\n        if (doingSticky) {\n            break;\n        }\n        y += rh;\n        row++;\n    }\n}\n\ntype WalkColsCallback = (\n    col: MappedGridColumn,\n    drawX: number,\n    drawY: number,\n    clipX: number,\n    startRow: number\n) => boolean | void;\n\nfunction walkColumns(\n    effectiveCols: readonly MappedGridColumn[],\n    cellYOffset: number,\n    translateX: number,\n    translateY: number,\n    totalHeaderHeight: number,\n    cb: WalkColsCallback\n): void {\n    let x = 0;\n    let clipX = 0; // this tracks the total width of sticky cols\n    const drawY = totalHeaderHeight + translateY;\n    for (const c of effectiveCols) {\n        const drawX = c.sticky ? clipX : x + translateX;\n        if (cb(c, drawX, drawY, clipX, cellYOffset) === true) {\n            break;\n        }\n\n        x += c.width;\n        clipX += c.sticky ? c.width : 0;\n    }\n}\n\ntype WalkGroupsCallback = (colSpan: Item, group: string, x: number, y: number, width: number, height: number) => void;\nfunction walkGroups(\n    effectiveCols: readonly MappedGridColumn[],\n    width: number,\n    translateX: number,\n    groupHeaderHeight: number,\n    cb: WalkGroupsCallback\n): void {\n    let x = 0;\n    let clipX = 0;\n    for (let index = 0; index < effectiveCols.length; index++) {\n        const startCol = effectiveCols[index];\n\n        let end = index + 1;\n        let boxWidth = startCol.width;\n        if (startCol.sticky) {\n            clipX += boxWidth;\n        }\n        while (\n            end < effectiveCols.length &&\n            isGroupEqual(effectiveCols[end].group, startCol.group) &&\n            effectiveCols[end].sticky === effectiveCols[index].sticky\n        ) {\n            const endCol = effectiveCols[end];\n            boxWidth += endCol.width;\n            end++;\n            index++;\n            if (endCol.sticky) {\n                clipX += endCol.width;\n            }\n        }\n\n        const t = startCol.sticky ? 0 : translateX;\n        const localX = x + t;\n        const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);\n        const w = Math.min(boxWidth - delta, width - (localX + delta));\n        cb(\n            [startCol.sourceIndex, effectiveCols[end - 1].sourceIndex],\n            startCol.group ?? \"\",\n            localX + delta,\n            0,\n            w,\n            groupHeaderHeight\n        );\n\n        x += boxWidth;\n    }\n}\n","// Shamelessly stolen from https://github.com/ricokahler/color2k\n// We don't need all the color functions but we deeply appreciate their work.\n\nconst cache: {\n    [color: string]: [number, number, number, number];\n} = {};\n\nlet div: HTMLDivElement | null = null;\n\nfunction createDiv() {\n    const d = document.createElement(\"div\");\n    d.style.opacity = \"0\";\n    d.style.pointerEvents = \"none\";\n    d.style.position = \"fixed\";\n    // div must be mounted for `getComputedStyle` to work\n    document.body.append(d);\n    return d;\n}\n\n/** @category Drawing */\nexport function parseToRgba(color: string): readonly [number, number, number, number] {\n    // normalize the color\n    const normalizedColor = color.toLowerCase().trim();\n\n    if (cache[normalizedColor] !== undefined) return cache[normalizedColor];\n\n    div = div || createDiv();\n\n    div.style.color = \"#000\";\n    div.style.color = normalizedColor;\n    const control = getComputedStyle(div).color;\n\n    div.style.color = \"#fff\";\n    div.style.color = normalizedColor;\n    const computedColor = getComputedStyle(div).color;\n\n    if (computedColor !== control) throw new Error(\"Could not parse color\");\n\n    const result = computedColor\n        // eslint-disable-next-line unicorn/better-regex\n        .replace(/[^\\d.,]/g, \"\")\n        .split(\",\")\n        .map(Number.parseFloat) as [number, number, number, number];\n\n    if (result.length < 4) {\n        result.push(1);\n    }\n\n    cache[normalizedColor] = result;\n    return result;\n}\n\n/** @category Drawing */\nexport function withAlpha(color: string, alpha: number): string {\n    const [r, g, b] = parseToRgba(color);\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\n\n/** @category Drawing */\nexport function blend(color: string, background: string | undefined): string {\n    if (background === undefined) return color;\n    const [r, g, b, a] = parseToRgba(color);\n    if (a === 1) return color;\n    const [br, bg, bb, ba] = parseToRgba(background);\n    const ao = a + ba * (1 - a);\n    // (xaA + xaB(1aA))/aR\n    const ro = (a * r + ba * br * (1 - a)) / ao;\n    const go = (a * g + ba * bg * (1 - a)) / ao;\n    const bo = (a * b + ba * bb * (1 - a)) / ao;\n    return `rgba(${ro}, ${go}, ${bo}, ${ao})`;\n}\n\n/** @category Drawing */\nexport function interpolateColors(leftColor: string, rightColor: string, val: number): string {\n    // toot toot im a GPU\n    if (val <= 0) return leftColor;\n    if (val >= 1) return rightColor;\n\n    // Parse to rgba returns straight alpha colors, for interpolation we want pre-multiplied alpha\n    const left = [...parseToRgba(leftColor)];\n    left[0] = left[0] * left[3];\n    left[1] = left[1] * left[3];\n    left[2] = left[2] * left[3];\n    const right = [...parseToRgba(rightColor)];\n    right[0] = right[0] * right[3];\n    right[1] = right[1] * right[3];\n    right[2] = right[2] * right[3];\n\n    const hScaler = val;\n    const nScaler = 1 - val;\n\n    const a = left[3] * nScaler + right[3] * hScaler;\n    // now we need to divide the alpha back out to get linear alpha back for the final result\n    const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);\n    const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);\n    const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);\n    return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n","import clamp from \"lodash/clamp.js\";\nimport type { Item } from \"./data-grid-types\";\n\ntype StateItem = { item: Item; hoverAmount: number };\nexport type HoverValues = readonly Readonly<StateItem>[];\nexport type StepCallback = (values: HoverValues) => void;\n\nconst hoverTime = 80;\n\nfunction easeOutCubic(x: number) {\n    const x1 = x - 1;\n    return x1 * x1 * x1 + 1;\n}\n\nexport class AnimationManager {\n    constructor(private callback: StepCallback) {}\n\n    private currentHoveredItem: StateItem | undefined = undefined;\n    private leavingItems: StateItem[] = [];\n\n    private lastAnimationTime: number | undefined;\n\n    private areSameItems = (left: Item | undefined, right: Item | undefined) => {\n        return left?.[0] === right?.[0] && left?.[1] === right?.[1];\n    };\n\n    private addToLeavingItems = (item: StateItem) => {\n        const isAlreadyLeaving = this.leavingItems.some(i => this.areSameItems(i.item, item.item));\n\n        if (isAlreadyLeaving) {\n            return;\n        }\n\n        this.leavingItems.push(item);\n    };\n\n    /**\n     * @returns the hover amount of the item, if it was leaving (0 if not).\n     */\n    private removeFromLeavingItems = (item: Item): number => {\n        const leavingItem = this.leavingItems.find(e => this.areSameItems(e.item, item));\n\n        this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);\n\n        return leavingItem?.hoverAmount ?? 0;\n    };\n\n    private cleanUpLeavingElements = () => {\n        this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);\n    };\n\n    private shouldStep = () => {\n        const hasLeavingItems = this.leavingItems.length > 0;\n        const currentHoveredIsAnimating =\n            this.currentHoveredItem !== undefined && this.currentHoveredItem.hoverAmount < 1;\n\n        return hasLeavingItems || currentHoveredIsAnimating;\n    };\n\n    private getAnimatingItems = (): StateItem[] => {\n        if (this.currentHoveredItem !== undefined) {\n            return [...this.leavingItems, this.currentHoveredItem];\n        }\n        return this.leavingItems.map(x => ({ ...x, hoverAmount: easeOutCubic(x.hoverAmount) }));\n    };\n\n    private step = (timestamp: number): void => {\n        if (this.lastAnimationTime === undefined) {\n            this.lastAnimationTime = timestamp;\n        } else {\n            const step = timestamp - this.lastAnimationTime;\n            const delta = step / hoverTime;\n\n            for (const item of this.leavingItems) {\n                item.hoverAmount = clamp(item.hoverAmount - delta, 0, 1);\n            }\n\n            if (this.currentHoveredItem !== undefined) {\n                this.currentHoveredItem.hoverAmount = clamp(this.currentHoveredItem.hoverAmount + delta, 0, 1);\n            }\n\n            const animating = this.getAnimatingItems();\n            this.callback(animating);\n\n            this.cleanUpLeavingElements();\n        }\n\n        if (this.shouldStep()) {\n            this.lastAnimationTime = timestamp;\n            window.requestAnimationFrame(this.step);\n        } else {\n            this.lastAnimationTime = undefined;\n        }\n    };\n\n    public setHovered = (item: Item | undefined): void => {\n        if (this.areSameItems(this.currentHoveredItem?.item, item)) {\n            return;\n        }\n\n        if (this.currentHoveredItem !== undefined) {\n            this.addToLeavingItems(this.currentHoveredItem);\n        }\n\n        if (item !== undefined) {\n            const hoverAmount = this.removeFromLeavingItems(item);\n            this.currentHoveredItem = {\n                item,\n                hoverAmount,\n            };\n        } else {\n            this.currentHoveredItem = undefined;\n        }\n\n        if (this.lastAnimationTime === undefined) {\n            window.requestAnimationFrame(this.step);\n        }\n    };\n}\n","class Lazy<T> {\n    private fn: () => T;\n    private val: T | undefined;\n    constructor(fn: () => T) {\n        this.fn = fn;\n    }\n\n    public get value() {\n        return this.val ?? (this.val = this.fn());\n    }\n}\n\nfunction lazy<T>(fn: () => T) {\n    return new Lazy(fn);\n}\n\n// next.js apps don't have window available at import time, so this will fail if its not lazy.\nexport const browserIsFirefox = lazy(() => window.navigator.userAgent.includes(\"Firefox\"));\nexport const browserIsSafari = lazy(\n    () =>\n        window.navigator.userAgent.includes(\"Mac OS\") &&\n        window.navigator.userAgent.includes(\"Safari\") &&\n        !window.navigator.userAgent.includes(\"Chrome\")\n);\nexport const browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith(\"mac\"));\n","import * as React from \"react\";\nimport type { Item } from \"./data-grid-types\";\n\nfunction hasItem(arr: readonly Item[], item: Item) {\n    for (const element of arr) {\n        if (element[0] === item[0] && element[1] === item[1]) return true;\n    }\n    return false;\n}\n\nexport function useAnimationQueue(draw: (items: readonly Item[]) => void) {\n    const queue = React.useRef<Item[]>([]);\n    const seq = React.useRef(0);\n    const drawRef = React.useRef(draw);\n    drawRef.current = draw;\n\n    const loop = React.useCallback(() => {\n        const requeue = () => window.requestAnimationFrame(fn);\n\n        const fn = () => {\n            const toDraw = queue.current;\n            queue.current = [];\n            drawRef.current(toDraw);\n            if (queue.current.length > 0) {\n                seq.current++;\n            } else {\n                seq.current = 0;\n            }\n        };\n\n        window.requestAnimationFrame(seq.current > 600 ? requeue : fn);\n    }, []);\n\n    return React.useCallback(\n        (item: Item) => {\n            if (hasItem(queue.current, item)) return;\n            if (queue.current.length === 0) {\n                loop();\n            }\n            queue.current.push(item);\n        },\n        [loop]\n    );\n}\n","import { styled } from \"@linaria/react\";\nimport type { Rectangle } from \"..\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"../common/resize-detector\";\nimport { browserIsSafari } from \"../common/browser-detect\";\nimport { useEventListener } from \"../common/utils\";\n\ninterface Props {\n    readonly className?: string;\n    readonly preventDiagonalScrolling?: boolean;\n    readonly draggable: boolean;\n    readonly paddingRight?: number;\n    readonly paddingBottom?: number;\n    readonly clientHeight: number;\n    readonly scrollWidth: number;\n    readonly scrollHeight: number;\n    readonly scrollToEnd?: boolean;\n    readonly initialScrollPosition?: readonly [scrollX: number, scrollY: number];\n    readonly initialSize?: readonly [width: number, height: number];\n    readonly rightElementProps?: {\n        readonly sticky?: boolean;\n        readonly fill?: boolean;\n    };\n    readonly rightElement?: React.ReactNode;\n    readonly minimap?: React.ReactNode;\n    readonly scrollRef?: React.MutableRefObject<HTMLDivElement | null>;\n    readonly update: (region: Rectangle & { paddingRight: number }) => void;\n}\n\nconst ScrollRegionStyle = styled.div<{ isSafari: boolean }>`\n    .dvn-scroller {\n        overflow: ${p => (p.isSafari ? \"scroll\" : \"auto\")};\n        transform: translate3d(0, 0, 0);\n    }\n\n    .hidden {\n        visibility: hidden;\n    }\n\n    .dvn-scroll-inner {\n        display: flex;\n        pointer-events: none;\n\n        > * {\n            flex-shrink: 0;\n        }\n\n        .dvn-spacer {\n            flex-grow: 1;\n        }\n\n        .dvn-stack {\n            display: flex;\n            flex-direction: column;\n        }\n    }\n\n    .dvn-underlay > * {\n        position: absolute;\n        left: 0;\n        top: 0;\n    }\n\n    canvas {\n        outline: none;\n\n        * {\n            height: 0;\n        }\n    }\n`;\n\ntype ScrollLock = [undefined, number] | [number, undefined] | undefined;\n\nfunction eatEvent(e: React.MouseEvent) {\n    e.stopPropagation();\n}\n\nfunction useTouchUpDelayed(delay: number): boolean {\n    const [hasTouches, setHasTouches] = React.useState(false);\n\n    const cbTimer = React.useRef(0);\n    useEventListener(\n        \"touchstart\",\n        React.useCallback(() => {\n            window.clearTimeout(cbTimer.current);\n            setHasTouches(true);\n        }, []),\n        window,\n        true,\n        false\n    );\n\n    useEventListener(\n        \"touchend\",\n        React.useCallback(\n            e => {\n                if (e.touches.length === 0) {\n                    cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\n                }\n            },\n            [delay]\n        ),\n        window,\n        true,\n        false\n    );\n\n    return hasTouches;\n}\n\nexport const InfiniteScroller: React.FC<Props> = p => {\n    const {\n        children,\n        clientHeight,\n        scrollHeight,\n        scrollWidth,\n        update,\n        draggable,\n        className,\n        preventDiagonalScrolling = false,\n        paddingBottom = 0,\n        paddingRight = 0,\n        rightElement,\n        rightElementProps,\n        scrollRef,\n        scrollToEnd,\n        initialSize,\n        minimap,\n    } = p;\n    const padders: React.ReactNode[] = [];\n\n    const rightElementSticky = rightElementProps?.sticky ?? false;\n    const rightElementFill = rightElementProps?.fill ?? false;\n\n    const offsetY = React.useRef(0);\n    const lastScrollY = React.useRef(0);\n    const scroller = React.useRef<HTMLDivElement | null>(null);\n\n    const dpr = window.devicePixelRatio;\n\n    React.useEffect(() => {\n        const el = scroller.current;\n        if (el === null || scrollToEnd !== true) return;\n\n        el.scrollLeft = el.scrollWidth - el.clientWidth;\n    }, [scrollToEnd]);\n\n    const lastScrollPosition = React.useRef({\n        scrollLeft: 0,\n        scrollTop: 0,\n        lockDirection: undefined as ScrollLock,\n    });\n\n    const rightWrapRef = React.useRef<HTMLDivElement | null>(null);\n\n    const hasTouches = useTouchUpDelayed(200);\n    const [isIdle, setIsIdle] = React.useState(true);\n    const idleTimer = React.useRef(0);\n\n    React.useEffect(() => {\n        if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;\n        const el = scroller.current;\n        if (el === null) return;\n        const [lx, ly] = lastScrollPosition.current.lockDirection;\n        if (lx !== undefined) {\n            el.scrollLeft = lx;\n        } else if (ly !== undefined) {\n            el.scrollTop = ly;\n        }\n        lastScrollPosition.current.lockDirection = undefined;\n    }, [hasTouches, isIdle]);\n\n    const onScroll = React.useCallback(() => {\n        const el = scroller.current;\n        if (el === null) return;\n\n        let scrollTop = el.scrollTop;\n        let scrollLeft = el.scrollLeft;\n        const lastScrollTop = lastScrollPosition.current.scrollTop;\n        const lastScrollLeft = lastScrollPosition.current.scrollLeft;\n\n        const dx = scrollLeft - lastScrollLeft;\n        const dy = scrollTop - lastScrollTop;\n\n        if (\n            hasTouches &&\n            dx !== 0 &&\n            dy !== 0 &&\n            (Math.abs(dx) > 3 || Math.abs(dy) > 3) &&\n            preventDiagonalScrolling &&\n            lastScrollPosition.current.lockDirection === undefined\n        ) {\n            lastScrollPosition.current.lockDirection =\n                Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];\n        }\n\n        const lock = lastScrollPosition.current.lockDirection;\n\n        scrollLeft = lock?.[0] ?? scrollLeft;\n        scrollTop = lock?.[1] ?? scrollTop;\n        lastScrollPosition.current.scrollLeft = scrollLeft;\n        lastScrollPosition.current.scrollTop = scrollTop;\n\n        const newY = scrollTop;\n        const delta = lastScrollY.current - newY;\n        const scrollableHeight = el.scrollHeight - el.clientHeight;\n        lastScrollY.current = newY;\n\n        if (\n            scrollableHeight > 0 &&\n            (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) &&\n            scrollHeight > el.scrollHeight + 5\n        ) {\n            const prog = newY / scrollableHeight;\n            const recomputed = (scrollHeight - el.clientHeight) * prog;\n            offsetY.current = recomputed - newY;\n        }\n\n        if (lock !== undefined) {\n            window.clearTimeout(idleTimer.current);\n            setIsIdle(false);\n            idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\n        }\n\n        update({\n            x: scrollLeft,\n            y: newY + offsetY.current,\n            width: el.clientWidth - paddingRight,\n            height: el.clientHeight - paddingBottom,\n            paddingRight: rightWrapRef.current?.clientWidth ?? 0,\n        });\n    }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\n\n    const onScrollRef = React.useRef(onScroll);\n    onScrollRef.current = onScroll;\n\n    const lastProps = React.useRef<{ width?: number; height?: number }>();\n\n    React.useEffect(() => {\n        onScroll();\n    }, [onScroll, paddingBottom, paddingRight]);\n\n    const setRefs = React.useCallback(\n        (instance: HTMLDivElement | null) => {\n            scroller.current = instance;\n            if (scrollRef !== undefined) {\n                scrollRef.current = instance;\n            }\n        },\n        [scrollRef]\n    );\n\n    let key = 0;\n    let h = 0;\n    padders.push(<div key={key++} style={{ width: scrollWidth, height: 0 }} />);\n    while (h < scrollHeight) {\n        const toAdd = Math.min(5_000_000, scrollHeight - h);\n        padders.push(<div key={key++} style={{ width: 0, height: toAdd }} />);\n        h += toAdd;\n    }\n\n    const { ref, width, height } = useResizeDetector<HTMLDivElement>(initialSize);\n\n    if (lastProps.current?.height !== height || lastProps.current?.width !== width) {\n        window.setTimeout(() => onScrollRef.current(), 0);\n        lastProps.current = { width, height };\n    }\n\n    if ((width ?? 0) === 0 || (height ?? 0) === 0) return <div ref={ref} />;\n\n    return (\n        <div ref={ref}>\n            <ScrollRegionStyle isSafari={browserIsSafari.value}>\n                {minimap}\n                <div className=\"dvn-underlay\">{children}</div>\n                <div\n                    ref={setRefs}\n                    style={lastProps.current}\n                    draggable={draggable}\n                    onDragStart={e => {\n                        if (!draggable) {\n                            e.stopPropagation();\n                            e.preventDefault();\n                        }\n                    }}\n                    className={\"dvn-scroller \" + (className ?? \"\")}\n                    onScroll={onScroll}>\n                    <div className={\"dvn-scroll-inner\" + (rightElement === undefined ? \" hidden\" : \"\")}>\n                        <div className=\"dvn-stack\">{padders}</div>\n                        {rightElement !== undefined && (\n                            <>\n                                {!rightElementFill && <div className=\"dvn-spacer\" />}\n                                <div\n                                    ref={rightWrapRef}\n                                    onMouseDown={eatEvent}\n                                    onMouseUp={eatEvent}\n                                    onMouseMove={eatEvent}\n                                    style={{\n                                        height,\n                                        maxHeight: clientHeight - Math.ceil(dpr % 1),\n                                        position: \"sticky\",\n                                        top: 0,\n                                        paddingLeft: 1,\n                                        marginBottom: -40,\n                                        marginRight: paddingRight,\n                                        flexGrow: rightElementFill ? 1 : undefined,\n                                        right: rightElementSticky ? paddingRight ?? 0 : undefined,\n                                        pointerEvents: \"auto\",\n                                    }}>\n                                    {rightElement}\n                                </div>\n                            </>\n                        )}\n                    </div>\n                </div>\n            </ScrollRegionStyle>\n        </div>\n    );\n};\n","/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { useLayoutEffect, useState, useRef, MutableRefObject } from \"react\";\ninterface ReactResizeDetectorDimensions {\n    height?: number;\n    width?: number;\n}\n\nexport function useResizeDetector<T extends HTMLElement = HTMLElement>(\n    initialSize?: readonly [width: number, height: number]\n): UseResizeDetectorReturn<T> {\n    const ref = useRef<T>(null);\n\n    const [size, setSize] = useState<ReactResizeDetectorDimensions>({\n        width: initialSize?.[0],\n        height: initialSize?.[1],\n    });\n\n    useLayoutEffect(() => {\n        const resizeCallback: ResizeObserverCallback = entries => {\n            for (const entry of entries) {\n                const { width, height } = (entry && entry.contentRect) || {};\n                setSize(cv => (cv.width === width && cv.height === height ? cv : { width, height }));\n            }\n        };\n\n        const resizeObserver = new window.ResizeObserver(resizeCallback);\n\n        if (ref.current) {\n            resizeObserver.observe(ref.current, undefined);\n        }\n\n        return () => {\n            resizeObserver.disconnect();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [ref.current]);\n\n    return { ref, ...size };\n}\n\nexport interface UseResizeDetectorReturn<T> extends ReactResizeDetectorDimensions {\n    ref: MutableRefObject<T | null>;\n}\n","import { styled } from \"@linaria/react\";\n\nexport const SearchWrapper = styled.div<{ showSearch: boolean }>`\n    position: absolute;\n    top: 4px;\n    right: 20px;\n\n    background-color: var(--gdg-bg-cell);\n    color: var(--gdg-text-dark);\n\n    padding: 8px;\n    border: 1px solid var(--gdg-border-color);\n    border-radius: 6px;\n\n    font-size: var(--gdg-editor-font-size);\n\n    transform: translateX(${p => (p.showSearch ? 0 : 400)}px);\n    transition: transform 0.15s;\n\n    .search-bar-inner {\n        display: flex;\n    }\n\n    .search-status {\n        padding-top: 4px;\n        font-size: 11px;\n    }\n\n    .search-progress {\n        position: absolute;\n        height: 4px;\n        left: 0;\n        bottom: 0;\n\n        background-color: var(--gdg-text-light);\n    }\n\n    input {\n        width: 220px;\n        color: var(--gdg-textDark);\n        background-color: var(--gdg-bg-cell);\n        border: none;\n        border-width: 0;\n        outline: none;\n    }\n\n    button {\n        width: 24px;\n        height: 24px;\n        padding: 0;\n\n        border: none;\n        outline: none;\n        background: none;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        cursor: pointer;\n        color: var(--gdg-text-medium);\n\n        :hover {\n            color: var(--gdg-text-dark);\n        }\n\n        .button-icon {\n            width: 16px;\n            height: 16px;\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n`;\n","import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { css } from \"@linaria/core\";\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly bounds: Rectangle;\n    readonly group: string;\n    readonly onClose: () => void;\n    readonly onFinish: (newVal: string) => void;\n    readonly canvasBounds: DOMRect;\n}\n\nconst RenameInput = styled.input<{ targetHeight: number }>`\n    flex-grow: 1;\n    border: none;\n    outline: none;\n    background-color: var(--gdg-bg-header-has-focus);\n    border-radius: 9px;\n    padding: 0 8px;\n    box-shadow: 0 0 0 1px var(--gdg-border-color);\n    color: var(--gdg-text-group-header);\n    min-height: ${p => Math.max(16, p.targetHeight - 10)}px;\n    font: var(--gdg-header-font-style) var(--gdg-font-family);\n`;\n\nexport const GroupRename: React.VFC<Props> = p => {\n    const { bounds, group, onClose, canvasBounds, onFinish } = p;\n\n    const [value, setValue] = React.useState(group);\n\n    return (\n        <ClickOutsideContainer\n            style={{\n                position: \"absolute\",\n                left: bounds.x - canvasBounds.left + 1,\n                top: bounds.y - canvasBounds.top,\n                width: bounds.width - 2,\n                height: bounds.height,\n            }}\n            className={css`\n                padding: 0 8px;\n                display: flex;\n                align-items: center;\n                background-color: var(--gdg-bg-header);\n            `}\n            onClickOutside={onClose}>\n            <RenameInput\n                targetHeight={bounds.height}\n                data-testid=\"group-rename-input\"\n                value={value}\n                onBlur={onClose}\n                onFocus={e => e.target.setSelectionRange(0, value.length)}\n                onChange={e => setValue(e.target.value)}\n                onKeyDown={e => {\n                    if (e.key === \"Enter\") {\n                        onFinish(value);\n                    } else if (e.key === \"Escape\") {\n                        onClose();\n                    }\n                }}\n                autoFocus={true}\n            />\n        </ClickOutsideContainer>\n    );\n};\n","import * as React from \"react\";\nimport type { Theme } from \"../common/styles\";\nimport type { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport {\n    CellArray,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    InnerGridColumn,\n    isSizedGridColumn,\n    resolveCellsThunk,\n    SizedGridColumn,\n} from \"../data-grid/data-grid-types\";\n\nconst defaultSize = 150;\n\nfunction measureCell(\n    ctx: CanvasRenderingContext2D,\n    cell: GridCell,\n    theme: Theme,\n    getCellRenderer: GetCellRendererCallback\n): number {\n    if (cell.kind === GridCellKind.Custom) return defaultSize;\n\n    const r = getCellRenderer(cell);\n    return r?.measure?.(ctx, cell, theme) ?? defaultSize;\n}\n\nexport function measureColumn(\n    ctx: CanvasRenderingContext2D,\n    theme: Theme,\n    c: GridColumn,\n    colIndex: number,\n    selectedData: CellArray,\n    minColumnWidth: number,\n    maxColumnWidth: number,\n    removeOutliers: boolean,\n    getCellRenderer: GetCellRendererCallback\n): SizedGridColumn {\n    let sizes: number[] = [];\n    if (selectedData !== undefined) {\n        sizes.push(\n            ...selectedData.map(row => row[colIndex]).map(cell => measureCell(ctx, cell, theme, getCellRenderer))\n        );\n    }\n    if (sizes.length > 5 && removeOutliers) {\n        // Filter out outliers\n        const average = sizes.reduce((a, b) => a + b) / sizes.length;\n        sizes = sizes.filter(a => a < average * 2);\n    }\n    sizes.push(ctx.measureText(c.title).width + 16 + (c.icon === undefined ? 0 : 28));\n    const biggest = Math.max(...sizes);\n    const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(biggest)));\n\n    return {\n        ...c,\n        width: final,\n    };\n}\n\n/** @category Hooks */\nexport function useColumnSizer(\n    columns: readonly GridColumn[],\n    rows: number,\n    getCellsForSelection: DataGridSearchProps[\"getCellsForSelection\"],\n    clientWidth: number,\n    minColumnWidth: number,\n    maxColumnWidth: number,\n    theme: Theme,\n    getCellRenderer: GetCellRendererCallback,\n    abortController: AbortController\n): readonly InnerGridColumn[] {\n    const rowsRef = React.useRef(rows);\n    const getCellsForSelectionRef = React.useRef(getCellsForSelection);\n    const themeRef = React.useRef(theme);\n    rowsRef.current = rows;\n    getCellsForSelectionRef.current = getCellsForSelection;\n    themeRef.current = theme;\n\n    const [ctx] = React.useState(() => {\n        const offscreen = document.createElement(\"canvas\");\n        return offscreen.getContext(\"2d\", { alpha: false });\n    });\n\n    const memoMap = React.useRef<Record<string, number>>({});\n\n    const lastColumns = React.useRef<typeof columns>();\n    const [selectedData, setSelectionData] = React.useState<CellArray | undefined>();\n\n    React.useLayoutEffect(() => {\n        const getCells = getCellsForSelectionRef.current;\n        if (getCells === undefined || columns.every(isSizedGridColumn)) return;\n        let computeRows = Math.max(1, 10 - Math.floor(columns.length / 10_000));\n        let tailRows = 0;\n        if (computeRows < rowsRef.current && computeRows > 1) {\n            computeRows--;\n            tailRows = 1;\n        }\n\n        const computeArea = {\n            x: 0,\n            y: 0,\n            width: columns.length,\n            height: Math.min(rowsRef.current, computeRows),\n        };\n\n        const tailComputeArea = {\n            x: 0,\n            y: rowsRef.current - 1,\n            width: columns.length,\n            height: 1,\n        };\n        const fn = async () => {\n            const getResult = getCells(computeArea, abortController.signal);\n            const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : undefined;\n            let toSet: CellArray;\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (typeof getResult === \"object\") {\n                toSet = getResult;\n            } else {\n                toSet = await resolveCellsThunk(getResult);\n            }\n            if (tailGetResult !== undefined) {\n                // eslint-disable-next-line unicorn/prefer-ternary\n                if (typeof tailGetResult === \"object\") {\n                    toSet = [...toSet, ...tailGetResult];\n                } else {\n                    toSet = [...toSet, ...(await resolveCellsThunk(tailGetResult))];\n                }\n            }\n            lastColumns.current = columns;\n            setSelectionData(toSet);\n        };\n        void fn();\n    }, [abortController.signal, columns]);\n\n    return React.useMemo(() => {\n        const getRaw = () => {\n            if (columns.every(isSizedGridColumn)) {\n                return columns;\n            }\n\n            if (ctx === null) {\n                return columns.map(c => {\n                    if (isSizedGridColumn(c)) return c;\n\n                    return {\n                        ...c,\n                        width: defaultSize,\n                    };\n                });\n            }\n\n            ctx.font = `${themeRef.current.baseFontStyle} ${themeRef.current.fontFamily}`;\n\n            return columns.map((c, colIndex) => {\n                if (isSizedGridColumn(c)) return c;\n\n                if (memoMap.current[c.id] !== undefined) {\n                    return {\n                        ...c,\n                        width: memoMap.current[c.id],\n                    };\n                }\n\n                if (selectedData === undefined || lastColumns.current !== columns || c.id === undefined) {\n                    return {\n                        ...c,\n                        width: defaultSize,\n                    };\n                }\n\n                const r = measureColumn(\n                    ctx,\n                    theme,\n                    c,\n                    colIndex,\n                    selectedData,\n                    minColumnWidth,\n                    maxColumnWidth,\n                    true,\n                    getCellRenderer\n                );\n                memoMap.current[c.id] = r.width;\n                return r;\n            });\n        };\n\n        let result: readonly InnerGridColumn[] = getRaw();\n        let totalWidth = 0;\n        let totalGrow = 0;\n        const distribute: number[] = [];\n        for (const [i, c] of result.entries()) {\n            totalWidth += c.width;\n            if (c.grow !== undefined && c.grow > 0) {\n                totalGrow += c.grow;\n                distribute.push(i);\n            }\n        }\n        if (totalWidth < clientWidth && distribute.length > 0) {\n            const writeable = [...result];\n            const extra = clientWidth - totalWidth;\n            let remaining = extra;\n            for (let di = 0; di < distribute.length; di++) {\n                const i = distribute[di];\n                const weighted = (result[i].grow ?? 0) / totalGrow;\n                const toAdd =\n                    di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));\n                writeable[i] = {\n                    ...result[i],\n                    growOffset: toAdd,\n                    width: result[i].width + toAdd,\n                };\n                remaining -= toAdd;\n            }\n            result = writeable;\n        }\n        return result;\n    }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);\n}\n","import type { GridKeyEventArgs } from \"../data-grid/data-grid-types\";\nimport { browserIsOSX } from \"./browser-detect\";\n\n// brain dead syntax, find your deps, and make buggy replacements with 5 times the effort\n// all lower case\n// ctrl+shift+alt+d or ctrl+x or shift+c or shift+Backspace or alt+_53\n// you get it, last one is always event.key, nothing fancy\n// special: primary === ctrl on windows, meta on mac\n// no to lower, its a waste, we're the only consumer, don't use caps\n\n// and before you ask, yes space is \" \", e.g. \"ctrl+alt+ \", whatacountry.gif\n// load bearing whitespace, it's basically python\n// if the char starts with a _ it is the event.keycode instead\nfunction checkKey(key: string | undefined, args: GridKeyEventArgs): boolean {\n    if (key === undefined) return false;\n    if (key.length > 1 && key.startsWith(\"_\")) {\n        const keycode = Number.parseInt(key.slice(1));\n        if (keycode !== args.keyCode) return false;\n    } else {\n        if (key !== args.key) return false;\n    }\n    return true;\n}\nexport function isHotkey(hotkey: string, args: GridKeyEventArgs): boolean {\n    if (hotkey.length === 0) return false;\n    let wantCtrl = false;\n    let wantShift = false;\n    let wantAlt = false;\n    let wantMeta = false;\n    const split = hotkey.split(\"+\");\n    const key = split.pop();\n    if (!checkKey(key, args)) return false;\n    for (const accel of split) {\n        switch (accel) {\n            case \"ctrl\":\n                wantCtrl = true;\n                break;\n            case \"shift\":\n                wantShift = true;\n                break;\n            case \"alt\":\n                wantAlt = true;\n                break;\n            case \"meta\":\n                wantMeta = true;\n                break;\n            case \"primary\":\n                if (browserIsOSX.value) {\n                    wantMeta = true;\n                } else {\n                    wantCtrl = true;\n                }\n                break;\n        }\n    }\n\n    return (\n        args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta\n    );\n}\n","import React from \"react\";\nimport { CompactSelection, GridSelection, Slice } from \"./data-grid-types\";\n\ntype SetCallback = (newVal: GridSelection, expand: boolean) => void;\n\nexport type SelectionBlending = \"exclusive\" | \"mixed\";\n\ntype SelectionTrigger = \"click\" | \"drag\" | \"keyboard-nav\" | \"keyboard-select\" | \"edit\";\n\nexport function useSelectionBehavior(\n    gridSelection: GridSelection,\n    setGridSelection: SetCallback,\n    rangeBehavior: SelectionBlending,\n    columnBehavior: SelectionBlending,\n    rowBehavior: SelectionBlending,\n    rangeSelect: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\"\n) {\n    // if append is true, the current range will be added to the rangeStack\n    const setCurrent = React.useCallback(\n        (\n            value: Pick<NonNullable<GridSelection[\"current\"]>, \"cell\" | \"range\"> | undefined,\n            expand: boolean,\n            append: boolean,\n            trigger: SelectionTrigger\n        ) => {\n            if ((rangeSelect === \"cell\" || rangeSelect === \"multi-cell\") && value !== undefined) {\n                value = {\n                    ...value,\n                    range: {\n                        x: value.cell[0],\n                        y: value.cell[1],\n                        width: 1,\n                        height: 1,\n                    },\n                };\n            }\n            const rangeMixable = rangeBehavior === \"mixed\" && (append || trigger === \"drag\");\n            const allowColumnCoSelect = columnBehavior === \"mixed\" && rangeMixable;\n            const allowRowCoSelect = rowBehavior === \"mixed\" && rangeMixable;\n            let newVal: GridSelection = {\n                current:\n                    value === undefined\n                        ? undefined\n                        : {\n                              ...value,\n                              rangeStack: trigger === \"drag\" ? gridSelection.current?.rangeStack ?? [] : [],\n                          },\n                columns: allowColumnCoSelect ? gridSelection.columns : CompactSelection.empty(),\n                rows: allowRowCoSelect ? gridSelection.rows : CompactSelection.empty(),\n            };\n\n            const addLastRange = append && (rangeSelect === \"multi-rect\" || rangeSelect === \"multi-cell\");\n            if (addLastRange && newVal.current !== undefined && gridSelection.current !== undefined) {\n                newVal = {\n                    ...newVal,\n                    current: {\n                        ...newVal.current,\n                        rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range],\n                    },\n                };\n            }\n            setGridSelection(newVal, expand);\n        },\n        [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]\n    );\n\n    const setSelectedRows = React.useCallback(\n        (newRows: CompactSelection | undefined, append: Slice | number | undefined, allowMixed: boolean): void => {\n            newRows = newRows ?? gridSelection.rows;\n            if (append !== undefined) {\n                newRows = newRows.add(append);\n            }\n            let newVal: GridSelection;\n            if (rowBehavior === \"exclusive\" && newRows.length > 0) {\n                newVal = {\n                    current: undefined,\n                    columns: CompactSelection.empty(),\n                    rows: newRows,\n                };\n            } else {\n                const rangeMixed = allowMixed && rangeBehavior === \"mixed\";\n                const columnMixed = allowMixed && columnBehavior === \"mixed\";\n                const current = !rangeMixed ? undefined : gridSelection.current;\n                newVal = {\n                    current,\n                    columns: columnMixed ? gridSelection.columns : CompactSelection.empty(),\n                    rows: newRows,\n                };\n            }\n            setGridSelection(newVal, false);\n        },\n        [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]\n    );\n\n    const setSelectedColumns = React.useCallback(\n        (newCols: CompactSelection | undefined, append: number | Slice | undefined, allowMixed: boolean): void => {\n            newCols = newCols ?? gridSelection.columns;\n            if (append !== undefined) {\n                newCols = newCols.add(append);\n            }\n            let newVal: GridSelection;\n            if (columnBehavior === \"exclusive\" && newCols.length > 0) {\n                newVal = {\n                    current: undefined,\n                    rows: CompactSelection.empty(),\n                    columns: newCols,\n                };\n            } else {\n                const rangeMixed = allowMixed && rangeBehavior === \"mixed\";\n                const rowMixed = allowMixed && rowBehavior === \"mixed\";\n                const current = !rangeMixed ? undefined : gridSelection.current;\n                newVal = {\n                    current,\n                    rows: rowMixed ? gridSelection.rows : CompactSelection.empty(),\n                    columns: newCols,\n                };\n            }\n            setGridSelection(newVal, false);\n        },\n        [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]\n    );\n\n    return [setCurrent, setSelectedRows, setSelectedColumns] as const;\n}\n","import * as React from \"react\";\nimport type { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport { CellArray, GridCell, GridCellKind } from \"../data-grid/data-grid-types\";\nimport type { DataEditorProps } from \"./data-editor\";\n\ntype CellsForSelectionCallback = NonNullable<DataGridSearchProps[\"getCellsForSelection\"]>;\nexport function useCellsForSelection(\n    getCellsForSelectionIn: CellsForSelectionCallback | true | undefined,\n    getCellContent: DataEditorProps[\"getCellContent\"],\n    rowMarkerOffset: number,\n    abortController: AbortController\n) {\n    const getCellsForSelectionDirectWhenValid = React.useCallback<CellsForSelectionCallback>(\n        rect => {\n            if (getCellsForSelectionIn === true) {\n                const result: GridCell[][] = [];\n\n                for (let y = rect.y; y < rect.y + rect.height; y++) {\n                    const row: GridCell[] = [];\n                    for (let x = rect.x; x < rect.x + rect.width; x++) {\n                        if (x < 0) {\n                            row.push({\n                                kind: GridCellKind.Loading,\n                                allowOverlay: false,\n                            });\n                        } else {\n                            row.push(getCellContent([x, y]));\n                        }\n                    }\n                    result.push(row);\n                }\n\n                return result;\n            }\n            return getCellsForSelectionIn?.(rect, abortController.signal) ?? [];\n        },\n        [abortController.signal, getCellContent, getCellsForSelectionIn]\n    );\n    const getCellsForSelectionDirect =\n        getCellsForSelectionIn !== undefined ? getCellsForSelectionDirectWhenValid : undefined;\n    const getCellsForSelectionMangled = React.useCallback<CellsForSelectionCallback>(\n        rect => {\n            if (getCellsForSelectionDirect === undefined) return [];\n            const newRect = {\n                ...rect,\n                x: rect.x - rowMarkerOffset,\n            };\n            if (newRect.x < 0) {\n                newRect.x = 0;\n                newRect.width--;\n                const r = getCellsForSelectionDirect(newRect, abortController.signal);\n\n                if (typeof r === \"function\") {\n                    return async () =>\n                        // eslint-disable-next-line unicorn/no-await-expression-member\n                        (await r()).map<CellArray[0]>(row => [\n                            { kind: GridCellKind.Loading, allowOverlay: false },\n                            ...row,\n                        ]);\n                }\n                return r.map(row => [{ kind: GridCellKind.Loading, allowOverlay: false }, ...row]);\n            }\n            return getCellsForSelectionDirect(newRect, abortController.signal);\n        },\n        [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]\n    );\n\n    const getCellsForSelection = getCellsForSelectionIn !== undefined ? getCellsForSelectionMangled : undefined;\n\n    return [getCellsForSelection, getCellsForSelectionDirect] as const;\n}\n","import { assertNever } from \"../common/support\";\nimport type { DataGridSearchProps } from \"../data-grid-search/data-grid-search\";\nimport {\n    BooleanEmpty,\n    BooleanIndeterminate,\n    GridCell,\n    GridCellKind,\n    GridSelection,\n    Rectangle,\n} from \"../data-grid/data-grid-types\";\n\nexport function expandSelection(\n    newVal: GridSelection,\n    getCellsForSelection: DataGridSearchProps[\"getCellsForSelection\"],\n    rowMarkerOffset: number,\n    spanRangeBehavior: \"allowPartial\" | \"default\",\n    abortController: AbortController\n): GridSelection {\n    const origVal = newVal;\n    if (spanRangeBehavior === \"allowPartial\" || newVal.current === undefined) return newVal;\n    if (getCellsForSelection !== undefined) {\n        let isFilled = false;\n        do {\n            if (newVal?.current === undefined) break;\n            const r: Rectangle = newVal.current?.range;\n            const cells: (readonly GridCell[])[] = [];\n            if (r.width > 2) {\n                const leftCells = getCellsForSelection(\n                    {\n                        x: r.x,\n                        y: r.y,\n                        width: 1,\n                        height: r.height,\n                    },\n                    abortController.signal\n                );\n\n                if (typeof leftCells === \"function\") {\n                    return origVal;\n                }\n\n                cells.push(...leftCells);\n\n                const rightCells = getCellsForSelection(\n                    {\n                        x: r.x + r.width - 1,\n                        y: r.y,\n                        width: 1,\n                        height: r.height,\n                    },\n                    abortController.signal\n                );\n\n                if (typeof rightCells === \"function\") {\n                    return origVal;\n                }\n\n                cells.push(...rightCells);\n            } else {\n                const rCells = getCellsForSelection(\n                    {\n                        x: r.x,\n                        y: r.y,\n                        width: r.width,\n                        height: r.height,\n                    },\n                    abortController.signal\n                );\n                if (typeof rCells === \"function\") {\n                    return origVal;\n                }\n                cells.push(...rCells);\n            }\n\n            let left = r.x - rowMarkerOffset;\n            let right = r.x + r.width - 1 - rowMarkerOffset;\n            for (const row of cells) {\n                for (const cell of row) {\n                    if (cell.span === undefined) continue;\n                    left = Math.min(cell.span[0], left);\n                    right = Math.max(cell.span[1], right);\n                }\n            }\n\n            if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {\n                isFilled = true;\n            } else {\n                newVal = {\n                    current: {\n                        cell: newVal.current.cell ?? [0, 0],\n                        range: {\n                            x: left + rowMarkerOffset,\n                            y: r.y,\n                            width: right - left + 1,\n                            height: r.height,\n                        },\n                        rangeStack: newVal.current.rangeStack,\n                    },\n                    columns: newVal.columns,\n                    rows: newVal.rows,\n                };\n            }\n        } while (!isFilled);\n    }\n    return newVal;\n}\n\nfunction descape(s: string): string {\n    if (s.startsWith('\"') && s.endsWith('\"')) {\n        s = s.slice(1, -1).replace(/\"\"/g, '\"');\n    }\n    return s;\n}\n\nexport function unquote(str: string): string[][] {\n    const enum State {\n        None,\n        inString,\n        inStringPostQuote,\n    }\n\n    const result: string[][] = [];\n    let current: string[] = [];\n\n    let start = 0;\n    let state = State.None;\n    str = str.replace(/\\r\\n/g, \"\\n\");\n    let index = 0;\n    for (const char of str) {\n        switch (state) {\n            case State.None:\n                if (char === \"\\t\" || char === \"\\n\") {\n                    current.push(str.slice(start, index));\n                    start = index + 1;\n\n                    if (char === \"\\n\") {\n                        result.push(current);\n                        current = [];\n                    }\n                } else if (char === `\"`) {\n                    state = State.inString;\n                }\n                break;\n            case State.inString:\n                if (char === `\"`) {\n                    state = State.inStringPostQuote;\n                }\n                break;\n            case State.inStringPostQuote:\n                if (char === '\"') {\n                    state = State.inString;\n                } else if (char === \"\\t\" || char === \"\\n\") {\n                    current.push(descape(str.slice(start, index)));\n                    start = index + 1;\n\n                    if (char === \"\\n\") {\n                        result.push(current);\n                        current = [];\n                    }\n                    state = State.None;\n                } else {\n                    state = State.None;\n                }\n                break;\n        }\n\n        index++;\n    }\n    if (start < str.length) {\n        current.push(descape(str.slice(start, str.length)));\n    }\n    result.push(current);\n    return result;\n}\n\nexport function decodeHTML(tableEl: HTMLTableElement): string[][] | undefined {\n    const walkEl: Element[] = [tableEl];\n    const result: string[][] = [];\n    let current: string[] | undefined;\n\n    while (walkEl.length > 0) {\n        const el = walkEl.pop();\n\n        if (el === undefined) break;\n\n        if (el instanceof HTMLTableElement || el.nodeName === \"TBODY\") {\n            walkEl.push(...[...el.children].reverse());\n        } else if (el instanceof HTMLTableRowElement) {\n            if (current !== undefined) {\n                result.push(current);\n            }\n            current = [];\n            walkEl.push(...[...el.children].reverse());\n        } else if (el instanceof HTMLTableCellElement) {\n            current?.push(el.innerText ?? el.textContent ?? \"\");\n        }\n    }\n\n    if (current !== undefined) {\n        result.push(current);\n    }\n\n    return result;\n}\n\nfunction escape(str: string): string {\n    if (/[\\t\\n\"]/.test(str)) {\n        str = `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n}\n\nconst formatBoolean = (val: boolean | BooleanEmpty | BooleanIndeterminate): string => {\n    switch (val) {\n        case true:\n            return \"TRUE\";\n\n        case false:\n            return \"FALSE\";\n\n        case BooleanIndeterminate:\n            return \"INDETERMINATE\";\n\n        case BooleanEmpty:\n            return \"\";\n\n        default:\n            assertNever(val);\n    }\n};\n\nexport function copyToClipboard(\n    cells: readonly (readonly GridCell[])[],\n    columnIndexes: readonly number[],\n    e?: ClipboardEvent\n) {\n    const formatCell = (cell: GridCell, index: number, raw: boolean): string => {\n        const colIndex = columnIndexes[index];\n        if (cell.span !== undefined && cell.span[0] !== colIndex) return \"\";\n        switch (cell.kind) {\n            case GridCellKind.Text:\n            case GridCellKind.Number:\n                return escape(raw ? cell.data?.toString() ?? \"\" : cell.displayData);\n            case GridCellKind.Markdown:\n            case GridCellKind.RowID:\n            case GridCellKind.Uri:\n                return escape(cell.data);\n            case GridCellKind.Image:\n            case GridCellKind.Bubble:\n                return cell.data.reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);\n            case GridCellKind.Boolean:\n                return formatBoolean(cell.data);\n            case GridCellKind.Loading:\n                return raw ? \"\" : \"#LOADING\";\n            case GridCellKind.Protected:\n                return raw ? \"\" : \"************\";\n            case GridCellKind.Drilldown:\n                return cell.data.map(i => i.text).reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);\n            case GridCellKind.Custom:\n                return escape(cell.copyData);\n            default:\n                assertNever(cell);\n        }\n    };\n\n    const str = cells.map(row => row.map((a, b) => formatCell(a, b, false)).join(\"\\t\")).join(\"\\n\");\n\n    if (window.navigator.clipboard?.write !== undefined || e !== undefined) {\n        const rootEl = document.createElement(\"tbody\");\n\n        for (const row of cells) {\n            const rowEl = document.createElement(\"tr\");\n\n            for (const [i, cell] of row.entries()) {\n                const cellEl = document.createElement(\"td\");\n                if (cell.kind === GridCellKind.Uri) {\n                    const link = document.createElement(\"a\");\n                    link.href = cell.data;\n                    link.innerText = cell.data;\n                    cellEl.append(link);\n                } else {\n                    cellEl.innerText = formatCell(cell, i, true);\n                }\n                rowEl.append(cellEl);\n            }\n\n            rootEl.append(rowEl);\n        }\n        if (window.navigator.clipboard?.write !== undefined) {\n            void window.navigator.clipboard.write([\n                new ClipboardItem({\n                    \"text/plain\": new Blob([str], { type: \"text/plain\" }),\n                    \"text/html\": new Blob([`<table>${rootEl.outerHTML}</table>`], { type: \"text/html\" }),\n                }),\n            ]);\n        } else if (e !== undefined && e?.clipboardData !== null) {\n            try {\n                // This might fail if we had to await the thunk\n                e.clipboardData.setData(\"text/plain\", str);\n                e.clipboardData.setData(\"text/html\", `<table>${rootEl.outerHTML}</table>`);\n            } catch {\n                void window.navigator.clipboard?.writeText(str);\n            }\n        }\n    } else {\n        void window.navigator.clipboard?.writeText(str);\n    }\n\n    e?.preventDefault();\n}\n","import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\n\ninterface WrapperProps {\n    inWidth: number | string;\n    inHeight: number | string;\n}\n\nfunction toCss(x: number | string) {\n    if (typeof x === \"string\") return x;\n    return `${x}px`;\n}\n\nconst Wrapper = styled.div<{ innerWidth: string; innerHeight: string }>`\n    position: relative;\n\n    min-width: 10px;\n    min-height: 10px;\n    max-width: 100%;\n    max-height: 100%;\n\n    width: ${p => p.innerWidth};\n    height: ${p => p.innerHeight};\n\n    overflow: hidden;\n    overflow: clip;\n\n    contain: strict;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\ninterface Props extends WrapperProps, React.HTMLAttributes<HTMLDivElement> {}\n\nexport const DataEditorContainer: React.FunctionComponent<React.PropsWithChildren<Props>> = p => {\n    const { inWidth, inHeight, children, ...rest } = p;\n    return (\n        <Wrapper innerHeight={toCss(inHeight)} innerWidth={toCss(inWidth)} {...rest}>\n            {children}\n        </Wrapper>\n    );\n};\n","import { drawBoolean } from \"../data-grid-lib\";\nimport {\n    GridCellKind,\n    BooleanCell,\n    booleanCellIsEditable,\n    BooleanEmpty,\n    BooleanIndeterminate,\n} from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\n/**\n * Checkbox behavior:\n *\n * true + click -> unchecked\n * false + click -> checked\n * indeterminate + click -> checked\n * empty + click -> checked\n */\nexport function toggleBoolean(data: boolean | null | undefined): boolean | null | undefined {\n    return data !== true;\n}\n\nexport const booleanCellRenderer: InternalCellRenderer<BooleanCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"false\",\n    kind: GridCellKind.Boolean,\n    needsHover: true,\n    useLabel: false,\n    needsHoverPosition: true,\n    measure: () => 50,\n    draw: a => drawBoolean(a, a.cell.data, booleanCellIsEditable(a.cell)),\n    onDelete: c => ({\n        ...c,\n        data: false,\n    }),\n    onClick: e => {\n        const { cell, posX: x, posY: y, bounds } = e;\n        if (\n            booleanCellIsEditable(cell) &&\n            Math.abs(x - bounds.width / 2) <= 10 &&\n            Math.abs(y - bounds.height / 2) <= 10\n        ) {\n            return {\n                ...cell,\n                data: toggleBoolean(cell.data),\n            };\n        }\n        return undefined;\n    },\n    onPaste: (toPaste, cell) => {\n        let newVal: boolean | BooleanEmpty | BooleanIndeterminate = BooleanEmpty;\n        if (toPaste.toLowerCase() === \"true\") {\n            newVal = true;\n        } else if (toPaste.toLowerCase() === \"false\") {\n            newVal = false;\n        } else if (toPaste.toLowerCase() === \"indeterminate\") {\n            newVal = BooleanIndeterminate;\n        }\n        return newVal === cell.data\n            ? undefined\n            : {\n                  ...cell,\n                  data: newVal,\n              };\n    },\n};\n","import React from \"react\";\nimport type { GridMouseCellEventArgs } from \"../data-grid/data-grid-types\";\n\nconst maxPxPerMs = 2;\nconst msToFullSpeed = 1300;\n\nexport function useAutoscroll(\n    scrollDirection: GridMouseCellEventArgs[\"scrollEdge\"] | undefined,\n    scrollRef: React.MutableRefObject<HTMLDivElement | null>\n) {\n    const speedScalar = React.useRef(0);\n    const [xDir, yDir] = scrollDirection ?? [0, 0];\n    React.useEffect(() => {\n        if (xDir === 0 && yDir === 0) {\n            speedScalar.current = 0;\n            return;\n        }\n\n        let lastTime = 0;\n        const scrollFn = (curTime: number) => {\n            if (lastTime === 0) {\n                lastTime = curTime;\n            } else {\n                const step = curTime - lastTime;\n                speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);\n                const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;\n                scrollRef.current?.scrollBy(xDir * motion, yDir * motion);\n                lastTime = curTime;\n            }\n            t = window.requestAnimationFrame(scrollFn);\n        };\n        let t = window.requestAnimationFrame(scrollFn);\n        return () => window.cancelAnimationFrame(t);\n    }, [scrollRef, xDir, yDir]);\n}\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport BubblesOverlayEditor from \"../../data-grid-overlay-editor/private/bubbles-overlay-editor\";\nimport { drawBubbles } from \"../data-grid-lib\";\nimport { GridCellKind, BubbleCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const bubbleCellRenderer: InternalCellRenderer<BubbleCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Bubble,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: (ctx, cell, t) =>\n        cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,\n    draw: a => drawBubbles(a, a.cell.data),\n    provideEditor: () => p => {\n        const { value } = p;\n        return <BubblesOverlayEditor bubbles={value.data} />;\n    },\n    onPaste: () => undefined,\n};\n","import * as React from \"react\";\nimport { BubblesOverlayEditorStyle } from \"./bubbles-overlay-editor-style\";\n\ninterface Props {\n    readonly bubbles: readonly string[];\n}\n\nconst BubblesOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { bubbles } = p;\n    return (\n        <BubblesOverlayEditorStyle>\n            {bubbles.map((b, i) => (\n                <div key={i} className=\"boe-bubble\">\n                    {b}\n                </div>\n            ))}\n            <textarea className=\"gdg-input\" autoFocus={true} />\n        </BubblesOverlayEditorStyle>\n    );\n};\nexport default BubblesOverlayEditor;\n","import { styled } from \"@linaria/react\";\n\nexport const BubblesOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .boe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 20px;\n\n        background-color: var(--gdg-bg-bubble);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport DrilldownOverlayEditor from \"../../data-grid-overlay-editor/private/drilldown-overlay-editor\";\nimport { drawDrilldownCell } from \"../data-grid-lib\";\nimport { GridCellKind, DrilldownCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const drilldownCellRenderer: InternalCellRenderer<DrilldownCell> = {\n    getAccessibilityString: c => c.data.map(d => d.text).join(\", \"),\n    kind: GridCellKind.Drilldown,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: (ctx, cell, t) =>\n        cell.data.reduce(\n            (acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== undefined ? 18 : 0),\n            0\n        ) +\n        2 * t.cellHorizontalPadding -\n        4,\n    draw: a => drawDrilldownCell(a, a.cell.data),\n    provideEditor: () => p => {\n        const { value } = p;\n        return <DrilldownOverlayEditor drilldowns={value.data} />;\n    },\n    onPaste: () => undefined,\n};\n","import type { DrilldownCellData } from \"../../data-grid/data-grid-types\";\nimport * as React from \"react\";\nimport { styled } from \"@linaria/react\";\n\nconst DrilldownOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .doe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 24px;\n\n        background-color: var(--gdg-bg-cell);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n\n        border-radius: 6px;\n\n        box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n\n        img {\n            height: 16px;\n            object-fit: contain;\n\n            margin-right: 4px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n\ninterface Props {\n    readonly drilldowns: readonly DrilldownCellData[];\n}\n\nconst DrilldownOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { drilldowns } = p;\n    return (\n        <DrilldownOverlayEditorStyle>\n            {drilldowns.map((d, i) => (\n                <div key={i} className=\"doe-bubble\">\n                    {d.img !== undefined && <img src={d.img} />}\n                    <div>{d.text}</div>\n                </div>\n            ))}\n        </DrilldownOverlayEditorStyle>\n    );\n};\nexport default DrilldownOverlayEditor;\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { ImageOverlayEditor } from \"../../data-grid-overlay-editor/private/image-overlay-editor\";\nimport { drawImage } from \"../data-grid-lib\";\nimport { GridCellKind, ImageCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const imageCellRenderer: InternalCellRenderer<ImageCell> = {\n    getAccessibilityString: c => c.data.join(\", \"),\n    kind: GridCellKind.Image,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    draw: a => drawImage(a, a.cell.displayData ?? a.cell.data, a.cell.rounding),\n    measure: (_ctx, cell) => cell.data.length * 50,\n    onDelete: c => ({\n        ...c,\n        data: [],\n    }),\n    provideEditor: () => p => {\n        const { value, onFinishedEditing, imageEditorOverride } = p;\n\n        const ImageEditor = imageEditorOverride ?? ImageOverlayEditor;\n\n        return (\n            <ImageEditor\n                urls={value.data}\n                canWrite={value.allowAdd}\n                onCancel={onFinishedEditing}\n                onChange={newImage => {\n                    onFinishedEditing({\n                        ...value,\n                        data: [newImage],\n                    });\n                }}\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => {\n        toPaste = toPaste.trim();\n        const fragments = toPaste.split(\",\");\n        const uris = fragments\n            .map(f => {\n                try {\n                    new URL(f);\n                    return f;\n                } catch {\n                    return undefined;\n                }\n            })\n            .filter(x => x !== undefined) as string[];\n\n        if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i])) return undefined;\n        return {\n            ...cell,\n            data: uris,\n        };\n    },\n};\n","import * as React from \"react\";\nimport { ImageOverlayEditorStyle } from \"./image-overlay-editor-style\";\nimport { Carousel } from \"react-responsive-carousel\";\nimport { EditPencil } from \"../../common/utils\";\n\n/** @category Types */\nexport interface OverlayImageEditorProps {\n    readonly urls: readonly string[];\n    readonly canWrite: boolean;\n    readonly onCancel: () => void;\n    readonly onChange: (newImage: string) => void;\n    readonly onEditClick?: () => void;\n    readonly renderImage?: (url: string) => React.ReactNode;\n}\n\n/** @category Renderers */\nexport const ImageOverlayEditor: React.FunctionComponent<OverlayImageEditorProps> = p => {\n    const { urls, canWrite, onEditClick, renderImage } = p;\n\n    const filtered = urls.filter(u => u !== \"\");\n\n    if (filtered.length === 0) {\n        return null;\n    }\n\n    const allowMove = filtered.length > 1;\n    return (\n        <ImageOverlayEditorStyle data-testid=\"GDG-default-image-overlay-editor\">\n            <Carousel\n                showArrows={allowMove}\n                showThumbs={false}\n                swipeable={allowMove}\n                emulateTouch={allowMove}\n                infiniteLoop={allowMove}>\n                {filtered.map(url => {\n                    const innerContent = renderImage?.(url) ?? <img draggable={false} src={url} />;\n                    return (\n                        <div className=\"centering-container\" key={url}>\n                            {innerContent}\n                        </div>\n                    );\n                })}\n            </Carousel>\n            {canWrite && onEditClick && (\n                <button className=\"edit-icon\" onClick={onEditClick}>\n                    <EditPencil />\n                </button>\n            )}\n        </ImageOverlayEditorStyle>\n    );\n};\n","import { styled } from \"@linaria/react\";\n\nexport const ImageOverlayEditorStyle = styled.div`\n    display: flex;\n\n    height: 100%;\n\n    .centering-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        height: 100%;\n\n        img,\n        canvas {\n            max-height: calc(100vh - var(--overlay-top) - 20px);\n            object-fit: contain;\n            user-select: none;\n        }\n\n        canvas {\n            max-width: 380px;\n        }\n    }\n\n    .edit-icon {\n        position: absolute;\n        top: 12px;\n        right: 0;\n        width: 48px;\n        height: 48px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n","import { GridCellKind, LoadingCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const loadingCellRenderer: InternalCellRenderer<LoadingCell> = {\n    getAccessibilityString: () => \"\",\n    kind: GridCellKind.Loading,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: () => 120,\n    draw: () => undefined,\n    onPaste: () => undefined,\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { MarkdownOverlayEditor } from \"../../data-grid-overlay-editor/private/markdown-overlay-editor\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, MarkdownCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const markdownCellRenderer: InternalCellRenderer<MarkdownCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Markdown,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: prepTextCell,\n    measure: (ctx, cell, t) => {\n        const firstLine = cell.data.split(\"\\n\")[0];\n        return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;\n    },\n    draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: () => p => {\n        const {\n            onChange,\n            value,\n            target,\n            onFinishedEditing,\n            markdownDivCreateNode,\n            forceEditMode,\n            validatedSelection,\n        } = p;\n        return (\n            <MarkdownOverlayEditor\n                onFinish={onFinishedEditing}\n                targetRect={target}\n                readonly={value.readonly === true}\n                markdown={value.data}\n                validatedSelection={validatedSelection}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n                forceEditMode={forceEditMode}\n                createNode={markdownDivCreateNode}\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => (toPaste === cell.data ? undefined : { ...cell, data: toPaste }),\n};\n","import * as React from \"react\";\nimport MarkdownDiv from \"../../markdown-div/markdown-div\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { MarkdownOverlayEditorStyle } from \"./markdown-overlay-editor-style\";\nimport { EditPencil, Checkmark } from \"../../common/utils\";\nimport type { Rectangle, SelectionRange } from \"../../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly targetRect: Rectangle;\n    readonly markdown: string;\n    readonly onChange: (ev: React.ChangeEvent<HTMLTextAreaElement>) => void;\n    readonly forceEditMode: boolean;\n    readonly onFinish: () => void;\n    readonly validatedSelection?: SelectionRange;\n\n    readonly readonly: boolean;\n\n    createNode?: (content: string) => DocumentFragment;\n}\n\nexport const MarkdownOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { markdown, onChange, forceEditMode, createNode, targetRect, readonly, onFinish, validatedSelection } = p;\n\n    const [editMode, setEditMode] = React.useState<boolean>(markdown === \"\" || forceEditMode);\n    const onEditClick = React.useCallback(() => {\n        setEditMode(e => !e);\n    }, []);\n    const addLeftPad = markdown ? \"ml-6\" : \"\";\n\n    if (editMode) {\n        return (\n            <MarkdownOverlayEditorStyle targetWidth={targetRect.width - 20}>\n                <GrowingEntry\n                    autoFocus={true}\n                    highlight={false}\n                    validatedSelection={validatedSelection}\n                    value={markdown}\n                    onKeyDown={e => {\n                        if (e.key === \"Enter\") e.stopPropagation();\n                    }}\n                    onChange={onChange}\n                />\n                <div className={`edit-icon checkmark-hover ${addLeftPad}`} onClick={() => onFinish()}>\n                    <Checkmark />\n                </div>\n            </MarkdownOverlayEditorStyle>\n        );\n    }\n    return (\n        <MarkdownOverlayEditorStyle targetWidth={targetRect.width}>\n            <MarkdownDiv contents={markdown} createNode={createNode} />\n            {!readonly && (\n                <>\n                    <div className=\"spacer\" />\n                    <div className={`edit-icon edit-hover ${addLeftPad}`} onClick={onEditClick}>\n                        <EditPencil />\n                    </div>\n                </>\n            )}\n            <textarea className=\"md-edit-textarea gdg-input\" autoFocus={true} />\n        </MarkdownOverlayEditorStyle>\n    );\n};\n","import React from \"react\";\nimport { marked } from \"marked\";\n\nimport { MarkdownContainer } from \"./private/markdown-container\";\n\n/** @category Renderers */\nexport interface MarkdownDivProps {\n    contents: string;\n    createNode?: (content: string) => DocumentFragment;\n}\n\n/** @category Renderers */\nexport default class MarkdownDiv<TProps extends MarkdownDivProps, TState> extends React.PureComponent<TProps, TState> {\n    private targetElement: HTMLElement | null = null;\n\n    private renderMarkdownIntoDiv() {\n        const { targetElement, props } = this;\n        if (targetElement === null) return;\n\n        const { contents, createNode } = props;\n\n        const innerHTML: string = (marked as any)(contents);\n\n        const childRange = document.createRange();\n        childRange.selectNodeContents(targetElement);\n        childRange.deleteContents();\n\n        let newChild: DocumentFragment | undefined = createNode?.(innerHTML);\n        if (newChild === undefined) {\n            const childDoc = document.createElement(\"template\");\n            childDoc.innerHTML = innerHTML;\n            newChild = childDoc.content;\n        }\n        targetElement.append(newChild);\n\n        const tags = targetElement.getElementsByTagName(\"a\");\n        for (const tag of tags) {\n            tag.target = \"_blank\";\n            tag.rel = \"noreferrer noopener\";\n        }\n    }\n\n    private containerRefHook = (element: HTMLElement | null) => {\n        this.targetElement = element;\n        this.renderMarkdownIntoDiv();\n    };\n\n    public render() {\n        // Doing this in the ref hook works great when we first render, but never again.\n        // This only works great after the first render, but not in the first render.\n        // Putting the two together makes the full solution.\n        this.renderMarkdownIntoDiv();\n        return <MarkdownContainer ref={this.containerRefHook as any} />;\n    }\n}\n","import { styled } from \"@linaria/react\";\n\nexport const MarkdownContainer = styled.div`\n    word-break: break-word;\n    -webkit-touch-callout: default;\n    padding-top: 6px;\n\n    > * {\n        margin: 0;\n    }\n\n    & *:last-child {\n        margin-bottom: 0;\n    }\n\n    & p img {\n        width: 100%;\n    }\n`;\n","import * as React from \"react\";\n\nimport { GrowingEntryStyle, ShadowBox, InputBox } from \"./growing-entry-style\";\nimport { assert } from \"../common/support\";\nimport type { SelectionRange } from \"../data-grid/data-grid-types\";\n\ninterface Props\n    extends React.DetailedHTMLProps<React.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement> {\n    readonly placeholder?: string;\n    readonly highlight: boolean;\n    readonly altNewline?: boolean;\n    readonly validatedSelection?: SelectionRange;\n}\n\n/** @category Renderers */\nexport const GrowingEntry: React.FunctionComponent<Props> = (props: Props) => {\n    const { placeholder, value, onKeyDown, highlight, altNewline, validatedSelection, ...rest } = props;\n    const { onChange, className } = rest;\n\n    const inputRef = React.useRef<HTMLTextAreaElement | null>(null);\n\n    const useText = value ?? \"\";\n\n    assert(onChange !== undefined, \"GrowingEntry must be a controlled input area\");\n\n    React.useEffect(() => {\n        const ta = inputRef.current;\n        if (ta === null) return;\n\n        if (ta.disabled) return;\n        const length = useText.toString().length;\n        ta.focus();\n        ta.setSelectionRange(highlight ? 0 : length, length);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    React.useLayoutEffect(() => {\n        if (validatedSelection !== undefined) {\n            const range = typeof validatedSelection === \"number\" ? [validatedSelection, null] : validatedSelection;\n            inputRef.current?.setSelectionRange(range[0], range[1]);\n        }\n    }, [validatedSelection]);\n\n    const onKeyDownInner = React.useCallback<NonNullable<typeof onKeyDown>>(\n        e => {\n            if (e.key === \"Enter\" && e.shiftKey && altNewline === true) {\n                return;\n            }\n            onKeyDown?.(e);\n        },\n        [altNewline, onKeyDown]\n    );\n\n    return (\n        <GrowingEntryStyle className=\"gdg-growing-entry\">\n            <ShadowBox className={className}>{useText + \"\\n\"}</ShadowBox>\n            <InputBox\n                {...rest}\n                className={(className ?? \"\") + \" gdg-input\"}\n                ref={inputRef}\n                onKeyDown={onKeyDownInner}\n                value={useText}\n                placeholder={placeholder}\n                dir=\"auto\"\n            />\n        </GrowingEntryStyle>\n    );\n};\n","import { styled } from \"@linaria/react\";\n\nexport const InputBox = styled.textarea`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n\n    border-radius: 0px;\n\n    resize: none;\n    white-space: pre-wrap;\n    min-width: 100%;\n    overflow: hidden;\n    border: 0;\n    background-color: transparent;\n\n    ::placeholder {\n        color: var(--gdg-text-light);\n    }\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    .invalid & {\n        text-decoration: underline;\n        text-decoration-color: #d60606;\n    }\n`;\n\nexport const ShadowBox = styled.div`\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n\n    width: max-content;\n    max-width: 100%;\n\n    min-width: 100%;\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    padding-bottom: 2px;\n`;\n\nexport const GrowingEntryStyle = styled.div`\n    position: relative;\n    margin-top: 6px;\n`;\n","import { GrowingEntryStyle } from \"../../growing-entry/growing-entry-style\";\nimport { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetWidth: number;\n}\n\nexport const MarkdownOverlayEditorStyle = styled.div<Props>`\n    min-width: ${p => p.targetWidth}px;\n    width: 100%;\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    position: relative;\n    color: var(--gdg-text-dark);\n\n    ${GrowingEntryStyle} {\n        flex-shrink: 1;\n        min-width: 0;\n    }\n\n    .spacer {\n        flex: 1;\n    }\n\n    .edit-icon {\n        position: relative;\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        color: var(--gdg-accent-color);\n\n        padding: 0;\n\n        height: 24px;\n        width: 24px;\n        flex-shrink: 0;\n\n        transition: all \"0.125s ease\";\n\n        border-radius: 6px;\n\n        > * {\n            width: 16px;\n            height: 16px;\n        }\n    }\n\n    .edit-hover {\n        :hover {\n            background-color: var(--gdg-accent-light);\n            transition: background-color 150ms;\n        }\n    }\n\n    .checkmark-hover {\n        :hover {\n            color: #ffffff;\n            background-color: var(--gdg-accent-color);\n        }\n    }\n\n    .md-edit-textarea {\n        position: relative;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n        margin-top: 25px;\n        opacity: 0;\n        padding: 0;\n    }\n\n    .ml-6 {\n        margin-left: 6px;\n    }\n`;\n","import { drawMarkerRowCell, prepMarkerRowCell } from \"../data-grid-lib\";\nimport { InnerGridCellKind, MarkerCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const markerCellRenderer: InternalCellRenderer<MarkerCell> = {\n    getAccessibilityString: c => c.row.toString(),\n    kind: InnerGridCellKind.Marker,\n    needsHover: true,\n    needsHoverPosition: false,\n    drawPrep: prepMarkerRowCell,\n    measure: () => 44,\n    draw: a => drawMarkerRowCell(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle),\n    onClick: e => {\n        const { bounds, cell, posX: x, posY: y } = e;\n        const { width, height } = bounds;\n\n        const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;\n        const centerY = height / 2;\n\n        if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {\n            return {\n                ...cell,\n                checked: !cell.checked,\n            };\n        }\n        return undefined;\n    },\n    onPaste: () => undefined,\n};\n","import { drawNewRowCell } from \"../data-grid-lib\";\nimport { InnerGridCellKind, NewRowCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const newRowCellRenderer: InternalCellRenderer<NewRowCell> = {\n    getAccessibilityString: () => \"\",\n    kind: InnerGridCellKind.NewRow,\n    needsHover: true,\n    needsHoverPosition: false,\n    measure: () => 200,\n    draw: a => drawNewRowCell(a, a.cell.hint, a.cell.icon),\n    onPaste: () => undefined,\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, NumberCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nconst NumberOverlayEditor = React.lazy(\n    async () => await import(\"../../data-grid-overlay-editor/private/number-overlay-editor\")\n);\n\nexport const numberCellRenderer: InternalCellRenderer<NumberCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Number,\n    needsHover: false,\n    needsHoverPosition: false,\n    useLabel: true,\n    drawPrep: prepTextCell,\n    draw: a => drawTextCell(a, a.cell.displayData, a.cell.contentAlign),\n    measure: (ctx, cell) => ctx.measureText(cell.displayData).width + 16,\n    onDelete: c => ({\n        ...c,\n        data: undefined,\n    }),\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (\n            <React.Suspense fallback={null}>\n                <NumberOverlayEditor\n                    highlight={isHighlighted}\n                    disabled={value.readonly === true}\n                    value={value.data}\n                    validatedSelection={validatedSelection}\n                    onChange={x =>\n                        onChange({\n                            ...value,\n                            data: Number.isNaN(x.floatValue ?? 0) ? 0 : x.floatValue,\n                        })\n                    }\n                />\n            </React.Suspense>\n        );\n    },\n    onPaste: (toPaste, cell) => {\n        const newNumber = Number.parseFloat(toPaste);\n        if (Number.isNaN(newNumber) || cell.data === newNumber) return undefined;\n        return { ...cell, data: newNumber };\n    },\n};\n","import { drawProtectedCell } from \"../data-grid-lib\";\nimport { GridCellKind, ProtectedCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const protectedCellRenderer: InternalCellRenderer<ProtectedCell> = {\n    getAccessibilityString: () => \"\",\n    measure: () => 108,\n    kind: GridCellKind.Protected,\n    needsHover: false,\n    needsHoverPosition: false,\n    draw: drawProtectedCell,\n    onPaste: () => undefined,\n};\n","import React from \"react\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, RowIDCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const rowIDCellRenderer: InternalCellRenderer<RowIDCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.RowID,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: (a, b) => prepTextCell(a, b, a.theme.textLight),\n    draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),\n    measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,\n    // eslint-disable-next-line react/display-name\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (\n            <GrowingEntry\n                highlight={isHighlighted}\n                autoFocus={value.readonly !== true}\n                disabled={value.readonly !== false}\n                value={value.data}\n                validatedSelection={validatedSelection}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n            />\n        );\n    },\n    onPaste: () => undefined,\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, TextCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const textCellRenderer: InternalCellRenderer<TextCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Text,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: prepTextCell,\n    useLabel: true,\n    draw: a => (drawTextCell(a, a.cell.displayData, a.cell.contentAlign, a.cell.allowWrapping, a.hyperWrapping), true),\n    measure: (ctx, cell, t) => {\n        const lines = cell.displayData.split(\"\\n\").slice(0, cell.allowWrapping === true ? undefined : 1);\n        return Math.max(...lines.map(l => ctx.measureText(l).width + 2 * t.cellHorizontalPadding));\n    },\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (\n            <GrowingEntry\n                highlight={isHighlighted}\n                autoFocus={value.readonly !== true}\n                disabled={value.readonly === true}\n                altNewline={true}\n                value={value.data}\n                validatedSelection={validatedSelection}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => (toPaste === cell.data ? undefined : { ...cell, data: toPaste }),\n};\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport UriOverlayEditor from \"../../data-grid-overlay-editor/private/uri-overlay-editor\";\nimport { drawTextCell, prepTextCell } from \"../data-grid-lib\";\nimport { GridCellKind, UriCell } from \"../data-grid-types\";\nimport type { InternalCellRenderer } from \"./cell-types\";\n\nexport const uriCellRenderer: InternalCellRenderer<UriCell> = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: GridCellKind.Uri,\n    needsHover: false,\n    needsHoverPosition: false,\n    useLabel: true,\n    drawPrep: prepTextCell,\n    draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),\n    measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: () => p => {\n        const { onChange, value, forceEditMode, validatedSelection } = p;\n        return (\n            <UriOverlayEditor\n                forceEditMode={forceEditMode}\n                uri={value.data}\n                validatedSelection={validatedSelection}\n                readonly={value.readonly === true}\n                onChange={e =>\n                    onChange({\n                        ...value,\n                        data: e.target.value,\n                    })\n                }\n            />\n        );\n    },\n    onPaste: (toPaste, cell) => (toPaste === cell.data ? undefined : { ...cell, data: toPaste }),\n};\n","import { EditPencil } from \"../../common/utils\";\nimport * as React from \"react\";\nimport { GrowingEntry } from \"../../growing-entry/growing-entry\";\nimport { UriOverlayEditorStyle } from \"./uri-overlay-editor-style\";\nimport type { SelectionRange } from \"../../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly uri: string;\n    readonly onChange: (ev: React.ChangeEvent<HTMLTextAreaElement>) => void;\n    readonly forceEditMode: boolean;\n    readonly readonly: boolean;\n    readonly validatedSelection?: SelectionRange;\n}\n\nconst UriOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { uri, onChange, forceEditMode, readonly, validatedSelection } = p;\n\n    const [editMode, setEditMode] = React.useState<boolean>(uri === \"\" || forceEditMode);\n\n    const onEditClick = React.useCallback(() => {\n        setEditMode(true);\n    }, []);\n\n    if (editMode) {\n        return (\n            <GrowingEntry\n                validatedSelection={validatedSelection}\n                highlight={true}\n                autoFocus={true}\n                value={uri}\n                onChange={onChange}\n            />\n        );\n    }\n\n    return (\n        <UriOverlayEditorStyle>\n            <a className=\"link-area\" href={uri} target=\"_blank\" rel=\"noopener noreferrer\">\n                {uri}\n            </a>\n            {!readonly && (\n                <div className=\"edit-icon\" onClick={onEditClick}>\n                    <EditPencil />\n                </div>\n            )}\n            <textarea className=\"gdg-input\" autoFocus={true} />\n        </UriOverlayEditorStyle>\n    );\n};\n\nexport default UriOverlayEditor;\n","import { styled } from \"@linaria/react\";\n\nexport const UriOverlayEditorStyle = styled.div`\n    display: flex;\n\n    flex-grow: 1;\n\n    align-items: center;\n\n    min-height: 21px;\n\n    .link-area {\n        flex-grow: 1;\n        flex-shrink: 1;\n\n        cursor: pointer;\n\n        margin-right: 8px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n\n        color: var(--gdg-link-color);\n        text-decoration: underline !important;\n    }\n\n    .edit-icon {\n        flex-shrink: 0;\n        width: 32px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n","import { GridCellKind, InnerGridCellKind } from \"../data-grid-types\";\nimport { booleanCellRenderer } from \"./boolean-cell\";\nimport { bubbleCellRenderer } from \"./bubble-cell\";\nimport { drilldownCellRenderer } from \"./drilldown-cell\";\nimport { imageCellRenderer } from \"./image-cell\";\nimport { loadingCellRenderer } from \"./loading-cell\";\nimport { markdownCellRenderer } from \"./markdown-cell\";\nimport { markerCellRenderer } from \"./marker-cell\";\nimport { newRowCellRenderer } from \"./new-row-cell\";\nimport { numberCellRenderer } from \"./number-cell\";\nimport { protectedCellRenderer } from \"./protected-cell\";\nimport { rowIDCellRenderer } from \"./row-id-cell\";\nimport { textCellRenderer } from \"./text-cell\";\nimport { uriCellRenderer } from \"./uri-cell\";\n\nexport const CellRenderers = {\n    [InnerGridCellKind.Marker]: markerCellRenderer,\n    [InnerGridCellKind.NewRow]: newRowCellRenderer,\n    [GridCellKind.Boolean]: booleanCellRenderer,\n    [GridCellKind.Bubble]: bubbleCellRenderer,\n    [GridCellKind.Drilldown]: drilldownCellRenderer,\n    [GridCellKind.Image]: imageCellRenderer,\n    [GridCellKind.Loading]: loadingCellRenderer,\n    [GridCellKind.Markdown]: markdownCellRenderer,\n    [GridCellKind.Number]: numberCellRenderer,\n    [GridCellKind.Protected]: protectedCellRenderer,\n    [GridCellKind.RowID]: rowIDCellRenderer,\n    [GridCellKind.Text]: textCellRenderer,\n    [GridCellKind.Uri]: uriCellRenderer,\n};\n","import * as React from \"react\";\nimport type { CustomRenderer } from \"../data-grid/cells/cell-types\";\nimport { CustomCell, GridCellKind } from \"../data-grid/data-grid-types\";\nimport type { DataEditorProps } from \"./data-editor\";\n\n/**\n * @category Renderers\n * @deprecated use CustomRenderer instead\n */\nexport type CustomCellRenderer<T extends CustomCell> = Omit<CustomRenderer<T>, \"kind\">;\n\nfunction inflate<T extends CustomCell>(input: CustomCellRenderer<T>): CustomRenderer<T> {\n    return {\n        ...input,\n        kind: GridCellKind.Custom,\n    };\n}\n\n/**\n * @category Hooks\n * @deprecated use customRenderers instead.\n * @param cells\n * @returns an object intended to be spread on the DataEditor.\n */\nexport function useCustomCells(cells: readonly CustomCellRenderer<any>[]): {\n    customRenderers: NonNullable<DataEditorProps[\"customRenderers\"]>;\n} {\n    return { customRenderers: React.useMemo(() => cells.map(inflate), [cells]) };\n}\n"],"names":[],"sourceRoot":""}