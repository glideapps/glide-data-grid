(self["webpackChunkroot"] = self["webpackChunkroot"] || []).push([[179],{

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s1wvhs74{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1wvhs74 *,.s1wvhs74 *::before,.s1wvhs74 *::after{box-sizing:inherit;}\n.b16aqpip{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b16aqpip > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b16aqpip .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b16aqpip .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d1npx1y{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXd2aHM3NCIsIi5iMTZhcXBpcCIsIi5kMW5weDF5Il0sIm1hcHBpbmdzIjoiQUFzQk1BO0FBaUNBQztBQW9FQUMiLCJmaWxlIjoicGFja2FnZXMvY2VsbHMvc3JjL2NlbGwuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQgfSBmcm9tIFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IERyb3Bkb3duQ2VsbCBhcyBEcm9wZG93blJlbmRlcmVyLCB1c2VFeHRyYUNlbGxzIH0gZnJvbSBcIi5cIjtcbmltcG9ydCB0eXBlIHsgU3RhckNlbGwgfSBmcm9tIFwiLi9jZWxscy9zdGFyLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgU3BhcmtsaW5lQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwYXJrbGluZS1jZWxsXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgdHlwZSB7IFRhZ3NDZWxsIH0gZnJvbSBcIi4vY2VsbHMvdGFncy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IFVzZXJQcm9maWxlQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3VzZXItcHJvZmlsZS1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IERyb3Bkb3duQ2VsbCB9IGZyb20gXCIuL2NlbGxzL2Ryb3Bkb3duLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgQXJ0aWNsZUNlbGwgfSBmcm9tIFwiLi9jZWxscy9hcnRpY2xlLWNlbGwtdHlwZXNcIjtcbmltcG9ydCB0eXBlIHsgUmFuZ2VDZWxsIH0gZnJvbSBcIi4vY2VsbHMvcmFuZ2UtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBTcGlubmVyQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwaW5uZXItY2VsbFwiO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tIFwicmVhY3QtcmVzaXplLWRldGVjdG9yXCI7XG5cbmltcG9ydCBcIkB0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci5jc3NcIjtcbmltcG9ydCBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvaW5kZXguY3NzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGVQaWNrZXJDZWxsIH0gZnJvbSBcIi4vY2VsbHMvZGF0ZS1waWNrZXItY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBMaW5rc0NlbGwgfSBmcm9tIFwiLi9jZWxscy9saW5rcy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IEJ1dHRvbkNlbGwgfSBmcm9tIFwiLi9jZWxscy9idXR0b24tY2VsbFwiO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvQ2VsbHNcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzI3OTBiOSwgIzIwNzBhOSk7XG4gICAgY29sb3I6IHdoaXRlO1xuXG4gICAgcGFkZGluZzogMzJweCA0OHB4O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwdmg7XG5cbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcblxuICAgICYgPiBoMSB7XG4gICAgICAgIGZvbnQtc2l6ZTogNTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIG1hcmdpbjogMCAwIDEycHggMDtcbiAgICB9XG5cbiAgICAuc2l6ZXIge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgYm94LXNoYWRvdzogcmdiYSg5LCAzMCwgNjYsIDAuMjUpIDBweCA0cHggOHB4IC0ycHgsIHJnYmEoOSwgMzAsIDY2LCAwLjA4KSAwcHggMHB4IDBweCAxcHg7XG5cbiAgICAgICAgLnNpemVyLWNsaXAge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG5cbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyB0aXRsZSwgY2hpbGRyZW4sIGRlc2NyaXB0aW9uIH0gPSBwO1xuXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICByb3dNYXJrZXJzOiBcIm5vbmVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5sZXQgbnVtOiBudW1iZXIgPSAxO1xuZnVuY3Rpb24gcmFuZCgpOiBudW1iZXIge1xuICAgIHJldHVybiAobnVtID0gKG51bSAqIDE2ODA3KSAlIDIxNDc0ODM2NDcpIC8gMjE0NzQ4MzY0Nztcbn1cblxuY29uc3QgcG9zc2libGVUYWdzID0gW1xuICAgIHtcbiAgICAgICAgdGFnOiBcIkJ1Z1wiLFxuICAgICAgICBjb2xvcjogXCIjZmY0ZDRkMzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZlYXR1cmVcIixcbiAgICAgICAgY29sb3I6IFwiIzM1ZjhmZjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJFbmhhbmNlbWVudFwiLFxuICAgICAgICBjb2xvcjogXCIjNDhmZjU3MzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZpcnN0IElzc3VlXCIsXG4gICAgICAgIGNvbG9yOiBcIiM0MzZmZmYzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiUFJcIixcbiAgICAgICAgY29sb3I6IFwiI2UwZmYzMjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJBc3NpZ25lZFwiLFxuICAgICAgICBjb2xvcjogXCIjZmYxZWVjMzVcIixcbiAgICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gY2VsbHNcIiBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPlNvbWUgb2Ygb3VyIGV4dGVuc2lvbiBjZWxscy48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoLi4uYXJncykgPT4gY29uc29sZS5sb2coXCJFZGl0IENlbGxcIiwgLi4uYXJncyl9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInN0YXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJUZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTdGFyQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3BhcmtsaW5lLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzOiB2YWx1ZXMubWFwKHggPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcIiM3N2M0YzRcIiA6IFwiI0Q5ODQ2NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogWy01MCwgNTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFNwYXJrbGluZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGFya2xpbmUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJhbmdlKDAsIDE1KS5tYXAoKCkgPT4gcmFuZCgpICogMTAwIC0gNTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcm93ICUgMiA9PT0gMCA/IFwiIzc3YzRjNFwiIDogXCIjRDk4NDY2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoS2luZDogXCJiYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJ0YWdzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzOiBwb3NzaWJsZVRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiByb3cgJSAyID09PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiB1bmlxKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBUYWdzQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidXNlci1wcm9maWxlLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHJvdyAlIDIgPyB1bmRlZmluZWQgOiBcImh0dHBzOi8vaS5yZWRkLml0L2FxYzFod2hhbHN6NzEuanBnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWw6IFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW50OiBcIiNGMUQ4NkVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93ICUgNSA/IHVuZGVmaW5lZCA6IFwiQmVlIGJiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVXNlclByb2ZpbGVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERyb3Bkb3duQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImRyb3Bkb3duLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1wiR29vZFwiLCBcIkJldHRlclwiLCBcIkJlc3RcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkdvb2RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBSYW5nZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJyYW5nZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxMCArIE1hdGgucm91bmQodiAqIDIwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke01hdGgucm91bmQodiAqIDEwMCl9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVMYWJlbDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBBcnRpY2xlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImFydGljbGUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bjogXCIjIyBUaGlzIGlzIGEgdGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogU3Bpbm5lckNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGlubmVyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERhdGVQaWNrZXJDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZS1waWNrZXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IExpbmtzQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImxpbmtzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lT2Zmc2V0OiA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmt5IHBob25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXCJDbGljayAxXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJDbGljayB0aGUgbGlua3kgZGlua3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBhbGVydChcIkNsaWNrIDJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IEJ1dHRvbkNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImJ1dHRvbi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1widHJhbnNwYXJlbnRcIiwgXCIjNjU3MmZmZWVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBbXCJhY2NlbnRDb2xvclwiLCBcImFjY2VudEZnXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjNjU3MmZmYTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJWaWV3IERldGFpbHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gd2luZG93LmFsZXJ0KFwiQnV0dG9uIGNsaWNrZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VGb250U3R5bGU6IFwiNzAwIDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxcIik7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlN0YXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTcGFya2xpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNwYXJrbGluZSAoYmFycylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlRhZ3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlByb2ZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJSYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQXJ0aWNsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiU3Bpbm5lclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRGF0ZSBQaWNrZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmtzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCdXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ3VzdG9tQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxFZGl0aW5nOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgY29uc3QgZGF0YSA9IFJlYWN0LnVzZVJlZjxzdHJpbmdbXT4oW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGNlbGwgZWRpdGluZ1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDZWxscyBjYW4gYmUgZWRpdGVkIGFuZCByZXNwb25kaW5nIHRvIGNvcHkvcGFzdGUgdXNpbmcgdGhlIGNvcHlEYXRhIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICB7Li4uY2VsbFByb3BzfVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoY2VsbCwgbmV3VmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwua2luZCAhPT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoRHJvcGRvd25SZW5kZXJlci5pc01hdGNoKG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFtjZWxsWzFdXSA9IG5ld1ZhbC5kYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Y2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFssIHJvd10gPSBjZWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkYXRhLmN1cnJlbnRbcm93XSA/PyBcIkFcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBEcm9wZG93bkNlbGw7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUNlbGxFZGl0aW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG4iXX0=*/", "",{"version":3,"sources":["webpack://./packages/cells/src/packages/cells/src/cell.stories.tsx","webpack://./packages/cells/src/cell.stories.tsx"],"names":[".s1wvhs74",".b16aqpip",".d1npx1y"],"mappings":"AAsBMA,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AAiCAC,UAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,eAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,6BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA;AAoEAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;ACxHN,muvBAAmuvB","sourcesContent":["import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { DataEditor, DataEditorProps, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport { DropdownCell as DropdownRenderer, useExtraCells } from \".\";\nimport type { StarCell } from \"./cells/star-cell\";\nimport type { SparklineCell } from \"./cells/sparkline-cell\";\nimport range from \"lodash/range.js\";\nimport uniq from \"lodash/uniq.js\";\nimport type { TagsCell } from \"./cells/tags-cell\";\nimport type { UserProfileCell } from \"./cells/user-profile-cell\";\nimport type { DropdownCell } from \"./cells/dropdown-cell\";\nimport type { ArticleCell } from \"./cells/article-cell-types\";\nimport type { RangeCell } from \"./cells/range-cell\";\nimport type { SpinnerCell } from \"./cells/spinner-cell\";\nimport { useResizeDetector } from \"react-resize-detector\";\n\nimport \"@toast-ui/editor/dist/toastui-editor.css\";\nimport \"@glideapps/glide-data-grid/dist/index.css\";\nimport type { DatePickerCell } from \"./cells/date-picker-cell\";\nimport type { LinksCell } from \"./cells/links-cell\";\nimport type { ButtonCell } from \"./cells/button-cell\";\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Cells\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16807) % 2147483647) / 2147483647;\n}\n\nconst possibleTags = [\n    {\n        tag: \"Bug\",\n        color: \"#ff4d4d35\",\n    },\n    {\n        tag: \"Feature\",\n        color: \"#35f8ff35\",\n    },\n    {\n        tag: \"Enhancement\",\n        color: \"#48ff5735\",\n    },\n    {\n        tag: \"First Issue\",\n        color: \"#436fff35\",\n    },\n    {\n        tag: \"PR\",\n        color: \"#e0ff3235\",\n    },\n    {\n        tag: \"Assigned\",\n        color: \"#ff1eec35\",\n    },\n];\n\nexport const CustomCells: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    return (\n        <BeautifulWrapper title=\"Custom cells\" description={<Description>Some of our extension cells.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                // eslint-disable-next-line no-console\n                onCellEdited={(...args) => console.log(\"Edit Cell\", ...args)}\n                getCellContent={cell => {\n                    const [col, row] = cell;\n                    if (col === 0) {\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"star-cell\",\n                                label: \"Test\",\n                                rating: 4,\n                            },\n                        } as StarCell;\n                    } else if (col === 1) {\n                        num = row + 1;\n                        const values = range(0, 15).map(() => rand() * 100 - 50);\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values,\n                                displayValues: values.map(x => Math.round(x).toString()),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 2) {\n                        num = row + 1;\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: false,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"sparkline-cell\",\n                                values: range(0, 15).map(() => rand() * 100 - 50),\n                                color: row % 2 === 0 ? \"#77c4c4\" : \"#D98466\",\n                                graphKind: \"bar\",\n                                yAxis: [-50, 50],\n                            },\n                        } as SparklineCell;\n                    } else if (col === 3) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"tags-cell\",\n                                possibleTags: possibleTags,\n                                readonly: row % 2 === 0,\n                                tags: uniq([\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                    possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag,\n                                ]),\n                            },\n                        } as TagsCell;\n                    } else if (col === 4) {\n                        num = row + 1;\n                        rand();\n                        return {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"user-profile-cell\",\n                                image: row % 2 ? undefined : \"https://i.redd.it/aqc1hwhalsz71.jpg\",\n                                initial: \"B\",\n                                tint: \"#F1D86E\",\n                                name: row % 5 ? undefined : \"Bee bb\",\n                            },\n                        } as UserProfileCell;\n                    } else if (col === 5) {\n                        num = row + 1;\n                        rand();\n                        const d: DropdownCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"dropdown-cell\",\n                                allowedValues: [\"Good\", \"Better\", \"Best\"],\n                                value: \"Good\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 6) {\n                        num = row + 1;\n                        rand();\n                        const v = rand();\n                        const d: RangeCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"range-cell\",\n                                min: 10,\n                                max: 30,\n                                value: 10 + Math.round(v * 20),\n                                step: 1,\n                                label: `${Math.round(v * 100)}%`,\n                                measureLabel: \"100%\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 7) {\n                        num = row + 1;\n                        rand();\n                        const d: ArticleCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"article-cell\",\n                                markdown: \"## This is a test\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 8) {\n                        num = row + 1;\n                        rand();\n                        const d: SpinnerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"spinner-cell\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 9) {\n                        num = row + 1;\n                        rand();\n                        const d: DatePickerCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"date-picker-cell\",\n                                date: new Date(),\n                                displayDate: new Date().toISOString(),\n                                format: \"date\",\n                            },\n                        };\n                        return d;\n                    } else if (col === 10) {\n                        num = row + 1;\n                        rand();\n                        const d: LinksCell = {\n                            kind: GridCellKind.Custom,\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            data: {\n                                kind: \"links-cell\",\n                                underlineOffset: 6,\n                                links: [\n                                    {\n                                        title: \"Linky phone\",\n                                        onClick: () => alert(\"Click 1\"),\n                                    },\n                                    {\n                                        title: \"Click the linky dinky\",\n                                        onClick: () => alert(\"Click 2\"),\n                                    },\n                                ],\n                            },\n                        };\n                        return d;\n                    } else if (col === 11) {\n                        num = row + 1;\n                        rand();\n                        const d: ButtonCell = {\n                            kind: GridCellKind.Custom,\n                            cursor: \"pointer\",\n                            allowOverlay: true,\n                            copyData: \"4\",\n                            readonly: true,\n                            data: {\n                                kind: \"button-cell\",\n                                backgroundColor: [\"transparent\", \"#6572ffee\"],\n                                color: [\"accentColor\", \"accentFg\"],\n                                borderColor: \"#6572ffa0\",\n                                borderRadius: 9,\n                                title: \"View Details\",\n                                onClick: () => window.alert(\"Button clicked\"),\n                            },\n                            themeOverride: {\n                                baseFontStyle: \"700 12px\",\n                            },\n                        };\n                        return d;\n                    }\n                    throw new Error(\"Fail\");\n                }}\n                columns={[\n                    {\n                        title: \"Stars\",\n                        width: 200,\n                    },\n                    {\n                        title: \"Sparkline\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Sparkline (bars)\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Tags\",\n                        width: 250,\n                    },\n                    {\n                        title: \"Profile\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Dropdown\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Range\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Article\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Spinner\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Date Picker\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Links\",\n                        width: 150,\n                    },\n                    {\n                        title: \"Button\",\n                        width: 120,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CustomCellEditing: React.VFC = () => {\n    const cellProps = useExtraCells();\n\n    const data = React.useRef<string[]>([]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Custom cell editing\"\n            description={\n                <Description>\n                    Cells can be edited and responding to copy/paste using the copyData attribute.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                {...cellProps}\n                onPaste={true}\n                onCellEdited={(cell, newVal) => {\n                    if (newVal.kind !== GridCellKind.Custom) return;\n                    if (DropdownRenderer.isMatch(newVal)) {\n                        data.current[cell[1]] = newVal.data.value;\n                    }\n                }}\n                getCellsForSelection={true}\n                getCellContent={cell => {\n                    const [, row] = cell;\n                    const val = data.current[row] ?? \"A\";\n                    return {\n                        kind: GridCellKind.Custom,\n                        allowOverlay: true,\n                        copyData: val,\n                        data: {\n                            kind: \"dropdown-cell\",\n                            allowedValues: [\"A\", \"B\", \"C\"],\n                            value: val,\n                        },\n                    } as DropdownCell;\n                }}\n                columns={[\n                    {\n                        title: \"Dropdown\",\n                        width: 200,\n                    },\n                ]}\n                rows={500}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomCellEditing as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",".s1wvhs74{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1wvhs74 *,.s1wvhs74 *::before,.s1wvhs74 *::after{box-sizing:inherit;}\n.b16aqpip{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b16aqpip > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b16aqpip .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b16aqpip .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d1npx1y{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXd2aHM3NCIsIi5iMTZhcXBpcCIsIi5kMW5weDF5Il0sIm1hcHBpbmdzIjoiQUFzQk1BO0FBaUNBQztBQW9FQUMiLCJmaWxlIjoicGFja2FnZXMvY2VsbHMvc3JjL2NlbGwuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQgfSBmcm9tIFwiQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IERyb3Bkb3duQ2VsbCBhcyBEcm9wZG93blJlbmRlcmVyLCB1c2VFeHRyYUNlbGxzIH0gZnJvbSBcIi5cIjtcbmltcG9ydCB0eXBlIHsgU3RhckNlbGwgfSBmcm9tIFwiLi9jZWxscy9zdGFyLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgU3BhcmtsaW5lQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwYXJrbGluZS1jZWxsXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgdHlwZSB7IFRhZ3NDZWxsIH0gZnJvbSBcIi4vY2VsbHMvdGFncy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IFVzZXJQcm9maWxlQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3VzZXItcHJvZmlsZS1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IERyb3Bkb3duQ2VsbCB9IGZyb20gXCIuL2NlbGxzL2Ryb3Bkb3duLWNlbGxcIjtcbmltcG9ydCB0eXBlIHsgQXJ0aWNsZUNlbGwgfSBmcm9tIFwiLi9jZWxscy9hcnRpY2xlLWNlbGwtdHlwZXNcIjtcbmltcG9ydCB0eXBlIHsgUmFuZ2VDZWxsIH0gZnJvbSBcIi4vY2VsbHMvcmFuZ2UtY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBTcGlubmVyQ2VsbCB9IGZyb20gXCIuL2NlbGxzL3NwaW5uZXItY2VsbFwiO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tIFwicmVhY3QtcmVzaXplLWRldGVjdG9yXCI7XG5cbmltcG9ydCBcIkB0b2FzdC11aS9lZGl0b3IvZGlzdC90b2FzdHVpLWVkaXRvci5jc3NcIjtcbmltcG9ydCBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvaW5kZXguY3NzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGVQaWNrZXJDZWxsIH0gZnJvbSBcIi4vY2VsbHMvZGF0ZS1waWNrZXItY2VsbFwiO1xuaW1wb3J0IHR5cGUgeyBMaW5rc0NlbGwgfSBmcm9tIFwiLi9jZWxscy9saW5rcy1jZWxsXCI7XG5pbXBvcnQgdHlwZSB7IEJ1dHRvbkNlbGwgfSBmcm9tIFwiLi9jZWxscy9idXR0b24tY2VsbFwiO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvQ2VsbHNcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IEJlYXV0aWZ1bFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjc5MGI5O1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzI3OTBiOSwgIzIwNzBhOSk7XG4gICAgY29sb3I6IHdoaXRlO1xuXG4gICAgcGFkZGluZzogMzJweCA0OHB4O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGhlaWdodDogMTAwdmg7XG5cbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcblxuICAgICYgPiBoMSB7XG4gICAgICAgIGZvbnQtc2l6ZTogNTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIG1hcmdpbjogMCAwIDEycHggMDtcbiAgICB9XG5cbiAgICAuc2l6ZXIge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgYm94LXNoYWRvdzogcmdiYSg5LCAzMCwgNjYsIDAuMjUpIDBweCA0cHggOHB4IC0ycHgsIHJnYmEoOSwgMzAsIDY2LCAwLjA4KSAwcHggMHB4IDBweCAxcHg7XG5cbiAgICAgICAgLnNpemVyLWNsaXAge1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG5cbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuY29uc3QgQmVhdXRpZnVsV3JhcHBlcjogUmVhY3QuRkM8QmVhdXRpZnVsUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyB0aXRsZSwgY2hpbGRyZW4sIGRlc2NyaXB0aW9uIH0gPSBwO1xuXG4gICAgY29uc3QgeyByZWYsIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVJlc2l6ZURldGVjdG9yKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsU3R5bGU+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuY29uc3QgZGVmYXVsdFByb3BzOiBQYXJ0aWFsPERhdGFFZGl0b3JQcm9wcz4gPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogdHJ1ZSxcbiAgICBzbW9vdGhTY3JvbGxZOiB0cnVlLFxuICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICByb3dNYXJrZXJzOiBcIm5vbmVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG59O1xuXG5sZXQgbnVtOiBudW1iZXIgPSAxO1xuZnVuY3Rpb24gcmFuZCgpOiBudW1iZXIge1xuICAgIHJldHVybiAobnVtID0gKG51bSAqIDE2ODA3KSAlIDIxNDc0ODM2NDcpIC8gMjE0NzQ4MzY0Nztcbn1cblxuY29uc3QgcG9zc2libGVUYWdzID0gW1xuICAgIHtcbiAgICAgICAgdGFnOiBcIkJ1Z1wiLFxuICAgICAgICBjb2xvcjogXCIjZmY0ZDRkMzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZlYXR1cmVcIixcbiAgICAgICAgY29sb3I6IFwiIzM1ZjhmZjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJFbmhhbmNlbWVudFwiLFxuICAgICAgICBjb2xvcjogXCIjNDhmZjU3MzVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGFnOiBcIkZpcnN0IElzc3VlXCIsXG4gICAgICAgIGNvbG9yOiBcIiM0MzZmZmYzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0YWc6IFwiUFJcIixcbiAgICAgICAgY29sb3I6IFwiI2UwZmYzMjM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRhZzogXCJBc3NpZ25lZFwiLFxuICAgICAgICBjb2xvcjogXCIjZmYxZWVjMzVcIixcbiAgICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gY2VsbHNcIiBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPlNvbWUgb2Ygb3VyIGV4dGVuc2lvbiBjZWxscy48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLmNlbGxQcm9wc31cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoLi4uYXJncykgPT4gY29uc29sZS5sb2coXCJFZGl0IENlbGxcIiwgLi4uYXJncyl9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2NlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInN0YXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJUZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTdGFyQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSByYW5nZSgwLCAxNSkubWFwKCgpID0+IHJhbmQoKSAqIDEwMCAtIDUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3BhcmtsaW5lLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzOiB2YWx1ZXMubWFwKHggPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBcIiM3N2M0YzRcIiA6IFwiI0Q5ODQ2NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogWy01MCwgNTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIFNwYXJrbGluZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGFya2xpbmUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHJhbmdlKDAsIDE1KS5tYXAoKCkgPT4gcmFuZCgpICogMTAwIC0gNTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcm93ICUgMiA9PT0gMCA/IFwiIzc3YzRjNFwiIDogXCIjRDk4NDY2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoS2luZDogXCJiYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IFstNTAsIDUwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBTcGFya2xpbmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJ0YWdzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzOiBwb3NzaWJsZVRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiByb3cgJSAyID09PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiB1bmlxKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUYWdzW01hdGgucm91bmQocmFuZCgpICogMTAwMCkgJSBwb3NzaWJsZVRhZ3MubGVuZ3RoXS50YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVRhZ3NbTWF0aC5yb3VuZChyYW5kKCkgKiAxMDAwKSAlIHBvc3NpYmxlVGFncy5sZW5ndGhdLnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGFnc1tNYXRoLnJvdW5kKHJhbmQoKSAqIDEwMDApICUgcG9zc2libGVUYWdzLmxlbmd0aF0udGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBhcyBUYWdzQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidXNlci1wcm9maWxlLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHJvdyAlIDIgPyB1bmRlZmluZWQgOiBcImh0dHBzOi8vaS5yZWRkLml0L2FxYzFod2hhbHN6NzEuanBnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWw6IFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW50OiBcIiNGMUQ4NkVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcm93ICUgNSA/IHVuZGVmaW5lZCA6IFwiQmVlIGJiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgVXNlclByb2ZpbGVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERyb3Bkb3duQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImRyb3Bkb3duLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogW1wiR29vZFwiLCBcIkJldHRlclwiLCBcIkJlc3RcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkdvb2RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBSYW5nZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJyYW5nZS1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxMCArIE1hdGgucm91bmQodiAqIDIwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGAke01hdGgucm91bmQodiAqIDEwMCl9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVMYWJlbDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHJvdyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkOiBBcnRpY2xlQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImFydGljbGUtY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bjogXCIjIyBUaGlzIGlzIGEgdGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDogU3Bpbm5lckNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weURhdGE6IFwiNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzcGlubmVyLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IERhdGVQaWNrZXJDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlEYXRhOiBcIjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZS1waWNrZXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IExpbmtzQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQ3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImxpbmtzLWNlbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lT2Zmc2V0OiA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmt5IHBob25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gYWxlcnQoXCJDbGljayAxXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJDbGljayB0aGUgbGlua3kgZGlua3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBhbGVydChcIkNsaWNrIDJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gcm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQ6IEJ1dHRvbkNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogXCI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcImJ1dHRvbi1jZWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1widHJhbnNwYXJlbnRcIiwgXCIjNjU3MmZmZWVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBbXCJhY2NlbnRDb2xvclwiLCBcImFjY2VudEZnXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjNjU3MmZmYTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJWaWV3IERldGFpbHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gd2luZG93LmFsZXJ0KFwiQnV0dG9uIGNsaWNrZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VGb250U3R5bGU6IFwiNzAwIDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxcIik7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlN0YXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJTcGFya2xpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNwYXJrbGluZSAoYmFycylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlRhZ3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAyNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlByb2ZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJSYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQXJ0aWNsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiU3Bpbm5lclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRGF0ZSBQaWNrZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxpbmtzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCdXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ3VzdG9tQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEN1c3RvbUNlbGxFZGl0aW5nOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2VsbFByb3BzID0gdXNlRXh0cmFDZWxscygpO1xuXG4gICAgY29uc3QgZGF0YSA9IFJlYWN0LnVzZVJlZjxzdHJpbmdbXT4oW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGNlbGwgZWRpdGluZ1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDZWxscyBjYW4gYmUgZWRpdGVkIGFuZCByZXNwb25kaW5nIHRvIGNvcHkvcGFzdGUgdXNpbmcgdGhlIGNvcHlEYXRhIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICB7Li4uY2VsbFByb3BzfVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXsoY2VsbCwgbmV3VmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwua2luZCAhPT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoRHJvcGRvd25SZW5kZXJlci5pc01hdGNoKG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3VycmVudFtjZWxsWzFdXSA9IG5ld1ZhbC5kYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Y2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFssIHJvd10gPSBjZWxsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkYXRhLmN1cnJlbnRbcm93XSA/PyBcIkFcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5RGF0YTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXM6IFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBEcm9wZG93bkNlbGw7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgcm93cz17NTAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUNlbGxFZGl0aW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".wg6ppx4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}.wg6ppx4 .glide-select{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);}\n.p7jnwoo{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);color:var(--gdg-text-dark);}.p7jnwoo > div{border-radius:4px;border:1px solid var(--gdg-border-color);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCJdLCJuYW1lcyI6WyIud2c2cHB4NCIsIi5wN2pud29vIl0sIm1hcHBpbmdzIjoiQUE2Qk1BO0FBV0FDIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBQcm92aWRlRWRpdG9yQ2FsbGJhY2ssXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICB1c2VUaGVtZSxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTZWxlY3QsIHsgTWVudVByb3BzLCBjb21wb25lbnRzIH0gZnJvbSBcInJlYWN0LXNlbGVjdFwiO1xuXG5pbnRlcmZhY2UgQ3VzdG9tTWVudVByb3BzIGV4dGVuZHMgTWVudVByb3BzPGFueT4ge31cblxuY29uc3QgQ3VzdG9tTWVudTogUmVhY3QuRkM8Q3VzdG9tTWVudVByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgTWVudSB9ID0gY29tcG9uZW50cztcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiA8TWVudSB7Li4ucmVzdH0+e2NoaWxkcmVufTwvTWVudT47XG59O1xuXG5pbnRlcmZhY2UgRHJvcGRvd25DZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiO1xuICAgIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgYWxsb3dlZFZhbHVlczogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgcmVhZG9ubHkgcmVhZG9ubHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBEcm9wZG93bkNlbGwgPSBDdXN0b21DZWxsPERyb3Bkb3duQ2VsbFByb3BzPjtcblxuY29uc3QgV3JhcCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuXG4gICAgLmdsaWRlLXNlbGVjdCB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgICAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICB9XG5gO1xuXG5jb25zdCBQb3J0YWxXcmFwID0gc3R5bGVkLmRpdmBcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICA+IGRpdiB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuYDtcblxuY29uc3QgRWRpdG9yOiBSZXR1cm5UeXBlPFByb3ZpZGVFZGl0b3JDYWxsYmFjazxEcm9wZG93bkNlbGw+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNlbGwsIG9uRmluaXNoZWRFZGl0aW5nLCBpbml0aWFsVmFsdWUgfSA9IHA7XG4gICAgY29uc3QgeyBhbGxvd2VkVmFsdWVzLCB2YWx1ZTogdmFsdWVJbiB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSh2YWx1ZUluKTtcbiAgICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsVmFsdWUgPz8gXCJcIik7XG5cbiAgICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBSZWFjdC51c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYWxsb3dlZFZhbHVlcy5tYXAoeCA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB4LFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBbYWxsb3dlZFZhbHVlc11cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFdyYXA+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2xpZGUtc2VsZWN0XCJcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlPXtpbnB1dFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uSW5wdXRDaGFuZ2U9e3NldElucHV0VmFsdWV9XG4gICAgICAgICAgICAgICAgbWVudVBsYWNlbWVudD17XCJhdXRvXCJ9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlcy5maW5kKHggPT4geC52YWx1ZSA9PT0gdmFsdWUpfVxuICAgICAgICAgICAgICAgIHN0eWxlcz17e1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBiYXNlID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICB0aGVtZT17dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udC5jb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDA6IHRoZW1lLmJnQ2VsbCwgLy8gdGhpcyBpcyBib3RoIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIEFORCB0aGUgZmcgY29sb3Igb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgaXRlbSBiZWNhdXNlIG9mIGNvdXJzZSBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNTogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwyMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwzMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw0MDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw1MDogdGhlbWUudGV4dExpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw2MDogdGhlbWUudGV4dE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNzA6IHRoZW1lLnRleHRNZWRpdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDgwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsOTA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk6IHRoZW1lLmFjY2VudENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk3NTogdGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTUwOiB0aGVtZS5hY2NlbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5MjU6IHRoZW1lLmFjY2VudExpZ2h0LCAvLyBwcmVsaWdodCBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG1lbnVQb3J0YWxUYXJnZXQ9e2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicG9ydGFsXCIpfVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvcGVuTWVudU9uRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cz17e1xuICAgICAgICAgICAgICAgICAgICBEcm9wZG93bkluZGljYXRvcjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgSW5kaWNhdG9yU2VwYXJhdG9yOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBNZW51OiBwcm9wcyA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8UG9ydGFsV3JhcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q3VzdG9tTWVudSBjbGFzc05hbWU9e1wiY2xpY2stb3V0c2lkZS1pZ25vcmVcIn0gey4uLnByb3BzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Qb3J0YWxXcmFwPlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17dmFsdWVzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXthc3luYyBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyKSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRmluaXNoZWRFZGl0aW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvV3JhcD5cbiAgICApO1xufTtcblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPERyb3Bkb3duQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgRHJvcGRvd25DZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcImRyb3Bkb3duLWNlbGxcIixcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGNlbGwuZGF0YTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLnRleHREYXJrO1xuICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHJlY3QueCArIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCB0aGVtZSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+ICh7XG4gICAgICAgIGVkaXRvcjogRWRpdG9yLFxuICAgICAgICBkaXNhYmxlUGFkZGluZzogdHJ1ZSxcbiAgICAgICAgZGVsZXRlZFZhbHVlOiB2ID0+ICh7XG4gICAgICAgICAgICAuLi52LFxuICAgICAgICAgICAgY29weURhdGE6IFwiXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4udi5kYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgfSksXG4gICAgb25QYXN0ZTogKHYsIGQpID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHZhbHVlOiBkLmFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModikgPyB2IDogZC52YWx1ZSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/cells/src/cells/packages/cells/src/cells/dropdown-cell.tsx","webpack://./packages/cells/src/cells/dropdown-cell.tsx"],"names":[".wg6ppx4",".p7jnwoo"],"mappings":"AA6BMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,uBAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA;AAWAC,SAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,eAAAA,iBAAAA,CAAAA,wCAAAA,CAAAA;ACtCN,2wPAA2wP","sourcesContent":["import {\n    CustomCell,\n    ProvideEditorCallback,\n    CustomRenderer,\n    getMiddleCenterBias,\n    useTheme,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport Select, { MenuProps, components } from \"react-select\";\n\ninterface CustomMenuProps extends MenuProps<any> {}\n\nconst CustomMenu: React.FC<CustomMenuProps> = p => {\n    const { Menu } = components;\n    const { children, ...rest } = p;\n    return <Menu {...rest}>{children}</Menu>;\n};\n\ninterface DropdownCellProps {\n    readonly kind: \"dropdown-cell\";\n    readonly value: string;\n    readonly allowedValues: readonly string[];\n    readonly readonly?: boolean;\n}\n\nexport type DropdownCell = CustomCell<DropdownCellProps>;\n\nconst Wrap = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n\n    .glide-select {\n        font-family: var(--gdg-font-family);\n        font-size: var(--gdg-editor-font-size);\n    }\n`;\n\nconst PortalWrap = styled.div`\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n    color: var(--gdg-text-dark);\n\n    > div {\n        border-radius: 4px;\n        border: 1px solid var(--gdg-border-color);\n    }\n`;\n\nconst Editor: ReturnType<ProvideEditorCallback<DropdownCell>> = p => {\n    const { value: cell, onFinishedEditing, initialValue } = p;\n    const { allowedValues, value: valueIn } = cell.data;\n\n    const [value, setValue] = React.useState(valueIn);\n    const [inputValue, setInputValue] = React.useState(initialValue ?? \"\");\n\n    const theme = useTheme();\n\n    const values = React.useMemo(\n        () =>\n            allowedValues.map(x => ({\n                value: x,\n                label: x,\n            })),\n        [allowedValues]\n    );\n\n    return (\n        <Wrap>\n            <Select\n                className=\"glide-select\"\n                inputValue={inputValue}\n                onInputChange={setInputValue}\n                menuPlacement={\"auto\"}\n                value={values.find(x => x.value === value)}\n                styles={{\n                    control: base => ({\n                        ...base,\n                        border: 0,\n                        boxShadow: \"none\",\n                    }),\n                }}\n                theme={t => {\n                    return {\n                        ...t,\n                        colors: {\n                            ...t.colors,\n                            neutral0: theme.bgCell, // this is both the background color AND the fg color of\n                            // the selected item because of course it is.\n                            neutral5: theme.bgCell,\n                            neutral10: theme.bgCell,\n                            neutral20: theme.bgCellMedium,\n                            neutral30: theme.bgCellMedium,\n                            neutral40: theme.bgCellMedium,\n                            neutral50: theme.textLight,\n                            neutral60: theme.textMedium,\n                            neutral70: theme.textMedium,\n                            neutral80: theme.textDark,\n                            neutral90: theme.textDark,\n                            neutral100: theme.textDark,\n                            primary: theme.accentColor,\n                            primary75: theme.accentColor,\n                            primary50: theme.accentColor,\n                            primary25: theme.accentLight, // prelight color\n                        },\n                    };\n                }}\n                menuPortalTarget={document.getElementById(\"portal\")}\n                autoFocus={true}\n                openMenuOnFocus={true}\n                components={{\n                    DropdownIndicator: () => null,\n                    IndicatorSeparator: () => null,\n                    Menu: props => (\n                        <PortalWrap>\n                            <CustomMenu className={\"click-outside-ignore\"} {...props} />\n                        </PortalWrap>\n                    ),\n                }}\n                options={values}\n                onChange={async e => {\n                    if (e === null) return;\n                    setValue(e.value);\n                    await new Promise(r => window.requestAnimationFrame(r));\n                    onFinishedEditing({\n                        ...cell,\n                        data: {\n                            ...cell.data,\n                            value: e.value,\n                        },\n                    });\n                }}\n            />\n        </Wrap>\n    );\n};\n\nconst renderer: CustomRenderer<DropdownCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is DropdownCell => (c.data as any).kind === \"dropdown-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { value } = cell.data;\n        ctx.fillStyle = theme.textDark;\n        ctx.fillText(\n            value,\n            rect.x + theme.cellHorizontalPadding,\n            rect.y + rect.height / 2 + getMiddleCenterBias(ctx, theme)\n        );\n\n        return true;\n    },\n    provideEditor: () => ({\n        editor: Editor,\n        disablePadding: true,\n        deletedValue: v => ({\n            ...v,\n            copyData: \"\",\n            data: {\n                ...v.data,\n                value: \"\",\n            },\n        }),\n    }),\n    onPaste: (v, d) => ({\n        ...d,\n        value: d.allowedValues.includes(v) ? v : d.value,\n    }),\n};\n\nexport default renderer;\n",".wg6ppx4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}.wg6ppx4 .glide-select{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);}\n.p7jnwoo{font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);color:var(--gdg-text-dark);}.p7jnwoo > div{border-radius:4px;border:1px solid var(--gdg-border-color);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCJdLCJuYW1lcyI6WyIud2c2cHB4NCIsIi5wN2pud29vIl0sIm1hcHBpbmdzIjoiQUE2Qk1BO0FBV0FDIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9kcm9wZG93bi1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBQcm92aWRlRWRpdG9yQ2FsbGJhY2ssXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICB1c2VUaGVtZSxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTZWxlY3QsIHsgTWVudVByb3BzLCBjb21wb25lbnRzIH0gZnJvbSBcInJlYWN0LXNlbGVjdFwiO1xuXG5pbnRlcmZhY2UgQ3VzdG9tTWVudVByb3BzIGV4dGVuZHMgTWVudVByb3BzPGFueT4ge31cblxuY29uc3QgQ3VzdG9tTWVudTogUmVhY3QuRkM8Q3VzdG9tTWVudVByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgTWVudSB9ID0gY29tcG9uZW50cztcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiA8TWVudSB7Li4ucmVzdH0+e2NoaWxkcmVufTwvTWVudT47XG59O1xuXG5pbnRlcmZhY2UgRHJvcGRvd25DZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwiZHJvcGRvd24tY2VsbFwiO1xuICAgIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgYWxsb3dlZFZhbHVlczogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgcmVhZG9ubHkgcmVhZG9ubHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBEcm9wZG93bkNlbGwgPSBDdXN0b21DZWxsPERyb3Bkb3duQ2VsbFByb3BzPjtcblxuY29uc3QgV3JhcCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuXG4gICAgLmdsaWRlLXNlbGVjdCB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgICAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICB9XG5gO1xuXG5jb25zdCBQb3J0YWxXcmFwID0gc3R5bGVkLmRpdmBcbiAgICBmb250LWZhbWlseTogdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcbiAgICBmb250LXNpemU6IHZhcigtLWdkZy1lZGl0b3ItZm9udC1zaXplKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICA+IGRpdiB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuYDtcblxuY29uc3QgRWRpdG9yOiBSZXR1cm5UeXBlPFByb3ZpZGVFZGl0b3JDYWxsYmFjazxEcm9wZG93bkNlbGw+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNlbGwsIG9uRmluaXNoZWRFZGl0aW5nLCBpbml0aWFsVmFsdWUgfSA9IHA7XG4gICAgY29uc3QgeyBhbGxvd2VkVmFsdWVzLCB2YWx1ZTogdmFsdWVJbiB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSh2YWx1ZUluKTtcbiAgICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsVmFsdWUgPz8gXCJcIik7XG5cbiAgICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBSZWFjdC51c2VNZW1vKFxuICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYWxsb3dlZFZhbHVlcy5tYXAoeCA9PiAoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB4LFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBbYWxsb3dlZFZhbHVlc11cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFdyYXA+XG4gICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2xpZGUtc2VsZWN0XCJcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlPXtpbnB1dFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uSW5wdXRDaGFuZ2U9e3NldElucHV0VmFsdWV9XG4gICAgICAgICAgICAgICAgbWVudVBsYWNlbWVudD17XCJhdXRvXCJ9XG4gICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlcy5maW5kKHggPT4geC52YWx1ZSA9PT0gdmFsdWUpfVxuICAgICAgICAgICAgICAgIHN0eWxlcz17e1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBiYXNlID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICB0aGVtZT17dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udC5jb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDA6IHRoZW1lLmJnQ2VsbCwgLy8gdGhpcyBpcyBib3RoIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIEFORCB0aGUgZmcgY29sb3Igb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgaXRlbSBiZWNhdXNlIG9mIGNvdXJzZSBpdCBpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNTogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDogdGhlbWUuYmdDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwyMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwzMDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw0MDogdGhlbWUuYmdDZWxsTWVkaXVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw1MDogdGhlbWUudGV4dExpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWw2MDogdGhlbWUudGV4dE1lZGl1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsNzA6IHRoZW1lLnRleHRNZWRpdW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV1dHJhbDgwOiB0aGVtZS50ZXh0RGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXV0cmFsOTA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldXRyYWwxMDA6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk6IHRoZW1lLmFjY2VudENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnk3NTogdGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeTUwOiB0aGVtZS5hY2NlbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5MjU6IHRoZW1lLmFjY2VudExpZ2h0LCAvLyBwcmVsaWdodCBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG1lbnVQb3J0YWxUYXJnZXQ9e2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicG9ydGFsXCIpfVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvcGVuTWVudU9uRm9jdXM9e3RydWV9XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cz17e1xuICAgICAgICAgICAgICAgICAgICBEcm9wZG93bkluZGljYXRvcjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgSW5kaWNhdG9yU2VwYXJhdG9yOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBNZW51OiBwcm9wcyA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8UG9ydGFsV3JhcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Q3VzdG9tTWVudSBjbGFzc05hbWU9e1wiY2xpY2stb3V0c2lkZS1pZ25vcmVcIn0gey4uLnByb3BzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Qb3J0YWxXcmFwPlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17dmFsdWVzfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXthc3luYyBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyKSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRmluaXNoZWRFZGl0aW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvV3JhcD5cbiAgICApO1xufTtcblxuY29uc3QgcmVuZGVyZXI6IEN1c3RvbVJlbmRlcmVyPERyb3Bkb3duQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoYyk6IGMgaXMgRHJvcGRvd25DZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcImRyb3Bkb3duLWNlbGxcIixcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGNlbGwuZGF0YTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLnRleHREYXJrO1xuICAgICAgICBjdHguZmlsbFRleHQoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHJlY3QueCArIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCB0aGVtZSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+ICh7XG4gICAgICAgIGVkaXRvcjogRWRpdG9yLFxuICAgICAgICBkaXNhYmxlUGFkZGluZzogdHJ1ZSxcbiAgICAgICAgZGVsZXRlZFZhbHVlOiB2ID0+ICh7XG4gICAgICAgICAgICAuLi52LFxuICAgICAgICAgICAgY29weURhdGE6IFwiXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4udi5kYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgfSksXG4gICAgb25QYXN0ZTogKHYsIGQpID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHZhbHVlOiBkLmFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModikgPyB2IDogZC52YWx1ZSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".lld219p{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;margin:4px 0;}.lld219p > button{color:var(--gdg-accent-color);font-weight:600;-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border:none;outline:none;background-color:transparent;-webkit-transition:background-color 200ms;transition:background-color 200ms;border-radius:4px;padding:6px 8px;cursor:pointer;}.lld219p > button:hover,.lld219p > button:focus-visible{background-color:var(--gdg-accent-light);}.lld219p > button:disabled{opacity:0.4;pointer-events:none;}.lld219p .gdg-link-title-editor{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-width:250px;}.lld219p .gdg-link-title-editor > input{outline:none;border:1px solid var(--gdg-border-color);border-radius:4px;box-shadow:none;padding:6px 8px;min-width:0;width:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-transition:border 200ms;transition:border 200ms;}.lld219p .gdg-link-title-editor > input:not(:last-child){margin-right:4px;}.lld219p .gdg-link-title-editor > input:focus{border:1px solid var(--gdg-accent-color);}.lld219p .gdg-link-title-editor:not(:last-child){margin-bottom:4px;}.lld219p .gdg-link-title-editor > button{border:none;outline:none;border-radius:4px;background-color:transparent;cursor:pointer;-webkit-transition:background-color 200ms,color 200ms;transition:background-color 200ms,color 200ms;color:var(--gdg-text-medium);}.lld219p .gdg-link-title-editor > button:hover,.lld219p .gdg-link-title-editor > button:focus-visible{background-color:var(--gdg-accent-light);color:var(--gdg-text-dark);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9saW5rcy1jZWxsLnRzeCJdLCJuYW1lcyI6WyIubGxkMjE5cCJdLCJtYXBwaW5ncyI6IkFBdU1NQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvbGlua3MtY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEN1c3RvbUNlbGwsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG4gICAgYmxlbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIExpbmtzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcImxpbmtzLWNlbGxcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGhhbmQgdHVuZSB0aGUgcG9zaXRpb24gb2YgdGhlIHVuZGVybGluZSBhcyB0aGlzIGlzIG5vdCBhIG5hdGl2ZSBjYW52YXMgY2FwYWJpbGl0eSwgaXQgY2FuIG5lZWQgdHdlYWtpbmdcbiAgICAgKiBmb3IgZGlmZmVyZW50IGZvbnRzLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHVuZGVybGluZU9mZnNldD86IG51bWJlcjtcbiAgICByZWFkb25seSBtYXhMaW5rcz86IG51bWJlcjtcbiAgICByZWFkb25seSBuYXZpZ2F0ZU9uPzogXCJjbGlja1wiIHwgXCJjb250cm9sLWNsaWNrXCI7XG4gICAgcmVhZG9ubHkgbGlua3M6IHJlYWRvbmx5IHtcbiAgICAgICAgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgaHJlZj86IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgb25DbGljaz86ICgpID0+IHZvaWQ7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBMaW5rc0NlbGwgPSBDdXN0b21DZWxsPExpbmtzQ2VsbFByb3BzPjtcblxuZnVuY3Rpb24gb25DbGlja1NlbGVjdChlOiBQYXJhbWV0ZXJzPE5vbk51bGxhYmxlPEN1c3RvbVJlbmRlcmVyPExpbmtzQ2VsbD5bXCJvblNlbGVjdFwiXT4+WzBdKSB7XG4gICAgY29uc3QgdXNlQ3RybCA9IGUuY2VsbC5kYXRhLm5hdmlnYXRlT24gIT09IFwiY2xpY2tcIjtcbiAgICBpZiAodXNlQ3RybCAhPT0gZS5jdHJsS2V5KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICBpZiAoY3R4ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHBvc1g6IGhvdmVyWCwgYm91bmRzOiByZWN0LCBjZWxsLCB0aGVtZSB9ID0gZTtcbiAgICBjb25zdCBmb250ID0gYCR7dGhlbWUuYmFzZUZvbnRTdHlsZX0gJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuXG4gICAgY29uc3QgeyBsaW5rcyB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgeFBhZCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcblxuICAgIGxldCBkcmF3WCA9IHJlY3QueCArIHhQYWQ7XG5cbiAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBuZWVkc0NvbW1hID0gaW5kZXggPCBsaW5rcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSwgY3R4KTtcbiAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gcmVjdEhvdmVyWCA+IGRyYXdYICYmIHJlY3RIb3ZlclggPCBkcmF3WCArIG1ldHJpY3Mud2lkdGg7XG5cbiAgICAgICAgaWYgKGlzSG92ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cblxuICAgICAgICBkcmF3WCArPSBjb21tYU1ldHJpY3Mud2lkdGggKyA0O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxMaW5rc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBuZWVkc0hvdmVyUG9zaXRpb246IHRydWUsXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIExpbmtzQ2VsbCA9PiAoYy5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJsaW5rcy1jZWxsXCIsXG4gICAgb25TZWxlY3Q6IGUgPT4ge1xuICAgICAgICBpZiAob25DbGlja1NlbGVjdChlKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2xpY2s6IGUgPT4ge1xuICAgICAgICBjb25zdCBob3ZlcmVkID0gb25DbGlja1NlbGVjdChlKTtcbiAgICAgICAgaWYgKGhvdmVyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaG92ZXJlZC5vbkNsaWNrPy4oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QsIHRoZW1lLCBob3ZlclggPSAtMTAwLCBoaWdobGlnaHRlZCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBsaW5rcywgdW5kZXJsaW5lT2Zmc2V0ID0gNSB9ID0gY2VsbC5kYXRhO1xuXG4gICAgICAgIGNvbnN0IHhQYWQgPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgICAgbGV0IGRyYXdYID0gcmVjdC54ICsgeFBhZDtcblxuICAgICAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgICAgIGNvbnN0IGZvbnQgPSBgJHt0aGVtZS5iYXNlRm9udFN0eWxlfSAke3RoZW1lLmZvbnRGYW1pbHl9YDtcblxuICAgICAgICBjb25zdCBtaWRkbGVDZW50ZXJCaWFzID0gZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIGZvbnQpO1xuICAgICAgICBjb25zdCBkcmF3WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIG1pZGRsZUNlbnRlckJpYXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgbmVlZHNDb21tYSA9IGluZGV4IDwgbGlua3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZChsLnRpdGxlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IHJlY3RIb3ZlclggPiBkcmF3WCAmJiByZWN0SG92ZXJYIDwgZHJhd1ggKyBtZXRyaWNzLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAoaXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhkcmF3WCwgTWF0aC5mbG9vcihkcmF3WSArIHVuZGVybGluZU9mZnNldCkgKyAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZHJhd1ggKyBtZXRyaWNzLndpZHRoLCBNYXRoLmZsb29yKGRyYXdZICsgdW5kZXJsaW5lT2Zmc2V0KSArIDAuNSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGlnaGxpZ2h0ZWQgPyBibGVuZCh0aGVtZS5hY2NlbnRMaWdodCwgdGhlbWUuYmdDZWxsKSA6IHRoZW1lLmJnQ2VsbDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMSwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAxLCBkcmF3WSk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMiwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAyLCBkcmF3WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYLCBkcmF3WSk7XG5cbiAgICAgICAgICAgIGRyYXdYICs9IGNvbW1hTWV0cmljcy53aWR0aCArIDQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiBwID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgb25DaGFuZ2UgfSA9IHA7XG4gICAgICAgIGNvbnN0IHsgbGlua3MsIG1heExpbmtzID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TGlua3NDZWxsRWRpdG9yU3R5bGUgb25LZXlEb3duPXtpZ25vcmVUYWJ9PlxuICAgICAgICAgICAgICAgIHtsaW5rcy5tYXAoKGwsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPExpbmtUaXRsZUVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluaz17bC5ocmVmID8/IFwiXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17bC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzPXtpID09PSAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGU9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsobGluaywgdGl0bGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5rcyA9IFsuLi5saW5rc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3NbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17bGlua3MubGVuZ3RoID49IG1heExpbmtzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhZGQtbGlua1wiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzLCB7IHRpdGxlOiBcIlwiIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgIEFkZCBsaW5rXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L0xpbmtzQ2VsbEVkaXRvclN0eWxlPlxuICAgICAgICApO1xuICAgIH0sXG4gICAgb25QYXN0ZTogKHYsIGQpID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgaWYgKGQubGlua3Muc29tZSgobCwgaSkgPT4gc3BsaXRbaV0gIT09IGwudGl0bGUpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIGxpbmtzOiBzcGxpdC5tYXAobCA9PiAoeyB0aXRsZTogbCB9KSksXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmNvbnN0IExpbmtzQ2VsbEVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICBtYXJnaW46IDRweCAwO1xuXG4gICAgPiBidXR0b24ge1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcblxuICAgICAgICBwYWRkaW5nOiA2cHggOHB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgOmhvdmVyLFxuICAgICAgICA6Zm9jdXMtdmlzaWJsZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIDpkaXNhYmxlZCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5nZGctbGluay10aXRsZS1lZGl0b3Ige1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgICAgIG1pbi13aWR0aDogMjUwcHg7XG5cbiAgICAgICAgPiBpbnB1dCB7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgICAgICAgIHdpZHRoOiAwO1xuICAgICAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgICAgICAmOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMjAwbXM7XG5cbiAgICAgICAgICAgICY6Zm9jdXMge1xuICAgICAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDRweDtcbiAgICAgICAgfVxuXG4gICAgICAgID4gYnV0dG9uIHtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG5cbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXMsIGNvbG9yIDIwMG1zO1xuXG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICAgICAgOmhvdmVyLFxuICAgICAgICAgICAgOmZvY3VzLXZpc2libGUge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBMaW5rVGl0bGVFZGl0b3JQcm9wcyB7XG4gICAgcmVhZG9ubHkgbGluazogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHRpdGxlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgb25DaGFuZ2U6IChsaW5rOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25EZWxldGU/OiAoKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IGZvY3VzOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBpZ25vcmVUYWIoZTogUmVhY3QuS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChlLmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbn1cblxuY29uc3QgTGlua1RpdGxlRWRpdG9yOiBSZWFjdC5WRkM8TGlua1RpdGxlRWRpdG9yUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBsaW5rLCBvbkNoYW5nZSwgdGl0bGUsIG9uRGVsZXRlLCBmb2N1cyB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdkZy1saW5rLXRpdGxlLWVkaXRvclwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLXRpdGxlLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGl0bGV9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJUaXRsZVwiXG4gICAgICAgICAgICAgICAgYXV0b0ZvY3VzPXtmb2N1c31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGxpbmssIGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdkZy1saW5rLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17bGlua31cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlVSTFwiXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShlLnRhcmdldC52YWx1ZSwgdGl0bGUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge29uRGVsZXRlICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17b25EZWxldGV9PlxuICAgICAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17MTZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9ezE2fVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cImljb24taW1wb3J0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0zIDZMNSA2TDIxIDZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTE3LjkwMTkgNkMxOC40OTEgNiAxOC45NTI1IDYuNTA2NzYgMTguODk3NSA3LjA5MzM0TDE3LjY3IDIwLjE4NjdDMTcuNTczNiAyMS4yMTQ0IDE2LjcxMSAyMiAxNS42Nzg3IDIySDguMzIxMjdDNy4yODkwMiAyMiA2LjQyNjM1IDIxLjIxNDQgNi4zMyAyMC4xODY3TDUuMTAyNSA3LjA5MzM0QzUuMDQ3NTEgNi41MDY3NiA1LjUwODk4IDYgNi4wOTgxMyA2SDE3LjkwMTlaXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0xNC40NDk5IDEwLjIxMUwxMy45OTQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk05LjU1NDk5IDEwLjIxMUwxMC4wMDQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk03LjUgMi4yNUgxNi41XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyZXI7XG4iXX0=*/", "",{"version":3,"sources":["webpack://./packages/cells/src/cells/packages/cells/src/cells/links-cell.tsx","webpack://./packages/cells/src/cells/links-cell.tsx"],"names":[".lld219p"],"mappings":"AAuMMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,CAAAA,kBAAAA,6BAAAA,CAAAA,eAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,4BAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,wDAAAA,wCAAAA,CAAAA,CAAAA,2BAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,gCAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,eAAAA,CAAAA,CAAAA,wCAAAA,YAAAA,CAAAA,wCAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,OAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,+BAAAA,CAAAA,uBAAAA,CAAAA,CAAAA,yDAAAA,gBAAAA,CAAAA,CAAAA,8CAAAA,wCAAAA,CAAAA,CAAAA,iDAAAA,iBAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,YAAAA,CAAAA,iBAAAA,CAAAA,4BAAAA,CAAAA,cAAAA,CAAAA,qDAAAA,CAAAA,6CAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,sGAAAA,wCAAAA,CAAAA,0BAAAA,CAAAA;ACtMN,mghBAAmghB","sourcesContent":["import {\n    CustomCell,\n    measureTextCached,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n    blend,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\n\ninterface LinksCellProps {\n    readonly kind: \"links-cell\";\n    /**\n     * Used to hand tune the position of the underline as this is not a native canvas capability, it can need tweaking\n     * for different fonts.\n     */\n    readonly underlineOffset?: number;\n    readonly maxLinks?: number;\n    readonly navigateOn?: \"click\" | \"control-click\";\n    readonly links: readonly {\n        readonly title: string;\n        readonly href?: string;\n        readonly onClick?: () => void;\n    }[];\n}\n\nexport type LinksCell = CustomCell<LinksCellProps>;\n\nfunction onClickSelect(e: Parameters<NonNullable<CustomRenderer<LinksCell>[\"onSelect\"]>>[0]) {\n    const useCtrl = e.cell.data.navigateOn !== \"click\";\n    if (useCtrl !== e.ctrlKey) return undefined;\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\", { alpha: false });\n    if (ctx === null) return;\n\n    const { posX: hoverX, bounds: rect, cell, theme } = e;\n    const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n    ctx.font = font;\n\n    const { links } = cell.data;\n\n    const xPad = theme.cellHorizontalPadding;\n\n    let drawX = rect.x + xPad;\n\n    const rectHoverX = rect.x + hoverX;\n\n    for (const [index, l] of links.entries()) {\n        const needsComma = index < links.length - 1;\n        const metrics = measureTextCached(l.title, ctx);\n        const commaMetrics = needsComma ? measureTextCached(l.title + \",\", ctx, font) : metrics;\n\n        const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\n\n        if (isHovered) {\n            return l;\n        }\n\n        drawX += commaMetrics.width + 4;\n    }\n\n    return undefined;\n}\n\nconst renderer: CustomRenderer<LinksCell> = {\n    kind: GridCellKind.Custom,\n    needsHover: true,\n    needsHoverPosition: true,\n    isMatch: (c): c is LinksCell => (c.data as any).kind === \"links-cell\",\n    onSelect: e => {\n        if (onClickSelect(e) !== undefined) {\n            e.preventDefault();\n        }\n    },\n    onClick: e => {\n        const hovered = onClickSelect(e);\n        if (hovered !== undefined) {\n            hovered.onClick?.();\n            e.preventDefault();\n        }\n        return undefined;\n    },\n    draw: (args, cell) => {\n        const { ctx, rect, theme, hoverX = -100, highlighted } = args;\n        const { links, underlineOffset = 5 } = cell.data;\n\n        const xPad = theme.cellHorizontalPadding;\n\n        let drawX = rect.x + xPad;\n\n        const rectHoverX = rect.x + hoverX;\n\n        const font = `${theme.baseFontStyle} ${theme.fontFamily}`;\n\n        const middleCenterBias = getMiddleCenterBias(ctx, font);\n        const drawY = rect.y + rect.height / 2 + middleCenterBias;\n\n        for (const [index, l] of links.entries()) {\n            const needsComma = index < links.length - 1;\n            const metrics = measureTextCached(l.title, ctx);\n            const commaMetrics = needsComma ? measureTextCached(l.title + \",\", ctx, font) : metrics;\n\n            const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;\n\n            if (isHovered) {\n                ctx.moveTo(drawX, Math.floor(drawY + underlineOffset) + 0.5);\n                ctx.lineTo(drawX + metrics.width, Math.floor(drawY + underlineOffset) + 0.5);\n\n                // ctx.lineWidth = 1;\n                ctx.strokeStyle = theme.textDark;\n                ctx.stroke();\n\n                ctx.fillStyle = highlighted ? blend(theme.accentLight, theme.bgCell) : theme.bgCell;\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX - 1, drawY);\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX + 1, drawY);\n\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX - 2, drawY);\n                ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX + 2, drawY);\n            }\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(needsComma ? l.title + \",\" : l.title, drawX, drawY);\n\n            drawX += commaMetrics.width + 4;\n        }\n\n        return true;\n    },\n    // eslint-disable-next-line react/display-name\n    provideEditor: () => p => {\n        const { value, onChange } = p;\n        const { links, maxLinks = Number.MAX_SAFE_INTEGER } = value.data;\n        return (\n            <LinksCellEditorStyle onKeyDown={ignoreTab}>\n                {links.map((l, i) => (\n                    <LinkTitleEditor\n                        key={i}\n                        link={l.href ?? \"\"}\n                        title={l.title}\n                        focus={i === 0}\n                        onDelete={\n                            links.length > 1\n                                ? () => {\n                                      const newLinks = [...links];\n                                      newLinks.splice(i, 1);\n                                      onChange({\n                                          ...value,\n                                          data: {\n                                              ...value.data,\n                                              links: newLinks,\n                                          },\n                                      });\n                                  }\n                                : undefined\n                        }\n                        onChange={(link, title) => {\n                            const newLinks = [...links];\n                            newLinks[i] = {\n                                href: link,\n                                title,\n                            };\n                            onChange({\n                                ...value,\n                                data: {\n                                    ...value.data,\n                                    links: newLinks,\n                                },\n                            });\n                        }}\n                    />\n                ))}\n                <button\n                    disabled={links.length >= maxLinks}\n                    className=\"add-link\"\n                    onClick={() => {\n                        const newLinks = [...links, { title: \"\" }];\n                        onChange({\n                            ...value,\n                            data: {\n                                ...value.data,\n                                links: newLinks,\n                            },\n                        });\n                    }}>\n                    Add link\n                </button>\n            </LinksCellEditorStyle>\n        );\n    },\n    onPaste: (v, d) => {\n        const split = v.split(\",\");\n        if (d.links.some((l, i) => split[i] !== l.title)) return undefined;\n        return {\n            ...d,\n            links: split.map(l => ({ title: l })),\n        };\n    },\n};\n\nconst LinksCellEditorStyle = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    margin: 4px 0;\n\n    > button {\n        color: var(--gdg-accent-color);\n        font-weight: 600;\n        align-self: flex-end;\n        border: none;\n        outline: none;\n        background-color: transparent;\n\n        transition: background-color 200ms;\n        border-radius: 4px;\n\n        padding: 6px 8px;\n        cursor: pointer;\n\n        :hover,\n        :focus-visible {\n            background-color: var(--gdg-accent-light);\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n\n    .gdg-link-title-editor {\n        display: flex;\n\n        min-width: 250px;\n\n        > input {\n            outline: none;\n            border: 1px solid var(--gdg-border-color);\n            border-radius: 4px;\n            box-shadow: none;\n            padding: 6px 8px;\n            min-width: 0;\n            width: 0;\n            flex-grow: 1;\n\n            &:not(:last-child) {\n                margin-right: 4px;\n            }\n\n            transition: border 200ms;\n\n            &:focus {\n                border: 1px solid var(--gdg-accent-color);\n            }\n        }\n\n        &:not(:last-child) {\n            margin-bottom: 4px;\n        }\n\n        > button {\n            border: none;\n            outline: none;\n            border-radius: 4px;\n\n            background-color: transparent;\n\n            cursor: pointer;\n\n            transition: background-color 200ms, color 200ms;\n\n            color: var(--gdg-text-medium);\n\n            :hover,\n            :focus-visible {\n                background-color: var(--gdg-accent-light);\n                color: var(--gdg-text-dark);\n            }\n        }\n    }\n`;\n\ninterface LinkTitleEditorProps {\n    readonly link: string;\n    readonly title: string;\n    readonly onChange: (link: string, title: string) => void;\n    readonly onDelete?: () => void;\n    readonly focus: boolean;\n}\n\nfunction ignoreTab(e: React.KeyboardEvent) {\n    if (e.key === \"Tab\") {\n        e.stopPropagation();\n    }\n}\n\nconst LinkTitleEditor: React.VFC<LinkTitleEditorProps> = p => {\n    const { link, onChange, title, onDelete, focus } = p;\n    return (\n        <div className=\"gdg-link-title-editor\">\n            <input\n                className=\"gdg-title-input\"\n                value={title}\n                placeholder=\"Title\"\n                autoFocus={focus}\n                onChange={e => {\n                    onChange(link, e.target.value);\n                }}\n            />\n            <input\n                className=\"gdg-link-input\"\n                value={link}\n                placeholder=\"URL\"\n                onChange={e => {\n                    onChange(e.target.value, title);\n                }}\n            />\n            {onDelete !== undefined && (\n                <button onClick={onDelete}>\n                    <svg\n                        width={16}\n                        height={16}\n                        viewBox=\"0 0 24 24\"\n                        fill=\"none\"\n                        id=\"icon-import\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M3 6L5 6L21 6\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M17.9019 6C18.491 6 18.9525 6.50676 18.8975 7.09334L17.67 20.1867C17.5736 21.2144 16.711 22 15.6787 22H8.32127C7.28902 22 6.42635 21.2144 6.33 20.1867L5.1025 7.09334C5.04751 6.50676 5.50898 6 6.09813 6H17.9019Z\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M14.4499 10.211L13.9949 17\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M9.55499 10.211L10.0049 17\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                        <path\n                            d=\"M7.5 2.25H16.5\"\n                            stroke=\"currentColor\"\n                            strokeWidth=\"1px\"\n                            strokeLinecap=\"round\"\n                            strokeLinejoin=\"round\"\n                        />\n                    </svg>\n                </button>\n            )}\n        </div>\n    );\n};\n\nexport default renderer;\n",".lld219p{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;margin:4px 0;}.lld219p > button{color:var(--gdg-accent-color);font-weight:600;-webkit-align-self:flex-end;-ms-flex-item-align:end;align-self:flex-end;border:none;outline:none;background-color:transparent;-webkit-transition:background-color 200ms;transition:background-color 200ms;border-radius:4px;padding:6px 8px;cursor:pointer;}.lld219p > button:hover,.lld219p > button:focus-visible{background-color:var(--gdg-accent-light);}.lld219p > button:disabled{opacity:0.4;pointer-events:none;}.lld219p .gdg-link-title-editor{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;min-width:250px;}.lld219p .gdg-link-title-editor > input{outline:none;border:1px solid var(--gdg-border-color);border-radius:4px;box-shadow:none;padding:6px 8px;min-width:0;width:0;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-transition:border 200ms;transition:border 200ms;}.lld219p .gdg-link-title-editor > input:not(:last-child){margin-right:4px;}.lld219p .gdg-link-title-editor > input:focus{border:1px solid var(--gdg-accent-color);}.lld219p .gdg-link-title-editor:not(:last-child){margin-bottom:4px;}.lld219p .gdg-link-title-editor > button{border:none;outline:none;border-radius:4px;background-color:transparent;cursor:pointer;-webkit-transition:background-color 200ms,color 200ms;transition:background-color 200ms,color 200ms;color:var(--gdg-text-medium);}.lld219p .gdg-link-title-editor > button:hover,.lld219p .gdg-link-title-editor > button:focus-visible{background-color:var(--gdg-accent-light);color:var(--gdg-text-dark);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9saW5rcy1jZWxsLnRzeCJdLCJuYW1lcyI6WyIubGxkMjE5cCJdLCJtYXBwaW5ncyI6IkFBdU1NQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvbGlua3MtY2VsbC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEN1c3RvbUNlbGwsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG4gICAgYmxlbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIExpbmtzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcImxpbmtzLWNlbGxcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGhhbmQgdHVuZSB0aGUgcG9zaXRpb24gb2YgdGhlIHVuZGVybGluZSBhcyB0aGlzIGlzIG5vdCBhIG5hdGl2ZSBjYW52YXMgY2FwYWJpbGl0eSwgaXQgY2FuIG5lZWQgdHdlYWtpbmdcbiAgICAgKiBmb3IgZGlmZmVyZW50IGZvbnRzLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHVuZGVybGluZU9mZnNldD86IG51bWJlcjtcbiAgICByZWFkb25seSBtYXhMaW5rcz86IG51bWJlcjtcbiAgICByZWFkb25seSBuYXZpZ2F0ZU9uPzogXCJjbGlja1wiIHwgXCJjb250cm9sLWNsaWNrXCI7XG4gICAgcmVhZG9ubHkgbGlua3M6IHJlYWRvbmx5IHtcbiAgICAgICAgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgaHJlZj86IHN0cmluZztcbiAgICAgICAgcmVhZG9ubHkgb25DbGljaz86ICgpID0+IHZvaWQ7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBMaW5rc0NlbGwgPSBDdXN0b21DZWxsPExpbmtzQ2VsbFByb3BzPjtcblxuZnVuY3Rpb24gb25DbGlja1NlbGVjdChlOiBQYXJhbWV0ZXJzPE5vbk51bGxhYmxlPEN1c3RvbVJlbmRlcmVyPExpbmtzQ2VsbD5bXCJvblNlbGVjdFwiXT4+WzBdKSB7XG4gICAgY29uc3QgdXNlQ3RybCA9IGUuY2VsbC5kYXRhLm5hdmlnYXRlT24gIT09IFwiY2xpY2tcIjtcbiAgICBpZiAodXNlQ3RybCAhPT0gZS5jdHJsS2V5KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiBmYWxzZSB9KTtcbiAgICBpZiAoY3R4ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBjb25zdCB7IHBvc1g6IGhvdmVyWCwgYm91bmRzOiByZWN0LCBjZWxsLCB0aGVtZSB9ID0gZTtcbiAgICBjb25zdCBmb250ID0gYCR7dGhlbWUuYmFzZUZvbnRTdHlsZX0gJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuXG4gICAgY29uc3QgeyBsaW5rcyB9ID0gY2VsbC5kYXRhO1xuXG4gICAgY29uc3QgeFBhZCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcblxuICAgIGxldCBkcmF3WCA9IHJlY3QueCArIHhQYWQ7XG5cbiAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBuZWVkc0NvbW1hID0gaW5kZXggPCBsaW5rcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQobC50aXRsZSwgY3R4KTtcbiAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gcmVjdEhvdmVyWCA+IGRyYXdYICYmIHJlY3RIb3ZlclggPCBkcmF3WCArIG1ldHJpY3Mud2lkdGg7XG5cbiAgICAgICAgaWYgKGlzSG92ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cblxuICAgICAgICBkcmF3WCArPSBjb21tYU1ldHJpY3Mud2lkdGggKyA0O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxMaW5rc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBuZWVkc0hvdmVyUG9zaXRpb246IHRydWUsXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIExpbmtzQ2VsbCA9PiAoYy5kYXRhIGFzIGFueSkua2luZCA9PT0gXCJsaW5rcy1jZWxsXCIsXG4gICAgb25TZWxlY3Q6IGUgPT4ge1xuICAgICAgICBpZiAob25DbGlja1NlbGVjdChlKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2xpY2s6IGUgPT4ge1xuICAgICAgICBjb25zdCBob3ZlcmVkID0gb25DbGlja1NlbGVjdChlKTtcbiAgICAgICAgaWYgKGhvdmVyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaG92ZXJlZC5vbkNsaWNrPy4oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZHJhdzogKGFyZ3MsIGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QsIHRoZW1lLCBob3ZlclggPSAtMTAwLCBoaWdobGlnaHRlZCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBsaW5rcywgdW5kZXJsaW5lT2Zmc2V0ID0gNSB9ID0gY2VsbC5kYXRhO1xuXG4gICAgICAgIGNvbnN0IHhQYWQgPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgICAgbGV0IGRyYXdYID0gcmVjdC54ICsgeFBhZDtcblxuICAgICAgICBjb25zdCByZWN0SG92ZXJYID0gcmVjdC54ICsgaG92ZXJYO1xuXG4gICAgICAgIGNvbnN0IGZvbnQgPSBgJHt0aGVtZS5iYXNlRm9udFN0eWxlfSAke3RoZW1lLmZvbnRGYW1pbHl9YDtcblxuICAgICAgICBjb25zdCBtaWRkbGVDZW50ZXJCaWFzID0gZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIGZvbnQpO1xuICAgICAgICBjb25zdCBkcmF3WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiArIG1pZGRsZUNlbnRlckJpYXM7XG5cbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGxdIG9mIGxpbmtzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgbmVlZHNDb21tYSA9IGluZGV4IDwgbGlua3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZWFzdXJlVGV4dENhY2hlZChsLnRpdGxlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgY29tbWFNZXRyaWNzID0gbmVlZHNDb21tYSA/IG1lYXN1cmVUZXh0Q2FjaGVkKGwudGl0bGUgKyBcIixcIiwgY3R4LCBmb250KSA6IG1ldHJpY3M7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IHJlY3RIb3ZlclggPiBkcmF3WCAmJiByZWN0SG92ZXJYIDwgZHJhd1ggKyBtZXRyaWNzLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAoaXNIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhkcmF3WCwgTWF0aC5mbG9vcihkcmF3WSArIHVuZGVybGluZU9mZnNldCkgKyAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZHJhd1ggKyBtZXRyaWNzLndpZHRoLCBNYXRoLmZsb29yKGRyYXdZICsgdW5kZXJsaW5lT2Zmc2V0KSArIDAuNSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZS50ZXh0RGFyaztcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGlnaGxpZ2h0ZWQgPyBibGVuZCh0aGVtZS5hY2NlbnRMaWdodCwgdGhlbWUuYmdDZWxsKSA6IHRoZW1lLmJnQ2VsbDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMSwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAxLCBkcmF3WSk7XG5cbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYIC0gMiwgZHJhd1kpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChuZWVkc0NvbW1hID8gbC50aXRsZSArIFwiLFwiIDogbC50aXRsZSwgZHJhd1ggKyAyLCBkcmF3WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobmVlZHNDb21tYSA/IGwudGl0bGUgKyBcIixcIiA6IGwudGl0bGUsIGRyYXdYLCBkcmF3WSk7XG5cbiAgICAgICAgICAgIGRyYXdYICs9IGNvbW1hTWV0cmljcy53aWR0aCArIDQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiBwID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgb25DaGFuZ2UgfSA9IHA7XG4gICAgICAgIGNvbnN0IHsgbGlua3MsIG1heExpbmtzID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TGlua3NDZWxsRWRpdG9yU3R5bGUgb25LZXlEb3duPXtpZ25vcmVUYWJ9PlxuICAgICAgICAgICAgICAgIHtsaW5rcy5tYXAoKGwsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPExpbmtUaXRsZUVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluaz17bC5ocmVmID8/IFwiXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17bC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzPXtpID09PSAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGU9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsobGluaywgdGl0bGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5rcyA9IFsuLi5saW5rc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlua3NbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBuZXdMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17bGlua3MubGVuZ3RoID49IG1heExpbmtzfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhZGQtbGlua1wiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmtzID0gWy4uLmxpbmtzLCB7IHRpdGxlOiBcIlwiIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IG5ld0xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgIEFkZCBsaW5rXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L0xpbmtzQ2VsbEVkaXRvclN0eWxlPlxuICAgICAgICApO1xuICAgIH0sXG4gICAgb25QYXN0ZTogKHYsIGQpID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgaWYgKGQubGlua3Muc29tZSgobCwgaSkgPT4gc3BsaXRbaV0gIT09IGwudGl0bGUpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIGxpbmtzOiBzcGxpdC5tYXAobCA9PiAoeyB0aXRsZTogbCB9KSksXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmNvbnN0IExpbmtzQ2VsbEVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICBtYXJnaW46IDRweCAwO1xuXG4gICAgPiBidXR0b24ge1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcblxuICAgICAgICBwYWRkaW5nOiA2cHggOHB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgOmhvdmVyLFxuICAgICAgICA6Zm9jdXMtdmlzaWJsZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIDpkaXNhYmxlZCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC5nZGctbGluay10aXRsZS1lZGl0b3Ige1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgICAgIG1pbi13aWR0aDogMjUwcHg7XG5cbiAgICAgICAgPiBpbnB1dCB7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgICAgICAgIHdpZHRoOiAwO1xuICAgICAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgICAgICAmOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgICAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNHB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBib3JkZXIgMjAwbXM7XG5cbiAgICAgICAgICAgICY6Zm9jdXMge1xuICAgICAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDRweDtcbiAgICAgICAgfVxuXG4gICAgICAgID4gYnV0dG9uIHtcbiAgICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG5cbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXMsIGNvbG9yIDIwMG1zO1xuXG4gICAgICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICAgICAgOmhvdmVyLFxuICAgICAgICAgICAgOmZvY3VzLXZpc2libGUge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtbGlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmludGVyZmFjZSBMaW5rVGl0bGVFZGl0b3JQcm9wcyB7XG4gICAgcmVhZG9ubHkgbGluazogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHRpdGxlOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgb25DaGFuZ2U6IChsaW5rOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25EZWxldGU/OiAoKSA9PiB2b2lkO1xuICAgIHJlYWRvbmx5IGZvY3VzOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBpZ25vcmVUYWIoZTogUmVhY3QuS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChlLmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbn1cblxuY29uc3QgTGlua1RpdGxlRWRpdG9yOiBSZWFjdC5WRkM8TGlua1RpdGxlRWRpdG9yUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBsaW5rLCBvbkNoYW5nZSwgdGl0bGUsIG9uRGVsZXRlLCBmb2N1cyB9ID0gcDtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdkZy1saW5rLXRpdGxlLWVkaXRvclwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLXRpdGxlLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGl0bGV9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJUaXRsZVwiXG4gICAgICAgICAgICAgICAgYXV0b0ZvY3VzPXtmb2N1c31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGxpbmssIGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdkZy1saW5rLWlucHV0XCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17bGlua31cbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlVSTFwiXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShlLnRhcmdldC52YWx1ZSwgdGl0bGUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge29uRGVsZXRlICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17b25EZWxldGV9PlxuICAgICAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17MTZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9ezE2fVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cImljb24taW1wb3J0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0zIDZMNSA2TDIxIDZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIxcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTE3LjkwMTkgNkMxOC40OTEgNiAxOC45NTI1IDYuNTA2NzYgMTguODk3NSA3LjA5MzM0TDE3LjY3IDIwLjE4NjdDMTcuNTczNiAyMS4yMTQ0IDE2LjcxMSAyMiAxNS42Nzg3IDIySDguMzIxMjdDNy4yODkwMiAyMiA2LjQyNjM1IDIxLjIxNDQgNi4zMyAyMC4xODY3TDUuMTAyNSA3LjA5MzM0QzUuMDQ3NTEgNi41MDY3NiA1LjUwODk4IDYgNi4wOTgxMyA2SDE3LjkwMTlaXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0xNC40NDk5IDEwLjIxMUwxMy45OTQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk05LjU1NDk5IDEwLjIxMUwxMC4wMDQ5IDE3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk03LjUgMi4yNUgxNi41XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMXB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyZXI7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".e8nv6xj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:6px 0;color:var(--gdg-text-light);}.e8nv6xj .active{color:var(--gdg-text-dark);}.e8nv6xj > *{position:relative;width:16px;height:16px;cursor:pointer;margin-right:2px;}.e8nv6xj > * svg{width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lOG52NnhqIl0sIm1hcHBpbmdzIjoiQUFrRE1BIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VzdG9tQ2VsbCwgSXRlbSwgQ3VzdG9tUmVuZGVyZXIsIEdyaWRDZWxsS2luZCB9IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFN0YXJDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwic3Rhci1jZWxsXCI7XG4gICAgcmVhZG9ubHkgcmF0aW5nOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFN0YXJDZWxsID0gQ3VzdG9tQ2VsbDxTdGFyQ2VsbFByb3BzPjtcblxuY29uc3Qgc3RhclBvaW50cyA9IFtcbiAgICBbNTAsIDVdLFxuICAgIFs2MS4yMywgMzkuNTVdLFxuICAgIFs5Ny41NSwgMzkuNTVdLFxuICAgIFs2OC4xNiwgNjAuOV0sXG4gICAgWzc5LjM5LCA5NS40NV0sXG4gICAgWzUwLCA3NC4xXSxcbiAgICBbMjAuNjEsIDk1LjQ1XSxcbiAgICBbMzEuODQsIDYwLjldLFxuICAgIFsyLjQ1LCAzOS41NV0sXG4gICAgWzM4Ljc3LCAzOS41NV0sXG5dO1xuXG5mdW5jdGlvbiBwYXRoU3RhcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2VudGVyOiBJdGVtLCBzaXplOiBudW1iZXIpIHtcbiAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHAgb2Ygc3RhclBvaW50cykge1xuICAgICAgICBjb25zdCB4ID0gKHBbMF0gLSA1MCkgKiAoc2l6ZSAvIDEwMCkgKyBjZW50ZXJbMF07XG4gICAgICAgIGNvbnN0IHkgPSAocFsxXSAtIDUwKSAqIChzaXplIC8gMTAwKSArIGNlbnRlclsxXTtcblxuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5jb25zdCBTdGFyU1ZHID0gKCkgPT4gKFxuICAgIDxzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGQ9XCJNNDcuMTQ2OCAxMy43ODExQzQ4LjA0NDkgMTEuMDE3MiA1MS45NTUxIDExLjAxNzIgNTIuODUzMiAxMy43ODEyTDYwLjU1MjIgMzcuNDc2MkM2MC45NTM4IDM4LjcxMjMgNjIuMTA1NiAzOS41NDkxIDYzLjQwNTMgMzkuNTQ5MUg4OC4zMTk4QzkxLjIyNiAzOS41NDkxIDkyLjQzNDMgNDMuMjY4IDkwLjA4MzEgNDQuOTc2Mkw2OS45MjY5IDU5LjYyMDVDNjguODc1NSA2MC4zODQ1IDY4LjQzNTUgNjEuNzM4NiA2OC44MzcxIDYyLjk3NDZMNzYuNTM2MSA4Ni42Njk3Qzc3LjQzNDIgODkuNDMzNiA3NC4yNzA3IDkxLjczMiA3MS45MTk2IDkwLjAyMzhMNTEuNzYzNCA3NS4zNzk0QzUwLjcxMTkgNzQuNjE1NSA0OS4yODgxIDc0LjYxNTUgNDguMjM2NiA3NS4zNzk1TDI4LjA4MDQgOTAuMDIzOEMyNS43MjkzIDkxLjczMiAyMi41NjU5IDg5LjQzMzYgMjMuNDYzOSA4Ni42Njk3TDMxLjE2MjkgNjIuOTc0NkMzMS41NjQ1IDYxLjczODYgMzEuMTI0NSA2MC4zODQ1IDMwLjA3MzEgNTkuNjIwNUw5LjkxNjg2IDQ0Ljk3NjJDNy41NjU3MiA0My4yNjggOC43NzQwNSAzOS41NDkxIDExLjY4MDIgMzkuNTQ5MUgzNi41OTQ3QzM3Ljg5NDQgMzkuNTQ5MSAzOS4wNDYyIDM4LjcxMjMgMzkuNDQ3OCAzNy40NzYyTDQ3LjE0NjggMTMuNzgxMVpcIlxuICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIC8+XG4gICAgPC9zdmc+XG4pO1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdmBcbiAgICAuYWN0aXZlIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIH1cblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiA2cHggMDtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuXG4gICAgPiAqIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTZweDtcbiAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMnB4O1xuXG4gICAgICAgIHN2ZyB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxTdGFyQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoY2VsbDogQ3VzdG9tQ2VsbCk6IGNlbGwgaXMgU3RhckNlbGwgPT4gKGNlbGwuZGF0YSBhcyBhbnkpLmtpbmQgPT09IFwic3Rhci1jZWxsXCIsXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QsIGhvdmVyQW1vdW50IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHJhdGluZyB9ID0gY2VsbC5kYXRhO1xuICAgICAgICBjb25zdCBwYWRYID0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuICAgICAgICBsZXQgZHJhd1ggPSByZWN0LnggKyBwYWRYO1xuICAgICAgICBjb25zdCBzdGFycyA9IE1hdGgubWluKDUsIE1hdGguY2VpbChyYXRpbmcpKTtcbiAgICAgICAgZHJhd1ggKz0gODtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJzOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGhTdGFyKGN0eCwgW2RyYXdYLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdLCAxNik7XG4gICAgICAgICAgICBkcmF3WCArPSAxODtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNiArIDAuNCAqIGhvdmVyQW1vdW50O1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgICAgICByZXR1cm4gcCA9PiAoXG4gICAgICAgICAgICA8RWRpdG9yV3JhcD5cbiAgICAgICAgICAgICAgICB7WzAsIDEsIDIsIDMsIDRdLm1hcChpbmRleCA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3AudmFsdWUuZGF0YS5yYXRpbmcgPCBpbmRleCArIDEgPyBcImluYWN0aXZlXCIgOiBcImFjdGl2ZVwifVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPFN0YXJTVkcgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L0VkaXRvcldyYXA+XG4gICAgICAgICk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAodmFsLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUludCh2YWwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIHJhdGluZzogTnVtYmVyLmlzTmFOKG51bSkgPyAwIDogbnVtLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/cells/src/cells/packages/cells/src/cells/star-cell.tsx","webpack://./packages/cells/src/cells/star-cell.tsx"],"names":[".e8nv6xj"],"mappings":"AAkDMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,aAAAA,CAAAA,2BAAAA,CAAAA,CAAAA,iBAAAA,0BAAAA,CAAAA,CAAAA,aAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,iBAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACjDN,mvLAAmvL","sourcesContent":["import { CustomCell, Item, CustomRenderer, GridCellKind } from \"@glideapps/glide-data-grid\";\nimport * as React from \"react\";\nimport { styled } from \"@linaria/react\";\n\ninterface StarCellProps {\n    readonly kind: \"star-cell\";\n    readonly rating: number;\n}\n\nexport type StarCell = CustomCell<StarCellProps>;\n\nconst starPoints = [\n    [50, 5],\n    [61.23, 39.55],\n    [97.55, 39.55],\n    [68.16, 60.9],\n    [79.39, 95.45],\n    [50, 74.1],\n    [20.61, 95.45],\n    [31.84, 60.9],\n    [2.45, 39.55],\n    [38.77, 39.55],\n];\n\nfunction pathStar(ctx: CanvasRenderingContext2D, center: Item, size: number) {\n    let moved = false;\n    for (const p of starPoints) {\n        const x = (p[0] - 50) * (size / 100) + center[0];\n        const y = (p[1] - 50) * (size / 100) + center[1];\n\n        if (moved) {\n            ctx.lineTo(x, y);\n        } else {\n            ctx.moveTo(x, y);\n            moved = true;\n        }\n    }\n\n    ctx.closePath();\n}\n\nconst StarSVG = () => (\n    <svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n        <path\n            d=\"M47.1468 13.7811C48.0449 11.0172 51.9551 11.0172 52.8532 13.7812L60.5522 37.4762C60.9538 38.7123 62.1056 39.5491 63.4053 39.5491H88.3198C91.226 39.5491 92.4343 43.268 90.0831 44.9762L69.9269 59.6205C68.8755 60.3845 68.4355 61.7386 68.8371 62.9746L76.5361 86.6697C77.4342 89.4336 74.2707 91.732 71.9196 90.0238L51.7634 75.3794C50.7119 74.6155 49.2881 74.6155 48.2366 75.3795L28.0804 90.0238C25.7293 91.732 22.5659 89.4336 23.4639 86.6697L31.1629 62.9746C31.5645 61.7386 31.1245 60.3845 30.0731 59.6205L9.91686 44.9762C7.56572 43.268 8.77405 39.5491 11.6802 39.5491H36.5947C37.8944 39.5491 39.0462 38.7123 39.4478 37.4762L47.1468 13.7811Z\"\n            fill=\"currentColor\"\n        />\n    </svg>\n);\n\nconst EditorWrap = styled.div`\n    .active {\n        color: var(--gdg-text-dark);\n    }\n\n    display: flex;\n    align-items: center;\n    padding: 6px 0;\n    color: var(--gdg-text-light);\n\n    > * {\n        position: relative;\n        width: 16px;\n        height: 16px;\n        cursor: pointer;\n        margin-right: 2px;\n\n        svg {\n            width: 100%;\n            height: 100%;\n        }\n    }\n`;\n\nconst renderer: CustomRenderer<StarCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (cell: CustomCell): cell is StarCell => (cell.data as any).kind === \"star-cell\",\n    needsHover: true,\n    draw: (args, cell) => {\n        const { ctx, theme, rect, hoverAmount } = args;\n        const { rating } = cell.data;\n        const padX = theme.cellHorizontalPadding;\n        let drawX = rect.x + padX;\n        const stars = Math.min(5, Math.ceil(rating));\n        drawX += 8;\n        ctx.beginPath();\n        for (let i = 0; i < stars; i++) {\n            pathStar(ctx, [drawX, rect.y + rect.height / 2], 16);\n            drawX += 18;\n        }\n        ctx.fillStyle = theme.textDark;\n        ctx.globalAlpha = 0.6 + 0.4 * hoverAmount;\n        ctx.fill();\n        ctx.globalAlpha = 1;\n        return true;\n    },\n    provideEditor: () => {\n        // eslint-disable-next-line react/display-name\n        return p => (\n            <EditorWrap>\n                {[0, 1, 2, 3, 4].map(index => (\n                    <div\n                        key={index}\n                        className={p.value.data.rating < index + 1 ? \"inactive\" : \"active\"}\n                        onClick={() => {\n                            p.onChange({\n                                ...p.value,\n                                data: {\n                                    ...p.value.data,\n                                    rating: index + 1,\n                                },\n                            });\n                        }}>\n                        <StarSVG />\n                    </div>\n                ))}\n            </EditorWrap>\n        );\n    },\n    onPaste: (val, d) => {\n        const num = Number.parseInt(val);\n        return {\n            ...d,\n            rating: Number.isNaN(num) ? 0 : num,\n        };\n    },\n};\n\nexport default renderer;\n",".e8nv6xj{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:6px 0;color:var(--gdg-text-light);}.e8nv6xj .active{color:var(--gdg-text-dark);}.e8nv6xj > *{position:relative;width:16px;height:16px;cursor:pointer;margin-right:2px;}.e8nv6xj > * svg{width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lOG52NnhqIl0sIm1hcHBpbmdzIjoiQUFrRE1BIiwiZmlsZSI6InBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy9zdGFyLWNlbGwudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VzdG9tQ2VsbCwgSXRlbSwgQ3VzdG9tUmVuZGVyZXIsIEdyaWRDZWxsS2luZCB9IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFN0YXJDZWxsUHJvcHMge1xuICAgIHJlYWRvbmx5IGtpbmQ6IFwic3Rhci1jZWxsXCI7XG4gICAgcmVhZG9ubHkgcmF0aW5nOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFN0YXJDZWxsID0gQ3VzdG9tQ2VsbDxTdGFyQ2VsbFByb3BzPjtcblxuY29uc3Qgc3RhclBvaW50cyA9IFtcbiAgICBbNTAsIDVdLFxuICAgIFs2MS4yMywgMzkuNTVdLFxuICAgIFs5Ny41NSwgMzkuNTVdLFxuICAgIFs2OC4xNiwgNjAuOV0sXG4gICAgWzc5LjM5LCA5NS40NV0sXG4gICAgWzUwLCA3NC4xXSxcbiAgICBbMjAuNjEsIDk1LjQ1XSxcbiAgICBbMzEuODQsIDYwLjldLFxuICAgIFsyLjQ1LCAzOS41NV0sXG4gICAgWzM4Ljc3LCAzOS41NV0sXG5dO1xuXG5mdW5jdGlvbiBwYXRoU3RhcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2VudGVyOiBJdGVtLCBzaXplOiBudW1iZXIpIHtcbiAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHAgb2Ygc3RhclBvaW50cykge1xuICAgICAgICBjb25zdCB4ID0gKHBbMF0gLSA1MCkgKiAoc2l6ZSAvIDEwMCkgKyBjZW50ZXJbMF07XG4gICAgICAgIGNvbnN0IHkgPSAocFsxXSAtIDUwKSAqIChzaXplIC8gMTAwKSArIGNlbnRlclsxXTtcblxuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuXG5jb25zdCBTdGFyU1ZHID0gKCkgPT4gKFxuICAgIDxzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGQ9XCJNNDcuMTQ2OCAxMy43ODExQzQ4LjA0NDkgMTEuMDE3MiA1MS45NTUxIDExLjAxNzIgNTIuODUzMiAxMy43ODEyTDYwLjU1MjIgMzcuNDc2MkM2MC45NTM4IDM4LjcxMjMgNjIuMTA1NiAzOS41NDkxIDYzLjQwNTMgMzkuNTQ5MUg4OC4zMTk4QzkxLjIyNiAzOS41NDkxIDkyLjQzNDMgNDMuMjY4IDkwLjA4MzEgNDQuOTc2Mkw2OS45MjY5IDU5LjYyMDVDNjguODc1NSA2MC4zODQ1IDY4LjQzNTUgNjEuNzM4NiA2OC44MzcxIDYyLjk3NDZMNzYuNTM2MSA4Ni42Njk3Qzc3LjQzNDIgODkuNDMzNiA3NC4yNzA3IDkxLjczMiA3MS45MTk2IDkwLjAyMzhMNTEuNzYzNCA3NS4zNzk0QzUwLjcxMTkgNzQuNjE1NSA0OS4yODgxIDc0LjYxNTUgNDguMjM2NiA3NS4zNzk1TDI4LjA4MDQgOTAuMDIzOEMyNS43MjkzIDkxLjczMiAyMi41NjU5IDg5LjQzMzYgMjMuNDYzOSA4Ni42Njk3TDMxLjE2MjkgNjIuOTc0NkMzMS41NjQ1IDYxLjczODYgMzEuMTI0NSA2MC4zODQ1IDMwLjA3MzEgNTkuNjIwNUw5LjkxNjg2IDQ0Ljk3NjJDNy41NjU3MiA0My4yNjggOC43NzQwNSAzOS41NDkxIDExLjY4MDIgMzkuNTQ5MUgzNi41OTQ3QzM3Ljg5NDQgMzkuNTQ5MSAzOS4wNDYyIDM4LjcxMjMgMzkuNDQ3OCAzNy40NzYyTDQ3LjE0NjggMTMuNzgxMVpcIlxuICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIC8+XG4gICAgPC9zdmc+XG4pO1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdmBcbiAgICAuYWN0aXZlIHtcbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIH1cblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiA2cHggMDtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuXG4gICAgPiAqIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTZweDtcbiAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMnB4O1xuXG4gICAgICAgIHN2ZyB7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IHJlbmRlcmVyOiBDdXN0b21SZW5kZXJlcjxTdGFyQ2VsbD4gPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkN1c3RvbSxcbiAgICBpc01hdGNoOiAoY2VsbDogQ3VzdG9tQ2VsbCk6IGNlbGwgaXMgU3RhckNlbGwgPT4gKGNlbGwuZGF0YSBhcyBhbnkpLmtpbmQgPT09IFwic3Rhci1jZWxsXCIsXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICBkcmF3OiAoYXJncywgY2VsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgdGhlbWUsIHJlY3QsIGhvdmVyQW1vdW50IH0gPSBhcmdzO1xuICAgICAgICBjb25zdCB7IHJhdGluZyB9ID0gY2VsbC5kYXRhO1xuICAgICAgICBjb25zdCBwYWRYID0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuICAgICAgICBsZXQgZHJhd1ggPSByZWN0LnggKyBwYWRYO1xuICAgICAgICBjb25zdCBzdGFycyA9IE1hdGgubWluKDUsIE1hdGguY2VpbChyYXRpbmcpKTtcbiAgICAgICAgZHJhd1ggKz0gODtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJzOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGhTdGFyKGN0eCwgW2RyYXdYLCByZWN0LnkgKyByZWN0LmhlaWdodCAvIDJdLCAxNik7XG4gICAgICAgICAgICBkcmF3WCArPSAxODtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNiArIDAuNCAqIGhvdmVyQW1vdW50O1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgICAgICByZXR1cm4gcCA9PiAoXG4gICAgICAgICAgICA8RWRpdG9yV3JhcD5cbiAgICAgICAgICAgICAgICB7WzAsIDEsIDIsIDMsIDRdLm1hcChpbmRleCA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3AudmFsdWUuZGF0YS5yYXRpbmcgPCBpbmRleCArIDEgPyBcImluYWN0aXZlXCIgOiBcImFjdGl2ZVwifVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAub25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbmc6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPFN0YXJTVkcgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L0VkaXRvcldyYXA+XG4gICAgICAgICk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAodmFsLCBkKSA9PiB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUludCh2YWwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgIHJhdGluZzogTnVtYmVyLmlzTmFOKG51bSkgPyAwIDogbnVtLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJlcjtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".e14vzbfa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;padding-top:6px;color:var(--gdg-text-dark);box-sizing:border-box;}.e14vzbfa *{box-sizing:border-box;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;cursor:pointer;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label input{cursor:pointer;width:auto;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill{margin-left:8px;margin-right:6px;margin-bottom:6px;border-radius:var(--e14vzbfa-0);min-height:var(--e14vzbfa-1);padding:2px var(--e14vzbfa-2);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font:12px var(--gdg-font-family);background-color:var(--gdg-bg-bubble);-webkit-transition:box-shadow 150ms;transition:box-shadow 150ms;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill.unselected{opacity:0.8;}.e14vzbfa label:hover .pill{box-shadow:0 1px 4px rgba(0,0,0,0.15);}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label{cursor:default;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label .pill{box-shadow:none !important;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy90YWdzLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lMTR2emJmYSJdLCJtYXBwaW5ncyI6IkFBMkJNQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvdGFncy1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBSZWN0YW5nbGUsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHJvdW5kZWRSZWN0IH0gZnJvbSBcIi4uL2RyYXctZm5zXCI7XG5cbmludGVyZmFjZSBUYWdzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcInRhZ3MtY2VsbFwiO1xuICAgIHJlYWRvbmx5IHRhZ3M6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICAgIHJlYWRvbmx5IHJlYWRvbmx5PzogYm9vbGVhbjtcbiAgICByZWFkb25seSBwb3NzaWJsZVRhZ3M6IHJlYWRvbmx5IHtcbiAgICAgICAgdGFnOiBzdHJpbmc7XG4gICAgICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBUYWdzQ2VsbCA9IEN1c3RvbUNlbGw8VGFnc0NlbGxQcm9wcz47XG5cbmNvbnN0IHRhZ0hlaWdodCA9IDIwO1xuY29uc3QgaW5uZXJQYWQgPSA2O1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdjx7IHRhZ0hlaWdodDogbnVtYmVyOyBpbm5lclBhZDogbnVtYmVyIH0+YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBwYWRkaW5nLXRvcDogNnB4O1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG5cbiAgICAmJiYmIGxhYmVsIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGlucHV0IHtcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLnBpbGwge1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNnB4O1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAke3AgPT4gcC50YWdIZWlnaHQgLyAyfXB4O1xuICAgICAgICAgICAgbWluLWhlaWdodDogJHtwID0+IHAudGFnSGVpZ2h0fXB4O1xuICAgICAgICAgICAgcGFkZGluZzogMnB4ICR7cCA9PiBwLmlubmVyUGFkfXB4O1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgICAgIGZvbnQ6IDEycHggdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcblxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWJ1YmJsZSk7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMTUwbXM7XG5cbiAgICAgICAgICAgICYudW5zZWxlY3RlZCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC44O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxhYmVsOmhvdmVyIC5waWxsIHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xNSk7XG4gICAgfVxuXG4gICAgJiYmJi5yZWFkb25seSBsYWJlbCB7XG4gICAgICAgIGN1cnNvcjogZGVmYXVsdDtcblxuICAgICAgICAucGlsbCB7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5jb25zdCByZW5kZXJlcjogQ3VzdG9tUmVuZGVyZXI8VGFnc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIFRhZ3NDZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcInRhZ3MtY2VsbFwiLFxuICAgIGRyYXc6IChhcmdzLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCB0aGVtZSwgcmVjdCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MgfSA9IGNlbGwuZGF0YTtcblxuICAgICAgICBjb25zdCBkcmF3QXJlYTogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogcmVjdC54ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nLFxuICAgICAgICAgICAgeTogcmVjdC55ICsgdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC0gMiAqIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLSAyICogdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZHJhd0FyZWEuaGVpZ2h0IC8gKHRhZ0hlaWdodCArIGlubmVyUGFkKSkpO1xuXG4gICAgICAgIGxldCB4ID0gZHJhd0FyZWEueDtcbiAgICAgICAgbGV0IHJvdyA9IDE7XG4gICAgICAgIGxldCB5ID0gZHJhd0FyZWEueSArIChkcmF3QXJlYS5oZWlnaHQgLSByb3dzICogdGFnSGVpZ2h0IC0gKHJvd3MgLSAxKSAqIGlubmVyUGFkKSAvIDI7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gcG9zc2libGVUYWdzLmZpbmQodCA9PiB0LnRhZyA9PT0gdGFnKT8uY29sb3IgPz8gdGhlbWUuYmdCdWJibGU7XG5cbiAgICAgICAgICAgIGN0eC5mb250ID0gYDEycHggJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQodGFnLCBjdHgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtZXRyaWNzLndpZHRoICsgaW5uZXJQYWQgKiAyO1xuICAgICAgICAgICAgY29uc3QgdGV4dFkgPSB0YWdIZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAhPT0gZHJhd0FyZWEueCAmJiB4ICsgd2lkdGggPiBkcmF3QXJlYS54ICsgZHJhd0FyZWEud2lkdGggJiYgcm93IDwgcm93cykge1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICAgIHkgKz0gdGFnSGVpZ2h0ICsgaW5uZXJQYWQ7XG4gICAgICAgICAgICAgICAgeCA9IGRyYXdBcmVhLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHJvdW5kZWRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIHRhZ0hlaWdodCwgdGFnSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGFnLCB4ICsgaW5uZXJQYWQsIHkgKyB0ZXh0WSArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCBgMTJweCAke3RoZW1lLmZvbnRGYW1pbHl9YCkpO1xuXG4gICAgICAgICAgICB4ICs9IHdpZHRoICsgODtcbiAgICAgICAgICAgIGlmICh4ID4gZHJhd0FyZWEueCArIGRyYXdBcmVhLndpZHRoICYmIHJvdyA+PSByb3dzKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgICAgIHJldHVybiBwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25DaGFuZ2UsIHZhbHVlIH0gPSBwO1xuICAgICAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MsIHJlYWRvbmx5ID0gZmFsc2UgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxFZGl0b3JXcmFwIHRhZ0hlaWdodD17dGFnSGVpZ2h0fSBpbm5lclBhZD17aW5uZXJQYWR9IGNsYXNzTmFtZT17cmVhZG9ubHkgPyBcInJlYWRvbmx5XCIgOiBcIlwifT5cbiAgICAgICAgICAgICAgICAgICAge3Bvc3NpYmxlVGFncy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRhZ3MuaW5kZXhPZih0LnRhZykgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwga2V5PXt0LnRhZ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmVhZG9ubHkgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3NlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBzZWxlY3RlZCA/IHRhZ3MuZmlsdGVyKHggPT4geCAhPT0gdC50YWcpIDogWy4uLnRhZ3MsIHQudGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IG5ld1RhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcInBpbGwgXCIgKyAoc2VsZWN0ZWQgPyBcInNlbGVjdGVkXCIgOiBcInVuc2VsZWN0ZWRcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IHNlbGVjdGVkID8gdC5jb2xvciA6IHVuZGVmaW5lZCB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0LnRhZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvRWRpdG9yV3JhcD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvblBhc3RlOiAodiwgZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgdGFnczogZC5wb3NzaWJsZVRhZ3NcbiAgICAgICAgICAgIC5tYXAoeCA9PiB4LnRhZylcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PlxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcyh4KVxuICAgICAgICAgICAgKSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/cells/src/cells/packages/cells/src/cells/tags-cell.tsx","webpack://./packages/cells/src/cells/tags-cell.tsx"],"names":[".e14vzbfa"],"mappings":"AA2BMA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,mBAAAA,CAAAA,eAAAA,CAAAA,0BAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,YAAAA,qBAAAA,CAAAA,CAAAA,2CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,cAAAA,CAAAA,CAAAA,iDAAAA,cAAAA,CAAAA,UAAAA,CAAAA,CAAAA,iDAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,+BAAAA,CAAAA,4BAAAA,CAAAA,6BAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,gCAAAA,CAAAA,qCAAAA,CAAAA,mCAAAA,CAAAA,2BAAAA,CAAAA,CAAAA,4DAAAA,WAAAA,CAAAA,CAAAA,4BAAAA,qCAAAA,CAAAA,CAAAA,oDAAAA,cAAAA,CAAAA,CAAAA,0DAAAA,0BAAAA,CAAAA;AC1BN,+pQAA+pQ","sourcesContent":["import {\n    CustomCell,\n    Rectangle,\n    measureTextCached,\n    CustomRenderer,\n    getMiddleCenterBias,\n    GridCellKind,\n} from \"@glideapps/glide-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { roundedRect } from \"../draw-fns\";\n\ninterface TagsCellProps {\n    readonly kind: \"tags-cell\";\n    readonly tags: readonly string[];\n    readonly readonly?: boolean;\n    readonly possibleTags: readonly {\n        tag: string;\n        color: string;\n    }[];\n}\n\nexport type TagsCell = CustomCell<TagsCellProps>;\n\nconst tagHeight = 20;\nconst innerPad = 6;\n\nconst EditorWrap = styled.div<{ tagHeight: number; innerPad: number }>`\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    padding-top: 6px;\n    color: var(--gdg-text-dark);\n\n    box-sizing: border-box;\n\n    * {\n        box-sizing: border-box;\n    }\n\n    &&&& label {\n        display: flex;\n        cursor: pointer;\n\n        input {\n            cursor: pointer;\n            width: auto;\n        }\n\n        .pill {\n            margin-left: 8px;\n            margin-right: 6px;\n            margin-bottom: 6px;\n\n            border-radius: ${p => p.tagHeight / 2}px;\n            min-height: ${p => p.tagHeight}px;\n            padding: 2px ${p => p.innerPad}px;\n            display: flex;\n            align-items: center;\n\n            font: 12px var(--gdg-font-family);\n\n            background-color: var(--gdg-bg-bubble);\n\n            transition: box-shadow 150ms;\n\n            &.unselected {\n                opacity: 0.8;\n            }\n        }\n    }\n    label:hover .pill {\n        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.15);\n    }\n\n    &&&&.readonly label {\n        cursor: default;\n\n        .pill {\n            box-shadow: none !important;\n        }\n    }\n`;\n\nconst renderer: CustomRenderer<TagsCell> = {\n    kind: GridCellKind.Custom,\n    isMatch: (c): c is TagsCell => (c.data as any).kind === \"tags-cell\",\n    draw: (args, cell) => {\n        const { ctx, theme, rect } = args;\n        const { possibleTags, tags } = cell.data;\n\n        const drawArea: Rectangle = {\n            x: rect.x + theme.cellHorizontalPadding,\n            y: rect.y + theme.cellVerticalPadding,\n            width: rect.width - 2 * theme.cellHorizontalPadding,\n            height: rect.height - 2 * theme.cellVerticalPadding,\n        };\n        const rows = Math.max(1, Math.floor(drawArea.height / (tagHeight + innerPad)));\n\n        let x = drawArea.x;\n        let row = 1;\n        let y = drawArea.y + (drawArea.height - rows * tagHeight - (rows - 1) * innerPad) / 2;\n        for (const tag of tags) {\n            const color = possibleTags.find(t => t.tag === tag)?.color ?? theme.bgBubble;\n\n            ctx.font = `12px ${theme.fontFamily}`;\n            const metrics = measureTextCached(tag, ctx);\n            const width = metrics.width + innerPad * 2;\n            const textY = tagHeight / 2;\n\n            if (x !== drawArea.x && x + width > drawArea.x + drawArea.width && row < rows) {\n                row++;\n                y += tagHeight + innerPad;\n                x = drawArea.x;\n            }\n\n            ctx.fillStyle = color;\n            ctx.beginPath();\n            roundedRect(ctx, x, y, width, tagHeight, tagHeight / 2);\n            ctx.fill();\n\n            ctx.fillStyle = theme.textDark;\n            ctx.fillText(tag, x + innerPad, y + textY + getMiddleCenterBias(ctx, `12px ${theme.fontFamily}`));\n\n            x += width + 8;\n            if (x > drawArea.x + drawArea.width && row >= rows) break;\n        }\n\n        return true;\n    },\n    provideEditor: () => {\n        // eslint-disable-next-line react/display-name\n        return p => {\n            const { onChange, value } = p;\n            const { possibleTags, tags, readonly = false } = value.data;\n            return (\n                <EditorWrap tagHeight={tagHeight} innerPad={innerPad} className={readonly ? \"readonly\" : \"\"}>\n                    {possibleTags.map(t => {\n                        const selected = tags.indexOf(t.tag) !== -1;\n                        return (\n                            <label key={t.tag}>\n                                {!readonly && (\n                                    <input\n                                        className=\"gdg-input\"\n                                        type=\"checkbox\"\n                                        checked={selected}\n                                        onChange={() => {\n                                            const newTags = selected ? tags.filter(x => x !== t.tag) : [...tags, t.tag];\n                                            onChange({\n                                                ...p.value,\n                                                data: {\n                                                    ...value.data,\n                                                    tags: newTags,\n                                                },\n                                            });\n                                        }}\n                                    />\n                                )}\n                                <div\n                                    className={\"pill \" + (selected ? \"selected\" : \"unselected\")}\n                                    style={{ backgroundColor: selected ? t.color : undefined }}>\n                                    {t.tag}\n                                </div>\n                            </label>\n                        );\n                    })}\n                </EditorWrap>\n            );\n        };\n    },\n    onPaste: (v, d) => ({\n        ...d,\n        tags: d.possibleTags\n            .map(x => x.tag)\n            .filter(x =>\n                v\n                    .split(\",\")\n                    .map(s => s.trim())\n                    .includes(x)\n            ),\n    }),\n};\n\nexport default renderer;\n",".e14vzbfa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;padding-top:6px;color:var(--gdg-text-dark);box-sizing:border-box;}.e14vzbfa *{box-sizing:border-box;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;cursor:pointer;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label input{cursor:pointer;width:auto;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill{margin-left:8px;margin-right:6px;margin-bottom:6px;border-radius:var(--e14vzbfa-0);min-height:var(--e14vzbfa-1);padding:2px var(--e14vzbfa-2);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font:12px var(--gdg-font-family);background-color:var(--gdg-bg-bubble);-webkit-transition:box-shadow 150ms;transition:box-shadow 150ms;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa label .pill.unselected{opacity:0.8;}.e14vzbfa label:hover .pill{box-shadow:0 1px 4px rgba(0,0,0,0.15);}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label{cursor:default;}.e14vzbfa.e14vzbfa.e14vzbfa.e14vzbfa.readonly label .pill{box-shadow:none !important;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NlbGxzL3NyYy9jZWxscy90YWdzLWNlbGwudHN4Il0sIm5hbWVzIjpbIi5lMTR2emJmYSJdLCJtYXBwaW5ncyI6IkFBMkJNQSIsImZpbGUiOiJwYWNrYWdlcy9jZWxscy9zcmMvY2VsbHMvdGFncy1jZWxsLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ3VzdG9tQ2VsbCxcbiAgICBSZWN0YW5nbGUsXG4gICAgbWVhc3VyZVRleHRDYWNoZWQsXG4gICAgQ3VzdG9tUmVuZGVyZXIsXG4gICAgZ2V0TWlkZGxlQ2VudGVyQmlhcyxcbiAgICBHcmlkQ2VsbEtpbmQsXG59IGZyb20gXCJAZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHJvdW5kZWRSZWN0IH0gZnJvbSBcIi4uL2RyYXctZm5zXCI7XG5cbmludGVyZmFjZSBUYWdzQ2VsbFByb3BzIHtcbiAgICByZWFkb25seSBraW5kOiBcInRhZ3MtY2VsbFwiO1xuICAgIHJlYWRvbmx5IHRhZ3M6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICAgIHJlYWRvbmx5IHJlYWRvbmx5PzogYm9vbGVhbjtcbiAgICByZWFkb25seSBwb3NzaWJsZVRhZ3M6IHJlYWRvbmx5IHtcbiAgICAgICAgdGFnOiBzdHJpbmc7XG4gICAgICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgfVtdO1xufVxuXG5leHBvcnQgdHlwZSBUYWdzQ2VsbCA9IEN1c3RvbUNlbGw8VGFnc0NlbGxQcm9wcz47XG5cbmNvbnN0IHRhZ0hlaWdodCA9IDIwO1xuY29uc3QgaW5uZXJQYWQgPSA2O1xuXG5jb25zdCBFZGl0b3JXcmFwID0gc3R5bGVkLmRpdjx7IHRhZ0hlaWdodDogbnVtYmVyOyBpbm5lclBhZDogbnVtYmVyIH0+YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBwYWRkaW5nLXRvcDogNnB4O1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAqIHtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG5cbiAgICAmJiYmIGxhYmVsIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGlucHV0IHtcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLnBpbGwge1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgICAgICAgICAgIG1hcmdpbi1yaWdodDogNnB4O1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogNnB4O1xuXG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAke3AgPT4gcC50YWdIZWlnaHQgLyAyfXB4O1xuICAgICAgICAgICAgbWluLWhlaWdodDogJHtwID0+IHAudGFnSGVpZ2h0fXB4O1xuICAgICAgICAgICAgcGFkZGluZzogMnB4ICR7cCA9PiBwLmlubmVyUGFkfXB4O1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgICAgIGZvbnQ6IDEycHggdmFyKC0tZ2RnLWZvbnQtZmFtaWx5KTtcblxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWJ1YmJsZSk7XG5cbiAgICAgICAgICAgIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMTUwbXM7XG5cbiAgICAgICAgICAgICYudW5zZWxlY3RlZCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC44O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxhYmVsOmhvdmVyIC5waWxsIHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xNSk7XG4gICAgfVxuXG4gICAgJiYmJi5yZWFkb25seSBsYWJlbCB7XG4gICAgICAgIGN1cnNvcjogZGVmYXVsdDtcblxuICAgICAgICAucGlsbCB7XG4gICAgICAgICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5jb25zdCByZW5kZXJlcjogQ3VzdG9tUmVuZGVyZXI8VGFnc0NlbGw+ID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5DdXN0b20sXG4gICAgaXNNYXRjaDogKGMpOiBjIGlzIFRhZ3NDZWxsID0+IChjLmRhdGEgYXMgYW55KS5raW5kID09PSBcInRhZ3MtY2VsbFwiLFxuICAgIGRyYXc6IChhcmdzLCBjZWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCB0aGVtZSwgcmVjdCB9ID0gYXJncztcbiAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MgfSA9IGNlbGwuZGF0YTtcblxuICAgICAgICBjb25zdCBkcmF3QXJlYTogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogcmVjdC54ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nLFxuICAgICAgICAgICAgeTogcmVjdC55ICsgdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC0gMiAqIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLSAyICogdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZHJhd0FyZWEuaGVpZ2h0IC8gKHRhZ0hlaWdodCArIGlubmVyUGFkKSkpO1xuXG4gICAgICAgIGxldCB4ID0gZHJhd0FyZWEueDtcbiAgICAgICAgbGV0IHJvdyA9IDE7XG4gICAgICAgIGxldCB5ID0gZHJhd0FyZWEueSArIChkcmF3QXJlYS5oZWlnaHQgLSByb3dzICogdGFnSGVpZ2h0IC0gKHJvd3MgLSAxKSAqIGlubmVyUGFkKSAvIDI7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gcG9zc2libGVUYWdzLmZpbmQodCA9PiB0LnRhZyA9PT0gdGFnKT8uY29sb3IgPz8gdGhlbWUuYmdCdWJibGU7XG5cbiAgICAgICAgICAgIGN0eC5mb250ID0gYDEycHggJHt0aGVtZS5mb250RmFtaWx5fWA7XG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQodGFnLCBjdHgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtZXRyaWNzLndpZHRoICsgaW5uZXJQYWQgKiAyO1xuICAgICAgICAgICAgY29uc3QgdGV4dFkgPSB0YWdIZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAhPT0gZHJhd0FyZWEueCAmJiB4ICsgd2lkdGggPiBkcmF3QXJlYS54ICsgZHJhd0FyZWEud2lkdGggJiYgcm93IDwgcm93cykge1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICAgIHkgKz0gdGFnSGVpZ2h0ICsgaW5uZXJQYWQ7XG4gICAgICAgICAgICAgICAgeCA9IGRyYXdBcmVhLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHJvdW5kZWRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIHRhZ0hlaWdodCwgdGFnSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGFnLCB4ICsgaW5uZXJQYWQsIHkgKyB0ZXh0WSArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCBgMTJweCAke3RoZW1lLmZvbnRGYW1pbHl9YCkpO1xuXG4gICAgICAgICAgICB4ICs9IHdpZHRoICsgODtcbiAgICAgICAgICAgIGlmICh4ID4gZHJhd0FyZWEueCArIGRyYXdBcmVhLndpZHRoICYmIHJvdyA+PSByb3dzKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgICAgIHJldHVybiBwID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25DaGFuZ2UsIHZhbHVlIH0gPSBwO1xuICAgICAgICAgICAgY29uc3QgeyBwb3NzaWJsZVRhZ3MsIHRhZ3MsIHJlYWRvbmx5ID0gZmFsc2UgfSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxFZGl0b3JXcmFwIHRhZ0hlaWdodD17dGFnSGVpZ2h0fSBpbm5lclBhZD17aW5uZXJQYWR9IGNsYXNzTmFtZT17cmVhZG9ubHkgPyBcInJlYWRvbmx5XCIgOiBcIlwifT5cbiAgICAgICAgICAgICAgICAgICAge3Bvc3NpYmxlVGFncy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRhZ3MuaW5kZXhPZih0LnRhZykgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwga2V5PXt0LnRhZ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmVhZG9ubHkgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2RnLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3NlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhZ3MgPSBzZWxlY3RlZCA/IHRhZ3MuZmlsdGVyKHggPT4geCAhPT0gdC50YWcpIDogWy4uLnRhZ3MsIHQudGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IG5ld1RhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcInBpbGwgXCIgKyAoc2VsZWN0ZWQgPyBcInNlbGVjdGVkXCIgOiBcInVuc2VsZWN0ZWRcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IHNlbGVjdGVkID8gdC5jb2xvciA6IHVuZGVmaW5lZCB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0LnRhZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvRWRpdG9yV3JhcD5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvblBhc3RlOiAodiwgZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgdGFnczogZC5wb3NzaWJsZVRhZ3NcbiAgICAgICAgICAgIC5tYXAoeCA9PiB4LnRhZylcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PlxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcyh4KVxuICAgICAgICAgICAgKSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".wo9gtxb{position:relative;min-width:10px;min-height:10px;max-width:100%;max-height:100%;width:var(--wo9gtxb-0);height:var(--wo9gtxb-1);overflow:hidden;overflow:clip;contain:strict;}.wo9gtxb > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyIud285Z3R4YiJdLCJtYXBwaW5ncyI6IkFBYU1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGluV2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgICBpbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b0Nzcyh4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHJldHVybiB4O1xuICAgIHJldHVybiBgJHt4fXB4YDtcbn1cblxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBpbm5lcldpZHRoOiBzdHJpbmc7IGlubmVySGVpZ2h0OiBzdHJpbmcgfT5gXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgbWluLXdpZHRoOiAxMHB4O1xuICAgIG1pbi1oZWlnaHQ6IDEwcHg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG5cbiAgICB3aWR0aDogJHtwID0+IHAuaW5uZXJXaWR0aH07XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5pbm5lckhlaWdodH07XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG92ZXJmbG93OiBjbGlwO1xuXG4gICAgY29udGFpbjogc3RyaWN0O1xuXG4gICAgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMgZXh0ZW5kcyBXcmFwcGVyUHJvcHMsIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiB7fVxuXG5leHBvcnQgY29uc3QgRGF0YUVkaXRvckNvbnRhaW5lcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48UHJvcHM+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwcGVyIGlubmVySGVpZ2h0PXt0b0NzcyhpbkhlaWdodCl9IGlubmVyV2lkdGg9e3RvQ3NzKGluV2lkdGgpfSB7Li4ucmVzdH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-editor-container/packages/core/src/data-editor-container/data-grid-container.tsx","webpack://./packages/core/src/data-editor-container/data-grid-container.tsx"],"names":[".wo9gtxb"],"mappings":"AAaMA,SAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,sBAAAA,CAAAA,uBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAAA,CAAAA,wBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACZN,22DAA22D","sourcesContent":["import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\n\ninterface WrapperProps {\n    inWidth: number | string;\n    inHeight: number | string;\n}\n\nfunction toCss(x: number | string) {\n    if (typeof x === \"string\") return x;\n    return `${x}px`;\n}\n\nconst Wrapper = styled.div<{ innerWidth: string; innerHeight: string }>`\n    position: relative;\n\n    min-width: 10px;\n    min-height: 10px;\n    max-width: 100%;\n    max-height: 100%;\n\n    width: ${p => p.innerWidth};\n    height: ${p => p.innerHeight};\n\n    overflow: hidden;\n    overflow: clip;\n\n    contain: strict;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\ninterface Props extends WrapperProps, React.HTMLAttributes<HTMLDivElement> {}\n\nexport const DataEditorContainer: React.FunctionComponent<React.PropsWithChildren<Props>> = p => {\n    const { inWidth, inHeight, children, ...rest } = p;\n    return (\n        <Wrapper innerHeight={toCss(inHeight)} innerWidth={toCss(inWidth)} {...rest}>\n            {children}\n        </Wrapper>\n    );\n};\n",".wo9gtxb{position:relative;min-width:10px;min-height:10px;max-width:100%;max-height:100%;width:var(--wo9gtxb-0);height:var(--wo9gtxb-1);overflow:hidden;overflow:clip;contain:strict;}.wo9gtxb > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCJdLCJuYW1lcyI6WyIud285Z3R4YiJdLCJtYXBwaW5ncyI6IkFBYU1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yLWNvbnRhaW5lci9kYXRhLWdyaWQtY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGluV2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgICBpbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiB0b0Nzcyh4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHJldHVybiB4O1xuICAgIHJldHVybiBgJHt4fXB4YDtcbn1cblxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBpbm5lcldpZHRoOiBzdHJpbmc7IGlubmVySGVpZ2h0OiBzdHJpbmcgfT5gXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgbWluLXdpZHRoOiAxMHB4O1xuICAgIG1pbi1oZWlnaHQ6IDEwcHg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG5cbiAgICB3aWR0aDogJHtwID0+IHAuaW5uZXJXaWR0aH07XG4gICAgaGVpZ2h0OiAke3AgPT4gcC5pbm5lckhlaWdodH07XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG92ZXJmbG93OiBjbGlwO1xuXG4gICAgY29udGFpbjogc3RyaWN0O1xuXG4gICAgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgUHJvcHMgZXh0ZW5kcyBXcmFwcGVyUHJvcHMsIFJlYWN0LkhUTUxBdHRyaWJ1dGVzPEhUTUxEaXZFbGVtZW50PiB7fVxuXG5leHBvcnQgY29uc3QgRGF0YUVkaXRvckNvbnRhaW5lcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48UHJvcHM+PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGNoaWxkcmVuLCAuLi5yZXN0IH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxXcmFwcGVyIGlubmVySGVpZ2h0PXt0b0NzcyhpbkhlaWdodCl9IGlubmVyV2lkdGg9e3RvQ3NzKGluV2lkdGgpfSB7Li4ucmVzdH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".r1fzhvm4{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;border:none;outline:none;background-color:var(--gdg-bg-header-has-focus);border-radius:9px;padding:0 8px;box-shadow:0 0 0 1px var(--gdg-border-color);color:var(--gdg-text-group-header);min-height:var(--r1fzhvm4-0);font:var(--gdg-header-font-style) var(--gdg-font-family);}\n.c181oggi{padding:0 8px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:var(--gdg-bg-header);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL2dyb3VwLXJlbmFtZS50c3giXSwibmFtZXMiOlsiLnIxZnpodm00IiwiLmMxODFvZ2dpIl0sIm1hcHBpbmdzIjoiQUFjTUE7QUEyQmdCQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9ncm91cC1yZW5hbWUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgeyBjc3MgfSBmcm9tIFwiQGxpbmFyaWEvY29yZVwiO1xuaW1wb3J0IENsaWNrT3V0c2lkZUNvbnRhaW5lciBmcm9tIFwiLi4vY2xpY2stb3V0c2lkZS1jb250YWluZXIvY2xpY2stb3V0c2lkZS1jb250YWluZXJcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICByZWFkb25seSBib3VuZHM6IFJlY3RhbmdsZTtcbiAgICByZWFkb25seSBncm91cDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG9uQ2xvc2U6ICgpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25GaW5pc2g6IChuZXdWYWw6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZWFkb25seSBjYW52YXNCb3VuZHM6IERPTVJlY3Q7XG59XG5cbmNvbnN0IFJlbmFtZUlucHV0ID0gc3R5bGVkLmlucHV0PHsgdGFyZ2V0SGVpZ2h0OiBudW1iZXIgfT5gXG4gICAgZmxleC1ncm93OiAxO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXItaGFzLWZvY3VzKTtcbiAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgcGFkZGluZzogMCA4cHg7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1ncm91cC1oZWFkZXIpO1xuICAgIG1pbi1oZWlnaHQ6ICR7cCA9PiBNYXRoLm1heCgxNiwgcC50YXJnZXRIZWlnaHQgLSAxMCl9cHg7XG4gICAgZm9udDogdmFyKC0tZ2RnLWhlYWRlci1mb250LXN0eWxlKSB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3VwUmVuYW1lOiBSZWFjdC5WRkM8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBib3VuZHMsIGdyb3VwLCBvbkNsb3NlLCBjYW52YXNCb3VuZHMsIG9uRmluaXNoIH0gPSBwO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShncm91cCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8Q2xpY2tPdXRzaWRlQ29udGFpbmVyXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLnggLSBjYW52YXNCb3VuZHMubGVmdCArIDEsXG4gICAgICAgICAgICAgICAgdG9wOiBib3VuZHMueSAtIGNhbnZhc0JvdW5kcy50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCAtIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyKTtcbiAgICAgICAgICAgIGB9XG4gICAgICAgICAgICBvbkNsaWNrT3V0c2lkZT17b25DbG9zZX0+XG4gICAgICAgICAgICA8UmVuYW1lSW5wdXRcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQ9e2JvdW5kcy5oZWlnaHR9XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJncm91cC1yZW5hbWUtaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICBvbkJsdXI9e29uQ2xvc2V9XG4gICAgICAgICAgICAgICAgb25Gb2N1cz17ZSA9PiBlLnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSgwLCB2YWx1ZS5sZW5ndGgpfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICBvbktleURvd249e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5pc2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xpY2tPdXRzaWRlQ29udGFpbmVyPlxuICAgICk7XG59O1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-editor/packages/core/src/data-editor/group-rename.tsx","webpack://./packages/core/src/data-editor/group-rename.tsx"],"names":[".r1fzhvm4",".c181oggi"],"mappings":"AAcMA,UAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,+CAAAA,CAAAA,iBAAAA,CAAAA,aAAAA,CAAAA,4CAAAA,CAAAA,kCAAAA,CAAAA,4BAAAA,CAAAA,wDAAAA,CAAAA;AA2BgBC,UAAAA,aAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,qCAAAA,CAAAA;ACvCtB,m4GAAm4G","sourcesContent":["import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { css } from \"@linaria/core\";\nimport ClickOutsideContainer from \"../click-outside-container/click-outside-container\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\n\ninterface Props {\n    readonly bounds: Rectangle;\n    readonly group: string;\n    readonly onClose: () => void;\n    readonly onFinish: (newVal: string) => void;\n    readonly canvasBounds: DOMRect;\n}\n\nconst RenameInput = styled.input<{ targetHeight: number }>`\n    flex-grow: 1;\n    border: none;\n    outline: none;\n    background-color: var(--gdg-bg-header-has-focus);\n    border-radius: 9px;\n    padding: 0 8px;\n    box-shadow: 0 0 0 1px var(--gdg-border-color);\n    color: var(--gdg-text-group-header);\n    min-height: ${p => Math.max(16, p.targetHeight - 10)}px;\n    font: var(--gdg-header-font-style) var(--gdg-font-family);\n`;\n\nexport const GroupRename: React.VFC<Props> = p => {\n    const { bounds, group, onClose, canvasBounds, onFinish } = p;\n\n    const [value, setValue] = React.useState(group);\n\n    return (\n        <ClickOutsideContainer\n            style={{\n                position: \"absolute\",\n                left: bounds.x - canvasBounds.left + 1,\n                top: bounds.y - canvasBounds.top,\n                width: bounds.width - 2,\n                height: bounds.height,\n            }}\n            className={css`\n                padding: 0 8px;\n                display: flex;\n                align-items: center;\n                background-color: var(--gdg-bg-header);\n            `}\n            onClickOutside={onClose}>\n            <RenameInput\n                targetHeight={bounds.height}\n                data-testid=\"group-rename-input\"\n                value={value}\n                onBlur={onClose}\n                onFocus={e => e.target.setSelectionRange(0, value.length)}\n                onChange={e => setValue(e.target.value)}\n                onKeyDown={e => {\n                    if (e.key === \"Enter\") {\n                        onFinish(value);\n                    } else if (e.key === \"Escape\") {\n                        onClose();\n                    }\n                }}\n                autoFocus={true}\n            />\n        </ClickOutsideContainer>\n    );\n};\n",".r1fzhvm4{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;border:none;outline:none;background-color:var(--gdg-bg-header-has-focus);border-radius:9px;padding:0 8px;box-shadow:0 0 0 1px var(--gdg-border-color);color:var(--gdg-text-group-header);min-height:var(--r1fzhvm4-0);font:var(--gdg-header-font-style) var(--gdg-font-family);}\n.c181oggi{padding:0 8px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:var(--gdg-bg-header);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL2dyb3VwLXJlbmFtZS50c3giXSwibmFtZXMiOlsiLnIxZnpodm00IiwiLmMxODFvZ2dpIl0sIm1hcHBpbmdzIjoiQUFjTUE7QUEyQmdCQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9ncm91cC1yZW5hbWUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgeyBjc3MgfSBmcm9tIFwiQGxpbmFyaWEvY29yZVwiO1xuaW1wb3J0IENsaWNrT3V0c2lkZUNvbnRhaW5lciBmcm9tIFwiLi4vY2xpY2stb3V0c2lkZS1jb250YWluZXIvY2xpY2stb3V0c2lkZS1jb250YWluZXJcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICByZWFkb25seSBib3VuZHM6IFJlY3RhbmdsZTtcbiAgICByZWFkb25seSBncm91cDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG9uQ2xvc2U6ICgpID0+IHZvaWQ7XG4gICAgcmVhZG9ubHkgb25GaW5pc2g6IChuZXdWYWw6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZWFkb25seSBjYW52YXNCb3VuZHM6IERPTVJlY3Q7XG59XG5cbmNvbnN0IFJlbmFtZUlucHV0ID0gc3R5bGVkLmlucHV0PHsgdGFyZ2V0SGVpZ2h0OiBudW1iZXIgfT5gXG4gICAgZmxleC1ncm93OiAxO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXItaGFzLWZvY3VzKTtcbiAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgcGFkZGluZzogMCA4cHg7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHZhcigtLWdkZy1ib3JkZXItY29sb3IpO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1ncm91cC1oZWFkZXIpO1xuICAgIG1pbi1oZWlnaHQ6ICR7cCA9PiBNYXRoLm1heCgxNiwgcC50YXJnZXRIZWlnaHQgLSAxMCl9cHg7XG4gICAgZm9udDogdmFyKC0tZ2RnLWhlYWRlci1mb250LXN0eWxlKSB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuYDtcblxuZXhwb3J0IGNvbnN0IEdyb3VwUmVuYW1lOiBSZWFjdC5WRkM8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBib3VuZHMsIGdyb3VwLCBvbkNsb3NlLCBjYW52YXNCb3VuZHMsIG9uRmluaXNoIH0gPSBwO1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShncm91cCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8Q2xpY2tPdXRzaWRlQ29udGFpbmVyXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmRzLnggLSBjYW52YXNCb3VuZHMubGVmdCArIDEsXG4gICAgICAgICAgICAgICAgdG9wOiBib3VuZHMueSAtIGNhbnZhc0JvdW5kcy50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCAtIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzYFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctaGVhZGVyKTtcbiAgICAgICAgICAgIGB9XG4gICAgICAgICAgICBvbkNsaWNrT3V0c2lkZT17b25DbG9zZX0+XG4gICAgICAgICAgICA8UmVuYW1lSW5wdXRcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQ9e2JvdW5kcy5oZWlnaHR9XG4gICAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJncm91cC1yZW5hbWUtaW5wdXRcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICBvbkJsdXI9e29uQ2xvc2V9XG4gICAgICAgICAgICAgICAgb25Gb2N1cz17ZSA9PiBlLnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSgwLCB2YWx1ZS5sZW5ndGgpfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICBvbktleURvd249e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GaW5pc2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGF1dG9Gb2N1cz17dHJ1ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQ2xpY2tPdXRzaWRlQ29udGFpbmVyPlxuICAgICk7XG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".k1txkgwh{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;}\n.s11gjm00{width:175px;padding:8px 0;border-radius:6px;box-shadow:0px 0px 1px rgba(62,65,86,0.7),0px 6px 12px rgba(62,65,86,0.35);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:white;font-size:13px;font-weight:600;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Open Sans\", \"Helvetica Neue\",sans-serif;}.s11gjm00 .danger{color:rgba(255,40,40,0.8);}.s11gjm00 .danger:hover{color:rgba(255,40,40,1);}.s11gjm00 > div{padding:6px 8px;color:rgba(0,0,0,0.7);-webkit-transition:background-color 100ms;transition:background-color 100ms;cursor:pointer;}.s11gjm00 > div:hover{background-color:rgba(0,0,0,0.05);color:rgba(0,0,0,0.9);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItYmVhdXRpZnVsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5rMXR4a2d3aCIsIi5zMTFnam0wMCJdLCJtYXBwaW5ncyI6IkFBazNDTUE7QUFrdUJBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLWJlYXV0aWZ1bC5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHNvbmFyanMvbm8taWRlbnRpY2FsLWZ1bmN0aW9ucyAqL1xuLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgICBDZWxsQXJyYXksXG4gICAgQ29tcGFjdFNlbGVjdGlvbixcbiAgICBEcmF3SGVhZGVyQ2FsbGJhY2ssXG4gICAgR3JpZENlbGwsXG4gICAgR3JpZENlbGxLaW5kLFxuICAgIEdyaWRDb2x1bW4sXG4gICAgR3JpZENvbHVtbkljb24sXG4gICAgR3JpZE1vdXNlRXZlbnRBcmdzLFxuICAgIEdyaWRTZWxlY3Rpb24sXG4gICAgR3JvdXBIZWFkZXJDbGlja2VkRXZlbnRBcmdzLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBJdGVtLFxuICAgIFJlY3RhbmdsZSxcbn0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IFNpbXBsZVRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsc1wiO1xuaW1wb3J0IHsgSUJvdW5kcywgdXNlTGF5ZXIgfSBmcm9tIFwicmVhY3QtbGFhZ1wiO1xuaW1wb3J0IHR5cGUgeyBTcHJpdGVNYXAgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC1zcHJpdGVzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGFFZGl0b3JSZWYsIFRoZW1lIH0gZnJvbSBcIi4uLy4uXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHtcbiAgICB1c2VNb2NrRGF0YUdlbmVyYXRvcixcbiAgICBCZWF1dGlmdWxXcmFwcGVyLFxuICAgIERlc2NyaXB0aW9uLFxuICAgIE1vcmVJbmZvLFxuICAgIFByb3BOYW1lLFxuICAgIGxvc3N5Q29weURhdGEsXG4gICAgZ2V0R3JpZENvbHVtbixcbiAgICBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvLFxuICAgIENvbnRlbnRDYWNoZSxcbiAgICBCZWF1dGlmdWxTdHlsZSxcbiAgICBDb2x1bW5BZGRCdXR0b24sXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwibG9kYXNoL25vb3AuanNcIjtcbmltcG9ydCB0eXBlIHsgR2V0Um93VGhlbWVDYWxsYmFjayB9IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXJlbmRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiR2xpZGUtRGF0YS1HcmlkL0RhdGFFZGl0b3IgRGVtb3NcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb246IHRydWUsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuZXhwb3J0IGNvbnN0IFJlc2l6YWJsZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlc2l6YWJsZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIHJlc2l6ZSBjb2x1bW5zIGJ5IGRyYWdnaW5nIHRoZWlyIGVkZ2VzLCBhcyBsb25nIGFzIHlvdSByZXNwb25kIHRvIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5vbkNvbHVtblJlc2l6ZTwvUHJvcE5hbWU+IHByb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IHNldHRpbmcgdGhlIDxQcm9wTmFtZT5vdmVyc2Nyb2xsWDwvUHJvcE5hbWU+IHByb3BlcnR5IGV4dHJhIHNwYWNlIGNhbiBiZSBhbGxvY2F0ZWQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGdyaWQgdG8gYWxsb3cgZm9yIGVhc2llciByZXNpemluZyBvZiB0aGUgZmluYWwgY29sdW1uLiBZb3UgY2FuIGhpZ2hsaWdodCBtdWx0aXBsZSBjb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB0byByZXNpemUgdGhlbSBhbGwgYXQgb25jZS5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9ezIwMH1cbiAgICAgICAgICAgICAgICBvdmVyc2Nyb2xsWT17MjAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbkF1dG9XaWR0aD17NTAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXsyMDAwfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVzaXphYmxlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgT3ZlcnNjcm9sbFByb3BzIHtcbiAgICBvdmVyc2Nyb2xsWDogbnVtYmVyO1xuICAgIG92ZXJzY3JvbGxZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBPdmVyc2Nyb2xsOiBSZWFjdC5WRkM8T3ZlcnNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgb3ZlcnNjcm9sbFgsIG92ZXJzY3JvbGxZIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk92ZXJzY3JvbGxcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWxsb2NhdGUgZXh0cmEgc3BhY2UgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b3ZlcnNjcm9sbFg8L1Byb3BOYW1lPiBhbmQgPFByb3BOYW1lPm92ZXJzY3JvbGxZPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e292ZXJzY3JvbGxYfVxuICAgICAgICAgICAgICAgIG92ZXJzY3JvbGxZPXtvdmVyc2Nyb2xsWX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgb3ZlcnNjcm9sbFg6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvdmVyc2Nyb2xsWToge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDYwMCxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBvdmVyc2Nyb2xsWDogMjAwLFxuICAgIG92ZXJzY3JvbGxZOiAyMDAsXG59O1xuKE92ZXJzY3JvbGwgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBjbGVhckNlbGwoY2VsbDogR3JpZENlbGwpOiBHcmlkQ2VsbCB7XG4gICAgc3dpdGNoIChjZWxsLmtpbmQpIHtcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuRHJpbGxkb3duOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5CdWJibGU6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVXJpOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5NYXJrZG93bjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlRleHQ6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5OdW1iZXI6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiAwLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbn1cblxuZXhwb3J0IGNvbnN0IEFkZERhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA2MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3Qgb25Sb3dBcHBlbmRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gbnVtUm93cztcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsQ29udGVudChbYywgbmV3Um93XSk7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWVSYXcoW2MsIG5ld1Jvd10sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgIH0sIFtnZXRDZWxsQ29udGVudCwgbnVtUm93cywgc2V0Q2VsbFZhbHVlUmF3XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPkRhdGEgY2FuIGJlIGFkZGVkIGJ5IGNsaWNraW5nIG9uIHRoZSB0cmFpbGluZyByb3cuPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgS2V5Ym9hcmQgaXMgYWxzbyBzdXBwb3J0ZWQsIGp1c3QgbmF2aWdhdGUgcGFzdCB0aGUgbGFzdCByb3cgYW5kIHByZXNzIDxLZXlOYW1lPkVudGVyPC9LZXlOYW1lPlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGREYXRhIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodFRvTGVmdDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2wsIF9yb3ddID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChjb2wgIT09IDApIHJldHVybiBnZXRDZWxsQ29udGVudChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwi15DXoNeZINeS15PXoteV158sINee15XXnteX15Qg15zXkNek15zXmden16bXmdeV16og15LXnNeZ15nXky5cIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCLXkNeg15kg15LXk9ei15XXnywg157Xldee15fXlCDXnNeQ16TXnNeZ16fXpteZ15XXqiDXktec15nXmdeTLlwiLFxuICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJpZ2h0IFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRoZSBkYXRhIGVkaXRvciBhdXRvbWF0aWNhbGx5IGRldGVjdHMgUlRMIGluIHRleHQgY2VsbHMgYW5kIHJlc3BlY3RzIGl0LjwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJpZ2h0VG9MZWZ0IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZURhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVmFsaWRhdGUgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YSBjYW4gYmUgdmFsaWRhdGVkIHVzaW5nIHRoZSA8UHJvcE5hbWU+dmFsaWRhdGVDZWxsPC9Qcm9wTmFtZT4gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlRoaXMgZXhhbXBsZSBvbmx5IGFsbG93cyB0aGUgd29yZCAmcXVvdDtWYWxpZCZxdW90OyBpbnNpZGUgdGV4dCBjZWxscy48L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDZWxsPXsoX2NlbGwsIG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5raW5kICE9PSBHcmlkQ2VsbEtpbmQuVGV4dCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5kYXRhID09PSBcIlZhbGlkXCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJWYWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBbMCwgM10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFZhbGlkYXRlRGF0YSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRmlsbEhhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoXG4gICAgICAgIDYwLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgICAgIGlmIChpWzBdID09PSAxICYmIHZhbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRmlsbCBoYW5kbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5GaWxsIGhhbmRsZXMgY2FuIGJlIHVzZWQgdG8gZG93bmZpbGwgZGF0YSB3aXRoIHRoZSBtb3VzZS48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBKdXN0IGNsaWNrIGFuZCBkcmFnLCB0aGUgdG9wIHJvdyB3aWxsIGJlIGNvcGllZCBkb3duLiBFbmFibGUgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmZpbGxIYW5kbGU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnRNYW5nbGVkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgZmlsbEhhbmRsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihGaWxsSGFuZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNIaW50OiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAgIDI6IFwiU21vbCB0ZXh0XCIsXG4gICAgMzogXCJBZGRcIixcbiAgICA1OiBcIk5ld1wiLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0ljb246IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7XG4gICAgMjogR3JpZENvbHVtbkljb24uSGVhZGVyQXJyYXksXG4gICAgMzogR3JpZENvbHVtbkljb24uSGVhZGVyRW1vamksXG4gICAgNTogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldDogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHtcbiAgICAyOiAwLFxuICAgIDM6IDAsXG4gICAgNTogMCxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNEaXNhYmxlZDogUmVjb3JkPG51bWJlciwgYm9vbGVhbj4gPSB7XG4gICAgMzogdHJ1ZSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNUaGVtZTogUmVjb3JkPG51bWJlciwgUGFydGlhbDxUaGVtZT4+ID0ge1xuICAgIDI6IHtcbiAgICAgICAgYmFzZUZvbnRTdHlsZTogXCIxMHB4XCIsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBUcmFpbGluZ1Jvd09wdGlvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgY29uc3QgY29sdW1uc1dpdGhSb3dPcHRpb25zOiBHcmlkQ29sdW1uW10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKChjLCBpZHgpID0+ICh7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgaGludDogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0hpbnRbaWR4XSxcbiAgICAgICAgICAgICAgICBhZGRJY29uOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzSWNvbltpZHhdLFxuICAgICAgICAgICAgICAgIHRhcmdldENvbHVtbjogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldFtpZHhdLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzRGlzYWJsZWRbaWR4XSxcbiAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzVGhlbWVbaWR4XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9LCBbY29sc10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVHJhaWxpbmcgcm93IG9wdGlvbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBjdXN0b21pemUgdGhlIHRyYWlsaW5nIHJvdyBpbiBlYWNoIGNvbHVtbiBieSBzZXR0aW5nIGF7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT50cmFpbGluZ1Jvd09wdGlvbnM8L1Byb3BOYW1lPiBpbiB5b3VyIGNvbHVtbnMuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnNXaXRoUm93T3B0aW9uc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRyYWlsaW5nUm93T3B0aW9ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQWRkRGF0YVRvVG9wOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlUmF3LCBzZXRDZWxsVmFsdWUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCBhbGwgb2YgdGhlIGV4aXN0aW5nIGNlbGxzIGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiAwOyB5LS0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFt4LCB5XSwgZ2V0Q2VsbENvbnRlbnQoW3gsIHkgLSAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIDBdKTtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbYywgMF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gXCJ0b3BcIiBhcyBjb25zdDtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQWRkIGRhdGFcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFkZERhdGFUb1RvcCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgQWRkRGF0YVRvTWlkZGxlUHJvcHMge1xuICAgIGluc2VydEluZGV4OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgQWRkRGF0YVRvTWlkZGxlOiBSZWFjdC5GQzxBZGREYXRhVG9NaWRkbGVQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IGluZGV4ID0gcC5pbnNlcnRJbmRleDtcbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCByb3dzIGJlbG93IGluZGV4IGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiBpbmRleDsgeS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDY7IHgrKykge1xuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbeCwgeV0sIGdldENlbGxDb250ZW50KFt4LCB5IC0gMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDY7IGMrKykge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGdldENlbGxDb250ZW50KFtjLCBpbmRleF0pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBpbmRleF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSwgW2dldENlbGxDb250ZW50LCBudW1Sb3dzLCBzZXRDZWxsVmFsdWVSYXcsIGluZGV4XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YSB0byBtaWRkbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCA8S2V5TmFtZT5pbnNlcnRJbmRleDwvS2V5TmFtZT4gaXMgemVyby1iYXNlZCB3aGlsZSB0aGUgbnVtYmVyIGNvbHVtbiBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZ3JpZCBpcyBvbmUtYmFzZWQsIHNvIGluc2VydGluZyBhdCBpbmRleCAmcXVvdDs0JnF1b3Q7IGNyZWF0ZXMgYSBuZXcgcm93IGF0ICZxdW90OzUmcXVvdDtcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIGhpbnQ6IFwiTmV3IHJvdy4uLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpbnNlcnRJbmRleDogMTAsXG59O1xuKEFkZERhdGFUb01pZGRsZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGluc2VydEluZGV4OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICAgIG1heDogNDgsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEFwcGVuZFJvd0hhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3Qgb25DbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdm9pZCByZWYuY3VycmVudD8uYXBwZW5kUm93KDMpO1xuICAgIH0sIFtyZWZdKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiYXBwZW5kUm93IFJlZlwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgQWRkaW5nIGRhdGEgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGZyb20gb3V0c2lkZSBvZiA8UHJvcE5hbWU+RGF0YUVkaXRvcjwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IGNhbGxpbmcgPFByb3BOYW1lPmFwcGVuZFJvdzwvUHJvcE5hbWU+IG9uIGEgPFByb3BOYW1lPnJlZjwvUHJvcE5hbWU+IHRvIHlvdXIgZ3JpZCwgeW91IGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciB0aGUgYXBwZW5kIGVsc2V3aGVyZSwgbGlrZSB0aGlzIDxLZXlOYW1lIG9uQ2xpY2s9e29uQ2xpY2t9PkFwcGVuZDwvS2V5TmFtZT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFwcGVuZFJvd0hhbmRsZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU21hbGxFZGl0YWJsZUdyaWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJFZGl0YWJsZSBHcmlkXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBzdXBwb3J0cyBvdmVybGF5IGVkaXRvcnMgZm9yIGNoYW5naW5nIHZhbHVlcy4gVGhlcmUgYXJlIGJlc3Bva2UgZWRpdG9ycyBmb3IgbnVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncywgaW1hZ2VzLCBib29sZWFucywgbWFya2Rvd24sIGFuZCB1cmkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezIwfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNtYWxsRWRpdGFibGVHcmlkIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVNaWxsaW9uUm93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk9uZSBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5EYXRhIGdyaWQgc3VwcG9ydHMgb3ZlciAxIG1pbGxpb24gcm93cy4gWW91ciBsaW1pdCBpcyBtb3N0bHkgUkFNLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxXzAwMF8wMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oT25lTWlsbGlvblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFNpbGx5TnVtYmVyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIjEwMCBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgMTAwIG1pbGxpb24gcm93cyBpcyBzaWxseS4gT25jZSB3ZSBjcm9zcyBhYm91dCAzMyBtaWxsaW9uIHBpeGVscyBpbiBoZWlnaHQgd2UgY2FuIG5vIGxvbmdlciB0cnVzdFxuICAgICAgICAgICAgICAgICAgICB0aGUgYnJvd3NlciB0byBzY3JvbGwgYWNjdXJhdGVseS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDBfMDAwXzAwMH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibnVtYmVyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTaWxseU51bWJlcnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IE9ic2VydmVWaXNpYmxlUmVnaW9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIGNvbnN0IFt2aXNpYmxlUmVnaW9uLCBzZXRWaXNpYmxlUmVnaW9uXSA9IFJlYWN0LnVzZVN0YXRlPFJlY3RhbmdsZT4oeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT2JzZXJ2ZSBWaXNpYmxlIFJlZ2lvblwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHZpc2libGUgcmVnaW9uIGNhbiBiZSBvYnNlcnZlZCB1c2luZyA8UHJvcE5hbWU+b25WaXNpYmxlUmVnaW9uQ2hhbmdlZDwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZW4gY3VycmVudCB2aXNpYmxlIHJlZ2lvbiBpcyB4OjxLZXlOYW1lPnt2aXNpYmxlUmVnaW9uLnh9PC9LZXlOYW1lPiB5OlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ueX08L0tleU5hbWU+IHdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ud2lkdGh9PC9LZXlOYW1lPiBoZWlnaHQ6PEtleU5hbWU+e3Zpc2libGVSZWdpb24uaGVpZ2h0fTwvS2V5TmFtZT5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPXtzZXRWaXNpYmxlUmVnaW9ufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZU1pbGxpb25Sb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVIdW5kcmVkVGhvdXNhbmRDb2xzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMF8wMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT25lIEh1bmRyZWQgVGhvdXNhbmQgQ29sdW1uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgd2F5IG1vcmUgY29sdW1ucyB0aGFuIHlvdSB3aWxsIGV2ZXIgbmVlZC4gQWxzbyB0aGlzIGlzIHJlbmRlcmluZyAxMCBtaWxsaW9uIGNlbGxzXG4gICAgICAgICAgICAgICAgICAgIGJ1dCB0aGF0JmFwb3M7cyBub3QgaW1wb3J0YW50LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZUh1bmRyZWRUaG91c2FuZENvbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRlbk1pbGxpb25DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJUZW4gTWlsbGlvbiBDZWxsc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPkRhdGEgZ3JpZCBzdXBwb3J0cyBvdmVyIDEwIG1pbGxpb24gY2VsbHMuIEdvIG51dHMgd2l0aCBpdC48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihUZW5NaWxsaW9uQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIFNtb290aFNjcm9sbGluZ0dyaWRQcm9wcyB7XG4gICAgc21vb3RoU2Nyb2xsWDogYm9vbGVhbjtcbiAgICBzbW9vdGhTY3JvbGxZOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgU21vb3RoU2Nyb2xsaW5nR3JpZDogUmVhY3QuRkM8U21vb3RoU2Nyb2xsaW5nR3JpZFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDMwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNtb290aCBzY3JvbGxpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBlbmFibGUgc21vb3RoIHNjcm9sbGluZyB3aXRoIHRoZSA8UHJvcE5hbWU+c21vb3RoU2Nyb2xsWDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPnNtb290aFNjcm9sbFk8L1Byb3BOYW1lPiBwcm9wcy4gRGlzYWJsaW5nIHNtb290aCBzY3JvbGxpbmcgY2FuIGRyYW1hdGljYWxseSBpbmNyZWFzZVxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZSBhbmQgaW1wcm92ZSB2aXN1YWwgc3RhYmlsaXR5IGR1cmluZyByYXBpZCBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17cC5zbW9vdGhTY3JvbGxYfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3Auc21vb3RoU2Nyb2xsWX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU21vb3RoU2Nyb2xsaW5nR3JpZCBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogZmFsc2UsXG4gICAgc21vb3RoU2Nyb2xsWTogZmFsc2UsXG59O1xuKFNtb290aFNjcm9sbGluZ0dyaWQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW5wdXRCbGVuZGluZ0dyaWRQcm9wcyB7XG4gICAgcmFuZ2VCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICBjb2x1bW5CbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByYW5nZU11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwiY2VsbFwiIHwgXCJyZWN0XCIgfCBcIm11bHRpLWNlbGxcIiB8IFwibXVsdGktcmVjdFwiO1xuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwic2luZ2xlXCIgfCBcIm11bHRpXCI7XG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibm9uZVwiIHwgXCJzaW5nbGVcIiB8IFwibXVsdGlcIjtcbn1cblxuZXhwb3J0IGNvbnN0IElucHV0QmxlbmRpbmc6IFJlYWN0LkZDPElucHV0QmxlbmRpbmdHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMzApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiSW5wdXQgYmxlbmRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgSW5wdXQgYmxlbmRpbmcgY2FuIGJlIGVuYWJsZWQgb3IgZGlzYWJsZSBiZXR3ZWVuIHJvdywgY29sdW1uLCBhbmQgcmFuZ2Ugc2VsZWN0aW9ucy4gTXVsdGktc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjYW4gYWxzbyBiZSBlbmFibGVkIG9yIGRpc2FibGVkIHdpdGggdGhlIHNhbWUgbGV2ZWwgb2YgZ3JhbnVsYXJpdHkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17cC5yb3dNdWx0aVNlbGVjdCA9PT0gXCJub25lXCIgPyBcIm51bWJlclwiIDogXCJib3RoXCJ9XG4gICAgICAgICAgICAgICAga2V5YmluZGluZ3M9e3tcbiAgICAgICAgICAgICAgICAgICAgY2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvcHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRvd25GaWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByaWdodEZpbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEb3duOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYWdlVXA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEFsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0Q29sdW1uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RSb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICByYW5nZVNlbGVjdD17cC5yYW5nZU11bHRpU2VsZWN0fVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdD17cC5jb2x1bW5NdWx0aVNlbGVjdH1cbiAgICAgICAgICAgICAgICByb3dTZWxlY3Q9e3Aucm93TXVsdGlTZWxlY3R9XG4gICAgICAgICAgICAgICAgcmFuZ2VTZWxlY3Rpb25CbGVuZGluZz17cC5yYW5nZUJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdGlvbkJsZW5kaW5nPXtwLmNvbHVtbkJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbkJsZW5kaW5nPXtwLnJvd0JsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkuYXJncyA9IHtcbiAgICByYW5nZUJsZW5kaW5nOiBcIm1peGVkXCIsXG4gICAgY29sdW1uQmxlbmRpbmc6IFwibWl4ZWRcIixcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiLFxuICAgIHJhbmdlTXVsdGlTZWxlY3Q6IFwicmVjdFwiLFxuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm11bHRpXCIsXG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibXVsdGlcIixcbn07XG4oSW5wdXRCbGVuZGluZyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJhbmdlQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgY29sdW1uQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcm93QmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcmFuZ2VNdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJjZWxsXCIsIFwicmVjdFwiLCBcIm11bHRpLWNlbGxcIiwgXCJtdWx0aS1yZWN0XCJdIH0sXG4gICAgfSxcbiAgICBjb2x1bW5NdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJzaW5nbGVcIiwgXCJtdWx0aVwiXSB9LFxuICAgIH0sXG4gICAgcm93TXVsdGlTZWxlY3Q6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJub25lXCIsIFwic2luZ2xlXCIsIFwibXVsdGlcIl0gfSxcbiAgICB9LFxufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIEFkZENvbHVtbnNQcm9wcyB7XG4gICAgY29sdW1uc0NvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBBZGRDb2x1bW5zOiBSZWFjdC5GQzxBZGRDb2x1bW5zUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKHAuY29sdW1uc0NvdW50KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkFkZCBhbmQgcmVtb3ZlIGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGFkZCBhbmQgcmVtb3ZlIGNvbHVtbnMgYXQgeW91ciBkaXNwb3NhbDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5Vc2UgdGhlIHN0b3J5JmFwb3M7cyBjb250cm9scyB0byBjaGFuZ2UgdGhlIG51bWJlciBvZiBjb2x1bW5zPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJncyA9IHtcbiAgICBjb2x1bW5zQ291bnQ6IDEwLFxufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgY29sdW1uc0NvdW50OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKEFkZENvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU2Nyb2xsU2hhZG93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IFJlYWN0LnVzZVN0YXRlPEdyaWRTZWxlY3Rpb24+KHtcbiAgICAgICAgcm93czogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBvblNlbGVjdGlvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdTZWw6IEdyaWRTZWxlY3Rpb24pID0+IHtcbiAgICAgICAgbGV0IG5ld1Jvd3MgPSBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIGlmIChuZXdTZWwuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdSb3dzID0gbmV3Um93cy5hZGQoW25ld1NlbC5jdXJyZW50LnJhbmdlLnksIG5ld1NlbC5jdXJyZW50LnJhbmdlLnkgKyBuZXdTZWwuY3VycmVudC5yYW5nZS5oZWlnaHRdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbmV3U2VsLmN1cnJlbnQ/LnJhbmdlU3RhY2sgPz8gW10pIHtcbiAgICAgICAgICAgIG5ld1Jvd3MgPSBuZXdSb3dzLmFkZChbYi55LCBiLnkgKyBiLmhlaWdodF0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAuLi5uZXdTZWwsXG4gICAgICAgICAgICByb3dzOiBuZXdSb3dzLFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB0aGVtZSA9IFJlYWN0LnVzZU1lbW88UGFydGlhbDxUaGVtZT4+KFxuICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgICAgYWNjZW50TGlnaHQ6IFwiI2IxZjZmZlwiLFxuICAgICAgICAgICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBoZWFkZXJCb3R0b21Cb3JkZXJDb2xvcjogXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXCIsXG4gICAgICAgIH0pLFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2socm93ID0+IChyb3cgJSAyID09PSAwID8gdW5kZWZpbmVkIDogeyBiZ0NlbGw6IFwiI2Y1ZjVmNlwiIH0pLCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBdXRvbWF0aWMgUm93IE1hcmtlcnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGVuYWJsZSBhbmQgZGlzYWJsZSB0aGUgaG9yaXpvbnRhbC92ZXJ0aWNhbCBzY3JvbGwgc2hhZG93cy48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcIm51bWJlclwifVxuICAgICAgICAgICAgICAgIGdyaWRTZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBvbkdyaWRTZWxlY3Rpb25DaGFuZ2U9e29uU2VsZWN0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0PXsyNn1cbiAgICAgICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezIyfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICB0aGVtZT17dGhlbWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU2Nyb2xsU2hhZG93cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQXV0b21hdGljUm93TWFya2VyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQXV0b21hdGljIFJvdyBNYXJrZXJzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGVuYWJsZSByb3cgbWFya2VycyB3aXRoIHJpY2ggc2VsZWN0aW9uIGJlaGF2aW9yIHVzaW5nIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5yb3dNYXJrZXJzPC9Qcm9wTmFtZT4gcHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIDxLZXlOYW1lPuKHpzwvS2V5TmFtZT4gKyBjbGljayB0byBtYWtlIHJhbmdlIHNlbGVjdGlvbnMsIGFuZCA8S2V5TmFtZT5DdHJsPC9LZXlOYW1lPiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyBjbGljayB0byBhZGQvcmVtb3ZlIGluZGl2aWR1YWwgcm93cy5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBdXRvbWF0aWNSb3dNYXJrZXJzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBXcmFwcGluZ1RleHQ6IFJlYWN0LlZGQzx7XG4gICAgYWxpZ25tZW50OiBcImxlZnRcIiB8IFwiY2VudGVyXCIgfCBcInJpZ2h0XCI7XG4gICAgbGVuZ3RoOiBudW1iZXI7XG4gICAgaHlwZXJXcmFwcGluZzogYm9vbGVhbjtcbn0+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3Qgc3VmZml4ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCAxMDApLm1hcCgoKSA9PiBmYWtlci5sb3JlbS5zZW50ZW5jZShwLmxlbmd0aCkpO1xuICAgIH0sIFtwLmxlbmd0aF0pO1xuXG4gICAgY29uc3QgbWFuZ2xlZEdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2s8dHlwZW9mIGdldENlbGxDb250ZW50PihcbiAgICAgICAgaSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gaTtcblxuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtyb3d9LFxcbiR7c3VmZml4W3JvdyAlIHN1ZmZpeC5sZW5ndGhdfWAsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd30sICR7c3VmZml4fWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBbGlnbjogcC5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50LCBwLmFsaWdubWVudCwgc3VmZml4XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJXcmFwcGluZyBUZXh0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRleHQgY2VsbHMgY2FuIGhhdmUgd3JhcHBpbmcgdGV4dCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+YWxsb3dXcmFwcGluZzwvUHJvcE5hbWU+IHByb3AgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezgwfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWw9e3tcbiAgICAgICAgICAgICAgICAgICAgaHlwZXJXcmFwcGluZzogcC5oeXBlcldyYXBwaW5nLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oV3JhcHBpbmdUZXh0IGFzIGFueSkuYXJncyA9IHtcbiAgICBhbGlnbm1lbnQ6IFwibGVmdFwiLFxuICAgIGxlbmd0aDogMjAsXG4gICAgaHlwZXJXcmFwcGluZzogZmFsc2UsXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGFsaWdubWVudDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXSB9LFxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBVbmV2ZW5Sb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJVbmV2ZW4gUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBSb3dzIGNhbiBiZSBtYWRlIHVuZXZlbiBieSBwYXNzaW5nIGEgY2FsbGJhY2sgdG8gdGhlIDxQcm9wTmFtZT5yb3dIZWlnaHQ8L1Byb3BOYW1lPiBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXtyID0+IChyICUgMyA9PT0gMCA/IDMwIDogciAlIDIgPyA1MCA6IDYwKX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVuZXZlblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IERyYXdDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhdyBjdXN0b20gY2VsbHNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmF3IGN1c3RvbSBjZWxsIGNvbnRlbnRzIGhvd2V2ZXIgeW91IHdhbnQgdXNpbmcgdGhlIDxQcm9wTmFtZT5kcmF3Q3VzdG9tQ2VsbDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZHJhd0NlbGw9e2FyZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNlbGwsIHJlY3QsIGN0eCB9ID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwua2luZCAhPT0gR3JpZENlbGxLaW5kLlRleHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNYID0gY2VsbC5kaXNwbGF5RGF0YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwieFwiKTsgLy8gYWxsIG15IHgncyBsaXZlIGluIHRleGFzXG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gY2VsbC5kaXNwbGF5RGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGFzWCA/IFwiI2JmZmZjZFwiIDogXCIjZmZlNmU2XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICsgMSwgeSArIDEsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGhhc1ggPyBcIiMwZmMwMzVcIiA6IFwiI2UwMWUxZVwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IFwiYm9sZCAxNHB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRhdGEsIHggKyA4ICsgMC41LCB5ICsgaGVpZ2h0IC8gMiArIDQuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKERyYXdDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUmVhcnJhbmdlQ29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZGlydHkgaGFjayBiZWNhdXNlIHRoZSBtb2NrIGdlbmVyYXRvciBkb2Vzbid0IHJlYWxseSBzdXBwb3J0IGNoYW5naW5nIHRoaXMuIEluIGEgcmVhbCBkYXRhIHNvdXJjZVxuICAgIC8vIHlvdSBzaG91bGQgdHJhY2sgaW5kZXhlcyBwcm9wZXJseVxuICAgIGNvbnN0IFtzb3J0YWJsZUNvbHMsIHNldFNvcnRhYmxlQ29sc10gPSBSZWFjdC51c2VTdGF0ZShjb2xzKTtcblxuICAgIGNvbnN0IG9uQ29sTW92ZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoc3RhcnRJbmRleDogbnVtYmVyLCBlbmRJbmRleDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIHNldFNvcnRhYmxlQ29scyhvbGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29scyA9IFsuLi5vbGRdO1xuICAgICAgICAgICAgY29uc3QgW3RvTW92ZV0gPSBuZXdDb2xzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgICAgICAgIG5ld0NvbHMuc3BsaWNlKGVuZEluZGV4LCAwLCB0b01vdmUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbHM7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldENlbGxDb250ZW50TWFuZ2xlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkQ29sID0gY29scy5maW5kSW5kZXgoYyA9PiBjLnRpdGxlID09PSBzb3J0YWJsZUNvbHNbY29sXS50aXRsZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2VsbENvbnRlbnQoW3JlbWFwcGVkQ29sLCByb3ddKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHMsIGdldENlbGxDb250ZW50LCBzb3J0YWJsZUNvbHNdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlYXJyYW5nZSBDb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgY2FuIGJlIHJlYXJyYW5nZWQgYnkgZHJhZyBhbmQgZHJvcHBpbmcsIGFzIGxvbmcgYXMgeW91IHJlc3BvbmQgdG8gdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25Db2x1bW5Nb3ZlZDwvUHJvcE5hbWU+IGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3NvcnRhYmxlQ29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtvbkNvbE1vdmVkfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVhcnJhbmdlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUm93QW5kSGVhZGVyU2l6ZXNQcm9wcyB7XG4gICAgcm93SGVpZ2h0OiBudW1iZXI7XG4gICAgaGVhZGVySGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgUm93QW5kSGVhZGVyU2l6ZXM6IFJlYWN0LlZGQzxSb3dBbmRIZWFkZXJTaXplc1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJvdyBhbmQgSGVhZGVyIHNpemVzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGUgcm93IHNpemUgY2FuIGJlIGNvbnRyb2xsZWQgd2l0aCA8UHJvcE5hbWU+cm93SGVpZ2h0PC9Qcm9wTmFtZT4gYW5kIHRoZSBoZWFkZXIgc2l6ZSB3aXRoe1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmhlYWRlckhlaWdodDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VXNlIHRoZSBzdG9yeSZhcG9zO3MgY29udHJvbHMgdG8gcmVzaXplIHRoZW08L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9e3Aucm93SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhlYWRlckhlaWdodD17cC5oZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wibnVtYmVyXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgcm93SGVpZ2h0OiAzNCxcbiAgICBoZWFkZXJIZWlnaHQ6IDM0LFxufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJvd0hlaWdodDoge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDIwLFxuICAgICAgICAgICAgbWF4OiAyMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBoZWFkZXJIZWlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAyMCxcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFJvd0FuZEhlYWRlclNpemVzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgS2V5TmFtZSA9IHN0eWxlZC5rYmRgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICBjb2xvcjogIzJiMmIyYjtcbiAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgbWFyZ2luOiAwIDAuMWVtO1xuYDtcblxuZXhwb3J0IGNvbnN0IE11bHRpU2VsZWN0Q29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTXVsdGkgc2VsZWN0IGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gc2VsZWN0IG11bHRpcGxlIGNvbHVtbnMgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5zZWxlY3RlZENvbHVtbnM8L1Byb3BOYW1lPiBhbmR7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25TZWxlY3RlZENvbHVtbnNDaGFuZ2U8L1Byb3BOYW1lPiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBIZXJlIHlvdSBjYW4gbXVsdGkgc2VsZWN0IGNvbHVtbnMgYnkgdXNpbmcgPEtleU5hbWU+Q3RybDwvS2V5TmFtZT4gKG9uIFdpbmRvd3MpIG9ye1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+4oyYPC9LZXlOYW1lPiAob24gTWFjKVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oTXVsdGlTZWxlY3RDb2x1bW5zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGdldENvbHVtbnNGb3JDZWxsVHlwZXMoKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJSb3cgSURcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJSb3dJRCxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Sb3dJRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFrZXIuZGF0YXR5cGUudXVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIlByb3RlY3RlZFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmYWtlci5maW5hbmNlLmJpdGNvaW5BZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkxvYWRpbmdcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJTdHJpbmcsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVGV4dFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTnVtYmVyXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gZmFrZXIuZGF0YXR5cGUubnVtYmVyKDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYWdlLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7YWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckJvb2xlYW4sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb2xsID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcm9sbCA8IDAuMSA/IHVuZGVmaW5lZCA6IHJvbGwgPCAwLjIgPyBudWxsIDogcm9sbCA8IDAuNjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIGVkaXRhYmxlLiBVWCBsb29rcyBiYWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJJbWFnZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYCR7ZmFrZXIuaW1hZ2UuYW5pbWFscyg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVXJpXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyVXJpLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZmFrZXIuaW50ZXJuZXQudXJsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlVyaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1hcmtkb3duXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTWFya2Rvd24sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZG93biA9IGAjIFRpdGxlXG5IZWxsbyBteSBuYW1lIGlzICoke2Zha2VyLm5hbWUuZmlyc3ROYW1lKCl9KlxuXG4jIyBUT0RPOlxuVHJ5IG91dCBbR2xpZGVdKGh0dHBzOi8vd3d3LmdsaWRlYXBwcy5jb20vKVxuYDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1hcmtkb3duLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkJ1YmJsZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2Zha2VyLmxvcmVtLndvcmQoKSwgZmFrZXIubG9yZW0ud29yZCgpLCBmYWtlci5sb3JlbS53b3JkKCldLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRyaWxsZG93blwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkRyaWxsZG93bixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZha2VyLmFkZHJlc3MuY2l0eU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IGAke2Zha2VyLmltYWdlLm5hdHVyZSg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmFrZXIuYWRkcmVzcy5jaXR5TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogYCR7ZmFrZXIuaW1hZ2UubmF0dXJlKDQwLCA0MCl9P3JhbmRvbT0ke2Zha2VyLmRhdGF0eXBlLm51bWJlcigxMDBfMDAwKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZUFsbE1vY2tlZEtpbmRzKCkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKGdldENvbHVtbnNGb3JDZWxsVHlwZXMpO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgW3VwZGF0ZVZlcnNpb24sIHNldFVwZGF0ZVZlcnNpb25dID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiB7XG4gICAgICAgICAgICAvLyBUZXJyaWJsZSBoYWNrIHRvIGZvcmNlIHVwZGF0ZSB3aGVuIHNldENlbGxWYWx1ZSByZXF1ZXN0cyBpdFxuICAgICAgICAgICAgbm9vcCh1cGRhdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBjYWNoZS5jdXJyZW50LmdldChjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbY29sc01hcCwgdXBkYXRlVmVyc2lvbl1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsLCBub0Rpc3BsYXk/OiBib29sZWFuLCBmb3JjZVVwZGF0ZT86IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY2FjaGUuY3VycmVudC5nZXQoY29sLCByb3cpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGVHcmlkQ2VsbCh2YWwpICYmIGlzRWRpdGFibGVHcmlkQ2VsbChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcGllZCA9IGxvc3N5Q29weURhdGEodmFsLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jdXJyZW50LnNldChjb2wsIHJvdywge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb3BpZWQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBub0Rpc3BsYXkgPT09IHRydWUgPyB1bmRlZmluZWQgOiBjb3BpZWQuZGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVVwZGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcGRhdGVWZXJzaW9uKHYgPT4gdiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNNYXBdXG4gICAgKTtcblxuICAgIHJldHVybiB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH07XG59XG5cbmV4cG9ydCBjb25zdCBBbGxDZWxsS2luZHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTG90c2EgY2VsbCBraW5kc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgcGxlbnR5IGNlbGwga2luZHMuIEFueXRoaW5nIHVuZGVyIDxQcm9wTmFtZT5HcmlkQ2VsbEtpbmQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjZmYwMGZmMzNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFsbENlbGxLaW5kcyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5jb25zdCBkYXJrVGhlbWUgPSB7XG4gICAgYWNjZW50Q29sb3I6IFwiIzhjOTZmZlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoMjAyLCAyMDYsIDI1NSwgMC4yNTMpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjZmZmZmZmXCIsXG4gICAgdGV4dE1lZGl1bTogXCIjYjhiOGI4XCIsXG4gICAgdGV4dExpZ2h0OiBcIiNhMGEwYTBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiNmZmZmZmZcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjYjhiOGI4XCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiMwMDAwMDBcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiNhMWExYTFcIixcbiAgICB0ZXh0SGVhZGVyU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdDZWxsOiBcIiMxNjE2MWJcIixcbiAgICBiZ0NlbGxNZWRpdW06IFwiIzIwMjAyN1wiLFxuICAgIGJnSGVhZGVyOiBcIiMyMTIxMjFcIixcbiAgICBiZ0hlYWRlckhhc0ZvY3VzOiBcIiM0NzQ3NDdcIixcbiAgICBiZ0hlYWRlckhvdmVyZWQ6IFwiIzQwNDA0MFwiLFxuXG4gICAgYmdCdWJibGU6IFwiIzIxMjEyMVwiLFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFwiIzQyM2MyNFwiLFxuXG4gICAgYm9yZGVyQ29sb3I6IFwicmdiYSgyMjUsMjI1LDIyNSwwLjIpXCIsXG4gICAgZHJpbGxkb3duQm9yZGVyOiBcInJnYmEoMjI1LDIyNSwyMjUsMC40KVwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmNvbnN0IGhvdGRvZ1N0YW5kID0ge1xuICAgIGFjY2VudENvbG9yOiBcIiM4Yzk2ZmZcIixcbiAgICBhY2NlbnRMaWdodDogXCJyZ2JhKDIwMiwgMjA2LCAyNTUsIDAuMjUzKVwiLFxuXG4gICAgdGV4dERhcms6IFwiI2ZmZmZmZlwiLFxuICAgIHRleHRNZWRpdW06IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpXCIsXG4gICAgdGV4dExpZ2h0OiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KVwiLFxuICAgIHRleHRCdWJibGU6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdJY29uSGVhZGVyOiBcIiM4ODAwMDBcIixcbiAgICBmZ0ljb25IZWFkZXI6IFwiI2ZmNTU1NVwiLFxuICAgIHRleHRIZWFkZXI6IFwicmdiYSgwLCAwLCAwLCAwLjkpXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiMwMDAwMDBcIixcblxuICAgIGJnQ2VsbDogXCIjZmYwMDAwXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNmZjRkNGRcIixcbiAgICBiZ0hlYWRlcjogXCIjZjNmMzAwXCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjZWVlZTAwXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNlMGUwMDBcIixcblxuICAgIGJnQnViYmxlOiBcIiNmZmZmMDBcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNmZmZmMDBcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiM0MjNjMjRcIixcblxuICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmMDBcIixcbiAgICBkcmlsbGRvd25Cb3JkZXI6IFwiI2ZmZmYwMFwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUaGVtZVN1cHBvcnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW3RoZW1lLCBzZXRUaGVtZV0gPSBSZWFjdC51c2VTdGF0ZTxQYXJ0aWFsPFRoZW1lPj4oe30pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMTAwMCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdSb3cgPSBudW1Sb3dzO1xuICAgICAgICBzZXROdW1Sb3dzKGN2ID0+IGN2ICsgMSk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoW2MsIG5ld1Jvd10sIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICB9XG4gICAgfSwgW251bVJvd3MsIHNldENlbGxWYWx1ZV0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YUdyaWQgcmVzcGVjdHMgdGhlIHRoZW1lIHByb3ZpZGVkIGJ5IHRoZSA8UHJvcE5hbWU+dGhlbWU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKHt9KX0+TGlnaHQ8L2J1dHRvbj4gb3J7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKGRhcmtUaGVtZSl9PkRhcms8L2J1dHRvbj4gZXZlbntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0VGhlbWUoaG90ZG9nU3RhbmQpfT5Ib3Rkb2cgU3RhbmQ8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgdGhlbWU9e3RoZW1lfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lU3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgVGhlbWVQZXJDb2x1bW46IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s0XSA9IHtcbiAgICAgICAgICAgIC4uLmNbNF0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s5XSA9IHtcbiAgICAgICAgICAgIC4uLmNbOV0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjWzEwXSA9IHtcbiAgICAgICAgICAgIC4uLmNbMTBdLFxuICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xuICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBiZ0ljb25IZWFkZXI6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudENvbG9yOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBhY2NlbnRMaWdodDogXCIjMDA5Q0E2MjBcIixcbiAgICAgICAgICAgICAgICBmZ0ljb25IZWFkZXI6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlRoZW1lIHBlciBjb2x1bW5cIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5FYWNoIGNvbHVtbiBjYW4gcHJvdmlkZSB0aGVtZSBvdmVycmlkZXMgZm9yIHJlbmRlcmluZyB0aGF0IGNvbHVtbi48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oVGhlbWVQZXJDb2x1bW4gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRoZW1lUGVyUm93OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgcGVyIHJvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRWFjaCByb3cgY2FuIHByb3ZpZGUgdGhlbWUgb3ZlcnJpZGVzIGZvciByZW5kZXJpbmcgdGhhdCByb3cgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmdldFJvd1RoZW1lT3ZlcnJpZGU8L1Byb3BOYW1lPiBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17aSA9PlxuICAgICAgICAgICAgICAgICAgICBpICUgMiA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmMGY4ZmZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzZjkwZTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgcm93cz17MV8wMDBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lUGVyUm93IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDZWxsQWN0aXZhdGVkRXZlbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW2xhc3RBY3RpdmF0ZWQsIHNldExhc3RBY3RpdmF0ZWRdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IG9uQ2VsbEFjdGl2YXRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChjZWxsOiBJdGVtKSA9PiB7XG4gICAgICAgIHNldExhc3RBY3RpdmF0ZWQoY2VsbCk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ2VsbCBBY3RpdmF0ZWQgZXZlbnRcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4geW91IHRhcCA8S2V5TmFtZT5FbnRlcjwvS2V5TmFtZT4sIDxLZXlOYW1lPlNwYWNlPC9LZXlOYW1lPiBvciBkb3VibGUgY2xpY2sgYSBjZWxsLCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsIGlzIGFjdGl2YXRlZC4gWW91IGNhbiB0cmFjayB0aGlzIHdpdGggPFByb3BOYW1lPm9uQ2VsbEFjdGl2YXRlZDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXN0IGFjdGl2YXRlZCBjZWxsOntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtsYXN0QWN0aXZhdGVkID09PSB1bmRlZmluZWQgPyBcIm5vbmVcIiA6IGAoJHtsYXN0QWN0aXZhdGVkWzBdfSwgJHtsYXN0QWN0aXZhdGVkWzFdfSlgfVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25DZWxsQWN0aXZhdGVkPXtvbkNlbGxBY3RpdmF0ZWR9XG4gICAgICAgICAgICAgICAgcm93cz17MTBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKENlbGxBY3RpdmF0ZWRFdmVudCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQnVpbHRJblNlYXJjaDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbc2hvd1NlYXJjaCwgc2V0U2hvd1NlYXJjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwia2V5ZG93blwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgZXZlbnQuY29kZSA9PT0gXCJLZXlGXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRTaG93U2VhcmNoKGN2ID0+ICFjdik7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pLFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNlYXJjaCBpcyBlYXN5XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZWFyY2ggZm9yIGFueSBkYXRhIGluIHlvdXIgZ3JpZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5zaG93U2VhcmNoPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEluIHRoaXMgc3RvcnksIDxLZXlOYW1lPkN0cmw8L0tleU5hbWU+ICg8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyA8S2V5TmFtZT5mPC9LZXlOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZXMgdGhlIHNlYXJjaCBiYXIuIE1ha2Ugc3VyZSB5b3UmYXBvcztyZSBmb2N1c2VkIG9uIHRoZSBEYXRhIEdyaWQhXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgc2hvd1NlYXJjaD17c2hvd1NlYXJjaH1cbiAgICAgICAgICAgICAgICBvblNlYXJjaENsb3NlPXsoKSA9PiBzZXRTaG93U2VhcmNoKGZhbHNlKX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQnVpbHRJblNlYXJjaCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW1wZXJhdGl2ZVNjcm9sbFByb3BzIHtcbiAgICBwYWRkaW5nWTogbnVtYmVyO1xuICAgIHBhZGRpbmdYOiBudW1iZXI7XG4gICAgdkFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG4gICAgaEFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG59XG5cbmV4cG9ydCBjb25zdCBJbXBlcmF0aXZlU2Nyb2xsOiBSZWFjdC5WRkM8SW1wZXJhdGl2ZVNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudD8uc2Nyb2xsVG8oNCwgOTksIFwiYm90aFwiLCBwLnBhZGRpbmdYLCBwLnBhZGRpbmdZLCB7XG4gICAgICAgICAgICB2QWxpZ246IHAudkFsaWduLFxuICAgICAgICAgICAgaEFsaWduOiBwLmhBbGlnbixcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkltcGVyYXRpdmUgc2Nyb2xsaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGltcGVyYXRpdmVseSBzY3JvbGwgdG8gYSBjZWxsIGJ5IGNhbGxpbmcgPFByb3BOYW1lPnNjcm9sbFRvPC9Qcm9wTmFtZT4gb24gYSBEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWNrIDxidXR0b24gb25DbGljaz17b25DbGlja30+SGVyZTwvYnV0dG9uPiB0byBzY3JvbGwgdG8gY29sdW1uIDQgcm93IDEwMFxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiY2xpY2thYmxlLW51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBwYWRkaW5nWTogMCxcbiAgICBwYWRkaW5nWDogMCxcbiAgICB2QWxpZ246IFwic3RhcnRcIixcbiAgICBoQWxpZ246IFwic3RhcnRcIixcbn07XG4oSW1wZXJhdGl2ZVNjcm9sbCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHBhZGRpbmdZOiAwLFxuICAgIHBhZGRpbmdYOiAwLFxuICAgIHZBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxuICAgIGhBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgU2ltcGxlTWVudSA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDE3NXB4O1xuICAgIHBhZGRpbmc6IDhweCAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNyksIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMzUpO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgZm9udC1zaXplOiAxM3B4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIFwiT3BlbiBTYW5zXCIsXG4gICAgICAgIFwiSGVsdmV0aWNhIE5ldWVcIiwgc2Fucy1zZXJpZjtcblxuICAgIC5kYW5nZXIge1xuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMC44KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgNDAsIDQwLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgID4gZGl2IHtcbiAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XG4gICAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTAwbXM7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgSGVhZGVyTWVudXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKGMgPT4gKHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIGNvbnN0IFttZW51LCBzZXRNZW51XSA9XG4gICAgICAgIFJlYWN0LnVzZVN0YXRlPHtcbiAgICAgICAgICAgIGNvbDogbnVtYmVyO1xuICAgICAgICAgICAgYm91bmRzOiBSZWN0YW5nbGU7XG4gICAgICAgIH0+KCk7XG5cbiAgICBjb25zdCBpc09wZW4gPSBtZW51ICE9PSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCB7IGxheWVyUHJvcHMsIHJlbmRlckxheWVyIH0gPSB1c2VMYXllcih7XG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgYXV0bzogdHJ1ZSxcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICAgICAgdHJpZ2dlck9mZnNldDogMixcbiAgICAgICAgb25PdXRzaWRlQ2xpY2s6ICgpID0+IHNldE1lbnUodW5kZWZpbmVkKSxcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG1lbnU/LmJvdW5kcy54ID8/IDAsXG4gICAgICAgICAgICAgICAgdG9wOiBtZW51Py5ib3VuZHMueSA/PyAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBtZW51Py5ib3VuZHMud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICByaWdodDogKG1lbnU/LmJvdW5kcy54ID8/IDApICsgKG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwKSxcbiAgICAgICAgICAgICAgICBib3R0b206IChtZW51Py5ib3VuZHMueSA/PyAwKSArIChtZW51Py5ib3VuZHMuaGVpZ2h0ID8/IDApLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkhlYWRlck1lbnVDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2w6IG51bWJlciwgYm91bmRzOiBSZWN0YW5nbGUpID0+IHtcbiAgICAgICAgc2V0TWVudSh7IGNvbCwgYm91bmRzIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2tlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coXCJIZWFkZXIgY2xpY2tlZFwiKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJIZWFkZXIgbWVudXNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIEhlYWRlcnMgb24gdGhlIGRhdGEgZ3JpZCBjYW4gYmUgY29uZmlndXJlZCB0byBzdXBwb3J0IG1lbnVzLiBXZSBwcm92aWRlIHRoZSBldmVudHMgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUsIHlvdSBwcm92aWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja2VkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtpc09wZW4gJiZcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcbiAgICAgICAgICAgICAgICAgICAgPFNpbXBsZU1lbnUgey4uLmxheWVyUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiBsZWZ0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRhbmdlclwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIZWFkZXJNZW51cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVySWNvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aXRsZTogXCJDVVNUT00gSUNPTlwiLFxuICAgICAgICAgICAgaWNvbjogXCJjdXN0b21cIixcbiAgICAgICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICBjb25zdCBoZWFkZXJJY29ucyA9IFJlYWN0LnVzZU1lbW88U3ByaXRlTWFwPigoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXN0b206IHAgPT4gYDxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgICAgICAgICAgPHJlY3QgeD1cIjIuMDAwMTVcIiB5PVwiMlwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiNFwiIGZpbGw9XCIke3AuYmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTQuNjk3NTkgNi4wMDk3N0M0LjIzNzM1IDYuMDA5NzcgMy44NjQyNiA2LjM4Mjg2IDMuODY0MjYgNi44NDMxQzMuODY0MjYgNy4zMDMzNCA0LjIzNzM1IDcuNjc2NDMgNC42OTc1OSA3LjY3NjQzSDguODY0MjZDOS4zMjQ1IDcuNjc2NDMgOS42OTc1OSA3LjMwMzM0IDkuNjk3NTkgNi44NDMxQzkuNjk3NTkgNi4zODI4NiA5LjMyNDQ5IDYuMDA5NzcgOC44NjQyNiA2LjAwOTc3SDQuNjk3NTlaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNy42MTQyNiA0Ljc2MDA5QzcuNjE0MjYgNC4yOTk4NSA3LjI0MTE2IDMuOTI2NzYgNi43ODA5MiAzLjkyNjc2QzYuMzIwNjkgMy45MjY3NiA1Ljk0NzU5IDQuMjk5ODUgNS45NDc1OSA0Ljc2MDA5TDUuOTQ3NTkgOC45MjY3NkM1Ljk0NzU5IDkuMzg3IDYuMzIwNjkgOS43NjAwOSA2Ljc4MDkyIDkuNzYwMDlDNy4yNDExNiA5Ljc2MDA5IDcuNjE0MjYgOS4zODY5OSA3LjYxNDI2IDguOTI2NzZMNy42MTQyNiA0Ljc2MDA5WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTExLjAzMzYgNi4wMDk3N0MxMC41NzM0IDYuMDA5NzcgMTAuMjAwMyA2LjM4Mjg2IDEwLjIwMDMgNi44NDMxQzEwLjIwMDMgNy4zMDMzNCAxMC41NzM0IDcuNjc2NDMgMTEuMDMzNiA3LjY3NjQzSDE1LjIwMDNDMTUuNjYwNSA3LjY3NjQzIDE2LjAzMzYgNy4zMDMzNCAxNi4wMzM2IDYuODQzMUMxNi4wMzM2IDYuMzgyODYgMTUuNjYwNSA2LjAwOTc3IDE1LjIwMDMgNi4wMDk3N0gxMS4wMzM2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTUuODk3MDQgMTAuOTkxNkM1LjU3MTYgMTAuNjY2MiA1LjA0Mzk3IDEwLjY2NjIgNC43MTg1MyAxMC45OTE2QzQuMzkzMDkgMTEuMzE3IDQuMzkzMDkgMTEuODQ0NyA0LjcxODUzIDEyLjE3MDFMNy42NjQ4MSAxNS4xMTY0QzcuOTkwMjQgMTUuNDQxOCA4LjUxNzg4IDE1LjQ0MTggOC44NDMzMiAxNS4xMTY0QzkuMTY4NzYgMTQuNzkxIDkuMTY4NzYgMTQuMjYzMyA4Ljg0MzMyIDEzLjkzNzlMNS44OTcwNCAxMC45OTE2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTguODQzMzIgMTIuMTcwM0M5LjE2ODc1IDExLjg0NDkgOS4xNjg3NSAxMS4zMTcyIDguODQzMzIgMTAuOTkxOEM4LjUxNzg4IDEwLjY2NjQgNy45OTAyNCAxMC42NjY0IDcuNjY0OCAxMC45OTE4TDQuNzE4NTMgMTMuOTM4MUM0LjM5MzA5IDE0LjI2MzUgNC4zOTMwOSAxNC43OTEyIDQuNzE4NTMgMTUuMTE2NkM1LjA0Mzk2IDE1LjQ0MiA1LjU3MTYgMTUuNDQyIDUuODk3MDQgMTUuMTE2Nkw4Ljg0MzMyIDEyLjE3MDNaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTEuODA0QzEwLjIwMDMgMTEuMzQzOCAxMC41NzM0IDEwLjk3MDcgMTEuMDMzNiAxMC45NzA3SDE1LjIwMDNDMTUuNjYwNSAxMC45NzA3IDE2LjAzMzYgMTEuMzQzOCAxNi4wMzM2IDExLjgwNEMxNi4wMzM2IDEyLjI2NDMgMTUuNjYwNSAxMi42Mzc0IDE1LjIwMDMgMTIuNjM3NEgxMS4wMzM2QzEwLjU3MzQgMTIuNjM3NCAxMC4yMDAzIDEyLjI2NDMgMTAuMjAwMyAxMS44MDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTQuMzA0QzEwLjIwMDMgMTMuODQzOCAxMC41NzM0IDEzLjQ3MDcgMTEuMDMzNiAxMy40NzA3SDE1LjIwMDNDMTUuNjYwNSAxMy40NzA3IDE2LjAzMzYgMTMuODQzOCAxNi4wMzM2IDE0LjMwNEMxNi4wMzM2IDE0Ljc2NDMgMTUuNjYwNSAxNS4xMzc0IDE1LjIwMDMgMTUuMTM3NEgxMS4wMzM2QzEwLjU3MzQgMTUuMTM3NCAxMC4yMDAzIDE0Ljc2NDMgMTAuMjAwMyAxNC4zMDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgIDwvc3ZnPmAsXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGhlYWRlciBpY29uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIG92ZXJyaWRlcyBmb3IgdGhlIGRlZmF1bHQgaWNvbnMgYnkgcGFzc2luZyB0aGUgPFByb3BOYW1lPmhlYWRlckljb25zPC9Qcm9wTmFtZT57XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIGhlYWRlckljb25zPXtoZWFkZXJJY29uc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlckljb25zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodEVsZW1lbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig4LCBmYWxzZSk7XG5cbiAgICBjb25zdCBjb2x1bW5zID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb2xzLm1hcChjID0+ICh7IC4uLmMsIGdyb3c6IDEgfSkpLCBbY29sc10pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMzAwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZShbYywgbmV3Um93XSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgIH1cbiAgICB9LCBbbnVtUm93cywgc2V0Q2VsbFZhbHVlXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSaWdodCBFbGVtZW50XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgRE9NIGVsZW1lbnQgbWF5IGJlIGFkZGVkIGFzIGEgdHJhaWxlciB0byB0aGUgZ3JpZCBieSB1c2luZyB0aGUgPFByb3BOYW1lPnJpZ2h0RWxlbWVudDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgaGludDogXCJOZXcgcm93Li4uXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17eyBzdGlja3k6IHRydWUgfX1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIyMHB4IDIwcHggNDBweCAyMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjUwLCAwLjIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwiMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjE1KVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wRmlsdGVyOiBcImJsdXIoMTJweClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBpcyBhIHJlYWwgRE9NIGVsZW1lbnQuIFlvdSBjYW4gcHV0IHdoYXRldmVyIHlvdSB3YW50IGhlcmUuIFlvdSBjYW4gYWxzbyBzaXplIGl0IGFzIGJpZyBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgeW91IHdhbnQuIHtcIlxcblxcblwifUl0IGFsc28gZG9lcyBub3QgaGF2ZSB0byBiZSBzdGlja3kuXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSaWdodEVsZW1lbnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxubGV0IG51bTogbnVtYmVyID0gMTtcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNl84MDcpICUgMl8xNDdfNDgzXzY0Nyk7XG59XG5cbmV4cG9ydCBjb25zdCBSYXBpZFVwZGF0ZXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3QgY291bnRSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgZGlzcGxheUNvdW50UmVmID0gUmVhY3QudXNlUmVmPEhUTUxFbGVtZW50PihudWxsKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCByYWZJRCA9IDA7XG5cbiAgICAgICAgY29uc3Qgc2VuZFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzOiB7XG4gICAgICAgICAgICAgICAgY2VsbDogSXRlbTtcbiAgICAgICAgICAgIH1bXSA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDUwMDA7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IE1hdGgubWF4KDEwLCByYW5kKCkgJSAxMDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHJhbmQoKSAlIDEwXzAwMDtcblxuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbY29sLCByb3ddLCB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB4LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHt4fWtgLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCAlIDUgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2YyZmZmNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMGQ0MWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2ZmZjZmNlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiNkNDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5vdyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHsgY2VsbDogW2NvbCwgcm93XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50UmVmLmN1cnJlbnQgKz0gNTAwMDtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5Q291bnRSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlDb3VudFJlZi5jdXJyZW50LnRleHRDb250ZW50ID0gYCR7Y291bnRSZWYuY3VycmVudH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWYuY3VycmVudD8udXBkYXRlQ2VsbHMoY2VsbHMpO1xuXG4gICAgICAgICAgICByYWZJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2VuZFVwZGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VuZFVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJRCk7XG4gICAgICAgIH07XG4gICAgfSwgW3NldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUmFwaWQgdXBkYXRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBjYW4gc3VwcG9ydCBtYW55IHRob3VzYW5kcyBvZiB1cGRhdGVzIHBlciBzZWNvbmRzLiBUaGUgZGF0YSBncmlkIGNhbiBlYXNpbHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGZhc3RlciB0aGFuIGEgaHVtYW4gY2FuIHJlYWQgaXQsIG1vcmUgaW1wb3J0YW50bHkgdGhlIGZhc3RlciB0aGUgZGF0YSBncmlkIGNhbiB1cGRhdGUsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZSB0aW1lIHlvdXIgY29kZSBjYW4gc3BlbmQgZG9pbmcgbW9yZSB2YWx1YWJsZSB3b3JrLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGVzIHByb2Nlc3NlZDogPEtleU5hbWUgcmVmPXtkaXNwbGF5Q291bnRSZWZ9IC8+IFdlIGNvdWxkIGRvIHRoaXMgZmFzdGVyIGJ1dCB3ZSB3cm90ZSBhXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsbHkgY3JhcHB5IGRhdGEgc3RvcmUgZm9yIHRoaXMgZGVtbyB3aGljaCBpcyBhY3R1YWxseSBzbG93aW5nIGRvd24gdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSYXBpZFVwZGF0ZXMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvcHlTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICAxMCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29weSBzdXBwb3J0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXJnZSBhbW91bnRzIG9mIGRhdGEgY2FuIGJlIGNvcGllZCBhbmQgY3VzdG9taXplZCB1c2luZ3tcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5nZXRDZWxsc0ZvclNlbGVjdGlvbjwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VGhlIGRhdGEgaXMgY29waWVkIGludG8gYSBmb3JtYXQgcmVhZHkgdG8gYmUgcGFzdGVkIGludG8gRXhjZWwgb3IgR29vZ2xlIFNoZWV0czwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJDb3B5IHNvbWV0aGluZyBiZWxvdyBhbmQgcGFzdGUgaXQgaGVyZS4uLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG1hcmdpbkJvdHRvbTogMjAsIGJvcmRlclJhZGl1czogOSwgbWluSGVpZ2h0OiAyMDAsIHBhZGRpbmc6IDEwIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb3B5U3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUGFzdGVTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA1MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUGFzdGUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZ3JpZCBjYW4gaGFuZGxlIHBhc3RlIGF1dG9tYXRpY2FsbHkgYnkgcmV0dXJuaW5nIHRydWUgZnJvbSA8UHJvcE5hbWU+b25QYXN0ZTwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgICAgICAuIFlvdSBjYW4gYWxzbyByZXR1cm4gZmFsc2UgYW5kIGhhbmRsZSBwYXN0ZSB5b3Vyc2VsZi4gSWYgcGFzdGUgaXMgdW5kZWZpbmVkIHRoZSBEYXRhRWRpdG9yIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIGl0cyBiZXN0IHRvIHBhc3RlIHRvIHRoZSBjdXJyZW50IGNlbGwuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFBhc3RlIHN1cHBvcnRzIHRoZSBjb3B5IGZvcm1hdCBvZiBHb29nbGUgU2hlZXRzIGFuZCBFeGNlbC4gQmVsb3cgaXMgYW4gZXhhbXBsZSBvZiBkYXRhIGNvcGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBleGNlbCB3aXRoIHNvbWUgZXNjYXBlZCB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtgU3VuZGF5XHREb2dzXHRodHRwczovL2dvb2dsZS5jb21cbk1vbmRheVx0Q2F0c1x0aHR0cHM6Ly9nb29nbGUuY29tXG5UdWVzZGF5XHRUdXJ0bGVzXHRodHRwczovL2dvb2dsZS5jb21cbldlZG5lc2RheVx0QmVhcnNcdGh0dHBzOi8vZ29vZ2xlLmNvbVxuVGh1cnNkYXlcdFwiTCAgaW9uc1wiXHRodHRwczovL2dvb2dsZS5jb21cbkZyaWRheVx0UGlnc1x0aHR0cHM6Ly9nb29nbGUuY29tXG5TYXR1cmRheVx0XCJUdXJrZXlzIGFuZCBzb21lIFwiXCJxdW90ZXNcIlwiIGFuZFxuYSBuZXcgbGluZSBjaGFyIFwiXCJtb3JlIHF1b3Rlc1wiXCIgcGx1cyBhIHRhYiAgLlwiXHRodHRwczovL2dvb2dsZS5jb21gfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBtYXJnaW5Cb3R0b206IDIwLCBib3JkZXJSYWRpdXM6IDksIG1pbkhlaWdodDogMjAwLCBwYWRkaW5nOiAxMCB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihQYXN0ZVN1cHBvcnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEZyZWV6ZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkZyZWV6ZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgZ3JpZCBjYW4gYmUgZnJvemVuIGluIHBsYWNlIGJ5IHNldHRpbmdze1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+ZnJlZXplQ29sdW1uczwvUHJvcE5hbWU+IHRvIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXsxfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17YyA9PiBjID4gMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEZyZWV6ZUNvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFJlb3JkZXJSb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29scyA9IFJlYWN0LnVzZU1lbW88R3JpZENvbHVtbltdPihcbiAgICAgICAgKCkgPT4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkNvbCBBXCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQ29sIEJcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgW3Jvd0RhdGEsIHNldFJvd0RhdGFdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgNTApLm1hcCh4ID0+IFtgQTogJHt4fWAsIGBCOiAke3h9YF0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjazxEYXRhRWRpdG9yUHJvcHNbXCJnZXRDZWxsQ29udGVudFwiXT4oXG4gICAgICAgIChbY29sLCByb3ddKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogcm93RGF0YVtyb3ddW2NvbF0sXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IHJvd0RhdGFbcm93XVtjb2xdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW3Jvd0RhdGFdXG4gICAgKTtcblxuICAgIGNvbnN0IHJlb3JkZXJSb3dzID0gUmVhY3QudXNlQ2FsbGJhY2soKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRSb3dEYXRhKGN2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBbLi4uY3ZdO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGQuc3BsaWNlKGZyb20sIDEpO1xuICAgICAgICAgICAgZC5zcGxpY2UodG8sIDAsIC4uLnJlbW92ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlb3JkZXIgUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgUm93cyBjYW4gYmUgcmUtYXJyYW5nZWQgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5vblJvd01vdmVkPC9Qcm9wTmFtZT4gY2FsbGJhY2suIFdoZW4gc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3Qgcm93IGNhbiBiZSB1c2VkIHRvIGRyYWcgYW5kIGRyb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUm93TW92ZWQ9e3Jlb3JkZXJSb3dzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJlb3JkZXJSb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb2x1bW5Hcm91cHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAsIHRydWUsIHRydWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29sdW1uIEdyb3VwaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgaW4gdGhlIGRhdGEgZ3JpZCBtYXkgYmUgZ3JvdXBlZCBieSBzZXR0aW5nIHRoZWlyIDxQcm9wTmFtZT5ncm91cDwvUHJvcE5hbWU+IHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBvbkdyb3VwSGVhZGVyUmVuYW1lZD17KHgsIHkpID0+IHdpbmRvdy5hbGVydChgUGxlYXNlIHJlbmFtZSBncm91cCAke3h9IHRvICR7eX1gKX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17ZyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBnLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBnID09PSBcIlwiID8gdW5kZWZpbmVkIDogR3JpZENvbHVtbkljb24uSGVhZGVyQ29kZSxcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ29sdW1uR3JvdXBzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBTdHJldGNoQ29sdW1uU2l6ZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uLCBvbkNvbHVtblJlc2l6ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBoYXNSZXNpemVkID0gUmVhY3QudXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKCh4LCBpKSA9PiAoeyAuLi54LCBncm93OiBoYXNSZXNpemVkLmN1cnJlbnQuaGFzKGkpID8gdW5kZWZpbmVkIDogKDUgKyBpKSAvIDUgfSkpO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb2x1bW4gR3Jvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDb2x1bW5zIGluIHRoZSBkYXRhIGdyaWQgbWF5IGJlIHNldCB0byBncm93IHRvIGZpbGwgc3BhY2UgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPmdyb3c8L1Byb3BOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgcHJvcC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17KGNvbCwgX25ld1NpemUsIGNvbEluZGV4LCBuZXdTaXplV2l0aEdyb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVzaXplZC5jdXJyZW50LmFkZChjb2xJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplKGNvbCwgbmV3U2l6ZVdpdGhHcm93KTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTdHJldGNoQ29sdW1uU2l6ZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiB1c2VDb2xsYXBzYWJsZUNvbHVtbkdyb3Vwcyhjb2xzOiByZWFkb25seSBHcmlkQ29sdW1uW10pIHtcbiAgICBjb25zdCBbY29sbGFwc2VkLCBzZXRDb2xsYXBzZWRdID0gUmVhY3QudXNlU3RhdGU8cmVhZG9ubHkgc3RyaW5nW10+KFtdKTtcblxuICAgIGNvbnN0IG9uR3JvdXBIZWFkZXJDbGlja2VkID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjb2xJbmRleDogbnVtYmVyLCBhcmdzOiBHcm91cEhlYWRlckNsaWNrZWRFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gY29sc1tjb2xJbmRleF0uZ3JvdXAgPz8gXCJcIjtcbiAgICAgICAgICAgIHNldENvbGxhcHNlZChjdiA9PiAoY3YuaW5jbHVkZXMoZ3JvdXApID8gY3YuZmlsdGVyKGcgPT4gZyAhPT0gZ3JvdXApIDogWy4uLmN2LCBncm91cF0pKTtcbiAgICAgICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNdXG4gICAgKTtcblxuICAgIGNvbnN0IFtzZWxlY3RlZENvbHVtbnMsIHNldFNlbGVjdGVkQ29sdW1uc10gPSBSZWFjdC51c2VTdGF0ZTxDb21wYWN0U2VsZWN0aW9uPihDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCkpO1xuXG4gICAgY29uc3Qgc2V0Q29scyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdWYWw6IENvbXBhY3RTZWxlY3Rpb24sIHRyaWdnZXI6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodHJpZ2dlciA9PT0gXCJncm91cFwiKSByZXR1cm47XG5cbiAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKG5ld1ZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY29scy5tYXAoYyA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbGxhcHNlZC5pbmNsdWRlcyhjLmdyb3VwID8/IFwiXCIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICAgIGhhc01lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgICAgICB3aWR0aDogOCxcbiAgICAgICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvbGxhcHNlZCwgY29sc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgb25Hcm91cEhlYWRlckNsaWNrZWQsXG4gICAgICAgIHNlbGVjdGVkQ29sdW1ucyxcbiAgICAgICAgb25TZWxlY3RlZENvbHVtbnNDaGFuZ2U6IHNldENvbHMsXG4gICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkdyb3VwQ29sbGFwc2U6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAsIHRydWUsIHRydWUpO1xuXG4gICAgY29uc3QgZ3JvdXBIZWFkZXJBcmdzID0gdXNlQ29sbGFwc2FibGVDb2x1bW5Hcm91cHMoY29scyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJHcm91cCBjb2xsYXBzZVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3VnaCBjbGV2ZXIgdXNhZ2Ugb2YgPFByb3BOYW1lPm9uR3JvdXBIZWFkZXJDbGlja2VkPC9Qcm9wTmFtZT4geW91IGNhbiBpbXBsZW1lbnQgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNpbmcuIFRoaXMgaXMgYSB2ZXJ5IGJhc2ljIHZlcnNpb24gaG93ZXZlciBpdCBpcyBwb3NzaWJsZSB0byBnbyBtdWNoIGZ1cnRoZXIuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5DZWxscyB1bmRlciBhIGNlcnRhaW4gc2l6ZSB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbmRlciB0byBzYXZlIHNvbWUgZnJhbWVzLjwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5ncm91cEhlYWRlckFyZ3N9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXsyNH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb2x1bW5Hcm91cENvbGxhcHNlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBNaW5pbWFwOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJNaW5pbWFwXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbWluaW1hcCBjYW4gYmUgZW5hYmxlZCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+c2hvd01pbmltYXA8L1Byb3BOYW1lPiBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBzaG93TWluaW1hcD17dHJ1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXszMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihNaW5pbWFwIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb250ZW50QWxpZ25tZW50OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgX3Jvd10gPSBjZWxsO1xuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdldENlbGxDb250ZW50KGNlbGwpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5nZXRDZWxsQ29udGVudChjZWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb250ZW50IEFsaWdubWVudFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgY29udGVudCBhbGlnbm1lbnQgYnkgc2V0dGluZyA8UHJvcE5hbWU+Y29udGVudEFsaWduPC9Qcm9wTmFtZT4gb2YgYSBjZWxsIHRve1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+bGVmdDwvUHJvcE5hbWU+LCA8UHJvcE5hbWU+cmlnaHQ8L1Byb3BOYW1lPiBvciA8UHJvcE5hbWU+Y2VudGVyPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvciB7Li4uZGVmYXVsdFByb3BzfSBnZXRDZWxsQ29udGVudD17bWFuZ2xlZEdldENlbGxDb250ZW50fSBjb2x1bW5zPXtjb2xzfSByb3dzPXszMDB9IC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFJvd0hvdmVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IFtob3ZlclJvdywgc2V0SG92ZXJSb3ddID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgW18sIHJvd10gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICBzZXRIb3ZlclJvdyhhcmdzLmtpbmQgIT09IFwiY2VsbFwiID8gdW5kZWZpbmVkIDogcm93KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2s8R2V0Um93VGhlbWVDYWxsYmFjaz4oXG4gICAgICAgIHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAocm93ICE9PSBob3ZlclJvdykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmN2Y3ZjdcIixcbiAgICAgICAgICAgICAgICBiZ0NlbGxNZWRpdW06IFwiI2YwZjBmMFwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW2hvdmVyUm93XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSb3cgSG92ZXIgRWZmZWN0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRocm91Z2ggY2FyZWZ1bCB1c2FnZSBvZiB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBjYWxsYmFjayBpdCBpcyBwb3NzaWJsZSB0byBlYXNpbHlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlIGEgcm93IGhvdmVyIGVmZmVjdC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17b25JdGVtSG92ZXJlZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNwYW5DZWxsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwLCB0cnVlLCB0cnVlKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAocm93ID09PSA2ICYmIGNvbCA+PSAzICYmIGNvbCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IFszLCA0XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPT09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJTcGFuIENlbGwgdGhhdCBpcyB2ZXJ5IGxvbmcgYW5kIHdpbGwgZ28gcGFzdCB0aGUgY2VsbCBsaW1pdHNcIixcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogWzAsIDk5XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRDZWxsc0ZvclNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoc2VsZWN0aW9uOiBSZWN0YW5nbGUpOiBDZWxsQXJyYXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBHcmlkQ2VsbFtdW10gPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHNlbGVjdGlvbi55OyB5IDwgc2VsZWN0aW9uLnkgKyBzZWxlY3Rpb24uaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3c6IEdyaWRDZWxsW10gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gc2VsZWN0aW9uLng7IHggPCBzZWxlY3Rpb24ueCArIHNlbGVjdGlvbi53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKG1hbmdsZWRHZXRDZWxsQ29udGVudChbeCwgeV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgW21hbmdsZWRHZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiU3BhbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgQnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnNwYW48L1Byb3BOYW1lPiBvZiBhIGNlbGwgeW91IGNhbiBjcmVhdGUgc3BhbnMgaW4geW91ciBncmlkLiBBbGwgY2VsbHNcbiAgICAgICAgICAgICAgICAgICAgd2l0aGluIGEgc3BhbiBtdXN0IHJldHVybiBjb25zaXN0ZW50IGRhdGEgZm9yIGRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNwYW5zIHdpbGwgYWx3YXlzIGJlIHNwbGl0IGlmIHRoZXkgc3BhbiBmcm96ZW4gYW5kIG5vbi1mcm96ZW4gY29sdW1ucy4gQnkgZGVmYXVsdCBzZWxlY3Rpb25zIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzIGV4cGFuZGVkIHRvIGluY2x1ZGUgYSBzcGFuLiBUaGlzIGNhbiBiZSBkaXNhYmxlZCB1c2luZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+c3BhblJhbmdlQmVoYXZpb3I8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17Mn1cbiAgICAgICAgICAgICAgICByb3dzPXszMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNwYW5DZWxsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHplcm9Cb3VuZHMgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICByaWdodDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBUb29sdGlwczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3Rvb2x0aXAsIHNldFRvb2x0aXBdID0gUmVhY3QudXNlU3RhdGU8eyB2YWw6IHN0cmluZzsgYm91bmRzOiBJQm91bmRzIH0gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gXCJjZWxsXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHNldFRvb2x0aXAodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBgVG9vbHRpcCBmb3IgJHthcmdzLmxvY2F0aW9uWzBdfSwgJHthcmdzLmxvY2F0aW9uWzFdfWAsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIHJlYWN0LWxhYWcgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFyZ3MuYm91bmRzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGFyZ3MuYm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGFyZ3MuYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBhcmdzLmJvdW5kcy54ICsgYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGFyZ3MuYm91bmRzLnkgKyBhcmdzLmJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IDA7XG4gICAgICAgICAgICBzZXRUb29sdGlwKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpLCBbXSk7XG5cbiAgICBjb25zdCBpc09wZW4gPSB0b29sdGlwICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyByZW5kZXJMYXllciwgbGF5ZXJQcm9wcyB9ID0gdXNlTGF5ZXIoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDQsXG4gICAgICAgIGF1dG86IHRydWUsXG4gICAgICAgIGNvbnRhaW5lcjogXCJwb3J0YWxcIixcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiB0b29sdGlwPy5ib3VuZHMgPz8gemVyb0JvdW5kcyxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiVG9vbHRpcHNcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvdWJsZVwiXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBVc2luZyB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBldmVudCBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSB0b29sdGlwcy4gVGhpcyBzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgaXMgaW50ZW50aW9uYWxseSBmb3JjZWQgdG8gc2Nyb2xsIHZlcnRpY2FsbHkgc28gbGF5b3V0IGluIHNjcm9sbGluZyBkb2N1bWVudHMgY2FuIGJlIGNvbmZpcm1lZC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICB9PlxuICAgICAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9e29uSXRlbUhvdmVyZWR9XG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICAgICAgICAge2lzT3BlbiAmJlxuICAgICAgICAgICAgICAgIHJlbmRlckxheWVyKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ubGF5ZXJQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGF5ZXJQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjhweCAxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250OiBcIjUwMCAxM3B4IEludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC44NSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0b29sdGlwLnZhbH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgPC8+XG4gICAgKTtcbn07XG4oVG9vbHRpcHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvbnRyb2xsZWRTZWxlY3Rpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigzMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkNvbnRyb2xsZWQgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBzZWxlY3Rpb24gb2YgdGhlIGdyaWQgY2FuIGJlIGNvbnRyb2xsZWQgdmlhIDxQcm9wTmFtZT5HcmlkU2VsZWN0aW9uPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25HcmlkU2VsZWN0aW9uQ2hhbmdlPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbj17MH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heD17Mjl9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2VsZWN0aW9uLmN1cnJlbnQ/LmNlbGxbMF0gPz8gMH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2wgPSBlLnRhcmdldC52YWx1ZUFzTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvbihjdiA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbDogW25ld0NvbCwgY3YuY3VycmVudD8uY2VsbFsxXSA/PyAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbmV3Q29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN2LmN1cnJlbnQ/LmNlbGxbMV0gPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFjazogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4PXs5OX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxlY3Rpb24uY3VycmVudD8uY2VsbFsxXSA/PyAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGUudGFyZ2V0LnZhbHVlQXNOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKGN2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsOiBbY3YuY3VycmVudD8uY2VsbFswXSA/PyAwLCBuZXdSb3ddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjdi5jdXJyZW50Py5jZWxsWzBdID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogbmV3Um93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTmV3Q29sdW1uQnV0dG9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAsIHRydWUpO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29scy5tYXAoYyA9PiAoeyAuLi5jLCBncm93OiAxIH0pKSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk5ldyBjb2x1bW4gYnV0dG9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbmV3IGNvbHVtbiBidXR0b24gY2FuIGJlIGNyZWF0ZWQgdXNpbmcgdGhlIDxQcm9wTmFtZT5yaWdodEVsZW1lbnQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8Q29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB3aW5kb3cuYWxlcnQoXCJBZGQgYSBjb2x1bW4hXCIpfT4rPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvQ29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17e1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkcmF3SGVhZGVyOiBEcmF3SGVhZGVyQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhhcmdzID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxnID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHJlY3QueSwgMCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICBsZy5hZGRDb2xvclN0b3AoMCwgXCIjZmYwMGQ5MzRcIik7XG4gICAgICAgIGxnLmFkZENvbG9yU3RvcCgxLCBcIiMwMGEyZmYzNFwiKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxnO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gSGVhZGVyXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5NYWtlIGl0IGFzIGZhbmN5IGFzIHlvdSBsaWtlLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtkcmF3SGVhZGVyfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlciBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUGFkZGluZ1Byb3BzIHtcbiAgICBwYWRkaW5nUmlnaHQ6IG51bWJlcjtcbiAgICBwYWRkaW5nQm90dG9tOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBQYWRkaW5nOiBSZWFjdC5WRkM8UGFkZGluZ1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlBhZGRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWRkIHBhZGRpbmcgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnBhZGRpbmdSaWdodDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5wYWRkaW5nQm90dG9tPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt7IHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdUeXBlcyA9IHtcbiAgICBwYWRkaW5nUmlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwYWRkaW5nQm90dG9tOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogNjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdzID0ge1xuICAgIHBhZGRpbmdSaWdodDogMjAwLFxuICAgIHBhZGRpbmdCb3R0b206IDIwMCxcbn07XG4oUGFkZGluZyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHRDZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgW2dyaWRTZWxlY3Rpb24sIHNldEdyaWRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGhpZ2hsaWdodHMgPSBSZWFjdC51c2VNZW1vPERhdGFFZGl0b3JQcm9wc1tcImhpZ2hsaWdodFJlZ2lvbnNcIl0+KCgpID0+IHtcbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGw7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFwiIzQ0QkIwMDIyXCIsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29sICsgMixcbiAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjYjAwMGIwMjFcIixcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJvdyArIDIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSwgW2dyaWRTZWxlY3Rpb25dKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkhpZ2hsaWdodENlbGxzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSA8UHJvcE5hbWU+aGlnaGxpZ2h0UmVnaW9uczwvUHJvcE5hbWU+IHByb3AgY2FuIGJlIHNldCB0byBwcm92aWRlIGFkZGl0aW9uYWwgaGludGluZyBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtncmlkU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17c2V0R3JpZFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdmVydGljYWxCb3JkZXI9e2MgPT4gYyA+IDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIaWdobGlnaHRDZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgTGF5b3V0SW50ZWdyYXRpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAwLCB0cnVlLCB0cnVlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxTdHlsZT5cbiAgICAgICAgICAgIDxoMT5MYXlvdXQgSW50ZWdyYXRpb248L2gxPlxuICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRyeWluZyB0aGUgZ3JpZCBpbiBkaWZmZXJlbnQgc2l0dWF0aW9uczwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGhlaWdodD17MjAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yIHsuLi5kZWZhdWx0UHJvcHN9IGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH0gY29sdW1ucz17Y29sc30gcm93cz17MTB9IHJvd01hcmtlcnM9XCJib3RoXCIgLz5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGhlaWdodDogXCIzMDBweFwiIH19PlxuICAgICAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTB9XG4gICAgICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleFNocmluazogMCB9fT5UaGlzIGlzIHNvbWUgdGV4dCB3aGF0IGhhcHBlbnMgaGVyZT88L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuKExheW91dEludGVncmF0aW9uIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBEcmFnU291cmNlOiBSZWFjdC5WRkM8eyBpc0RyYWdnYWJsZTogYm9vbGVhbiB8IFwiaGVhZGVyXCIgfCBcImNlbGxcIiB9PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigyMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhZyBzb3VyY2VcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmcgdGhlIDxQcm9wTmFtZT5pc0RyYWdnYWJsZTwvUHJvcE5hbWU+IHByb3AgY2FuIGFsbG93IGZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wgb3ZlciB3aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyBkcmFnZ2FibGUgaW4gdGhlIGdyaWQgdmlhIEhUTUwgZHJhZyBhbmQgZHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17KHMsIGUpID0+IHdpbmRvdy5hbGVydChgTW92ZWQgcm93ICR7c30gdG8gJHtlfWApfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9eyhzLCBlKSA9PiB3aW5kb3cuYWxlcnQoYE1vdmVkIGNvbCAke3N9IHRvICR7ZX1gKX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIFwiRHJhZyBkYXRhIGhlcmUhXCIpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJhZ1NvdXJjZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGlzRHJhZ2dhYmxlOiB7XG4gICAgICAgIGNvbnRyb2w6IHsgdHlwZTogXCJzZWxlY3RcIiwgb3B0aW9uczogW3RydWUsIGZhbHNlLCBcImNlbGxcIiwgXCJoZWFkZXJcIl0gfSxcbiAgICB9LFxufTtcbihEcmFnU291cmNlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG59O1xuKERyYWdTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUHJldmVudERpYWdvbmFsU2Nyb2xsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlByZXZlbnQgRGlhZ29uYWwgU2Nyb2xsXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBEaWFnb25hbCBzY3JvbGxpbmcgY2FuIGJlIHByZXZlbnRlZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5wcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUHJldmVudERpYWdvbmFsU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbi8vIEEgZmV3IHN1cHBvcnRlZCBtaW1lIHR5cGVzIGZvciBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMuXG5jb25zdCBTVVBQT1JURURfSU1BR0VfVFlQRVMgPSBuZXcgU2V0KFtcImltYWdlL3BuZ1wiLCBcImltYWdlL2dpZlwiLCBcImltYWdlL2JtcFwiLCBcImltYWdlL2pwZWdcIl0pO1xuXG5leHBvcnQgY29uc3QgRHJvcEV2ZW50czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbaGlnaGxpZ2h0cywgc2V0SGlnaGxpZ2h0c10gPSBSZWFjdC51c2VTdGF0ZTxEYXRhRWRpdG9yUHJvcHNbXCJoaWdobGlnaHRSZWdpb25zXCJdPihbXSk7XG5cbiAgICBjb25zdCBbbGFzdERyb3BDZWxsLCBzZXRMYXN0RHJvcENlbGxdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IG9uRHJvcCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoY2VsbDogSXRlbSwgZGF0YVRyYW5zZmVyOiBEYXRhVHJhbnNmZXIgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBmaWxlcyB9ID0gZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IHN1cHBvcnRzIG9uZSBpbWFnZSwgZm9yIHNpbXBsaWNpdHkuXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBbZmlsZV0gPSBmaWxlcztcbiAgICAgICAgICAgIGlmICghU1VQUE9SVEVEX0lNQUdFX1RZUEVTLmhhcyhmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbWdVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuXG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoXG4gICAgICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5JbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2ltZ1VybF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzZXRMYXN0RHJvcENlbGwoY2VsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtzZXRDZWxsVmFsdWVdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ092ZXJDZWxsID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjZWxsOiBJdGVtLCBkYXRhVHJhbnNmZXI6IERhdGFUcmFuc2ZlciB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IGRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIC8vIFRoaXMgb25seSBzdXBwb3J0cyBvbmUgaW1hZ2UsIGZvciBzaW1wbGljaXR5LlxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2l0ZW1dID0gaXRlbXM7XG4gICAgICAgICAgICBpZiAoIVNVUFBPUlRFRF9JTUFHRV9UWVBFUy5oYXMoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAoZ2V0Q2VsbENvbnRlbnQoY2VsbCkua2luZCA9PT0gR3JpZENlbGxLaW5kLkltYWdlKSB7XG4gICAgICAgICAgICAgICAgc2V0SGlnaGxpZ2h0cyhbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiM0NEJCMDAyMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEhpZ2hsaWdodHMoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ0xlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJEcm9wIGV2ZW50c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMgYnkgdXNpbmcgPFByb3BOYW1lPm9uRHJhZ092ZXJDZWxsPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPm9uRHJvcDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7bGFzdERyb3BDZWxsID09PSB1bmRlZmluZWQgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPk5vdGhpbmcgZHJvcHBlZCwgeWV0PC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWW91IGxhc3QgZHJvcHBlZCBpbiBjZWxsIDxQcm9wTmFtZT57SlNPTi5zdHJpbmdpZnkobGFzdERyb3BDZWxsKX08L1Byb3BOYW1lPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uRHJvcD17b25Ecm9wfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtvbkRyYWdPdmVyQ2VsbH1cbiAgICAgICAgICAgICAgICBvbkRyYWdMZWF2ZT17b25EcmFnTGVhdmV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibm9uZVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJvcEV2ZW50cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-editor/stories/packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx","webpack://./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx"],"names":[".k1txkgwh",".s11gjm00"],"mappings":"AAk3CMA,UAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA;AAkuBAC,UAAAA,WAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,0EAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,sBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,+HAAAA,CAAAA,CAAAA,kBAAAA,yBAAAA,CAAAA,CAAAA,wBAAAA,uBAAAA,CAAAA,CAAAA,gBAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,iCAAAA,CAAAA,qBAAAA,CAAAA;ACllEN,uk6JAAuk6J","sourcesContent":["/* eslint-disable sonarjs/no-identical-functions */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport * as React from \"react\";\n\nimport {\n    CellArray,\n    CompactSelection,\n    DrawHeaderCallback,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridColumnIcon,\n    GridMouseEventArgs,\n    GridSelection,\n    GroupHeaderClickedEventArgs,\n    isEditableGridCell,\n    Item,\n    Rectangle,\n} from \"../../data-grid/data-grid-types\";\nimport { DataEditor, DataEditorProps } from \"../data-editor\";\n\nimport faker from \"faker\";\nimport { styled } from \"@linaria/react\";\nimport { SimpleThemeWrapper } from \"../../stories/story-utils\";\nimport { useEventListener } from \"../../common/utils\";\nimport { IBounds, useLayer } from \"react-laag\";\nimport type { SpriteMap } from \"../../data-grid/data-grid-sprites\";\nimport type { DataEditorRef, Theme } from \"../..\";\nimport range from \"lodash/range.js\";\nimport {\n    useMockDataGenerator,\n    BeautifulWrapper,\n    Description,\n    MoreInfo,\n    PropName,\n    lossyCopyData,\n    getGridColumn,\n    GridColumnWithMockingInfo,\n    ContentCache,\n    BeautifulStyle,\n    ColumnAddButton,\n} from \"./utils\";\nimport noop from \"lodash/noop.js\";\nimport type { GetRowThemeCallback } from \"../../data-grid/data-grid-render\";\n\nexport default {\n    title: \"Glide-Data-Grid/DataEditor Demos\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    getCellsForSelection: true,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nexport const ResizableColumns: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, getCellsForSelection } = useMockDataGenerator(60);\n\n    return (\n        <BeautifulWrapper\n            title=\"Resizable columns\"\n            description={\n                <>\n                    <Description>\n                        You can resize columns by dragging their edges, as long as you respond to the{\" \"}\n                        <PropName>onColumnResize</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        By setting the <PropName>overscrollX</PropName> property extra space can be allocated at the end\n                        of the grid to allow for easier resizing of the final column. You can highlight multiple columns\n                        to resize them all at once.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                overscrollX={200}\n                overscrollY={200}\n                maxColumnAutoWidth={500}\n                maxColumnWidth={2000}\n                rows={50}\n                onColumnResize={onColumnResize}\n                getCellsForSelection={getCellsForSelection}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ResizableColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface OverscrollProps {\n    overscrollX: number;\n    overscrollY: number;\n}\n\nexport const Overscroll: React.VFC<OverscrollProps> = p => {\n    const { overscrollX, overscrollY } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <BeautifulWrapper\n            title=\"Overscroll\"\n            description={\n                <>\n                    <Description>\n                        You can allocate extra space at the ends of the grid by setting the{\" \"}\n                        <PropName>overscrollX</PropName> and <PropName>overscrollY</PropName> props\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                overscrollX={overscrollX}\n                overscrollY={overscrollY}\n                rows={50}\n            />\n        </BeautifulWrapper>\n    );\n};\n(Overscroll as any).argTypes = {\n    overscrollX: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    overscrollY: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Overscroll as any).args = {\n    overscrollX: 200,\n    overscrollY: 200,\n};\n(Overscroll as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nfunction clearCell(cell: GridCell): GridCell {\n    switch (cell.kind) {\n        case GridCellKind.Boolean: {\n            return {\n                ...cell,\n                data: false,\n            };\n        }\n        case GridCellKind.Image: {\n            return {\n                ...cell,\n                data: [],\n                displayData: [],\n            };\n        }\n        case GridCellKind.Drilldown:\n        case GridCellKind.Bubble: {\n            return {\n                ...cell,\n                data: [],\n            };\n        }\n        case GridCellKind.Uri:\n        case GridCellKind.Markdown: {\n            return {\n                ...cell,\n                data: \"\",\n            };\n        }\n        case GridCellKind.Text: {\n            return {\n                ...cell,\n                data: \"\",\n                displayData: \"\",\n            };\n        }\n        case GridCellKind.Number: {\n            return {\n                ...cell,\n                data: 0,\n                displayData: \"\",\n            };\n        }\n    }\n    return cell;\n}\n\nexport const AddData: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        60,\n        false\n    );\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add data\"\n            description={\n                <>\n                    <Description>Data can be added by clicking on the trailing row.</Description>\n                    <MoreInfo>\n                        Keyboard is also supported, just navigate past the last row and press <KeyName>Enter</KeyName>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    sticky: true,\n                    tint: true,\n                    hint: \"New row...\",\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const RightToLeft: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, onColumnResize } = useMockDataGenerator(60, false);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        item => {\n            const [col, _row] = item;\n            if (col !== 0) return getCellContent(item);\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: \" ,   .\",\n                displayData: \" ,   .\",\n                allowWrapping: true,\n            };\n        },\n        [getCellContent]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Right \"\n            description={\n                <>\n                    <Description>The data editor automatically detects RTL in text cells and respects it.</Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContentMangled}\n                columns={cols}\n                onColumnResize={onColumnResize}\n                getCellsForSelection={true}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                onCellEdited={setCellValue}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RightToLeft as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ValidateData: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, getCellsForSelection } = useMockDataGenerator(60, false);\n\n    return (\n        <BeautifulWrapper\n            title=\"Validate data\"\n            description={\n                <>\n                    <Description>\n                        Data can be validated using the <PropName>validateCell</PropName> callback\n                    </Description>\n                    <MoreInfo>This example only allows the word &quot;Valid&quot; inside text cells.</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                onCellEdited={setCellValue}\n                rows={100}\n                validateCell={(_cell, newValue) => {\n                    if (newValue.kind !== GridCellKind.Text) return true;\n                    if (newValue.data === \"Valid\") return true;\n                    if (newValue.data.toLowerCase() === \"valid\") {\n                        return {\n                            ...newValue,\n                            data: \"Valid\",\n                            selectionRange: [0, 3],\n                        };\n                    }\n                    return false;\n                }}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ValidateData as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const FillHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        60,\n        false\n    );\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const getCellContentMangled = React.useCallback<typeof getCellContent>(\n        i => {\n            let val = getCellContent(i);\n            if (i[0] === 1 && val.kind === GridCellKind.Text) {\n                val = {\n                    ...val,\n                    readonly: true,\n                };\n            }\n\n            return val;\n        },\n        [getCellContent]\n    );\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Fill handle\"\n            description={\n                <>\n                    <Description>Fill handles can be used to downfill data with the mouse.</Description>\n                    <MoreInfo>\n                        Just click and drag, the top row will be copied down. Enable using the{\" \"}\n                        <PropName>fillHandle</PropName> prop.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContentMangled}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onPaste={true}\n                fillHandle={true}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    sticky: true,\n                    tint: true,\n                    hint: \"New row...\",\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(FillHandle as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nconst trailingRowOptionsColumnIndexesHint: Record<number, string> = {\n    2: \"Smol text\",\n    3: \"Add\",\n    5: \"New\",\n};\n\nconst trailingRowOptionsColumnIndexesIcon: Record<number, string> = {\n    2: GridColumnIcon.HeaderArray,\n    3: GridColumnIcon.HeaderEmoji,\n    5: GridColumnIcon.HeaderNumber,\n};\n\nconst trailingRowOptionsColumnIndexesTarget: Record<number, number> = {\n    2: 0,\n    3: 0,\n    5: 0,\n};\n\nconst trailingRowOptionsColumnIndexesDisabled: Record<number, boolean> = {\n    3: true,\n};\n\nconst trailingRowOptionsColumnIndexesTheme: Record<number, Partial<Theme>> = {\n    2: {\n        baseFontStyle: \"10px\",\n    },\n};\n\nexport const TrailingRowOptions: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    const columnsWithRowOptions: GridColumn[] = React.useMemo(() => {\n        return cols.map((c, idx) => ({\n            ...c,\n            trailingRowOptions: {\n                hint: trailingRowOptionsColumnIndexesHint[idx],\n                addIcon: trailingRowOptionsColumnIndexesIcon[idx],\n                targetColumn: trailingRowOptionsColumnIndexesTarget[idx],\n                disabled: trailingRowOptionsColumnIndexesDisabled[idx],\n                themeOverride: trailingRowOptionsColumnIndexesTheme[idx],\n            },\n        }));\n    }, [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Trailing row options\"\n            description={\n                <Description>\n                    You can customize the trailing row in each column by setting a{\" \"}\n                    <PropName>trailingRowOptions</PropName> in your columns.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columnsWithRowOptions}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    tint: true,\n                    sticky: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(TrailingRowOptions as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const AddDataToTop: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const onRowAppended = React.useCallback(async () => {\n        // shift all of the existing cells down\n        for (let y = numRows; y > 0; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, 0]);\n            setCellValueRaw([c, 0], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return \"top\" as const;\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add data\"\n            description={\n                <>\n                    <Description>\n                        You can return a different location to have the new row append take place.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddDataToTop as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface AddDataToMiddleProps {\n    insertIndex: number;\n}\nexport const AddDataToMiddle: React.FC<AddDataToMiddleProps> = p => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const index = p.insertIndex;\n    const onRowAppended = React.useCallback(async () => {\n        // shift rows below index down\n        for (let y = numRows; y > index; y--) {\n            for (let x = 0; x < 6; x++) {\n                setCellValueRaw([x, y], getCellContent([x, y - 1]));\n            }\n        }\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, index]);\n            setCellValueRaw([c, index], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n        return index;\n    }, [getCellContent, numRows, setCellValueRaw, index]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add data to middle\"\n            description={\n                <>\n                    <Description>\n                        You can return a different location to have the new row append take place.\n                    </Description>\n                    <MoreInfo>\n                        Note that <KeyName>insertIndex</KeyName> is zero-based while the number column on the left side\n                        of the grid is one-based, so inserting at index &quot;4&quot; creates a new row at &quot;5&quot;\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddDataToMiddle as any).args = {\n    insertIndex: 10,\n};\n(AddDataToMiddle as any).argTypes = {\n    insertIndex: {\n        control: {\n            type: \"range\",\n            min: 1,\n            max: 48,\n        },\n    },\n};\n(AddDataToMiddle as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const AppendRowHandle: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, setCellValue } = useMockDataGenerator(60, false);\n\n    const [numRows, setNumRows] = React.useState(50);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = React.useCallback(() => {\n        void ref.current?.appendRow(3);\n    }, [ref]);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        for (let c = 0; c < 6; c++) {\n            const cell = getCellContent([c, newRow]);\n            setCellValueRaw([c, newRow], clearCell(cell));\n        }\n        setNumRows(cv => cv + 1);\n    }, [getCellContent, numRows, setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"appendRow Ref\"\n            description={\n                <>\n                    <Description>\n                        Adding data can also be triggered from outside of <PropName>DataEditor</PropName>\n                    </Description>\n                    <MoreInfo>\n                        By calling <PropName>appendRow</PropName> on a <PropName>ref</PropName> to your grid, you can\n                        trigger the append elsewhere, like this <KeyName onClick={onClick}>Append</KeyName> button\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AppendRowHandle as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const SmallEditableGrid = () => {\n    const { cols, getCellContent, setCellValue } = useMockDataGenerator(6, false);\n\n    return (\n        <BeautifulWrapper\n            title=\"Editable Grid\"\n            description={\n                <Description>\n                    Data grid supports overlay editors for changing values. There are bespoke editors for numbers,\n                    strings, images, booleans, markdown, and uri.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                rowMarkers=\"both\"\n                columns={cols}\n                rows={20}\n                onCellEdited={setCellValue}\n            />\n        </BeautifulWrapper>\n    );\n};\n(SmallEditableGrid as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const OneMillionRows: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"One Million Rows\"\n            description={<Description>Data grid supports over 1 million rows. Your limit is mostly RAM.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                rowHeight={31}\n                rows={1_000_000}\n                rowMarkers=\"number\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(OneMillionRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const SillyNumbers: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"100 Million Rows\"\n            description={\n                <Description>\n                    100 million rows is silly. Once we cross about 33 million pixels in height we can no longer trust\n                    the browser to scroll accurately.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                rowHeight={31}\n                rows={100_000_000}\n                rowMarkers=\"number\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(SillyNumbers as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ObserveVisibleRegion: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    const [visibleRegion, setVisibleRegion] = React.useState<Rectangle>({ x: 0, y: 0, width: 0, height: 0 });\n\n    return (\n        <BeautifulWrapper\n            title=\"Observe Visible Region\"\n            description={\n                <>\n                    <Description>\n                        The visible region can be observed using <PropName>onVisibleRegionChanged</PropName>\n                    </Description>\n                    <MoreInfo>\n                        Then current visible region is x:<KeyName>{visibleRegion.x}</KeyName> y:\n                        <KeyName>{visibleRegion.y}</KeyName> width:\n                        <KeyName>{visibleRegion.width}</KeyName> height:<KeyName>{visibleRegion.height}</KeyName>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n                onVisibleRegionChanged={setVisibleRegion}\n            />\n        </BeautifulWrapper>\n    );\n};\n(OneMillionRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const OneHundredThousandCols: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100_000);\n\n    return (\n        <BeautifulWrapper\n            title=\"One Hundred Thousand Columns\"\n            description={\n                <Description>\n                    Data grid supports way more columns than you will ever need. Also this is rendering 10 million cells\n                    but that&apos;s not important.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellsForSelection={getCellsForSelection}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(OneHundredThousandCols as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const TenMillionCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100);\n\n    return (\n        <BeautifulWrapper\n            title=\"Ten Million Cells\"\n            description={<Description>Data grid supports over 10 million cells. Go nuts with it.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"number\"\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={100_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(TenMillionCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface SmoothScrollingGridProps {\n    smoothScrollX: boolean;\n    smoothScrollY: boolean;\n}\n\nexport const SmoothScrollingGrid: React.FC<SmoothScrollingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <BeautifulWrapper\n            title=\"Smooth scrolling\"\n            description={\n                <Description>\n                    You can enable smooth scrolling with the <PropName>smoothScrollX</PropName> and{\" \"}\n                    <PropName>smoothScrollY</PropName> props. Disabling smooth scrolling can dramatically increase\n                    performance and improve visual stability during rapid scrolling.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(SmoothScrollingGrid as any).args = {\n    smoothScrollX: false,\n    smoothScrollY: false,\n};\n(SmoothScrollingGrid as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\ninterface InputBlendingGridProps {\n    rangeBlending: \"mixed\" | \"exclusive\";\n    columnBlending: \"mixed\" | \"exclusive\";\n    rowBlending: \"mixed\" | \"exclusive\";\n    rangeMultiSelect: \"none\" | \"cell\" | \"rect\" | \"multi-cell\" | \"multi-rect\";\n    columnMultiSelect: \"none\" | \"single\" | \"multi\";\n    rowMultiSelect: \"none\" | \"single\" | \"multi\";\n}\n\nexport const InputBlending: React.FC<InputBlendingGridProps> = p => {\n    const { cols, getCellContent } = useMockDataGenerator(30);\n\n    return (\n        <BeautifulWrapper\n            title=\"Input blending\"\n            description={\n                <Description>\n                    Input blending can be enabled or disable between row, column, and range selections. Multi-selections\n                    can also be enabled or disabled with the same level of granularity.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={p.rowMultiSelect === \"none\" ? \"number\" : \"both\"}\n                keybindings={{\n                    clear: true,\n                    copy: true,\n                    downFill: true,\n                    rightFill: true,\n                    pageDown: true,\n                    pageUp: true,\n                    paste: true,\n                    search: true,\n                    selectAll: true,\n                    selectColumn: true,\n                    selectRow: true,\n                }}\n                getCellsForSelection={true}\n                rangeSelect={p.rangeMultiSelect}\n                columnSelect={p.columnMultiSelect}\n                rowSelect={p.rowMultiSelect}\n                rangeSelectionBlending={p.rangeBlending}\n                columnSelectionBlending={p.columnBlending}\n                rowSelectionBlending={p.rowBlending}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(InputBlending as any).args = {\n    rangeBlending: \"mixed\",\n    columnBlending: \"mixed\",\n    rowBlending: \"mixed\",\n    rangeMultiSelect: \"rect\",\n    columnMultiSelect: \"multi\",\n    rowMultiSelect: \"multi\",\n};\n(InputBlending as any).argTypes = {\n    rangeBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    columnBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rowBlending: {\n        control: { type: \"select\", options: [\"mixed\", \"exclusive\"] },\n    },\n    rangeMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"cell\", \"rect\", \"multi-cell\", \"multi-rect\"] },\n    },\n    columnMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n    rowMultiSelect: {\n        control: { type: \"select\", options: [\"none\", \"single\", \"multi\"] },\n    },\n};\n(InputBlending as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\ninterface AddColumnsProps {\n    columnsCount: number;\n}\n\nexport const AddColumns: React.FC<AddColumnsProps> = p => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(p.columnsCount);\n\n    return (\n        <BeautifulWrapper\n            title=\"Add and remove columns\"\n            description={\n                <>\n                    <Description>You can add and remove columns at your disposal</Description>\n                    <MoreInfo>Use the story&apos;s controls to change the number of columns</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"number\"\n                getCellsForSelection={getCellsForSelection}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AddColumns as any).args = {\n    columnsCount: 10,\n};\n(AddColumns as any).argTypes = {\n    columnsCount: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n(AddColumns as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const ScrollShadows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    const onSelectionChange = React.useCallback((newSel: GridSelection) => {\n        let newRows = CompactSelection.empty();\n        if (newSel.current !== undefined) {\n            newRows = newRows.add([newSel.current.range.y, newSel.current.range.y + newSel.current.range.height]);\n        }\n        for (const b of newSel.current?.rangeStack ?? []) {\n            newRows = newRows.add([b.y, b.y + b.height]);\n        }\n        setSelection({\n            ...newSel,\n            rows: newRows,\n        });\n    }, []);\n\n    const theme = React.useMemo<Partial<Theme>>(\n        () => ({\n            accentLight: \"#b1f6ff\",\n            horizontalBorderColor: \"transparent\",\n            headerBottomBorderColor: \"rgba(115, 116, 131, 0.16)\",\n        }),\n        []\n    );\n\n    const getRowThemeOverride = React.useCallback(row => (row % 2 === 0 ? undefined : { bgCell: \"#f5f5f6\" }), []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Automatic Row Markers\"\n            description={\n                <>\n                    <Description>You can enable and disable the horizontal/vertical scroll shadows.</Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={\"number\"}\n                gridSelection={selection}\n                onGridSelectionChange={onSelectionChange}\n                fixedShadowX={false}\n                headerHeight={26}\n                drawFocusRing={false}\n                rowHeight={22}\n                fixedShadowY={false}\n                getRowThemeOverride={getRowThemeOverride}\n                verticalBorder={false}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n                theme={theme}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ScrollShadows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const AutomaticRowMarkers: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Automatic Row Markers\"\n            description={\n                <>\n                    <Description>\n                        You can enable row markers with rich selection behavior using the{\" \"}\n                        <PropName>rowMarkers</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        Use <KeyName></KeyName> + click to make range selections, and <KeyName>Ctrl</KeyName> (\n                        <KeyName></KeyName> on Mac) + click to add/remove individual rows.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={\"both\"}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AutomaticRowMarkers as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const WrappingText: React.VFC<{\n    alignment: \"left\" | \"center\" | \"right\";\n    length: number;\n    hyperWrapping: boolean;\n}> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(6);\n\n    const suffix = React.useMemo(() => {\n        return range(0, 100).map(() => faker.lorem.sentence(p.length));\n    }, [p.length]);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        i => {\n            const [col, row] = i;\n\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    displayData: `${row},\\n${suffix[row % suffix.length]}`,\n                    data: `${row}, ${suffix}`,\n                    allowWrapping: true,\n                    contentAlign: p.alignment,\n                };\n            }\n            return getCellContent(i);\n        },\n        [getCellContent, p.alignment, suffix]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Wrapping Text\"\n            description={\n                <Description>\n                    Text cells can have wrapping text by setting the <PropName>allowWrapping</PropName> prop to true.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowHeight={80}\n                getCellContent={mangledGetCellContent}\n                columns={cols}\n                rows={1000}\n                onColumnResize={onColumnResize}\n                experimental={{\n                    hyperWrapping: p.hyperWrapping,\n                }}\n            />\n        </BeautifulWrapper>\n    );\n};\n(WrappingText as any).args = {\n    alignment: \"left\",\n    length: 20,\n    hyperWrapping: false,\n};\n(WrappingText as any).argTypes = {\n    alignment: {\n        control: { type: \"select\", options: [\"left\", \"center\", \"right\"] },\n    },\n    length: {\n        control: {\n            type: \"range\",\n            min: 2,\n            max: 200,\n        },\n    },\n};\n(WrappingText as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const UnevenRows: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Uneven Rows\"\n            description={\n                <Description>\n                    Rows can be made uneven by passing a callback to the <PropName>rowHeight</PropName> prop\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowHeight={r => (r % 3 === 0 ? 30 : r % 2 ? 50 : 60)}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UnevenRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const DrawCustomCells: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Draw custom cells\"\n            description={\n                <Description>\n                    You can draw custom cell contents however you want using the <PropName>drawCustomCell</PropName>{\" \"}\n                    prop\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                drawCell={args => {\n                    const { cell, rect, ctx } = args;\n                    if (cell.kind !== GridCellKind.Text) return false;\n\n                    const hasX = cell.displayData.toLowerCase().includes(\"x\"); // all my x's live in texas\n\n                    ctx.save();\n                    const { x, y, width, height } = rect;\n                    const data = cell.displayData;\n\n                    ctx.fillStyle = hasX ? \"#bfffcd\" : \"#ffe6e6\";\n                    ctx.fillRect(x + 1, y + 1, width - 1, height - 1);\n\n                    ctx.fillStyle = hasX ? \"#0fc035\" : \"#e01e1e\";\n                    ctx.font = \"bold 14px sans-serif\";\n                    ctx.fillText(data, x + 8 + 0.5, y + height / 2 + 4.5);\n                    ctx.restore();\n\n                    return true;\n                }}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(DrawCustomCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const RearrangeColumns: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(60);\n\n    // This is a dirty hack because the mock generator doesn't really support changing this. In a real data source\n    // you should track indexes properly\n    const [sortableCols, setSortableCols] = React.useState(cols);\n\n    const onColMoved = React.useCallback((startIndex: number, endIndex: number): void => {\n        setSortableCols(old => {\n            const newCols = [...old];\n            const [toMove] = newCols.splice(startIndex, 1);\n            newCols.splice(endIndex, 0, toMove);\n            return newCols;\n        });\n    }, []);\n\n    const getCellContentMangled = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            const remappedCol = cols.findIndex(c => c.title === sortableCols[col].title);\n            return getCellContent([remappedCol, row]);\n        },\n        [cols, getCellContent, sortableCols]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Rearrange Columns\"\n            description={\n                <Description>\n                    Columns can be rearranged by drag and dropping, as long as you respond to the{\" \"}\n                    <PropName>onColumnMoved</PropName> callback.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                freezeColumns={1}\n                rowMarkers=\"both\"\n                getCellContent={getCellContentMangled}\n                getCellsForSelection={getCellsForSelection}\n                columns={sortableCols}\n                onColumnMoved={onColMoved}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RearrangeColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface RowAndHeaderSizesProps {\n    rowHeight: number;\n    headerHeight: number;\n}\nexport const RowAndHeaderSizes: React.VFC<RowAndHeaderSizesProps> = p => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(6);\n\n    return (\n        <BeautifulWrapper\n            title=\"Row and Header sizes\"\n            description={\n                <>\n                    <Description>\n                        The row size can be controlled with <PropName>rowHeight</PropName> and the header size with{\" \"}\n                        <PropName>headerHeight</PropName>.\n                    </Description>\n                    <MoreInfo>Use the story&apos;s controls to resize them</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowHeight={p.rowHeight}\n                headerHeight={p.headerHeight}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"number\"}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RowAndHeaderSizes as any).args = {\n    rowHeight: 34,\n    headerHeight: 34,\n};\n(RowAndHeaderSizes as any).argTypes = {\n    rowHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n    headerHeight: {\n        control: {\n            type: \"range\",\n            min: 20,\n            max: 200,\n        },\n    },\n};\n(RowAndHeaderSizes as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nconst KeyName = styled.kbd`\n    background-color: #f4f4f4;\n    color: #2b2b2b;\n    padding: 2px 6px;\n    font-family: monospace;\n    font-size: 14px;\n    border-radius: 4px;\n    box-shadow: 0px 1px 2px #00000040;\n    margin: 0 0.1em;\n`;\n\nexport const MultiSelectColumns: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\n\n    return (\n        <BeautifulWrapper\n            title=\"Multi select columns\"\n            description={\n                <>\n                    <Description>\n                        You can select multiple columns by using the <PropName>selectedColumns</PropName> and{\" \"}\n                        <PropName>onSelectedColumnsChange</PropName> props\n                    </Description>\n                    <MoreInfo>\n                        Here you can multi select columns by using <KeyName>Ctrl</KeyName> (on Windows) or{\" \"}\n                        <KeyName></KeyName> (on Mac)\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers=\"both\"\n                columns={cols}\n                rows={100_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(MultiSelectColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nfunction getColumnsForCellTypes(): GridColumnWithMockingInfo[] {\n    return [\n        {\n            title: \"Row ID\",\n            width: 120,\n            icon: GridColumnIcon.HeaderRowID,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.RowID,\n                    data: faker.datatype.uuid(),\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Protected\",\n            width: 120,\n            icon: GridColumnIcon.HeaderCode,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Protected,\n                    data: faker.finance.bitcoinAddress(),\n                    allowOverlay: false,\n                };\n            },\n        },\n        {\n            title: \"Loading\",\n            width: 120,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Loading,\n                    allowOverlay: false,\n                };\n            },\n        },\n        {\n            title: \"Text\",\n            width: 120,\n            icon: GridColumnIcon.HeaderCode,\n            hasMenu: false,\n            getContent: () => {\n                const name = faker.name.firstName();\n                return {\n                    kind: GridCellKind.Text,\n                    data: name,\n                    displayData: name,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Number\",\n            width: 120,\n            icon: GridColumnIcon.HeaderNumber,\n            hasMenu: false,\n            getContent: () => {\n                const age = faker.datatype.number(100);\n                return {\n                    kind: GridCellKind.Number,\n                    data: age,\n                    displayData: `${age}`,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Boolean\",\n            width: 120,\n            icon: GridColumnIcon.HeaderBoolean,\n            hasMenu: false,\n            getContent: () => {\n                const roll = Math.random();\n                const checked = roll < 0.1 ? undefined : roll < 0.2 ? null : roll < 0.6;\n                // TODO: Make editable. UX looks bad by default.\n                return {\n                    kind: GridCellKind.Boolean,\n                    data: checked,\n                    allowOverlay: false,\n                    readonly: false,\n                };\n            },\n        },\n        {\n            title: \"Image\",\n            width: 120,\n            icon: GridColumnIcon.HeaderImage,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Image,\n                    data: [`${faker.image.animals(40, 40)}?random=${faker.datatype.number(100_000)}`],\n                    allowOverlay: true,\n                    allowAdd: false,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Uri\",\n            width: 120,\n            icon: GridColumnIcon.HeaderUri,\n            hasMenu: false,\n            getContent: () => {\n                const url = faker.internet.url();\n                return {\n                    kind: GridCellKind.Uri,\n                    data: url,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Markdown\",\n            width: 120,\n            icon: GridColumnIcon.HeaderMarkdown,\n            hasMenu: false,\n            getContent: () => {\n                const markdown = `# Title\nHello my name is *${faker.name.firstName()}*\n\n## TODO:\nTry out [Glide](https://www.glideapps.com/)\n`;\n                return {\n                    kind: GridCellKind.Markdown,\n                    data: markdown,\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Bubble\",\n            width: 120,\n            icon: GridColumnIcon.HeaderArray,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Bubble,\n                    data: [faker.lorem.word(), faker.lorem.word(), faker.lorem.word()],\n                    allowOverlay: true,\n                };\n            },\n        },\n        {\n            title: \"Drilldown\",\n            width: 120,\n            icon: GridColumnIcon.HeaderArray,\n            hasMenu: false,\n            getContent: () => {\n                return {\n                    kind: GridCellKind.Drilldown,\n                    data: [\n                        {\n                            text: faker.address.cityName(),\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\n                        },\n                        {\n                            text: faker.address.cityName(),\n                            img: `${faker.image.nature(40, 40)}?random=${faker.datatype.number(100_000)}`,\n                        },\n                    ],\n                    allowOverlay: true,\n                };\n            },\n        },\n    ];\n}\n\nfunction useAllMockedKinds() {\n    const cache = React.useRef<ContentCache>(new ContentCache());\n\n    const [colsMap, setColsMap] = React.useState(getColumnsForCellTypes);\n\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\n        setColsMap(prevColsMap => {\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\n            const newArray = [...prevColsMap];\n            newArray.splice(index, 1, {\n                ...prevColsMap[index],\n                width: newSize,\n            });\n            return newArray;\n        });\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return colsMap.map(getGridColumn);\n    }, [colsMap]);\n\n    const [updateVersion, setUpdateVersion] = React.useState(0);\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            // Terrible hack to force update when setCellValue requests it\n            noop(updateVersion);\n            let val = cache.current.get(col, row);\n            if (val === undefined) {\n                val = colsMap[col].getContent();\n                cache.current.set(col, row, val);\n            }\n\n            return val;\n        },\n        [colsMap, updateVersion]\n    );\n\n    const setCellValue = React.useCallback(\n        ([col, row]: Item, val: GridCell, noDisplay?: boolean, forceUpdate?: boolean): void => {\n            let current = cache.current.get(col, row);\n            if (current === undefined) {\n                current = colsMap[col].getContent();\n            }\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\n                const copied = lossyCopyData(val, current);\n                cache.current.set(col, row, {\n                    ...copied,\n                    displayData: noDisplay === true ? undefined : copied.data?.toString() ?? \"\",\n                } as any);\n\n                if (forceUpdate === true) {\n                    setUpdateVersion(v => v + 1);\n                }\n            }\n        },\n        [colsMap]\n    );\n\n    return { cols, getCellContent, onColumnResize, setCellValue };\n}\n\nexport const AllCellKinds: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    return (\n        <BeautifulWrapper\n            title=\"Lotsa cell kinds\"\n            description={\n                <Description>\n                    Data grid supports plenty cell kinds. Anything under <PropName>GridCellKind</PropName>.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                highlightRegions={[\n                    {\n                        color: \"#ff00ff33\",\n                        range: {\n                            x: 1,\n                            y: 1,\n                            width: 3,\n                            height: 3,\n                        },\n                    },\n                ]}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(AllCellKinds as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nconst darkTheme = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"#b8b8b8\",\n    textLight: \"#a0a0a0\",\n    textBubble: \"#ffffff\",\n\n    bgIconHeader: \"#b8b8b8\",\n    fgIconHeader: \"#000000\",\n    textHeader: \"#a1a1a1\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#16161b\",\n    bgCellMedium: \"#202027\",\n    bgHeader: \"#212121\",\n    bgHeaderHasFocus: \"#474747\",\n    bgHeaderHovered: \"#404040\",\n\n    bgBubble: \"#212121\",\n    bgBubbleSelected: \"#000000\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"rgba(225,225,225,0.2)\",\n    drilldownBorder: \"rgba(225,225,225,0.4)\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst hotdogStand = {\n    accentColor: \"#8c96ff\",\n    accentLight: \"rgba(202, 206, 255, 0.253)\",\n\n    textDark: \"#ffffff\",\n    textMedium: \"rgba(255, 255, 255, 0.9)\",\n    textLight: \"rgba(255, 255, 255, 0.7)\",\n    textBubble: \"#000000\",\n\n    bgIconHeader: \"#880000\",\n    fgIconHeader: \"#ff5555\",\n    textHeader: \"rgba(0, 0, 0, 0.9)\",\n    textHeaderSelected: \"#000000\",\n\n    bgCell: \"#ff0000\",\n    bgCellMedium: \"#ff4d4d\",\n    bgHeader: \"#f3f300\",\n    bgHeaderHasFocus: \"#eeee00\",\n    bgHeaderHovered: \"#e0e000\",\n\n    bgBubble: \"#ffff00\",\n    bgBubbleSelected: \"#ffff00\",\n\n    bgSearchResult: \"#423c24\",\n\n    borderColor: \"#ffff00\",\n    drilldownBorder: \"#ffff00\",\n\n    linkColor: \"#4F5DFF\",\n\n    headerFontStyle: \"bold 14px\",\n    baseFontStyle: \"13px\",\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nexport const ThemeSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [theme, setTheme] = React.useState<Partial<Theme>>({});\n\n    const [numRows, setNumRows] = React.useState(1000);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme support\"\n            description={\n                <>\n                    <Description>\n                        DataGrid respects the theme provided by the <PropName>theme</PropName> prop.\n                    </Description>\n                    <MoreInfo>\n                        <button onClick={() => setTheme({})}>Light</button> or{\" \"}\n                        <button onClick={() => setTheme(darkTheme)}>Dark</button> even{\" \"}\n                        <button onClick={() => setTheme(hotdogStand)}>Hotdog Stand</button>\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                theme={theme}\n                getCellContent={getCellContent}\n                columns={cols}\n                onRowAppended={onRowAppended}\n                trailingRowOptions={{\n                    tint: true,\n                    sticky: true,\n                }}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={numRows}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ThemeSupport as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ThemePerColumn: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[4] = {\n            ...c[4],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n                baseFontStyle: \"600 13px\",\n            },\n        };\n        c[9] = {\n            ...c[9],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        c[10] = {\n            ...c[10],\n            themeOverride: {\n                textDark: \"#009CA6\",\n                bgIconHeader: \"#009CA6\",\n                accentColor: \"#009CA6\",\n                accentLight: \"#009CA620\",\n                fgIconHeader: \"#FFFFFF\",\n            },\n        };\n        return c;\n    }, [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme per column\"\n            description={\n                <>\n                    <Description>Each column can provide theme overrides for rendering that column.</Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={realCols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ThemePerColumn as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ThemePerRow: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(5);\n\n    return (\n        <BeautifulWrapper\n            title=\"Theme per row\"\n            description={\n                <>\n                    <Description>\n                        Each row can provide theme overrides for rendering that row using the{\" \"}\n                        <PropName>getRowThemeOverride</PropName> callback.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                trailingRowOptions={{\n                    sticky: true,\n                    tint: true,\n                }}\n                onRowAppended={() => undefined}\n                getCellsForSelection={getCellsForSelection}\n                getRowThemeOverride={i =>\n                    i % 2 === 0\n                        ? undefined\n                        : {\n                              bgCell: \"#f0f8ff\",\n                              borderColor: \"#3f90e0\",\n                          }\n                }\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1_000_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ThemePerRow as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CellActivatedEvent: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [lastActivated, setLastActivated] = React.useState<Item | undefined>(undefined);\n\n    const onCellActivated = React.useCallback((cell: Item) => {\n        setLastActivated(cell);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Cell Activated event\"\n            description={\n                <>\n                    <Description>\n                        When you tap <KeyName>Enter</KeyName>, <KeyName>Space</KeyName> or double click a cell, that\n                        cell is activated. You can track this with <PropName>onCellActivated</PropName>.\n                    </Description>\n                    <MoreInfo>\n                        Last activated cell:{\" \"}\n                        {lastActivated === undefined ? \"none\" : `(${lastActivated[0]}, ${lastActivated[1]})`}\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={true}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                onCellActivated={onCellActivated}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CellActivatedEvent as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const BuiltInSearch: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [showSearch, setShowSearch] = React.useState(false);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        rows: CompactSelection.empty(),\n        columns: CompactSelection.empty(),\n    });\n\n    useEventListener(\n        \"keydown\",\n        React.useCallback(event => {\n            if ((event.ctrlKey || event.metaKey) && event.code === \"KeyF\") {\n                setShowSearch(cv => !cv);\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        }, []),\n        window,\n        false,\n        true\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Search is easy\"\n            description={\n                <>\n                    <Description>\n                        Search for any data in your grid by setting <PropName>showSearch</PropName>.\n                    </Description>\n                    <MoreInfo>\n                        In this story, <KeyName>Ctrl</KeyName> (<KeyName></KeyName> on Mac) + <KeyName>f</KeyName>{\" \"}\n                        toggles the search bar. Make sure you&apos;re focused on the Data Grid!\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                getCellsForSelection={true}\n                gridSelection={selection}\n                onGridSelectionChange={setSelection}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                showSearch={showSearch}\n                onSearchClose={() => setShowSearch(false)}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(BuiltInSearch as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface ImperativeScrollProps {\n    paddingY: number;\n    paddingX: number;\n    vAlign?: \"start\" | \"center\" | \"end\";\n    hAlign?: \"start\" | \"center\" | \"end\";\n}\n\nexport const ImperativeScroll: React.VFC<ImperativeScrollProps> = p => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const onClick = () => {\n        ref.current?.scrollTo(4, 99, \"both\", p.paddingX, p.paddingY, {\n            vAlign: p.vAlign,\n            hAlign: p.hAlign,\n        });\n    };\n\n    return (\n        <BeautifulWrapper\n            title=\"Imperative scrolling\"\n            description={\n                <>\n                    <Description>\n                        You can imperatively scroll to a cell by calling <PropName>scrollTo</PropName> on a DataEditor\n                        ref.\n                    </Description>\n                    <MoreInfo>\n                        Click <button onClick={onClick}>Here</button> to scroll to column 4 row 100\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                rowMarkers=\"clickable-number\"\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ImperativeScroll as any).args = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: \"start\",\n    hAlign: \"start\",\n};\n(ImperativeScroll as any).argTypes = {\n    paddingY: 0,\n    paddingX: 0,\n    vAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n    hAlign: {\n        control: { type: \"select\", options: [\"start\", \"center\", \"end\", undefined] },\n    },\n};\n(ImperativeScroll as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nconst SimpleMenu = styled.div`\n    width: 175px;\n    padding: 8px 0;\n    border-radius: 6px;\n    box-shadow: 0px 0px 1px rgba(62, 65, 86, 0.7), 0px 6px 12px rgba(62, 65, 86, 0.35);\n\n    display: flex;\n    flex-direction: column;\n\n    background-color: white;\n    font-size: 13px;\n    font-weight: 600;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\",\n        \"Helvetica Neue\", sans-serif;\n\n    .danger {\n        color: rgba(255, 40, 40, 0.8);\n        :hover {\n            color: rgba(255, 40, 40, 1);\n        }\n    }\n\n    > div {\n        padding: 6px 8px;\n        color: rgba(0, 0, 0, 0.7);\n        :hover {\n            background-color: rgba(0, 0, 0, 0.05);\n            color: rgba(0, 0, 0, 0.9);\n        }\n        transition: background-color 100ms;\n        cursor: pointer;\n    }\n`;\n\nexport const HeaderMenus: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        return cols.map(c => ({\n            ...c,\n            hasMenu: true,\n        }));\n    }, [cols]);\n\n    const [menu, setMenu] =\n        React.useState<{\n            col: number;\n            bounds: Rectangle;\n        }>();\n\n    const isOpen = menu !== undefined;\n\n    const { layerProps, renderLayer } = useLayer({\n        isOpen,\n        auto: true,\n        placement: \"bottom-end\",\n        triggerOffset: 2,\n        onOutsideClick: () => setMenu(undefined),\n        trigger: {\n            getBounds: () => ({\n                left: menu?.bounds.x ?? 0,\n                top: menu?.bounds.y ?? 0,\n                width: menu?.bounds.width ?? 0,\n                height: menu?.bounds.height ?? 0,\n                right: (menu?.bounds.x ?? 0) + (menu?.bounds.width ?? 0),\n                bottom: (menu?.bounds.y ?? 0) + (menu?.bounds.height ?? 0),\n            }),\n        },\n    });\n\n    const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {\n        setMenu({ col, bounds });\n    }, []);\n\n    const onHeaderClicked = React.useCallback(() => {\n        // eslint-disable-next-line no-console\n        console.log(\"Header clicked\");\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Header menus\"\n            description={\n                <>\n                    <Description>\n                        Headers on the data grid can be configured to support menus. We provide the events and the\n                        triangle, you provide the menu.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                onHeaderMenuClick={onHeaderMenuClick}\n                onHeaderClicked={onHeaderClicked}\n                columns={realCols}\n                onCellContextMenu={(_, e) => e.preventDefault()}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n            />\n            {isOpen &&\n                renderLayer(\n                    <SimpleMenu {...layerProps}>\n                        <div onClick={() => setMenu(undefined)}>These do nothing</div>\n                        <div onClick={() => setMenu(undefined)}>Add column right</div>\n                        <div onClick={() => setMenu(undefined)}>Add column left</div>\n                        <div className=\"danger\" onClick={() => setMenu(undefined)}>\n                            Delete\n                        </div>\n                    </SimpleMenu>\n                )}\n        </BeautifulWrapper>\n    );\n};\n(HeaderMenus as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CustomHeaderIcons: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const realCols = React.useMemo(() => {\n        const c = [...cols];\n        c[3] = {\n            ...c[3],\n            title: \"CUSTOM ICON\",\n            icon: \"custom\",\n            width: 200,\n        };\n        return c;\n    }, [cols]);\n\n    const headerIcons = React.useMemo<SpriteMap>(() => {\n        return {\n            custom: p => `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <rect x=\"2.00015\" y=\"2\" width=\"16\" height=\"16\" rx=\"4\" fill=\"${p.bgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.69759 6.00977C4.23735 6.00977 3.86426 6.38286 3.86426 6.8431C3.86426 7.30334 4.23735 7.67643 4.69759 7.67643H8.86426C9.3245 7.67643 9.69759 7.30334 9.69759 6.8431C9.69759 6.38286 9.32449 6.00977 8.86426 6.00977H4.69759Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.61426 4.76009C7.61426 4.29985 7.24116 3.92676 6.78092 3.92676C6.32069 3.92676 5.94759 4.29985 5.94759 4.76009L5.94759 8.92676C5.94759 9.387 6.32069 9.76009 6.78092 9.76009C7.24116 9.76009 7.61426 9.38699 7.61426 8.92676L7.61426 4.76009Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M11.0336 6.00977C10.5734 6.00977 10.2003 6.38286 10.2003 6.8431C10.2003 7.30334 10.5734 7.67643 11.0336 7.67643H15.2003C15.6605 7.67643 16.0336 7.30334 16.0336 6.8431C16.0336 6.38286 15.6605 6.00977 15.2003 6.00977H11.0336Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.89704 10.9916C5.5716 10.6662 5.04397 10.6662 4.71853 10.9916C4.39309 11.317 4.39309 11.8447 4.71853 12.1701L7.66481 15.1164C7.99024 15.4418 8.51788 15.4418 8.84332 15.1164C9.16876 14.791 9.16876 14.2633 8.84332 13.9379L5.89704 10.9916Z\" fill=\"${p.fgColor}\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.84332 12.1703C9.16875 11.8449 9.16875 11.3172 8.84332 10.9918C8.51788 10.6664 7.99024 10.6664 7.6648 10.9918L4.71853 13.9381C4.39309 14.2635 4.39309 14.7912 4.71853 15.1166C5.04396 15.442 5.5716 15.442 5.89704 15.1166L8.84332 12.1703Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 11.804C10.2003 11.3438 10.5734 10.9707 11.0336 10.9707H15.2003C15.6605 10.9707 16.0336 11.3438 16.0336 11.804C16.0336 12.2643 15.6605 12.6374 15.2003 12.6374H11.0336C10.5734 12.6374 10.2003 12.2643 10.2003 11.804Z\" fill=\"${p.fgColor}\"/>\n                <path d=\"M10.2003 14.304C10.2003 13.8438 10.5734 13.4707 11.0336 13.4707H15.2003C15.6605 13.4707 16.0336 13.8438 16.0336 14.304C16.0336 14.7643 15.6605 15.1374 15.2003 15.1374H11.0336C10.5734 15.1374 10.2003 14.7643 10.2003 14.304Z\" fill=\"${p.fgColor}\"/>\n            </svg>`,\n        };\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Custom header icons\"\n            description={\n                <>\n                    <Description>\n                        You can provide overrides for the default icons by passing the <PropName>headerIcons</PropName>{\" \"}\n                        prop.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={realCols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                headerIcons={headerIcons}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomHeaderIcons as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const RightElement: React.VFC = () => {\n    const { cols, getCellContent, setCellValue, getCellsForSelection } = useMockDataGenerator(8, false);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    const [numRows, setNumRows] = React.useState(300);\n\n    const onRowAppended = React.useCallback(() => {\n        const newRow = numRows;\n        setNumRows(cv => cv + 1);\n        for (let c = 0; c < 6; c++) {\n            setCellValue([c, newRow], {\n                displayData: \"\",\n                data: \"\",\n            } as any);\n        }\n    }, [numRows, setCellValue]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Right Element\"\n            description={\n                <Description>\n                    A DOM element may be added as a trailer to the grid by using the <PropName>rightElement</PropName>{\" \"}\n                    prop.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columns}\n                getCellsForSelection={getCellsForSelection}\n                rowMarkers={\"both\"}\n                onCellEdited={setCellValue}\n                trailingRowOptions={{\n                    hint: \"New row...\",\n                    sticky: true,\n                    tint: true,\n                }}\n                rows={numRows}\n                onRowAppended={onRowAppended}\n                rightElementProps={{ sticky: true }}\n                rightElement={\n                    <div\n                        style={{\n                            height: \"100%\",\n                            padding: \"20px 20px 40px 20px\",\n                            width: 200,\n                            color: \"black\",\n                            whiteSpace: \"pre-wrap\",\n                            backgroundColor: \"rgba(240, 240, 250, 0.2)\",\n                            display: \"flex\",\n                            justifyContent: \"center\",\n                            alignItems: \"center\",\n                            boxShadow: \"0 0 10px rgba(0, 0, 0, 0.15)\",\n                            backdropFilter: \"blur(12px)\",\n                        }}>\n                        This is a real DOM element. You can put whatever you want here. You can also size it as big as\n                        you want. {\"\\n\\n\"}It also does not have to be sticky.\n                    </div>\n                }\n            />\n        </BeautifulWrapper>\n    );\n};\n(RightElement as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nlet num: number = 1;\nfunction rand(): number {\n    return (num = (num * 16_807) % 2_147_483_647);\n}\n\nexport const RapidUpdates: React.VFC = () => {\n    const { cols, getCellContent, setCellValueRaw, getCellsForSelection } = useMockDataGenerator(100);\n\n    const ref = React.useRef<DataEditorRef>(null);\n\n    const countRef = React.useRef(0);\n    const displayCountRef = React.useRef<HTMLElement>(null);\n\n    React.useEffect(() => {\n        let rafID = 0;\n\n        const sendUpdate = () => {\n            const cells: {\n                cell: Item;\n            }[] = [];\n            const now = performance.now();\n            for (let x = 0; x < 5000; x++) {\n                const col = Math.max(10, rand() % 100);\n                const row = rand() % 10_000;\n\n                setCellValueRaw([col, row], {\n                    kind: GridCellKind.Text,\n                    data: x.toString(),\n                    displayData: `${x}k`,\n                    themeOverride:\n                        x % 5 !== 0\n                            ? {\n                                  bgCell: \"#f2fff4\",\n                                  textDark: \"#00d41c\",\n                              }\n                            : {\n                                  bgCell: \"#fff6f6\",\n                                  textDark: \"#d40000\",\n                              },\n                    allowOverlay: true,\n                    lastUpdated: now,\n                });\n                cells.push({ cell: [col, row] });\n            }\n            countRef.current += 5000;\n            if (displayCountRef.current !== null) {\n                displayCountRef.current.textContent = `${countRef.current}`;\n            }\n\n            ref.current?.updateCells(cells);\n\n            rafID = window.requestAnimationFrame(sendUpdate);\n        };\n\n        sendUpdate();\n\n        return () => {\n            cancelAnimationFrame(rafID);\n        };\n    }, [setCellValueRaw]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Rapid updating\"\n            description={\n                <>\n                    <Description>\n                        Data grid can support many thousands of updates per seconds. The data grid can easily update\n                        data faster than a human can read it, more importantly the faster the data grid can update, the\n                        more time your code can spend doing more valuable work.\n                    </Description>\n                    <MoreInfo>\n                        Updates processed: <KeyName ref={displayCountRef} /> We could do this faster but we wrote a\n                        really crappy data store for this demo which is actually slowing down the data grid.\n                    </MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                ref={ref}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                rows={10_000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(RapidUpdates as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const CopySupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        10,\n        false\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Copy support\"\n            description={\n                <>\n                    <Description>\n                        Large amounts of data can be copied and customized using{\" \"}\n                        <PropName>getCellsForSelection</PropName>.\n                    </Description>\n                    <MoreInfo>The data is copied into a format ready to be pasted into Excel or Google Sheets</MoreInfo>\n                    <textarea\n                        placeholder=\"Copy something below and paste it here...\"\n                        style={{ width: \"100%\", marginBottom: 20, borderRadius: 9, minHeight: 200, padding: 10 }}\n                    />\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                rowMarkers=\"both\"\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={400}\n            />\n        </BeautifulWrapper>\n    );\n};\n(CopySupport as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const PasteSupport: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection } = useMockDataGenerator(\n        50,\n        false\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Paste support\"\n            description={\n                <>\n                    <Description>\n                        The data grid can handle paste automatically by returning true from <PropName>onPaste</PropName>\n                        . You can also return false and handle paste yourself. If paste is undefined the DataEditor will\n                        do its best to paste to the current cell.\n                    </Description>\n                    <MoreInfo>\n                        Paste supports the copy format of Google Sheets and Excel. Below is an example of data copied\n                        from excel with some escaped text.\n                    </MoreInfo>\n                    <textarea\n                        value={`Sunday\tDogs\thttps://google.com\nMonday\tCats\thttps://google.com\nTuesday\tTurtles\thttps://google.com\nWednesday\tBears\thttps://google.com\nThursday\t\"L  ions\"\thttps://google.com\nFriday\tPigs\thttps://google.com\nSaturday\t\"Turkeys and some \"\"quotes\"\" and\na new line char \"\"more quotes\"\" plus a tab  .\"\thttps://google.com`}\n                        style={{ width: \"100%\", marginBottom: 20, borderRadius: 9, minHeight: 200, padding: 10 }}\n                    />\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                rowMarkers=\"both\"\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                onPaste={true}\n                rows={400}\n            />\n        </BeautifulWrapper>\n    );\n};\n(PasteSupport as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const FreezeColumns: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\n\n    return (\n        <BeautifulWrapper\n            title=\"Freeze columns\"\n            description={\n                <Description>\n                    Columns at the start of your grid can be frozen in place by settings{\" \"}\n                    <PropName>freezeColumns</PropName> to a number greater than 0.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"both\"\n                freezeColumns={1}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                verticalBorder={c => c > 0}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(FreezeColumns as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ReorderRows: React.VFC = () => {\n    const cols = React.useMemo<GridColumn[]>(\n        () => [\n            {\n                title: \"Col A\",\n                width: 150,\n            },\n            {\n                title: \"Col B\",\n                width: 150,\n            },\n        ],\n        []\n    );\n\n    const [rowData, setRowData] = React.useState(() => {\n        return range(0, 50).map(x => [`A: ${x}`, `B: ${x}`]);\n    });\n\n    const getCellContent = React.useCallback<DataEditorProps[\"getCellContent\"]>(\n        ([col, row]) => {\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: false,\n                data: rowData[row][col],\n                displayData: rowData[row][col],\n            };\n        },\n        [rowData]\n    );\n\n    const reorderRows = React.useCallback((from: number, to: number) => {\n        setRowData(cv => {\n            const d = [...cv];\n            const removed = d.splice(from, 1);\n            d.splice(to, 0, ...removed);\n            return d;\n        });\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Reorder Rows\"\n            description={\n                <>\n                    <Description>\n                        Rows can be re-arranged by using the <PropName>onRowMoved</PropName> callback. When set the\n                        first row can be used to drag and drop.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers={\"both\"}\n                onRowMoved={reorderRows}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={50}\n            />\n        </BeautifulWrapper>\n    );\n};\n(ReorderRows as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ColumnGroups: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(20, true, true);\n\n    return (\n        <BeautifulWrapper\n            title=\"Column Grouping\"\n            description={\n                <Description>\n                    Columns in the data grid may be grouped by setting their <PropName>group</PropName> property.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                onGroupHeaderRenamed={(x, y) => window.alert(`Please rename group ${x} to ${y}`)}\n                columns={cols}\n                getCellsForSelection={getCellsForSelection}\n                rows={1000}\n                getGroupDetails={g => ({\n                    name: g,\n                    icon: g === \"\" ? undefined : GridColumnIcon.HeaderCode,\n                })}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(ColumnGroups as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const StretchColumnSize: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection, onColumnResize } = useMockDataGenerator(5, true, true);\n\n    const hasResized = React.useRef(new Set<number>());\n\n    const columns = React.useMemo(() => {\n        return cols.map((x, i) => ({ ...x, grow: hasResized.current.has(i) ? undefined : (5 + i) / 5 }));\n    }, [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"Column Grow\"\n            description={\n                <Description>\n                    Columns in the data grid may be set to grow to fill space by setting the <PropName>grow</PropName>{\" \"}\n                    prop.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columns}\n                getCellsForSelection={getCellsForSelection}\n                rows={1000}\n                onColumnResize={(col, _newSize, colIndex, newSizeWithGrow) => {\n                    hasResized.current.add(colIndex);\n                    onColumnResize(col, newSizeWithGrow);\n                }}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(StretchColumnSize as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nfunction useCollapsableColumnGroups(cols: readonly GridColumn[]) {\n    const [collapsed, setCollapsed] = React.useState<readonly string[]>([]);\n\n    const onGroupHeaderClicked = React.useCallback(\n        (colIndex: number, args: GroupHeaderClickedEventArgs) => {\n            const group = cols[colIndex].group ?? \"\";\n            setCollapsed(cv => (cv.includes(group) ? cv.filter(g => g !== group) : [...cv, group]));\n            args.preventDefault();\n        },\n        [cols]\n    );\n\n    const [selectedColumns, setSelectedColumns] = React.useState<CompactSelection>(CompactSelection.empty());\n\n    const setCols = React.useCallback((newVal: CompactSelection, trigger: string) => {\n        if (trigger === \"group\") return;\n\n        setSelectedColumns(newVal);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        return cols.map(c => {\n            if (!collapsed.includes(c.group ?? \"\"))\n                return {\n                    ...c,\n                    hasMenu: true,\n                };\n            return {\n                ...c,\n                width: 8,\n                hasMenu: true,\n            };\n        });\n    }, [collapsed, cols]);\n\n    return {\n        columns,\n        onGroupHeaderClicked,\n        selectedColumns,\n        onSelectedColumnsChange: setCols,\n    };\n}\n\nexport const ColumnGroupCollapse: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const groupHeaderArgs = useCollapsableColumnGroups(cols);\n\n    return (\n        <BeautifulWrapper\n            title=\"Group collapse\"\n            description={\n                <>\n                    <Description>\n                        Through clever usage of <PropName>onGroupHeaderClicked</PropName> you can implement group\n                        collapsing. This is a very basic version however it is possible to go much further.\n                    </Description>\n                    <MoreInfo>Cells under a certain size will not attempt to render to save some frames.</MoreInfo>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                {...groupHeaderArgs}\n                getCellContent={getCellContent}\n                groupHeaderHeight={24}\n                rows={1000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(ColumnGroupCollapse as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const Minimap: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <BeautifulWrapper\n            title=\"Minimap\"\n            description={\n                <Description>\n                    A minimap can be enabled by setting the <PropName>showMinimap</PropName> property.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                showMinimap={true}\n                rows={3000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(Minimap as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ContentAlignment: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, _row] = cell;\n            if (col === 3) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"center\",\n                };\n            }\n            if (col === 4) {\n                return {\n                    ...getCellContent(cell),\n                    contentAlign: \"right\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Content Alignment\"\n            description={\n                <Description>\n                    You can customize the content alignment by setting <PropName>contentAlign</PropName> of a cell to{\" \"}\n                    <PropName>left</PropName>, <PropName>right</PropName> or <PropName>center</PropName>.\n                </Description>\n            }>\n            <DataEditor {...defaultProps} getCellContent={mangledGetCellContent} columns={cols} rows={300} />\n        </BeautifulWrapper>\n    );\n};\n\nexport const RowHover: React.VFC = () => {\n    const { cols, getCellContent } = useAllMockedKinds();\n\n    const [hoverRow, setHoverRow] = React.useState<number | undefined>(undefined);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        const [_, row] = args.location;\n        setHoverRow(args.kind !== \"cell\" ? undefined : row);\n    }, []);\n\n    const getRowThemeOverride = React.useCallback<GetRowThemeCallback>(\n        row => {\n            if (row !== hoverRow) return undefined;\n            return {\n                bgCell: \"#f7f7f7\",\n                bgCellMedium: \"#f0f0f0\",\n            };\n        },\n        [hoverRow]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Row Hover Effect\"\n            description={\n                <Description>\n                    Through careful usage of the <PropName>onItemHovered</PropName> callback it is possible to easily\n                    create a row hover effect.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"both\"\n                onItemHovered={onItemHovered}\n                getCellContent={getCellContent}\n                getRowThemeOverride={getRowThemeOverride}\n                columns={cols}\n                rows={300}\n            />\n        </BeautifulWrapper>\n    );\n};\n\nexport const SpanCell: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(100, true, true);\n\n    const mangledGetCellContent = React.useCallback<typeof getCellContent>(\n        cell => {\n            const [col, row] = cell;\n            if (row === 6 && col >= 3 && col <= 4) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [3, 4],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            if (row === 5) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: false,\n                    data: \"Span Cell that is very long and will go past the cell limits\",\n                    span: [0, 99],\n                    displayData: \"Span Cell that is very long and will go past the cell limits\",\n                };\n            }\n            return getCellContent(cell);\n        },\n        [getCellContent]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (selection: Rectangle): CellArray => {\n            const result: GridCell[][] = [];\n\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\n                const row: GridCell[] = [];\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\n                    row.push(mangledGetCellContent([x, y]));\n                }\n                result.push(row);\n            }\n\n            return result;\n        },\n        [mangledGetCellContent]\n    );\n\n    return (\n        <BeautifulWrapper\n            title=\"Spans\"\n            description={\n                <Description>\n                    By setting the <PropName>span</PropName> of a cell you can create spans in your grid. All cells\n                    within a span must return consistent data for defined behavior.\n                    <MoreInfo>\n                        Spans will always be split if they span frozen and non-frozen columns. By default selections are\n                        always expanded to include a span. This can be disabled using the{\" \"}\n                        <PropName>spanRangeBehavior</PropName> prop.\n                    </MoreInfo>\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={mangledGetCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                freezeColumns={2}\n                rows={300}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(SpanCell as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nconst zeroBounds = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n};\n\nexport const Tooltips: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(6);\n\n    const [tooltip, setTooltip] = React.useState<{ val: string; bounds: IBounds } | undefined>();\n\n    const timeoutRef = React.useRef(0);\n\n    const onItemHovered = React.useCallback((args: GridMouseEventArgs) => {\n        if (args.kind === \"cell\") {\n            window.clearTimeout(timeoutRef.current);\n            setTooltip(undefined);\n            timeoutRef.current = window.setTimeout(() => {\n                setTooltip({\n                    val: `Tooltip for ${args.location[0]}, ${args.location[1]}`,\n                    bounds: {\n                        // translate to react-laag types\n                        left: args.bounds.x,\n                        top: args.bounds.y,\n                        width: args.bounds.width,\n                        height: args.bounds.height,\n                        right: args.bounds.x + args.bounds.width,\n                        bottom: args.bounds.y + args.bounds.height,\n                    },\n                });\n            }, 1000);\n        } else {\n            window.clearTimeout(timeoutRef.current);\n            timeoutRef.current = 0;\n            setTooltip(undefined);\n        }\n    }, []);\n\n    React.useEffect(() => () => window.clearTimeout(timeoutRef.current), []);\n\n    const isOpen = tooltip !== undefined;\n    const { renderLayer, layerProps } = useLayer({\n        isOpen,\n        triggerOffset: 4,\n        auto: true,\n        container: \"portal\",\n        trigger: {\n            getBounds: () => tooltip?.bounds ?? zeroBounds,\n        },\n    });\n\n    return (\n        <>\n            <BeautifulWrapper\n                title=\"Tooltips\"\n                className=\"double\"\n                description={\n                    <Description>\n                        Using the <PropName>onItemHovered</PropName> event makes it easy to create tooltips. This story\n                        is intentionally forced to scroll vertically so layout in scrolling documents can be confirmed.\n                    </Description>\n                }>\n                <DataEditor\n                    {...defaultProps}\n                    onItemHovered={onItemHovered}\n                    getCellContent={getCellContent}\n                    columns={cols}\n                    rows={1000}\n                />\n            </BeautifulWrapper>\n            {isOpen &&\n                renderLayer(\n                    <div\n                        {...layerProps}\n                        style={{\n                            ...layerProps.style,\n                            padding: \"8px 12px\",\n                            color: \"white\",\n                            font: \"500 13px Inter\",\n                            backgroundColor: \"rgba(0, 0, 0, 0.85)\",\n                            borderRadius: 9,\n                        }}>\n                        {tooltip.val}\n                    </div>\n                )}\n        </>\n    );\n};\n(Tooltips as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const ControlledSelection: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(30, true, true);\n\n    const [selection, setSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    return (\n        <BeautifulWrapper\n            title=\"Controlled Selection\"\n            description={\n                <Description>\n                    The selection of the grid can be controlled via <PropName>GridSelection</PropName> and{\" \"}\n                    <PropName>onGridSelectionChange</PropName>.\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={29}\n                        value={selection.current?.cell[0] ?? 0}\n                        onChange={e => {\n                            const newCol = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [newCol, cv.current?.cell[1] ?? 0],\n                                    range: {\n                                        x: newCol,\n                                        y: cv.current?.cell[1] ?? 0,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                    <input\n                        type=\"range\"\n                        min={0}\n                        max={99}\n                        value={selection.current?.cell[1] ?? 0}\n                        onChange={e => {\n                            const newRow = e.target.valueAsNumber;\n                            setSelection(cv => ({\n                                ...cv,\n                                current: {\n                                    cell: [cv.current?.cell[0] ?? 0, newRow],\n                                    range: {\n                                        x: cv.current?.cell[0] ?? 0,\n                                        y: newRow,\n                                        width: 1,\n                                        height: 1,\n                                    },\n                                    rangeStack: [],\n                                },\n                            }));\n                        }}\n                    />\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                gridSelection={selection}\n                onGridSelectionChange={setSelection}\n                columns={cols}\n                rows={100}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n\nexport const NewColumnButton: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(10, true);\n\n    const columns = React.useMemo(() => cols.map(c => ({ ...c, grow: 1 })), [cols]);\n\n    return (\n        <BeautifulWrapper\n            title=\"New column button\"\n            description={\n                <Description>\n                    A new column button can be created using the <PropName>rightElement</PropName>.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={columns}\n                rightElement={\n                    <ColumnAddButton>\n                        <button onClick={() => window.alert(\"Add a column!\")}>+</button>\n                    </ColumnAddButton>\n                }\n                rightElementProps={{\n                    fill: false,\n                    sticky: false,\n                }}\n                rows={3000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n\nexport const CustomHeader: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    const drawHeader: DrawHeaderCallback = React.useCallback(args => {\n        const { ctx, rect } = args;\n        ctx.rect(rect.x, rect.y, rect.width, rect.height);\n        const lg = ctx.createLinearGradient(0, rect.y, 0, rect.y + rect.height);\n        lg.addColorStop(0, \"#ff00d934\");\n        lg.addColorStop(1, \"#00a2ff34\");\n        ctx.fillStyle = lg;\n        ctx.fill();\n        return false;\n    }, []);\n\n    return (\n        <BeautifulWrapper title=\"Custom Header\" description={<Description>Make it as fancy as you like.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                drawHeader={drawHeader}\n                rows={3000}\n                rowMarkers=\"both\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(CustomHeader as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\ninterface PaddingProps {\n    paddingRight: number;\n    paddingBottom: number;\n}\n\nexport const Padding: React.VFC<PaddingProps> = p => {\n    const { paddingRight, paddingBottom } = p;\n    const { cols, getCellContent } = useMockDataGenerator(20);\n\n    return (\n        <BeautifulWrapper\n            title=\"Padding\"\n            description={\n                <>\n                    <Description>\n                        You can add padding at the ends of the grid by setting the <PropName>paddingRight</PropName> and{\" \"}\n                        <PropName>paddingBottom</PropName> props\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers={\"both\"}\n                experimental={{ paddingRight, paddingBottom }}\n                rows={50}\n            />\n        </BeautifulWrapper>\n    );\n};\n(Padding as any).argTypes = {\n    paddingRight: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n    paddingBottom: {\n        control: {\n            type: \"range\",\n            min: 0,\n            max: 600,\n        },\n    },\n};\n(Padding as any).args = {\n    paddingRight: 200,\n    paddingBottom: 200,\n};\n(Padding as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const HighlightCells: React.VFC = () => {\n    const { cols, getCellContent, getCellsForSelection } = useMockDataGenerator(100);\n\n    const [gridSelection, setGridSelection] = React.useState<GridSelection>({\n        columns: CompactSelection.empty(),\n        rows: CompactSelection.empty(),\n    });\n\n    const highlights = React.useMemo<DataEditorProps[\"highlightRegions\"]>(() => {\n        if (gridSelection.current === undefined) return undefined;\n        const [col, row] = gridSelection.current.cell;\n        return [\n            {\n                color: \"#44BB0022\",\n                range: {\n                    x: col + 2,\n                    y: row,\n                    width: 10,\n                    height: 10,\n                },\n                style: \"solid\",\n            },\n            {\n                color: \"#b000b021\",\n                range: {\n                    x: col,\n                    y: row + 2,\n                    width: 1,\n                    height: 1,\n                },\n            },\n        ];\n    }, [gridSelection]);\n\n    return (\n        <BeautifulWrapper\n            title=\"HighlightCells\"\n            description={\n                <Description>\n                    The <PropName>highlightRegions</PropName> prop can be set to provide additional hinting or context\n                    for the current selection.\n                </Description>\n            }>\n            <DataEditor\n                {...defaultProps}\n                rowMarkers=\"both\"\n                freezeColumns={1}\n                highlightRegions={highlights}\n                gridSelection={gridSelection}\n                onGridSelectionChange={setGridSelection}\n                getCellContent={getCellContent}\n                getCellsForSelection={getCellsForSelection}\n                columns={cols}\n                verticalBorder={c => c > 0}\n                rows={1000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(HighlightCells as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const LayoutIntegration: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(1000, true, true);\n\n    return (\n        <BeautifulStyle>\n            <h1>Layout Integration</h1>\n            <Description>Trying the grid in different situations</Description>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rows={10}\n                rowMarkers=\"both\"\n                height={200}\n            />\n            <DataEditor {...defaultProps} getCellContent={getCellContent} columns={cols} rows={10} rowMarkers=\"both\" />\n            <div style={{ display: \"flex\", height: \"300px\" }}>\n                <DataEditor\n                    {...defaultProps}\n                    getCellContent={getCellContent}\n                    columns={cols}\n                    rows={10}\n                    rowMarkers=\"both\"\n                />\n                <div style={{ flexShrink: 0 }}>This is some text what happens here?</div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n(LayoutIntegration as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\nexport const DragSource: React.VFC<{ isDraggable: boolean | \"header\" | \"cell\" }> = p => {\n    const { cols, getCellContent, onColumnResize } = useMockDataGenerator(200);\n\n    return (\n        <BeautifulWrapper\n            title=\"Drag source\"\n            description={\n                <>\n                    <Description>\n                        Setting the <PropName>isDraggable</PropName> prop can allow for more granular control over what\n                        is draggable in the grid via HTML drag and drop.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                rowMarkers=\"both\"\n                rows={5000}\n                onRowMoved={(s, e) => window.alert(`Moved row ${s} to ${e}`)}\n                onColumnMoved={(s, e) => window.alert(`Moved col ${s} to ${e}`)}\n                onColumnResize={onColumnResize}\n                isDraggable={p.isDraggable}\n                onDragStart={e => {\n                    e.setData(\"text/plain\", \"Drag data here!\");\n                }}\n            />\n        </BeautifulWrapper>\n    );\n};\n(DragSource as any).argTypes = {\n    isDraggable: {\n        control: { type: \"select\", options: [true, false, \"cell\", \"header\"] },\n    },\n};\n(DragSource as any).args = {\n    isDraggable: false,\n};\n(DragSource as any).parameters = {\n    options: {\n        showPanel: true,\n    },\n};\n\nexport const PreventDiagonalScroll: React.VFC = () => {\n    const { cols, getCellContent } = useMockDataGenerator(200);\n\n    return (\n        <BeautifulWrapper\n            title=\"Prevent Diagonal Scroll\"\n            description={\n                <>\n                    <Description>\n                        Diagonal scrolling can be prevented by setting <PropName>preventDiagonalScrolling</PropName>.\n                    </Description>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                preventDiagonalScrolling={true}\n                rows={5000}\n            />\n        </BeautifulWrapper>\n    );\n};\n(PreventDiagonalScroll as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n\n// A few supported mime types for drag and drop into cells.\nconst SUPPORTED_IMAGE_TYPES = new Set([\"image/png\", \"image/gif\", \"image/bmp\", \"image/jpeg\"]);\n\nexport const DropEvents: React.VFC = () => {\n    const { cols, getCellContent, onColumnResize, setCellValue } = useAllMockedKinds();\n\n    const [highlights, setHighlights] = React.useState<DataEditorProps[\"highlightRegions\"]>([]);\n\n    const [lastDropCell, setLastDropCell] = React.useState<Item | undefined>();\n\n    const onDrop = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            setHighlights([]);\n\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { files } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (files.length !== 1) {\n                return;\n            }\n\n            const [file] = files;\n            if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {\n                return;\n            }\n\n            const imgUrl = URL.createObjectURL(file);\n\n            setCellValue(\n                cell,\n                {\n                    kind: GridCellKind.Image,\n                    data: [imgUrl],\n                    allowOverlay: true,\n                    allowAdd: false,\n                },\n                true,\n                true\n            );\n\n            setLastDropCell(cell);\n        },\n        [setCellValue]\n    );\n\n    const onDragOverCell = React.useCallback(\n        (cell: Item, dataTransfer: DataTransfer | null) => {\n            if (dataTransfer === null) {\n                return;\n            }\n\n            const { items } = dataTransfer;\n            // This only supports one image, for simplicity.\n            if (items.length !== 1) {\n                return;\n            }\n\n            const [item] = items;\n            if (!SUPPORTED_IMAGE_TYPES.has(item.type)) {\n                return;\n            }\n\n            const [col, row] = cell;\n            if (getCellContent(cell).kind === GridCellKind.Image) {\n                setHighlights([\n                    {\n                        color: \"#44BB0022\",\n                        range: {\n                            x: col,\n                            y: row,\n                            width: 1,\n                            height: 1,\n                        },\n                    },\n                ]);\n            } else {\n                setHighlights([]);\n            }\n        },\n        [getCellContent]\n    );\n\n    const onDragLeave = React.useCallback(() => {\n        setHighlights([]);\n    }, []);\n\n    return (\n        <BeautifulWrapper\n            title=\"Drop events\"\n            description={\n                <>\n                    <Description>\n                        You can drag and drop into cells by using <PropName>onDragOverCell</PropName> and{\" \"}\n                        <PropName>onDrop</PropName>.\n                    </Description>\n\n                    <div>\n                        {lastDropCell === undefined ? (\n                            <MoreInfo>Nothing dropped, yet</MoreInfo>\n                        ) : (\n                            <>\n                                <MoreInfo>\n                                    You last dropped in cell <PropName>{JSON.stringify(lastDropCell)}</PropName>\n                                </MoreInfo>\n                            </>\n                        )}\n                    </div>\n                </>\n            }>\n            <DataEditor\n                {...defaultProps}\n                getCellContent={getCellContent}\n                columns={cols}\n                onCellEdited={setCellValue}\n                onColumnResize={onColumnResize}\n                rows={1000}\n                onDrop={onDrop}\n                onDragOverCell={onDragOverCell}\n                onDragLeave={onDragLeave}\n                highlightRegions={highlights}\n                rowMarkers=\"none\"\n            />\n        </BeautifulWrapper>\n    );\n};\n(DropEvents as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",".k1txkgwh{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;}\n.s11gjm00{width:175px;padding:8px 0;border-radius:6px;box-shadow:0px 0px 1px rgba(62,65,86,0.7),0px 6px 12px rgba(62,65,86,0.35);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:white;font-size:13px;font-weight:600;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Open Sans\", \"Helvetica Neue\",sans-serif;}.s11gjm00 .danger{color:rgba(255,40,40,0.8);}.s11gjm00 .danger:hover{color:rgba(255,40,40,1);}.s11gjm00 > div{padding:6px 8px;color:rgba(0,0,0,0.7);-webkit-transition:background-color 100ms;transition:background-color 100ms;cursor:pointer;}.s11gjm00 > div:hover{background-color:rgba(0,0,0,0.05);color:rgba(0,0,0,0.9);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItYmVhdXRpZnVsLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5rMXR4a2d3aCIsIi5zMTFnam0wMCJdLCJtYXBwaW5ncyI6IkFBazNDTUE7QUFrdUJBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLWJlYXV0aWZ1bC5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHNvbmFyanMvbm8taWRlbnRpY2FsLWZ1bmN0aW9ucyAqL1xuLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgICBDZWxsQXJyYXksXG4gICAgQ29tcGFjdFNlbGVjdGlvbixcbiAgICBEcmF3SGVhZGVyQ2FsbGJhY2ssXG4gICAgR3JpZENlbGwsXG4gICAgR3JpZENlbGxLaW5kLFxuICAgIEdyaWRDb2x1bW4sXG4gICAgR3JpZENvbHVtbkljb24sXG4gICAgR3JpZE1vdXNlRXZlbnRBcmdzLFxuICAgIEdyaWRTZWxlY3Rpb24sXG4gICAgR3JvdXBIZWFkZXJDbGlja2VkRXZlbnRBcmdzLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBJdGVtLFxuICAgIFJlY3RhbmdsZSxcbn0gZnJvbSBcIi4uLy4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IsIERhdGFFZGl0b3JQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IFNpbXBsZVRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsc1wiO1xuaW1wb3J0IHsgSUJvdW5kcywgdXNlTGF5ZXIgfSBmcm9tIFwicmVhY3QtbGFhZ1wiO1xuaW1wb3J0IHR5cGUgeyBTcHJpdGVNYXAgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC1zcHJpdGVzXCI7XG5pbXBvcnQgdHlwZSB7IERhdGFFZGl0b3JSZWYsIFRoZW1lIH0gZnJvbSBcIi4uLy4uXCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcImxvZGFzaC9yYW5nZS5qc1wiO1xuaW1wb3J0IHtcbiAgICB1c2VNb2NrRGF0YUdlbmVyYXRvcixcbiAgICBCZWF1dGlmdWxXcmFwcGVyLFxuICAgIERlc2NyaXB0aW9uLFxuICAgIE1vcmVJbmZvLFxuICAgIFByb3BOYW1lLFxuICAgIGxvc3N5Q29weURhdGEsXG4gICAgZ2V0R3JpZENvbHVtbixcbiAgICBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvLFxuICAgIENvbnRlbnRDYWNoZSxcbiAgICBCZWF1dGlmdWxTdHlsZSxcbiAgICBDb2x1bW5BZGRCdXR0b24sXG59IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwibG9kYXNoL25vb3AuanNcIjtcbmltcG9ydCB0eXBlIHsgR2V0Um93VGhlbWVDYWxsYmFjayB9IGZyb20gXCIuLi8uLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXJlbmRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiR2xpZGUtRGF0YS1HcmlkL0RhdGFFZGl0b3IgRGVtb3NcIixcblxuICAgIGRlY29yYXRvcnM6IFtcbiAgICAgICAgKFN0b3J5OiBSZWFjdC5Db21wb25lbnRUeXBlKSA9PiAoXG4gICAgICAgICAgICA8U2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgPC9TaW1wbGVUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb246IHRydWUsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuZXhwb3J0IGNvbnN0IFJlc2l6YWJsZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlc2l6YWJsZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIHJlc2l6ZSBjb2x1bW5zIGJ5IGRyYWdnaW5nIHRoZWlyIGVkZ2VzLCBhcyBsb25nIGFzIHlvdSByZXNwb25kIHRvIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5vbkNvbHVtblJlc2l6ZTwvUHJvcE5hbWU+IHByb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IHNldHRpbmcgdGhlIDxQcm9wTmFtZT5vdmVyc2Nyb2xsWDwvUHJvcE5hbWU+IHByb3BlcnR5IGV4dHJhIHNwYWNlIGNhbiBiZSBhbGxvY2F0ZWQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGdyaWQgdG8gYWxsb3cgZm9yIGVhc2llciByZXNpemluZyBvZiB0aGUgZmluYWwgY29sdW1uLiBZb3UgY2FuIGhpZ2hsaWdodCBtdWx0aXBsZSBjb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB0byByZXNpemUgdGhlbSBhbGwgYXQgb25jZS5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9ezIwMH1cbiAgICAgICAgICAgICAgICBvdmVyc2Nyb2xsWT17MjAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbkF1dG9XaWR0aD17NTAwfVxuICAgICAgICAgICAgICAgIG1heENvbHVtbldpZHRoPXsyMDAwfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVzaXphYmxlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgT3ZlcnNjcm9sbFByb3BzIHtcbiAgICBvdmVyc2Nyb2xsWDogbnVtYmVyO1xuICAgIG92ZXJzY3JvbGxZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBPdmVyc2Nyb2xsOiBSZWFjdC5WRkM8T3ZlcnNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgb3ZlcnNjcm9sbFgsIG92ZXJzY3JvbGxZIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk92ZXJzY3JvbGxcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWxsb2NhdGUgZXh0cmEgc3BhY2UgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b3ZlcnNjcm9sbFg8L1Byb3BOYW1lPiBhbmQgPFByb3BOYW1lPm92ZXJzY3JvbGxZPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e292ZXJzY3JvbGxYfVxuICAgICAgICAgICAgICAgIG92ZXJzY3JvbGxZPXtvdmVyc2Nyb2xsWX1cbiAgICAgICAgICAgICAgICByb3dzPXs1MH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgb3ZlcnNjcm9sbFg6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBvdmVyc2Nyb2xsWToge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDYwMCxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbihPdmVyc2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBvdmVyc2Nyb2xsWDogMjAwLFxuICAgIG92ZXJzY3JvbGxZOiAyMDAsXG59O1xuKE92ZXJzY3JvbGwgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBjbGVhckNlbGwoY2VsbDogR3JpZENlbGwpOiBHcmlkQ2VsbCB7XG4gICAgc3dpdGNoIChjZWxsLmtpbmQpIHtcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuRHJpbGxkb3duOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5CdWJibGU6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVXJpOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5NYXJrZG93bjoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlRleHQ6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5OdW1iZXI6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiAwLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbn1cblxuZXhwb3J0IGNvbnN0IEFkZERhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA2MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3Qgb25Sb3dBcHBlbmRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gbnVtUm93cztcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsQ29udGVudChbYywgbmV3Um93XSk7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWVSYXcoW2MsIG5ld1Jvd10sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgIH0sIFtnZXRDZWxsQ29udGVudCwgbnVtUm93cywgc2V0Q2VsbFZhbHVlUmF3XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPkRhdGEgY2FuIGJlIGFkZGVkIGJ5IGNsaWNraW5nIG9uIHRoZSB0cmFpbGluZyByb3cuPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgS2V5Ym9hcmQgaXMgYWxzbyBzdXBwb3J0ZWQsIGp1c3QgbmF2aWdhdGUgcGFzdCB0aGUgbGFzdCByb3cgYW5kIHByZXNzIDxLZXlOYW1lPkVudGVyPC9LZXlOYW1lPlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGREYXRhIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodFRvTGVmdDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZSwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2wsIF9yb3ddID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChjb2wgIT09IDApIHJldHVybiBnZXRDZWxsQ29udGVudChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwi15DXoNeZINeS15PXoteV158sINee15XXnteX15Qg15zXkNek15zXmden16bXmdeV16og15LXnNeZ15nXky5cIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCLXkNeg15kg15LXk9ei15XXnywg157Xldee15fXlCDXnNeQ16TXnNeZ16fXpteZ15XXqiDXktec15nXmdeTLlwiLFxuICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJpZ2h0IFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRoZSBkYXRhIGVkaXRvciBhdXRvbWF0aWNhbGx5IGRldGVjdHMgUlRMIGluIHRleHQgY2VsbHMgYW5kIHJlc3BlY3RzIGl0LjwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJpZ2h0VG9MZWZ0IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBWYWxpZGF0ZURhdGE6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVmFsaWRhdGUgZGF0YVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YSBjYW4gYmUgdmFsaWRhdGVkIHVzaW5nIHRoZSA8UHJvcE5hbWU+dmFsaWRhdGVDZWxsPC9Qcm9wTmFtZT4gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlRoaXMgZXhhbXBsZSBvbmx5IGFsbG93cyB0aGUgd29yZCAmcXVvdDtWYWxpZCZxdW90OyBpbnNpZGUgdGV4dCBjZWxscy48L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25QYXN0ZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDZWxsPXsoX2NlbGwsIG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5raW5kICE9PSBHcmlkQ2VsbEtpbmQuVGV4dCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5kYXRhID09PSBcIlZhbGlkXCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJWYWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBbMCwgM10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFZhbGlkYXRlRGF0YSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRmlsbEhhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoXG4gICAgICAgIDYwLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudE1hbmdsZWQgPSBSZWFjdC51c2VDYWxsYmFjazx0eXBlb2YgZ2V0Q2VsbENvbnRlbnQ+KFxuICAgICAgICBpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgICAgIGlmIChpWzBdID09PSAxICYmIHZhbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRmlsbCBoYW5kbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5GaWxsIGhhbmRsZXMgY2FuIGJlIHVzZWQgdG8gZG93bmZpbGwgZGF0YSB3aXRoIHRoZSBtb3VzZS48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBKdXN0IGNsaWNrIGFuZCBkcmFnLCB0aGUgdG9wIHJvdyB3aWxsIGJlIGNvcGllZCBkb3duLiBFbmFibGUgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmZpbGxIYW5kbGU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnRNYW5nbGVkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUGFzdGU9e3RydWV9XG4gICAgICAgICAgICAgICAgZmlsbEhhbmRsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihGaWxsSGFuZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNIaW50OiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAgIDI6IFwiU21vbCB0ZXh0XCIsXG4gICAgMzogXCJBZGRcIixcbiAgICA1OiBcIk5ld1wiLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0ljb246IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7XG4gICAgMjogR3JpZENvbHVtbkljb24uSGVhZGVyQXJyYXksXG4gICAgMzogR3JpZENvbHVtbkljb24uSGVhZGVyRW1vamksXG4gICAgNTogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxufTtcblxuY29uc3QgdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldDogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHtcbiAgICAyOiAwLFxuICAgIDM6IDAsXG4gICAgNTogMCxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNEaXNhYmxlZDogUmVjb3JkPG51bWJlciwgYm9vbGVhbj4gPSB7XG4gICAgMzogdHJ1ZSxcbn07XG5cbmNvbnN0IHRyYWlsaW5nUm93T3B0aW9uc0NvbHVtbkluZGV4ZXNUaGVtZTogUmVjb3JkPG51bWJlciwgUGFydGlhbDxUaGVtZT4+ID0ge1xuICAgIDI6IHtcbiAgICAgICAgYmFzZUZvbnRTdHlsZTogXCIxMHB4XCIsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBUcmFpbGluZ1Jvd09wdGlvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgY29uc3QgY29sdW1uc1dpdGhSb3dPcHRpb25zOiBHcmlkQ29sdW1uW10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKChjLCBpZHgpID0+ICh7XG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgaGludDogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc0hpbnRbaWR4XSxcbiAgICAgICAgICAgICAgICBhZGRJY29uOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzSWNvbltpZHhdLFxuICAgICAgICAgICAgICAgIHRhcmdldENvbHVtbjogdHJhaWxpbmdSb3dPcHRpb25zQ29sdW1uSW5kZXhlc1RhcmdldFtpZHhdLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzRGlzYWJsZWRbaWR4XSxcbiAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB0cmFpbGluZ1Jvd09wdGlvbnNDb2x1bW5JbmRleGVzVGhlbWVbaWR4XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9LCBbY29sc10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVHJhaWxpbmcgcm93IG9wdGlvbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBjdXN0b21pemUgdGhlIHRyYWlsaW5nIHJvdyBpbiBlYWNoIGNvbHVtbiBieSBzZXR0aW5nIGF7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT50cmFpbGluZ1Jvd09wdGlvbnM8L1Byb3BOYW1lPiBpbiB5b3VyIGNvbHVtbnMuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnNXaXRoUm93T3B0aW9uc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRyYWlsaW5nUm93T3B0aW9ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQWRkRGF0YVRvVG9wOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlUmF3LCBzZXRDZWxsVmFsdWUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYwLCBmYWxzZSk7XG5cbiAgICBjb25zdCBbbnVtUm93cywgc2V0TnVtUm93c10gPSBSZWFjdC51c2VTdGF0ZSg1MCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCBhbGwgb2YgdGhlIGV4aXN0aW5nIGNlbGxzIGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiAwOyB5LS0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFt4LCB5XSwgZ2V0Q2VsbENvbnRlbnQoW3gsIHkgLSAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIDBdKTtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbYywgMF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gXCJ0b3BcIiBhcyBjb25zdDtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQWRkIGRhdGFcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFkZERhdGFUb1RvcCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgQWRkRGF0YVRvTWlkZGxlUHJvcHMge1xuICAgIGluc2VydEluZGV4OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgQWRkRGF0YVRvTWlkZGxlOiBSZWFjdC5GQzxBZGREYXRhVG9NaWRkbGVQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIHNldENlbGxWYWx1ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNjAsIGZhbHNlKTtcblxuICAgIGNvbnN0IFtudW1Sb3dzLCBzZXROdW1Sb3dzXSA9IFJlYWN0LnVzZVN0YXRlKDUwKTtcblxuICAgIGNvbnN0IGluZGV4ID0gcC5pbnNlcnRJbmRleDtcbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBzaGlmdCByb3dzIGJlbG93IGluZGV4IGRvd25cbiAgICAgICAgZm9yIChsZXQgeSA9IG51bVJvd3M7IHkgPiBpbmRleDsgeS0tKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDY7IHgrKykge1xuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbeCwgeV0sIGdldENlbGxDb250ZW50KFt4LCB5IC0gMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDY7IGMrKykge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGdldENlbGxDb250ZW50KFtjLCBpbmRleF0pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBpbmRleF0sIGNsZWFyQ2VsbChjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TnVtUm93cyhjdiA9PiBjdiArIDEpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSwgW2dldENlbGxDb250ZW50LCBudW1Sb3dzLCBzZXRDZWxsVmFsdWVSYXcsIGluZGV4XSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBZGQgZGF0YSB0byBtaWRkbGVcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gcmV0dXJuIGEgZGlmZmVyZW50IGxvY2F0aW9uIHRvIGhhdmUgdGhlIG5ldyByb3cgYXBwZW5kIHRha2UgcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCA8S2V5TmFtZT5pbnNlcnRJbmRleDwvS2V5TmFtZT4gaXMgemVyby1iYXNlZCB3aGlsZSB0aGUgbnVtYmVyIGNvbHVtbiBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgZ3JpZCBpcyBvbmUtYmFzZWQsIHNvIGluc2VydGluZyBhdCBpbmRleCAmcXVvdDs0JnF1b3Q7IGNyZWF0ZXMgYSBuZXcgcm93IGF0ICZxdW90OzUmcXVvdDtcbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIGhpbnQ6IFwiTmV3IHJvdy4uLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpbnNlcnRJbmRleDogMTAsXG59O1xuKEFkZERhdGFUb01pZGRsZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGluc2VydEluZGV4OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMSxcbiAgICAgICAgICAgIG1heDogNDgsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG4oQWRkRGF0YVRvTWlkZGxlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEFwcGVuZFJvd0hhbmRsZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIHNldENlbGxWYWx1ZVJhdywgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCwgZmFsc2UpO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoNTApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3Qgb25DbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdm9pZCByZWYuY3VycmVudD8uYXBwZW5kUm93KDMpO1xuICAgIH0sIFtyZWZdKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2MsIG5ld1Jvd10pO1xuICAgICAgICAgICAgc2V0Q2VsbFZhbHVlUmF3KFtjLCBuZXdSb3ddLCBjbGVhckNlbGwoY2VsbCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICB9LCBbZ2V0Q2VsbENvbnRlbnQsIG51bVJvd3MsIHNldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiYXBwZW5kUm93IFJlZlwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgQWRkaW5nIGRhdGEgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGZyb20gb3V0c2lkZSBvZiA8UHJvcE5hbWU+RGF0YUVkaXRvcjwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5IGNhbGxpbmcgPFByb3BOYW1lPmFwcGVuZFJvdzwvUHJvcE5hbWU+IG9uIGEgPFByb3BOYW1lPnJlZjwvUHJvcE5hbWU+IHRvIHlvdXIgZ3JpZCwgeW91IGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlciB0aGUgYXBwZW5kIGVsc2V3aGVyZSwgbGlrZSB0aGlzIDxLZXlOYW1lIG9uQ2xpY2s9e29uQ2xpY2t9PkFwcGVuZDwvS2V5TmFtZT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIHRyYWlsaW5nUm93T3B0aW9ucz17e1xuICAgICAgICAgICAgICAgICAgICBoaW50OiBcIk5ldyByb3cuLi5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgcm93cz17bnVtUm93c31cbiAgICAgICAgICAgICAgICBvblJvd0FwcGVuZGVkPXtvblJvd0FwcGVuZGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFwcGVuZFJvd0hhbmRsZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU21hbGxFZGl0YWJsZUdyaWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJFZGl0YWJsZSBHcmlkXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBzdXBwb3J0cyBvdmVybGF5IGVkaXRvcnMgZm9yIGNoYW5naW5nIHZhbHVlcy4gVGhlcmUgYXJlIGJlc3Bva2UgZWRpdG9ycyBmb3IgbnVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncywgaW1hZ2VzLCBib29sZWFucywgbWFya2Rvd24sIGFuZCB1cmkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezIwfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNtYWxsRWRpdGFibGVHcmlkIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVNaWxsaW9uUm93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk9uZSBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5EYXRhIGdyaWQgc3VwcG9ydHMgb3ZlciAxIG1pbGxpb24gcm93cy4gWW91ciBsaW1pdCBpcyBtb3N0bHkgUkFNLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxXzAwMF8wMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oT25lTWlsbGlvblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFNpbGx5TnVtYmVyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIjEwMCBNaWxsaW9uIFJvd3NcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgMTAwIG1pbGxpb24gcm93cyBpcyBzaWxseS4gT25jZSB3ZSBjcm9zcyBhYm91dCAzMyBtaWxsaW9uIHBpeGVscyBpbiBoZWlnaHQgd2UgY2FuIG5vIGxvbmdlciB0cnVzdFxuICAgICAgICAgICAgICAgICAgICB0aGUgYnJvd3NlciB0byBzY3JvbGwgYWNjdXJhdGVseS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXszMX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDBfMDAwXzAwMH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibnVtYmVyXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTaWxseU51bWJlcnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IE9ic2VydmVWaXNpYmxlUmVnaW9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIGNvbnN0IFt2aXNpYmxlUmVnaW9uLCBzZXRWaXNpYmxlUmVnaW9uXSA9IFJlYWN0LnVzZVN0YXRlPFJlY3RhbmdsZT4oeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT2JzZXJ2ZSBWaXNpYmxlIFJlZ2lvblwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHZpc2libGUgcmVnaW9uIGNhbiBiZSBvYnNlcnZlZCB1c2luZyA8UHJvcE5hbWU+b25WaXNpYmxlUmVnaW9uQ2hhbmdlZDwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZW4gY3VycmVudCB2aXNpYmxlIHJlZ2lvbiBpcyB4OjxLZXlOYW1lPnt2aXNpYmxlUmVnaW9uLnh9PC9LZXlOYW1lPiB5OlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ueX08L0tleU5hbWU+IHdpZHRoOlxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+e3Zpc2libGVSZWdpb24ud2lkdGh9PC9LZXlOYW1lPiBoZWlnaHQ6PEtleU5hbWU+e3Zpc2libGVSZWdpb24uaGVpZ2h0fTwvS2V5TmFtZT5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPXtzZXRWaXNpYmxlUmVnaW9ufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZU1pbGxpb25Sb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBPbmVIdW5kcmVkVGhvdXNhbmRDb2xzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMF8wMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiT25lIEh1bmRyZWQgVGhvdXNhbmQgQ29sdW1uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgd2F5IG1vcmUgY29sdW1ucyB0aGFuIHlvdSB3aWxsIGV2ZXIgbmVlZC4gQWxzbyB0aGlzIGlzIHJlbmRlcmluZyAxMCBtaWxsaW9uIGNlbGxzXG4gICAgICAgICAgICAgICAgICAgIGJ1dCB0aGF0JmFwb3M7cyBub3QgaW1wb3J0YW50LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKE9uZUh1bmRyZWRUaG91c2FuZENvbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRlbk1pbGxpb25DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDEwMCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJUZW4gTWlsbGlvbiBDZWxsc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17PERlc2NyaXB0aW9uPkRhdGEgZ3JpZCBzdXBwb3J0cyBvdmVyIDEwIG1pbGxpb24gY2VsbHMuIEdvIG51dHMgd2l0aCBpdC48L0Rlc2NyaXB0aW9uPn0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihUZW5NaWxsaW9uQ2VsbHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIFNtb290aFNjcm9sbGluZ0dyaWRQcm9wcyB7XG4gICAgc21vb3RoU2Nyb2xsWDogYm9vbGVhbjtcbiAgICBzbW9vdGhTY3JvbGxZOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgU21vb3RoU2Nyb2xsaW5nR3JpZDogUmVhY3QuRkM8U21vb3RoU2Nyb2xsaW5nR3JpZFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDMwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNtb290aCBzY3JvbGxpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBlbmFibGUgc21vb3RoIHNjcm9sbGluZyB3aXRoIHRoZSA8UHJvcE5hbWU+c21vb3RoU2Nyb2xsWDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPnNtb290aFNjcm9sbFk8L1Byb3BOYW1lPiBwcm9wcy4gRGlzYWJsaW5nIHNtb290aCBzY3JvbGxpbmcgY2FuIGRyYW1hdGljYWxseSBpbmNyZWFzZVxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZSBhbmQgaW1wcm92ZSB2aXN1YWwgc3RhYmlsaXR5IGR1cmluZyByYXBpZCBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17cC5zbW9vdGhTY3JvbGxYfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3Auc21vb3RoU2Nyb2xsWX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU21vb3RoU2Nyb2xsaW5nR3JpZCBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgc21vb3RoU2Nyb2xsWDogZmFsc2UsXG4gICAgc21vb3RoU2Nyb2xsWTogZmFsc2UsXG59O1xuKFNtb290aFNjcm9sbGluZ0dyaWQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW5wdXRCbGVuZGluZ0dyaWRQcm9wcyB7XG4gICAgcmFuZ2VCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICBjb2x1bW5CbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiIHwgXCJleGNsdXNpdmVcIjtcbiAgICByYW5nZU11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwiY2VsbFwiIHwgXCJyZWN0XCIgfCBcIm11bHRpLWNlbGxcIiB8IFwibXVsdGktcmVjdFwiO1xuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm5vbmVcIiB8IFwic2luZ2xlXCIgfCBcIm11bHRpXCI7XG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibm9uZVwiIHwgXCJzaW5nbGVcIiB8IFwibXVsdGlcIjtcbn1cblxuZXhwb3J0IGNvbnN0IElucHV0QmxlbmRpbmc6IFJlYWN0LkZDPElucHV0QmxlbmRpbmdHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMzApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiSW5wdXQgYmxlbmRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgSW5wdXQgYmxlbmRpbmcgY2FuIGJlIGVuYWJsZWQgb3IgZGlzYWJsZSBiZXR3ZWVuIHJvdywgY29sdW1uLCBhbmQgcmFuZ2Ugc2VsZWN0aW9ucy4gTXVsdGktc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjYW4gYWxzbyBiZSBlbmFibGVkIG9yIGRpc2FibGVkIHdpdGggdGhlIHNhbWUgbGV2ZWwgb2YgZ3JhbnVsYXJpdHkuXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17cC5yb3dNdWx0aVNlbGVjdCA9PT0gXCJub25lXCIgPyBcIm51bWJlclwiIDogXCJib3RoXCJ9XG4gICAgICAgICAgICAgICAga2V5YmluZGluZ3M9e3tcbiAgICAgICAgICAgICAgICAgICAgY2xlYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvcHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRvd25GaWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByaWdodEZpbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEb3duOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYWdlVXA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEFsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0Q29sdW1uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RSb3c6IHRydWUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICByYW5nZVNlbGVjdD17cC5yYW5nZU11bHRpU2VsZWN0fVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdD17cC5jb2x1bW5NdWx0aVNlbGVjdH1cbiAgICAgICAgICAgICAgICByb3dTZWxlY3Q9e3Aucm93TXVsdGlTZWxlY3R9XG4gICAgICAgICAgICAgICAgcmFuZ2VTZWxlY3Rpb25CbGVuZGluZz17cC5yYW5nZUJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdGlvbkJsZW5kaW5nPXtwLmNvbHVtbkJsZW5kaW5nfVxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGlvbkJsZW5kaW5nPXtwLnJvd0JsZW5kaW5nfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkuYXJncyA9IHtcbiAgICByYW5nZUJsZW5kaW5nOiBcIm1peGVkXCIsXG4gICAgY29sdW1uQmxlbmRpbmc6IFwibWl4ZWRcIixcbiAgICByb3dCbGVuZGluZzogXCJtaXhlZFwiLFxuICAgIHJhbmdlTXVsdGlTZWxlY3Q6IFwicmVjdFwiLFxuICAgIGNvbHVtbk11bHRpU2VsZWN0OiBcIm11bHRpXCIsXG4gICAgcm93TXVsdGlTZWxlY3Q6IFwibXVsdGlcIixcbn07XG4oSW5wdXRCbGVuZGluZyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJhbmdlQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgY29sdW1uQmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcm93QmxlbmRpbmc6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJtaXhlZFwiLCBcImV4Y2x1c2l2ZVwiXSB9LFxuICAgIH0sXG4gICAgcmFuZ2VNdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJjZWxsXCIsIFwicmVjdFwiLCBcIm11bHRpLWNlbGxcIiwgXCJtdWx0aS1yZWN0XCJdIH0sXG4gICAgfSxcbiAgICBjb2x1bW5NdWx0aVNlbGVjdDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcIm5vbmVcIiwgXCJzaW5nbGVcIiwgXCJtdWx0aVwiXSB9LFxuICAgIH0sXG4gICAgcm93TXVsdGlTZWxlY3Q6IHtcbiAgICAgICAgY29udHJvbDogeyB0eXBlOiBcInNlbGVjdFwiLCBvcHRpb25zOiBbXCJub25lXCIsIFwic2luZ2xlXCIsIFwibXVsdGlcIl0gfSxcbiAgICB9LFxufTtcbihJbnB1dEJsZW5kaW5nIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuaW50ZXJmYWNlIEFkZENvbHVtbnNQcm9wcyB7XG4gICAgY29sdW1uc0NvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBBZGRDb2x1bW5zOiBSZWFjdC5GQzxBZGRDb2x1bW5zUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKHAuY29sdW1uc0NvdW50KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkFkZCBhbmQgcmVtb3ZlIGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGFkZCBhbmQgcmVtb3ZlIGNvbHVtbnMgYXQgeW91ciBkaXNwb3NhbDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5Vc2UgdGhlIHN0b3J5JmFwb3M7cyBjb250cm9scyB0byBjaGFuZ2UgdGhlIG51bWJlciBvZiBjb2x1bW5zPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJncyA9IHtcbiAgICBjb2x1bW5zQ291bnQ6IDEwLFxufTtcbihBZGRDb2x1bW5zIGFzIGFueSkuYXJnVHlwZXMgPSB7XG4gICAgY29sdW1uc0NvdW50OiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKEFkZENvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgU2Nyb2xsU2hhZG93czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IFJlYWN0LnVzZVN0YXRlPEdyaWRTZWxlY3Rpb24+KHtcbiAgICAgICAgcm93czogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgfSk7XG5cbiAgICBjb25zdCBvblNlbGVjdGlvbkNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdTZWw6IEdyaWRTZWxlY3Rpb24pID0+IHtcbiAgICAgICAgbGV0IG5ld1Jvd3MgPSBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIGlmIChuZXdTZWwuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdSb3dzID0gbmV3Um93cy5hZGQoW25ld1NlbC5jdXJyZW50LnJhbmdlLnksIG5ld1NlbC5jdXJyZW50LnJhbmdlLnkgKyBuZXdTZWwuY3VycmVudC5yYW5nZS5oZWlnaHRdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbmV3U2VsLmN1cnJlbnQ/LnJhbmdlU3RhY2sgPz8gW10pIHtcbiAgICAgICAgICAgIG5ld1Jvd3MgPSBuZXdSb3dzLmFkZChbYi55LCBiLnkgKyBiLmhlaWdodF0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAuLi5uZXdTZWwsXG4gICAgICAgICAgICByb3dzOiBuZXdSb3dzLFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB0aGVtZSA9IFJlYWN0LnVzZU1lbW88UGFydGlhbDxUaGVtZT4+KFxuICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgICAgYWNjZW50TGlnaHQ6IFwiI2IxZjZmZlwiLFxuICAgICAgICAgICAgaG9yaXpvbnRhbEJvcmRlckNvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBoZWFkZXJCb3R0b21Cb3JkZXJDb2xvcjogXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXCIsXG4gICAgICAgIH0pLFxuICAgICAgICBbXVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2socm93ID0+IChyb3cgJSAyID09PSAwID8gdW5kZWZpbmVkIDogeyBiZ0NlbGw6IFwiI2Y1ZjVmNlwiIH0pLCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJBdXRvbWF0aWMgUm93IE1hcmtlcnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5Zb3UgY2FuIGVuYWJsZSBhbmQgZGlzYWJsZSB0aGUgaG9yaXpvbnRhbC92ZXJ0aWNhbCBzY3JvbGwgc2hhZG93cy48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcIm51bWJlclwifVxuICAgICAgICAgICAgICAgIGdyaWRTZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBvbkdyaWRTZWxlY3Rpb25DaGFuZ2U9e29uU2VsZWN0aW9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgaGVhZGVySGVpZ2h0PXsyNn1cbiAgICAgICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezIyfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17ZmFsc2V9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICB0aGVtZT17dGhlbWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oU2Nyb2xsU2hhZG93cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQXV0b21hdGljUm93TWFya2VyczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQXV0b21hdGljIFJvdyBNYXJrZXJzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGVuYWJsZSByb3cgbWFya2VycyB3aXRoIHJpY2ggc2VsZWN0aW9uIGJlaGF2aW9yIHVzaW5nIHRoZXtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5yb3dNYXJrZXJzPC9Qcm9wTmFtZT4gcHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgVXNlIDxLZXlOYW1lPuKHpzwvS2V5TmFtZT4gKyBjbGljayB0byBtYWtlIHJhbmdlIHNlbGVjdGlvbnMsIGFuZCA8S2V5TmFtZT5DdHJsPC9LZXlOYW1lPiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyBjbGljayB0byBhZGQvcmVtb3ZlIGluZGl2aWR1YWwgcm93cy5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihBdXRvbWF0aWNSb3dNYXJrZXJzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBXcmFwcGluZ1RleHQ6IFJlYWN0LlZGQzx7XG4gICAgYWxpZ25tZW50OiBcImxlZnRcIiB8IFwiY2VudGVyXCIgfCBcInJpZ2h0XCI7XG4gICAgbGVuZ3RoOiBudW1iZXI7XG4gICAgaHlwZXJXcmFwcGluZzogYm9vbGVhbjtcbn0+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3Qgc3VmZml4ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZSgwLCAxMDApLm1hcCgoKSA9PiBmYWtlci5sb3JlbS5zZW50ZW5jZShwLmxlbmd0aCkpO1xuICAgIH0sIFtwLmxlbmd0aF0pO1xuXG4gICAgY29uc3QgbWFuZ2xlZEdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2s8dHlwZW9mIGdldENlbGxDb250ZW50PihcbiAgICAgICAgaSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gaTtcblxuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtyb3d9LFxcbiR7c3VmZml4W3JvdyAlIHN1ZmZpeC5sZW5ndGhdfWAsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGAke3Jvd30sICR7c3VmZml4fWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93V3JhcHBpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBbGlnbjogcC5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChpKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50LCBwLmFsaWdubWVudCwgc3VmZml4XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJXcmFwcGluZyBUZXh0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRleHQgY2VsbHMgY2FuIGhhdmUgd3JhcHBpbmcgdGV4dCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+YWxsb3dXcmFwcGluZzwvUHJvcE5hbWU+IHByb3AgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9ezgwfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWw9e3tcbiAgICAgICAgICAgICAgICAgICAgaHlwZXJXcmFwcGluZzogcC5oeXBlcldyYXBwaW5nLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oV3JhcHBpbmdUZXh0IGFzIGFueSkuYXJncyA9IHtcbiAgICBhbGlnbm1lbnQ6IFwibGVmdFwiLFxuICAgIGxlbmd0aDogMjAsXG4gICAgaHlwZXJXcmFwcGluZzogZmFsc2UsXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGFsaWdubWVudDoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXSB9LFxuICAgIH0sXG4gICAgbGVuZ3RoOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMixcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFdyYXBwaW5nVGV4dCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBVbmV2ZW5Sb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJVbmV2ZW4gUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBSb3dzIGNhbiBiZSBtYWRlIHVuZXZlbiBieSBwYXNzaW5nIGEgY2FsbGJhY2sgdG8gdGhlIDxQcm9wTmFtZT5yb3dIZWlnaHQ8L1Byb3BOYW1lPiBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93SGVpZ2h0PXtyID0+IChyICUgMyA9PT0gMCA/IDMwIDogciAlIDIgPyA1MCA6IDYwKX1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVuZXZlblJvd3MgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IERyYXdDdXN0b21DZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhdyBjdXN0b20gY2VsbHNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmF3IGN1c3RvbSBjZWxsIGNvbnRlbnRzIGhvd2V2ZXIgeW91IHdhbnQgdXNpbmcgdGhlIDxQcm9wTmFtZT5kcmF3Q3VzdG9tQ2VsbDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZHJhd0NlbGw9e2FyZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNlbGwsIHJlY3QsIGN0eCB9ID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwua2luZCAhPT0gR3JpZENlbGxLaW5kLlRleHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNYID0gY2VsbC5kaXNwbGF5RGF0YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwieFwiKTsgLy8gYWxsIG15IHgncyBsaXZlIGluIHRleGFzXG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gY2VsbC5kaXNwbGF5RGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaGFzWCA/IFwiI2JmZmZjZFwiIDogXCIjZmZlNmU2XCI7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICsgMSwgeSArIDEsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGhhc1ggPyBcIiMwZmMwMzVcIiA6IFwiI2UwMWUxZVwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IFwiYm9sZCAxNHB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGRhdGEsIHggKyA4ICsgMC41LCB5ICsgaGVpZ2h0IC8gMiArIDQuNSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKERyYXdDdXN0b21DZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUmVhcnJhbmdlQ29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2MCk7XG5cbiAgICAvLyBUaGlzIGlzIGEgZGlydHkgaGFjayBiZWNhdXNlIHRoZSBtb2NrIGdlbmVyYXRvciBkb2Vzbid0IHJlYWxseSBzdXBwb3J0IGNoYW5naW5nIHRoaXMuIEluIGEgcmVhbCBkYXRhIHNvdXJjZVxuICAgIC8vIHlvdSBzaG91bGQgdHJhY2sgaW5kZXhlcyBwcm9wZXJseVxuICAgIGNvbnN0IFtzb3J0YWJsZUNvbHMsIHNldFNvcnRhYmxlQ29sc10gPSBSZWFjdC51c2VTdGF0ZShjb2xzKTtcblxuICAgIGNvbnN0IG9uQ29sTW92ZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoc3RhcnRJbmRleDogbnVtYmVyLCBlbmRJbmRleDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIHNldFNvcnRhYmxlQ29scyhvbGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29scyA9IFsuLi5vbGRdO1xuICAgICAgICAgICAgY29uc3QgW3RvTW92ZV0gPSBuZXdDb2xzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgICAgICAgIG5ld0NvbHMuc3BsaWNlKGVuZEluZGV4LCAwLCB0b01vdmUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbHM7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldENlbGxDb250ZW50TWFuZ2xlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkQ29sID0gY29scy5maW5kSW5kZXgoYyA9PiBjLnRpdGxlID09PSBzb3J0YWJsZUNvbHNbY29sXS50aXRsZSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2VsbENvbnRlbnQoW3JlbWFwcGVkQ29sLCByb3ddKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHMsIGdldENlbGxDb250ZW50LCBzb3J0YWJsZUNvbHNdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlYXJyYW5nZSBDb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgY2FuIGJlIHJlYXJyYW5nZWQgYnkgZHJhZyBhbmQgZHJvcHBpbmcsIGFzIGxvbmcgYXMgeW91IHJlc3BvbmQgdG8gdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25Db2x1bW5Nb3ZlZDwvUHJvcE5hbWU+IGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudE1hbmdsZWR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3NvcnRhYmxlQ29sc31cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtvbkNvbE1vdmVkfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUmVhcnJhbmdlQ29sdW1ucyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUm93QW5kSGVhZGVyU2l6ZXNQcm9wcyB7XG4gICAgcm93SGVpZ2h0OiBudW1iZXI7XG4gICAgaGVhZGVySGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgUm93QW5kSGVhZGVyU2l6ZXM6IFJlYWN0LlZGQzxSb3dBbmRIZWFkZXJTaXplc1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJvdyBhbmQgSGVhZGVyIHNpemVzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBUaGUgcm93IHNpemUgY2FuIGJlIGNvbnRyb2xsZWQgd2l0aCA8UHJvcE5hbWU+cm93SGVpZ2h0PC9Qcm9wTmFtZT4gYW5kIHRoZSBoZWFkZXIgc2l6ZSB3aXRoe1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmhlYWRlckhlaWdodDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VXNlIHRoZSBzdG9yeSZhcG9zO3MgY29udHJvbHMgdG8gcmVzaXplIHRoZW08L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dIZWlnaHQ9e3Aucm93SGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhlYWRlckhlaWdodD17cC5oZWFkZXJIZWlnaHR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wibnVtYmVyXCJ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ3MgPSB7XG4gICAgcm93SGVpZ2h0OiAzNCxcbiAgICBoZWFkZXJIZWlnaHQ6IDM0LFxufTtcbihSb3dBbmRIZWFkZXJTaXplcyBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHJvd0hlaWdodDoge1xuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICBtaW46IDIwLFxuICAgICAgICAgICAgbWF4OiAyMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBoZWFkZXJIZWlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAyMCxcbiAgICAgICAgICAgIG1heDogMjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFJvd0FuZEhlYWRlclNpemVzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgS2V5TmFtZSA9IHN0eWxlZC5rYmRgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y0ZjRmNDtcbiAgICBjb2xvcjogIzJiMmIyYjtcbiAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAjMDAwMDAwNDA7XG4gICAgbWFyZ2luOiAwIDAuMWVtO1xuYDtcblxuZXhwb3J0IGNvbnN0IE11bHRpU2VsZWN0Q29sdW1uczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTXVsdGkgc2VsZWN0IGNvbHVtbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gc2VsZWN0IG11bHRpcGxlIGNvbHVtbnMgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5zZWxlY3RlZENvbHVtbnM8L1Byb3BOYW1lPiBhbmR7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25TZWxlY3RlZENvbHVtbnNDaGFuZ2U8L1Byb3BOYW1lPiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBIZXJlIHlvdSBjYW4gbXVsdGkgc2VsZWN0IGNvbHVtbnMgYnkgdXNpbmcgPEtleU5hbWU+Q3RybDwvS2V5TmFtZT4gKG9uIFdpbmRvd3MpIG9ye1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPEtleU5hbWU+4oyYPC9LZXlOYW1lPiAob24gTWFjKVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oTXVsdGlTZWxlY3RDb2x1bW5zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGdldENvbHVtbnNGb3JDZWxsVHlwZXMoKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJSb3cgSURcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJSb3dJRCxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Sb3dJRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFrZXIuZGF0YXR5cGUudXVpZCgpLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIlByb3RlY3RlZFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmYWtlci5maW5hbmNlLmJpdGNvaW5BZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkxvYWRpbmdcIixcbiAgICAgICAgICAgIHdpZHRoOiAxMjAsXG4gICAgICAgICAgICBpY29uOiBHcmlkQ29sdW1uSWNvbi5IZWFkZXJTdHJpbmcsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVGV4dFwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckNvZGUsXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmFrZXIubmFtZS5maXJzdE5hbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTnVtYmVyXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTnVtYmVyLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gZmFrZXIuZGF0YXR5cGUubnVtYmVyKDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYWdlLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogYCR7YWdlfWAsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckJvb2xlYW4sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb2xsID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcm9sbCA8IDAuMSA/IHVuZGVmaW5lZCA6IHJvbGwgPCAwLjIgPyBudWxsIDogcm9sbCA8IDAuNjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIGVkaXRhYmxlLiBVWCBsb29rcyBiYWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJJbWFnZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYCR7ZmFrZXIuaW1hZ2UuYW5pbWFscyg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiVXJpXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyVXJpLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZmFrZXIuaW50ZXJuZXQudXJsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlVyaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdXJsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1hcmtkb3duXCIsXG4gICAgICAgICAgICB3aWR0aDogMTIwLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyTWFya2Rvd24sXG4gICAgICAgICAgICBoYXNNZW51OiBmYWxzZSxcbiAgICAgICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZG93biA9IGAjIFRpdGxlXG5IZWxsbyBteSBuYW1lIGlzICoke2Zha2VyLm5hbWUuZmlyc3ROYW1lKCl9KlxuXG4jIyBUT0RPOlxuVHJ5IG91dCBbR2xpZGVdKGh0dHBzOi8vd3d3LmdsaWRlYXBwcy5jb20vKVxuYDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1hcmtkb3duLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkJ1YmJsZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkJ1YmJsZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2Zha2VyLmxvcmVtLndvcmQoKSwgZmFrZXIubG9yZW0ud29yZCgpLCBmYWtlci5sb3JlbS53b3JkKCldLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkRyaWxsZG93blwiLFxuICAgICAgICAgICAgd2lkdGg6IDEyMCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckFycmF5LFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkRyaWxsZG93bixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZha2VyLmFkZHJlc3MuY2l0eU5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWc6IGAke2Zha2VyLmltYWdlLm5hdHVyZSg0MCwgNDApfT9yYW5kb209JHtmYWtlci5kYXRhdHlwZS5udW1iZXIoMTAwXzAwMCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZmFrZXIuYWRkcmVzcy5jaXR5TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZzogYCR7ZmFrZXIuaW1hZ2UubmF0dXJlKDQwLCA0MCl9P3JhbmRvbT0ke2Zha2VyLmRhdGF0eXBlLm51bWJlcigxMDBfMDAwKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZUFsbE1vY2tlZEtpbmRzKCkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKGdldENvbHVtbnNGb3JDZWxsVHlwZXMpO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgW3VwZGF0ZVZlcnNpb24sIHNldFVwZGF0ZVZlcnNpb25dID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgKFtjb2wsIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiB7XG4gICAgICAgICAgICAvLyBUZXJyaWJsZSBoYWNrIHRvIGZvcmNlIHVwZGF0ZSB3aGVuIHNldENlbGxWYWx1ZSByZXF1ZXN0cyBpdFxuICAgICAgICAgICAgbm9vcCh1cGRhdGVWZXJzaW9uKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBjYWNoZS5jdXJyZW50LmdldChjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnQuc2V0KGNvbCwgcm93LCB2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbY29sc01hcCwgdXBkYXRlVmVyc2lvbl1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsLCBub0Rpc3BsYXk/OiBib29sZWFuLCBmb3JjZVVwZGF0ZT86IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gY2FjaGUuY3VycmVudC5nZXQoY29sLCByb3cpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb2xzTWFwW2NvbF0uZ2V0Q29udGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGVHcmlkQ2VsbCh2YWwpICYmIGlzRWRpdGFibGVHcmlkQ2VsbChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcGllZCA9IGxvc3N5Q29weURhdGEodmFsLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jdXJyZW50LnNldChjb2wsIHJvdywge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb3BpZWQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBub0Rpc3BsYXkgPT09IHRydWUgPyB1bmRlZmluZWQgOiBjb3BpZWQuZGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVVwZGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcGRhdGVWZXJzaW9uKHYgPT4gdiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNNYXBdXG4gICAgKTtcblxuICAgIHJldHVybiB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH07XG59XG5cbmV4cG9ydCBjb25zdCBBbGxDZWxsS2luZHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiTG90c2EgY2VsbCBraW5kc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBEYXRhIGdyaWQgc3VwcG9ydHMgcGxlbnR5IGNlbGwga2luZHMuIEFueXRoaW5nIHVuZGVyIDxQcm9wTmFtZT5HcmlkQ2VsbEtpbmQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjZmYwMGZmMzNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEFsbENlbGxLaW5kcyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5jb25zdCBkYXJrVGhlbWUgPSB7XG4gICAgYWNjZW50Q29sb3I6IFwiIzhjOTZmZlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoMjAyLCAyMDYsIDI1NSwgMC4yNTMpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjZmZmZmZmXCIsXG4gICAgdGV4dE1lZGl1bTogXCIjYjhiOGI4XCIsXG4gICAgdGV4dExpZ2h0OiBcIiNhMGEwYTBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiNmZmZmZmZcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjYjhiOGI4XCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiMwMDAwMDBcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiNhMWExYTFcIixcbiAgICB0ZXh0SGVhZGVyU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdDZWxsOiBcIiMxNjE2MWJcIixcbiAgICBiZ0NlbGxNZWRpdW06IFwiIzIwMjAyN1wiLFxuICAgIGJnSGVhZGVyOiBcIiMyMTIxMjFcIixcbiAgICBiZ0hlYWRlckhhc0ZvY3VzOiBcIiM0NzQ3NDdcIixcbiAgICBiZ0hlYWRlckhvdmVyZWQ6IFwiIzQwNDA0MFwiLFxuXG4gICAgYmdCdWJibGU6IFwiIzIxMjEyMVwiLFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdTZWFyY2hSZXN1bHQ6IFwiIzQyM2MyNFwiLFxuXG4gICAgYm9yZGVyQ29sb3I6IFwicmdiYSgyMjUsMjI1LDIyNSwwLjIpXCIsXG4gICAgZHJpbGxkb3duQm9yZGVyOiBcInJnYmEoMjI1LDIyNSwyMjUsMC40KVwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmNvbnN0IGhvdGRvZ1N0YW5kID0ge1xuICAgIGFjY2VudENvbG9yOiBcIiM4Yzk2ZmZcIixcbiAgICBhY2NlbnRMaWdodDogXCJyZ2JhKDIwMiwgMjA2LCAyNTUsIDAuMjUzKVwiLFxuXG4gICAgdGV4dERhcms6IFwiI2ZmZmZmZlwiLFxuICAgIHRleHRNZWRpdW06IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpXCIsXG4gICAgdGV4dExpZ2h0OiBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KVwiLFxuICAgIHRleHRCdWJibGU6IFwiIzAwMDAwMFwiLFxuXG4gICAgYmdJY29uSGVhZGVyOiBcIiM4ODAwMDBcIixcbiAgICBmZ0ljb25IZWFkZXI6IFwiI2ZmNTU1NVwiLFxuICAgIHRleHRIZWFkZXI6IFwicmdiYSgwLCAwLCAwLCAwLjkpXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiMwMDAwMDBcIixcblxuICAgIGJnQ2VsbDogXCIjZmYwMDAwXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNmZjRkNGRcIixcbiAgICBiZ0hlYWRlcjogXCIjZjNmMzAwXCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjZWVlZTAwXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNlMGUwMDBcIixcblxuICAgIGJnQnViYmxlOiBcIiNmZmZmMDBcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNmZmZmMDBcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiM0MjNjMjRcIixcblxuICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmMDBcIixcbiAgICBkcmlsbGRvd25Cb3JkZXI6IFwiI2ZmZmYwMFwiLFxuXG4gICAgbGlua0NvbG9yOiBcIiM0RjVERkZcIixcblxuICAgIGhlYWRlckZvbnRTdHlsZTogXCJib2xkIDE0cHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBmb250RmFtaWx5OlxuICAgICAgICBcIkludGVyLCBSb2JvdG8sIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgYXZlbmlyIG5leHQsIGF2ZW5pciwgc2Vnb2UgdWksIGhlbHZldGljYSBuZXVlLCBoZWx2ZXRpY2EsIFVidW50dSwgbm90bywgYXJpYWwsIHNhbnMtc2VyaWZcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUaGVtZVN1cHBvcnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW3RoZW1lLCBzZXRUaGVtZV0gPSBSZWFjdC51c2VTdGF0ZTxQYXJ0aWFsPFRoZW1lPj4oe30pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMTAwMCk7XG5cbiAgICBjb25zdCBvblJvd0FwcGVuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdSb3cgPSBudW1Sb3dzO1xuICAgICAgICBzZXROdW1Sb3dzKGN2ID0+IGN2ICsgMSk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgNjsgYysrKSB7XG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoW2MsIG5ld1Jvd10sIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogXCJcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBcIlwiLFxuICAgICAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICB9XG4gICAgfSwgW251bVJvd3MsIHNldENlbGxWYWx1ZV0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRGF0YUdyaWQgcmVzcGVjdHMgdGhlIHRoZW1lIHByb3ZpZGVkIGJ5IHRoZSA8UHJvcE5hbWU+dGhlbWU8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKHt9KX0+TGlnaHQ8L2J1dHRvbj4gb3J7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFRoZW1lKGRhcmtUaGVtZSl9PkRhcms8L2J1dHRvbj4gZXZlbntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0VGhlbWUoaG90ZG9nU3RhbmQpfT5Ib3Rkb2cgU3RhbmQ8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgdGhlbWU9e3RoZW1lfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9e29uUm93QXBwZW5kZWR9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHRpbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXtudW1Sb3dzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lU3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgVGhlbWVQZXJDb2x1bW46IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s0XSA9IHtcbiAgICAgICAgICAgIC4uLmNbNF0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgYmFzZUZvbnRTdHlsZTogXCI2MDAgMTNweFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY1s5XSA9IHtcbiAgICAgICAgICAgIC4uLmNbOV0sXG4gICAgICAgICAgICB0aGVtZU92ZXJyaWRlOiB7XG4gICAgICAgICAgICAgICAgdGV4dERhcms6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGJnSWNvbkhlYWRlcjogXCIjMDA5Q0E2XCIsXG4gICAgICAgICAgICAgICAgYWNjZW50Q29sb3I6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudExpZ2h0OiBcIiMwMDlDQTYyMFwiLFxuICAgICAgICAgICAgICAgIGZnSWNvbkhlYWRlcjogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjWzEwXSA9IHtcbiAgICAgICAgICAgIC4uLmNbMTBdLFxuICAgICAgICAgICAgdGhlbWVPdmVycmlkZToge1xuICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBiZ0ljb25IZWFkZXI6IFwiIzAwOUNBNlwiLFxuICAgICAgICAgICAgICAgIGFjY2VudENvbG9yOiBcIiMwMDlDQTZcIixcbiAgICAgICAgICAgICAgICBhY2NlbnRMaWdodDogXCIjMDA5Q0E2MjBcIixcbiAgICAgICAgICAgICAgICBmZ0ljb25IZWFkZXI6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlRoZW1lIHBlciBjb2x1bW5cIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5FYWNoIGNvbHVtbiBjYW4gcHJvdmlkZSB0aGVtZSBvdmVycmlkZXMgZm9yIHJlbmRlcmluZyB0aGF0IGNvbHVtbi48L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oVGhlbWVQZXJDb2x1bW4gYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFRoZW1lUGVyUm93OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiVGhlbWUgcGVyIHJvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgRWFjaCByb3cgY2FuIHByb3ZpZGUgdGhlbWUgb3ZlcnJpZGVzIGZvciByZW5kZXJpbmcgdGhhdCByb3cgdXNpbmcgdGhle1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPmdldFJvd1RoZW1lT3ZlcnJpZGU8L1Byb3BOYW1lPiBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPXt7XG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uUm93QXBwZW5kZWQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17aSA9PlxuICAgICAgICAgICAgICAgICAgICBpICUgMiA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmMGY4ZmZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMzZjkwZTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgcm93cz17MV8wMDBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFRoZW1lUGVyUm93IGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDZWxsQWN0aXZhdGVkRXZlbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgW2xhc3RBY3RpdmF0ZWQsIHNldExhc3RBY3RpdmF0ZWRdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IG9uQ2VsbEFjdGl2YXRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChjZWxsOiBJdGVtKSA9PiB7XG4gICAgICAgIHNldExhc3RBY3RpdmF0ZWQoY2VsbCk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ2VsbCBBY3RpdmF0ZWQgZXZlbnRcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4geW91IHRhcCA8S2V5TmFtZT5FbnRlcjwvS2V5TmFtZT4sIDxLZXlOYW1lPlNwYWNlPC9LZXlOYW1lPiBvciBkb3VibGUgY2xpY2sgYSBjZWxsLCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsIGlzIGFjdGl2YXRlZC4gWW91IGNhbiB0cmFjayB0aGlzIHdpdGggPFByb3BOYW1lPm9uQ2VsbEFjdGl2YXRlZDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXN0IGFjdGl2YXRlZCBjZWxsOntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtsYXN0QWN0aXZhdGVkID09PSB1bmRlZmluZWQgPyBcIm5vbmVcIiA6IGAoJHtsYXN0QWN0aXZhdGVkWzBdfSwgJHtsYXN0QWN0aXZhdGVkWzFdfSlgfVxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e3RydWV9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25DZWxsQWN0aXZhdGVkPXtvbkNlbGxBY3RpdmF0ZWR9XG4gICAgICAgICAgICAgICAgcm93cz17MTBfMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKENlbGxBY3RpdmF0ZWRFdmVudCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQnVpbHRJblNlYXJjaDogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbc2hvd1NlYXJjaCwgc2V0U2hvd1NlYXJjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwia2V5ZG93blwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgZXZlbnQuY29kZSA9PT0gXCJLZXlGXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRTaG93U2VhcmNoKGN2ID0+ICFjdik7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pLFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlNlYXJjaCBpcyBlYXN5XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZWFyY2ggZm9yIGFueSBkYXRhIGluIHlvdXIgZ3JpZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5zaG93U2VhcmNoPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIEluIHRoaXMgc3RvcnksIDxLZXlOYW1lPkN0cmw8L0tleU5hbWU+ICg8S2V5TmFtZT7ijJg8L0tleU5hbWU+IG9uIE1hYykgKyA8S2V5TmFtZT5mPC9LZXlOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZXMgdGhlIHNlYXJjaCBiYXIuIE1ha2Ugc3VyZSB5b3UmYXBvcztyZSBmb2N1c2VkIG9uIHRoZSBEYXRhIEdyaWQhXG4gICAgICAgICAgICAgICAgICAgIDwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17dHJ1ZX1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgc2hvd1NlYXJjaD17c2hvd1NlYXJjaH1cbiAgICAgICAgICAgICAgICBvblNlYXJjaENsb3NlPXsoKSA9PiBzZXRTaG93U2VhcmNoKGZhbHNlKX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMF8wMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQnVpbHRJblNlYXJjaCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgSW1wZXJhdGl2ZVNjcm9sbFByb3BzIHtcbiAgICBwYWRkaW5nWTogbnVtYmVyO1xuICAgIHBhZGRpbmdYOiBudW1iZXI7XG4gICAgdkFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG4gICAgaEFsaWduPzogXCJzdGFydFwiIHwgXCJjZW50ZXJcIiB8IFwiZW5kXCI7XG59XG5cbmV4cG9ydCBjb25zdCBJbXBlcmF0aXZlU2Nyb2xsOiBSZWFjdC5WRkM8SW1wZXJhdGl2ZVNjcm9sbFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWY8RGF0YUVkaXRvclJlZj4obnVsbCk7XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudD8uc2Nyb2xsVG8oNCwgOTksIFwiYm90aFwiLCBwLnBhZGRpbmdYLCBwLnBhZGRpbmdZLCB7XG4gICAgICAgICAgICB2QWxpZ246IHAudkFsaWduLFxuICAgICAgICAgICAgaEFsaWduOiBwLmhBbGlnbixcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkltcGVyYXRpdmUgc2Nyb2xsaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGltcGVyYXRpdmVseSBzY3JvbGwgdG8gYSBjZWxsIGJ5IGNhbGxpbmcgPFByb3BOYW1lPnNjcm9sbFRvPC9Qcm9wTmFtZT4gb24gYSBEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWNrIDxidXR0b24gb25DbGljaz17b25DbGlja30+SGVyZTwvYnV0dG9uPiB0byBzY3JvbGwgdG8gY29sdW1uIDQgcm93IDEwMFxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiY2xpY2thYmxlLW51bWJlclwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkuYXJncyA9IHtcbiAgICBwYWRkaW5nWTogMCxcbiAgICBwYWRkaW5nWDogMCxcbiAgICB2QWxpZ246IFwic3RhcnRcIixcbiAgICBoQWxpZ246IFwic3RhcnRcIixcbn07XG4oSW1wZXJhdGl2ZVNjcm9sbCBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIHBhZGRpbmdZOiAwLFxuICAgIHBhZGRpbmdYOiAwLFxuICAgIHZBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxuICAgIGhBbGlnbjoge1xuICAgICAgICBjb250cm9sOiB7IHR5cGU6IFwic2VsZWN0XCIsIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCIsIHVuZGVmaW5lZF0gfSxcbiAgICB9LFxufTtcbihJbXBlcmF0aXZlU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogdHJ1ZSxcbiAgICB9LFxufTtcblxuY29uc3QgU2ltcGxlTWVudSA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDE3NXB4O1xuICAgIHBhZGRpbmc6IDhweCAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDFweCByZ2JhKDYyLCA2NSwgODYsIDAuNyksIDBweCA2cHggMTJweCByZ2JhKDYyLCA2NSwgODYsIDAuMzUpO1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgZm9udC1zaXplOiAxM3B4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIFwiT3BlbiBTYW5zXCIsXG4gICAgICAgIFwiSGVsdmV0aWNhIE5ldWVcIiwgc2Fucy1zZXJpZjtcblxuICAgIC5kYW5nZXIge1xuICAgICAgICBjb2xvcjogcmdiYSgyNTUsIDQwLCA0MCwgMC44KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGNvbG9yOiByZ2JhKDI1NSwgNDAsIDQwLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgID4gZGl2IHtcbiAgICAgICAgcGFkZGluZzogNnB4IDhweDtcbiAgICAgICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgOmhvdmVyIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XG4gICAgICAgICAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTAwbXM7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgSGVhZGVyTWVudXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKGMgPT4gKHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgfSwgW2NvbHNdKTtcblxuICAgIGNvbnN0IFttZW51LCBzZXRNZW51XSA9XG4gICAgICAgIFJlYWN0LnVzZVN0YXRlPHtcbiAgICAgICAgICAgIGNvbDogbnVtYmVyO1xuICAgICAgICAgICAgYm91bmRzOiBSZWN0YW5nbGU7XG4gICAgICAgIH0+KCk7XG5cbiAgICBjb25zdCBpc09wZW4gPSBtZW51ICE9PSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCB7IGxheWVyUHJvcHMsIHJlbmRlckxheWVyIH0gPSB1c2VMYXllcih7XG4gICAgICAgIGlzT3BlbixcbiAgICAgICAgYXV0bzogdHJ1ZSxcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICAgICAgdHJpZ2dlck9mZnNldDogMixcbiAgICAgICAgb25PdXRzaWRlQ2xpY2s6ICgpID0+IHNldE1lbnUodW5kZWZpbmVkKSxcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG1lbnU/LmJvdW5kcy54ID8/IDAsXG4gICAgICAgICAgICAgICAgdG9wOiBtZW51Py5ib3VuZHMueSA/PyAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBtZW51Py5ib3VuZHMud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbnU/LmJvdW5kcy5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICByaWdodDogKG1lbnU/LmJvdW5kcy54ID8/IDApICsgKG1lbnU/LmJvdW5kcy53aWR0aCA/PyAwKSxcbiAgICAgICAgICAgICAgICBib3R0b206IChtZW51Py5ib3VuZHMueSA/PyAwKSArIChtZW51Py5ib3VuZHMuaGVpZ2h0ID8/IDApLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkhlYWRlck1lbnVDbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2w6IG51bWJlciwgYm91bmRzOiBSZWN0YW5nbGUpID0+IHtcbiAgICAgICAgc2V0TWVudSh7IGNvbCwgYm91bmRzIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2tlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2coXCJIZWFkZXIgY2xpY2tlZFwiKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJIZWFkZXIgbWVudXNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIEhlYWRlcnMgb24gdGhlIGRhdGEgZ3JpZCBjYW4gYmUgY29uZmlndXJlZCB0byBzdXBwb3J0IG1lbnVzLiBXZSBwcm92aWRlIHRoZSBldmVudHMgYW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUsIHlvdSBwcm92aWRlIHRoZSBtZW51LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e29uSGVhZGVyTWVudUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD17b25IZWFkZXJDbGlja2VkfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e3JlYWxDb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbENvbnRleHRNZW51PXsoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtpc09wZW4gJiZcbiAgICAgICAgICAgICAgICByZW5kZXJMYXllcihcbiAgICAgICAgICAgICAgICAgICAgPFNpbXBsZU1lbnUgey4uLmxheWVyUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiBzZXRNZW51KHVuZGVmaW5lZCl9PlRoZXNlIGRvIG5vdGhpbmc8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0TWVudSh1bmRlZmluZWQpfT5BZGQgY29sdW1uIHJpZ2h0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+QWRkIGNvbHVtbiBsZWZ0PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRhbmdlclwiIG9uQ2xpY2s9eygpID0+IHNldE1lbnUodW5kZWZpbmVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsZXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9TaW1wbGVNZW51PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIZWFkZXJNZW51cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVySWNvbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBvbkNvbHVtblJlc2l6ZSwgc2V0Q2VsbFZhbHVlIH0gPSB1c2VBbGxNb2NrZWRLaW5kcygpO1xuXG4gICAgY29uc3QgcmVhbENvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IFsuLi5jb2xzXTtcbiAgICAgICAgY1szXSA9IHtcbiAgICAgICAgICAgIC4uLmNbM10sXG4gICAgICAgICAgICB0aXRsZTogXCJDVVNUT00gSUNPTlwiLFxuICAgICAgICAgICAgaWNvbjogXCJjdXN0b21cIixcbiAgICAgICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICBjb25zdCBoZWFkZXJJY29ucyA9IFJlYWN0LnVzZU1lbW88U3ByaXRlTWFwPigoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXN0b206IHAgPT4gYDxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgICAgICAgICAgPHJlY3QgeD1cIjIuMDAwMTVcIiB5PVwiMlwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiNFwiIGZpbGw9XCIke3AuYmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTQuNjk3NTkgNi4wMDk3N0M0LjIzNzM1IDYuMDA5NzcgMy44NjQyNiA2LjM4Mjg2IDMuODY0MjYgNi44NDMxQzMuODY0MjYgNy4zMDMzNCA0LjIzNzM1IDcuNjc2NDMgNC42OTc1OSA3LjY3NjQzSDguODY0MjZDOS4zMjQ1IDcuNjc2NDMgOS42OTc1OSA3LjMwMzM0IDkuNjk3NTkgNi44NDMxQzkuNjk3NTkgNi4zODI4NiA5LjMyNDQ5IDYuMDA5NzcgOC44NjQyNiA2LjAwOTc3SDQuNjk3NTlaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNy42MTQyNiA0Ljc2MDA5QzcuNjE0MjYgNC4yOTk4NSA3LjI0MTE2IDMuOTI2NzYgNi43ODA5MiAzLjkyNjc2QzYuMzIwNjkgMy45MjY3NiA1Ljk0NzU5IDQuMjk5ODUgNS45NDc1OSA0Ljc2MDA5TDUuOTQ3NTkgOC45MjY3NkM1Ljk0NzU5IDkuMzg3IDYuMzIwNjkgOS43NjAwOSA2Ljc4MDkyIDkuNzYwMDlDNy4yNDExNiA5Ljc2MDA5IDcuNjE0MjYgOS4zODY5OSA3LjYxNDI2IDguOTI2NzZMNy42MTQyNiA0Ljc2MDA5WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTExLjAzMzYgNi4wMDk3N0MxMC41NzM0IDYuMDA5NzcgMTAuMjAwMyA2LjM4Mjg2IDEwLjIwMDMgNi44NDMxQzEwLjIwMDMgNy4zMDMzNCAxMC41NzM0IDcuNjc2NDMgMTEuMDMzNiA3LjY3NjQzSDE1LjIwMDNDMTUuNjYwNSA3LjY3NjQzIDE2LjAzMzYgNy4zMDMzNCAxNi4wMzM2IDYuODQzMUMxNi4wMzM2IDYuMzgyODYgMTUuNjYwNSA2LjAwOTc3IDE1LjIwMDMgNi4wMDk3N0gxMS4wMzM2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTUuODk3MDQgMTAuOTkxNkM1LjU3MTYgMTAuNjY2MiA1LjA0Mzk3IDEwLjY2NjIgNC43MTg1MyAxMC45OTE2QzQuMzkzMDkgMTEuMzE3IDQuMzkzMDkgMTEuODQ0NyA0LjcxODUzIDEyLjE3MDFMNy42NjQ4MSAxNS4xMTY0QzcuOTkwMjQgMTUuNDQxOCA4LjUxNzg4IDE1LjQ0MTggOC44NDMzMiAxNS4xMTY0QzkuMTY4NzYgMTQuNzkxIDkuMTY4NzYgMTQuMjYzMyA4Ljg0MzMyIDEzLjkzNzlMNS44OTcwNCAxMC45OTE2WlwiIGZpbGw9XCIke3AuZmdDb2xvcn1cIi8+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTguODQzMzIgMTIuMTcwM0M5LjE2ODc1IDExLjg0NDkgOS4xNjg3NSAxMS4zMTcyIDguODQzMzIgMTAuOTkxOEM4LjUxNzg4IDEwLjY2NjQgNy45OTAyNCAxMC42NjY0IDcuNjY0OCAxMC45OTE4TDQuNzE4NTMgMTMuOTM4MUM0LjM5MzA5IDE0LjI2MzUgNC4zOTMwOSAxNC43OTEyIDQuNzE4NTMgMTUuMTE2NkM1LjA0Mzk2IDE1LjQ0MiA1LjU3MTYgMTUuNDQyIDUuODk3MDQgMTUuMTE2Nkw4Ljg0MzMyIDEyLjE3MDNaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTEuODA0QzEwLjIwMDMgMTEuMzQzOCAxMC41NzM0IDEwLjk3MDcgMTEuMDMzNiAxMC45NzA3SDE1LjIwMDNDMTUuNjYwNSAxMC45NzA3IDE2LjAzMzYgMTEuMzQzOCAxNi4wMzM2IDExLjgwNEMxNi4wMzM2IDEyLjI2NDMgMTUuNjYwNSAxMi42Mzc0IDE1LjIwMDMgMTIuNjM3NEgxMS4wMzM2QzEwLjU3MzQgMTIuNjM3NCAxMC4yMDAzIDEyLjI2NDMgMTAuMjAwMyAxMS44MDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTEwLjIwMDMgMTQuMzA0QzEwLjIwMDMgMTMuODQzOCAxMC41NzM0IDEzLjQ3MDcgMTEuMDMzNiAxMy40NzA3SDE1LjIwMDNDMTUuNjYwNSAxMy40NzA3IDE2LjAzMzYgMTMuODQzOCAxNi4wMzM2IDE0LjMwNEMxNi4wMzM2IDE0Ljc2NDMgMTUuNjYwNSAxNS4xMzc0IDE1LjIwMDMgMTUuMTM3NEgxMS4wMzM2QzEwLjU3MzQgMTUuMTM3NCAxMC4yMDAzIDE0Ljc2NDMgMTAuMjAwMyAxNC4zMDRaXCIgZmlsbD1cIiR7cC5mZ0NvbG9yfVwiLz5cbiAgICAgICAgICAgIDwvc3ZnPmAsXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ3VzdG9tIGhlYWRlciBpY29uc1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBwcm92aWRlIG92ZXJyaWRlcyBmb3IgdGhlIGRlZmF1bHQgaWNvbnMgYnkgcGFzc2luZyB0aGUgPFByb3BOYW1lPmhlYWRlckljb25zPC9Qcm9wTmFtZT57XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17cmVhbENvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIGhlYWRlckljb25zPXtoZWFkZXJJY29uc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlckljb25zIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBSaWdodEVsZW1lbnQ6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWUsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcig4LCBmYWxzZSk7XG5cbiAgICBjb25zdCBjb2x1bW5zID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb2xzLm1hcChjID0+ICh7IC4uLmMsIGdyb3c6IDEgfSkpLCBbY29sc10pO1xuXG4gICAgY29uc3QgW251bVJvd3MsIHNldE51bVJvd3NdID0gUmVhY3QudXNlU3RhdGUoMzAwKTtcblxuICAgIGNvbnN0IG9uUm93QXBwZW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1JvdyA9IG51bVJvd3M7XG4gICAgICAgIHNldE51bVJvd3MoY3YgPT4gY3YgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA2OyBjKyspIHtcbiAgICAgICAgICAgIHNldENlbGxWYWx1ZShbYywgbmV3Um93XSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBcIlwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgIH1cbiAgICB9LCBbbnVtUm93cywgc2V0Q2VsbFZhbHVlXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSaWdodCBFbGVtZW50XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgRE9NIGVsZW1lbnQgbWF5IGJlIGFkZGVkIGFzIGEgdHJhaWxlciB0byB0aGUgZ3JpZCBieSB1c2luZyB0aGUgPFByb3BOYW1lPnJpZ2h0RWxlbWVudDwvUHJvcE5hbWU+e1wiIFwifVxuICAgICAgICAgICAgICAgICAgICBwcm9wLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPXtcImJvdGhcIn1cbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ9e3NldENlbGxWYWx1ZX1cbiAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM9e3tcbiAgICAgICAgICAgICAgICAgICAgaGludDogXCJOZXcgcm93Li4uXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9e251bVJvd3N9XG4gICAgICAgICAgICAgICAgb25Sb3dBcHBlbmRlZD17b25Sb3dBcHBlbmRlZH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17eyBzdGlja3k6IHRydWUgfX1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIyMHB4IDIwcHggNDBweCAyMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlLXdyYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyNDAsIDI0MCwgMjUwLCAwLjIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwiMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjE1KVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wRmlsdGVyOiBcImJsdXIoMTJweClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBpcyBhIHJlYWwgRE9NIGVsZW1lbnQuIFlvdSBjYW4gcHV0IHdoYXRldmVyIHlvdSB3YW50IGhlcmUuIFlvdSBjYW4gYWxzbyBzaXplIGl0IGFzIGJpZyBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgeW91IHdhbnQuIHtcIlxcblxcblwifUl0IGFsc28gZG9lcyBub3QgaGF2ZSB0byBiZSBzdGlja3kuXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSaWdodEVsZW1lbnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxubGV0IG51bTogbnVtYmVyID0gMTtcbmZ1bmN0aW9uIHJhbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKG51bSA9IChudW0gKiAxNl84MDcpICUgMl8xNDdfNDgzXzY0Nyk7XG59XG5cbmV4cG9ydCBjb25zdCBSYXBpZFVwZGF0ZXM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBzZXRDZWxsVmFsdWVSYXcsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmPERhdGFFZGl0b3JSZWY+KG51bGwpO1xuXG4gICAgY29uc3QgY291bnRSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgZGlzcGxheUNvdW50UmVmID0gUmVhY3QudXNlUmVmPEhUTUxFbGVtZW50PihudWxsKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCByYWZJRCA9IDA7XG5cbiAgICAgICAgY29uc3Qgc2VuZFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzOiB7XG4gICAgICAgICAgICAgICAgY2VsbDogSXRlbTtcbiAgICAgICAgICAgIH1bXSA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDUwMDA7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IE1hdGgubWF4KDEwLCByYW5kKCkgJSAxMDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHJhbmQoKSAlIDEwXzAwMDtcblxuICAgICAgICAgICAgICAgIHNldENlbGxWYWx1ZVJhdyhbY29sLCByb3ddLCB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB4LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHt4fWtgLFxuICAgICAgICAgICAgICAgICAgICB0aGVtZU92ZXJyaWRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCAlIDUgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2YyZmZmNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiMwMGQ0MWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ0NlbGw6IFwiI2ZmZjZmNlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREYXJrOiBcIiNkNDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5vdyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHsgY2VsbDogW2NvbCwgcm93XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50UmVmLmN1cnJlbnQgKz0gNTAwMDtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5Q291bnRSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlDb3VudFJlZi5jdXJyZW50LnRleHRDb250ZW50ID0gYCR7Y291bnRSZWYuY3VycmVudH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWYuY3VycmVudD8udXBkYXRlQ2VsbHMoY2VsbHMpO1xuXG4gICAgICAgICAgICByYWZJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2VuZFVwZGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VuZFVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJRCk7XG4gICAgICAgIH07XG4gICAgfSwgW3NldENlbGxWYWx1ZVJhd10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUmFwaWQgdXBkYXRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIERhdGEgZ3JpZCBjYW4gc3VwcG9ydCBtYW55IHRob3VzYW5kcyBvZiB1cGRhdGVzIHBlciBzZWNvbmRzLiBUaGUgZGF0YSBncmlkIGNhbiBlYXNpbHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGZhc3RlciB0aGFuIGEgaHVtYW4gY2FuIHJlYWQgaXQsIG1vcmUgaW1wb3J0YW50bHkgdGhlIGZhc3RlciB0aGUgZGF0YSBncmlkIGNhbiB1cGRhdGUsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZSB0aW1lIHlvdXIgY29kZSBjYW4gc3BlbmQgZG9pbmcgbW9yZSB2YWx1YWJsZSB3b3JrLlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGVzIHByb2Nlc3NlZDogPEtleU5hbWUgcmVmPXtkaXNwbGF5Q291bnRSZWZ9IC8+IFdlIGNvdWxkIGRvIHRoaXMgZmFzdGVyIGJ1dCB3ZSB3cm90ZSBhXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsbHkgY3JhcHB5IGRhdGEgc3RvcmUgZm9yIHRoaXMgZGVtbyB3aGljaCBpcyBhY3R1YWxseSBzbG93aW5nIGRvd24gdGhlIGRhdGEgZ3JpZC5cbiAgICAgICAgICAgICAgICAgICAgPC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihSYXBpZFVwZGF0ZXMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvcHlTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICAxMCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29weSBzdXBwb3J0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBMYXJnZSBhbW91bnRzIG9mIGRhdGEgY2FuIGJlIGNvcGllZCBhbmQgY3VzdG9taXplZCB1c2luZ3tcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5nZXRDZWxsc0ZvclNlbGVjdGlvbjwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8TW9yZUluZm8+VGhlIGRhdGEgaXMgY29waWVkIGludG8gYSBmb3JtYXQgcmVhZHkgdG8gYmUgcGFzdGVkIGludG8gRXhjZWwgb3IgR29vZ2xlIFNoZWV0czwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJDb3B5IHNvbWV0aGluZyBiZWxvdyBhbmQgcGFzdGUgaXQgaGVyZS4uLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG1hcmdpbkJvdHRvbTogMjAsIGJvcmRlclJhZGl1czogOSwgbWluSGVpZ2h0OiAyMDAsIHBhZGRpbmc6IDEwIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgb25DZWxsRWRpdGVkPXtzZXRDZWxsVmFsdWV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e29uQ29sdW1uUmVzaXplfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb3B5U3VwcG9ydCBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUGFzdGVTdXBwb3J0OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKFxuICAgICAgICA1MCxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiUGFzdGUgc3VwcG9ydFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZ3JpZCBjYW4gaGFuZGxlIHBhc3RlIGF1dG9tYXRpY2FsbHkgYnkgcmV0dXJuaW5nIHRydWUgZnJvbSA8UHJvcE5hbWU+b25QYXN0ZTwvUHJvcE5hbWU+XG4gICAgICAgICAgICAgICAgICAgICAgICAuIFlvdSBjYW4gYWxzbyByZXR1cm4gZmFsc2UgYW5kIGhhbmRsZSBwYXN0ZSB5b3Vyc2VsZi4gSWYgcGFzdGUgaXMgdW5kZWZpbmVkIHRoZSBEYXRhRWRpdG9yIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIGl0cyBiZXN0IHRvIHBhc3RlIHRvIHRoZSBjdXJyZW50IGNlbGwuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFBhc3RlIHN1cHBvcnRzIHRoZSBjb3B5IGZvcm1hdCBvZiBHb29nbGUgU2hlZXRzIGFuZCBFeGNlbC4gQmVsb3cgaXMgYW4gZXhhbXBsZSBvZiBkYXRhIGNvcGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBleGNlbCB3aXRoIHNvbWUgZXNjYXBlZCB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtgU3VuZGF5XHREb2dzXHRodHRwczovL2dvb2dsZS5jb21cbk1vbmRheVx0Q2F0c1x0aHR0cHM6Ly9nb29nbGUuY29tXG5UdWVzZGF5XHRUdXJ0bGVzXHRodHRwczovL2dvb2dsZS5jb21cbldlZG5lc2RheVx0QmVhcnNcdGh0dHBzOi8vZ29vZ2xlLmNvbVxuVGh1cnNkYXlcdFwiTCAgaW9uc1wiXHRodHRwczovL2dvb2dsZS5jb21cbkZyaWRheVx0UGlnc1x0aHR0cHM6Ly9nb29nbGUuY29tXG5TYXR1cmRheVx0XCJUdXJrZXlzIGFuZCBzb21lIFwiXCJxdW90ZXNcIlwiIGFuZFxuYSBuZXcgbGluZSBjaGFyIFwiXCJtb3JlIHF1b3Rlc1wiXCIgcGx1cyBhIHRhYiAgLlwiXHRodHRwczovL2dvb2dsZS5jb21gfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBtYXJnaW5Cb3R0b206IDIwLCBib3JkZXJSYWRpdXM6IDksIG1pbkhlaWdodDogMjAwLCBwYWRkaW5nOiAxMCB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICBvblBhc3RlPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezQwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihQYXN0ZVN1cHBvcnQgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IEZyZWV6ZUNvbHVtbnM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkZyZWV6ZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgZ3JpZCBjYW4gYmUgZnJvemVuIGluIHBsYWNlIGJ5IHNldHRpbmdze1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+ZnJlZXplQ29sdW1uczwvUHJvcE5hbWU+IHRvIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwLlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXsxfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEJvcmRlcj17YyA9PiBjID4gMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEZyZWV6ZUNvbHVtbnMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IFJlb3JkZXJSb3dzOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29scyA9IFJlYWN0LnVzZU1lbW88R3JpZENvbHVtbltdPihcbiAgICAgICAgKCkgPT4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkNvbCBBXCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDE1MCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQ29sIEJcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogMTUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgW11cbiAgICApO1xuXG4gICAgY29uc3QgW3Jvd0RhdGEsIHNldFJvd0RhdGFdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UoMCwgNTApLm1hcCh4ID0+IFtgQTogJHt4fWAsIGBCOiAke3h9YF0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0Q2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjazxEYXRhRWRpdG9yUHJvcHNbXCJnZXRDZWxsQ29udGVudFwiXT4oXG4gICAgICAgIChbY29sLCByb3ddKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YTogcm93RGF0YVtyb3ddW2NvbF0sXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IHJvd0RhdGFbcm93XVtjb2xdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW3Jvd0RhdGFdXG4gICAgKTtcblxuICAgIGNvbnN0IHJlb3JkZXJSb3dzID0gUmVhY3QudXNlQ2FsbGJhY2soKGZyb206IG51bWJlciwgdG86IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRSb3dEYXRhKGN2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBbLi4uY3ZdO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGQuc3BsaWNlKGZyb20sIDEpO1xuICAgICAgICAgICAgZC5zcGxpY2UodG8sIDAsIC4uLnJlbW92ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlJlb3JkZXIgUm93c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgUm93cyBjYW4gYmUgcmUtYXJyYW5nZWQgYnkgdXNpbmcgdGhlIDxQcm9wTmFtZT5vblJvd01vdmVkPC9Qcm9wTmFtZT4gY2FsbGJhY2suIFdoZW4gc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3Qgcm93IGNhbiBiZSB1c2VkIHRvIGRyYWcgYW5kIGRyb3AuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9e1wiYm90aFwifVxuICAgICAgICAgICAgICAgIG9uUm93TW92ZWQ9e3Jlb3JkZXJSb3dzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFJlb3JkZXJSb3dzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb2x1bW5Hcm91cHM6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50LCBnZXRDZWxsc0ZvclNlbGVjdGlvbiB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAsIHRydWUsIHRydWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiQ29sdW1uIEdyb3VwaW5nXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIENvbHVtbnMgaW4gdGhlIGRhdGEgZ3JpZCBtYXkgYmUgZ3JvdXBlZCBieSBzZXR0aW5nIHRoZWlyIDxQcm9wTmFtZT5ncm91cDwvUHJvcE5hbWU+IHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBvbkdyb3VwSGVhZGVyUmVuYW1lZD17KHgsIHkpID0+IHdpbmRvdy5hbGVydChgUGxlYXNlIHJlbmFtZSBncm91cCAke3h9IHRvICR7eX1gKX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uPXtnZXRDZWxsc0ZvclNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIGdldEdyb3VwRGV0YWlscz17ZyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBnLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiBnID09PSBcIlwiID8gdW5kZWZpbmVkIDogR3JpZENvbHVtbkljb24uSGVhZGVyQ29kZSxcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oQ29sdW1uR3JvdXBzIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBTdHJldGNoQ29sdW1uU2l6ZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uLCBvbkNvbHVtblJlc2l6ZSB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoNSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBoYXNSZXNpemVkID0gUmVhY3QudXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHMubWFwKCh4LCBpKSA9PiAoeyAuLi54LCBncm93OiBoYXNSZXNpemVkLmN1cnJlbnQuaGFzKGkpID8gdW5kZWZpbmVkIDogKDUgKyBpKSAvIDUgfSkpO1xuICAgIH0sIFtjb2xzXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb2x1bW4gR3Jvd1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBDb2x1bW5zIGluIHRoZSBkYXRhIGdyaWQgbWF5IGJlIHNldCB0byBncm93IHRvIGZpbGwgc3BhY2UgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPmdyb3c8L1Byb3BOYW1lPntcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgcHJvcC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbj17Z2V0Q2VsbHNGb3JTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17KGNvbCwgX25ld1NpemUsIGNvbEluZGV4LCBuZXdTaXplV2l0aEdyb3cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVzaXplZC5jdXJyZW50LmFkZChjb2xJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplKGNvbCwgbmV3U2l6ZVdpdGhHcm93KTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihTdHJldGNoQ29sdW1uU2l6ZSBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiB1c2VDb2xsYXBzYWJsZUNvbHVtbkdyb3Vwcyhjb2xzOiByZWFkb25seSBHcmlkQ29sdW1uW10pIHtcbiAgICBjb25zdCBbY29sbGFwc2VkLCBzZXRDb2xsYXBzZWRdID0gUmVhY3QudXNlU3RhdGU8cmVhZG9ubHkgc3RyaW5nW10+KFtdKTtcblxuICAgIGNvbnN0IG9uR3JvdXBIZWFkZXJDbGlja2VkID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjb2xJbmRleDogbnVtYmVyLCBhcmdzOiBHcm91cEhlYWRlckNsaWNrZWRFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gY29sc1tjb2xJbmRleF0uZ3JvdXAgPz8gXCJcIjtcbiAgICAgICAgICAgIHNldENvbGxhcHNlZChjdiA9PiAoY3YuaW5jbHVkZXMoZ3JvdXApID8gY3YuZmlsdGVyKGcgPT4gZyAhPT0gZ3JvdXApIDogWy4uLmN2LCBncm91cF0pKTtcbiAgICAgICAgICAgIGFyZ3MucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NvbHNdXG4gICAgKTtcblxuICAgIGNvbnN0IFtzZWxlY3RlZENvbHVtbnMsIHNldFNlbGVjdGVkQ29sdW1uc10gPSBSZWFjdC51c2VTdGF0ZTxDb21wYWN0U2VsZWN0aW9uPihDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCkpO1xuXG4gICAgY29uc3Qgc2V0Q29scyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdWYWw6IENvbXBhY3RTZWxlY3Rpb24sIHRyaWdnZXI6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodHJpZ2dlciA9PT0gXCJncm91cFwiKSByZXR1cm47XG5cbiAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKG5ld1ZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY29scy5tYXAoYyA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbGxhcHNlZC5pbmNsdWRlcyhjLmdyb3VwID8/IFwiXCIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICAgIGhhc01lbnU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgICAgICB3aWR0aDogOCxcbiAgICAgICAgICAgICAgICBoYXNNZW51OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvbGxhcHNlZCwgY29sc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1ucyxcbiAgICAgICAgb25Hcm91cEhlYWRlckNsaWNrZWQsXG4gICAgICAgIHNlbGVjdGVkQ29sdW1ucyxcbiAgICAgICAgb25TZWxlY3RlZENvbHVtbnNDaGFuZ2U6IHNldENvbHMsXG4gICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkdyb3VwQ29sbGFwc2U6IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAsIHRydWUsIHRydWUpO1xuXG4gICAgY29uc3QgZ3JvdXBIZWFkZXJBcmdzID0gdXNlQ29sbGFwc2FibGVDb2x1bW5Hcm91cHMoY29scyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJHcm91cCBjb2xsYXBzZVwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgVGhyb3VnaCBjbGV2ZXIgdXNhZ2Ugb2YgPFByb3BOYW1lPm9uR3JvdXBIZWFkZXJDbGlja2VkPC9Qcm9wTmFtZT4geW91IGNhbiBpbXBsZW1lbnQgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNpbmcuIFRoaXMgaXMgYSB2ZXJ5IGJhc2ljIHZlcnNpb24gaG93ZXZlciBpdCBpcyBwb3NzaWJsZSB0byBnbyBtdWNoIGZ1cnRoZXIuXG4gICAgICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5DZWxscyB1bmRlciBhIGNlcnRhaW4gc2l6ZSB3aWxsIG5vdCBhdHRlbXB0IHRvIHJlbmRlciB0byBzYXZlIHNvbWUgZnJhbWVzLjwvTW9yZUluZm8+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5ncm91cEhlYWRlckFyZ3N9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXsyNH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihDb2x1bW5Hcm91cENvbGxhcHNlIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBNaW5pbWFwOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJNaW5pbWFwXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbWluaW1hcCBjYW4gYmUgZW5hYmxlZCBieSBzZXR0aW5nIHRoZSA8UHJvcE5hbWU+c2hvd01pbmltYXA8L1Byb3BOYW1lPiBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBzaG93TWluaW1hcD17dHJ1ZX1cbiAgICAgICAgICAgICAgICByb3dzPXszMDAwfVxuICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihNaW5pbWFwIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBDb250ZW50QWxpZ25tZW50OiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgX3Jvd10gPSBjZWxsO1xuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdldENlbGxDb250ZW50KGNlbGwpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5nZXRDZWxsQ29udGVudChjZWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJDb250ZW50IEFsaWdubWVudFwiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgY29udGVudCBhbGlnbm1lbnQgYnkgc2V0dGluZyA8UHJvcE5hbWU+Y29udGVudEFsaWduPC9Qcm9wTmFtZT4gb2YgYSBjZWxsIHRve1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+bGVmdDwvUHJvcE5hbWU+LCA8UHJvcE5hbWU+cmlnaHQ8L1Byb3BOYW1lPiBvciA8UHJvcE5hbWU+Y2VudGVyPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvciB7Li4uZGVmYXVsdFByb3BzfSBnZXRDZWxsQ29udGVudD17bWFuZ2xlZEdldENlbGxDb250ZW50fSBjb2x1bW5zPXtjb2xzfSByb3dzPXszMDB9IC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFJvd0hvdmVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlQWxsTW9ja2VkS2luZHMoKTtcblxuICAgIGNvbnN0IFtob3ZlclJvdywgc2V0SG92ZXJSb3ddID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgW18sIHJvd10gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICBzZXRIb3ZlclJvdyhhcmdzLmtpbmQgIT09IFwiY2VsbFwiID8gdW5kZWZpbmVkIDogcm93KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRSb3dUaGVtZU92ZXJyaWRlID0gUmVhY3QudXNlQ2FsbGJhY2s8R2V0Um93VGhlbWVDYWxsYmFjaz4oXG4gICAgICAgIHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAocm93ICE9PSBob3ZlclJvdykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmdDZWxsOiBcIiNmN2Y3ZjdcIixcbiAgICAgICAgICAgICAgICBiZ0NlbGxNZWRpdW06IFwiI2YwZjBmMFwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgW2hvdmVyUm93XVxuICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJSb3cgSG92ZXIgRWZmZWN0XCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRocm91Z2ggY2FyZWZ1bCB1c2FnZSBvZiB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBjYWxsYmFjayBpdCBpcyBwb3NzaWJsZSB0byBlYXNpbHlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlIGEgcm93IGhvdmVyIGVmZmVjdC5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwiYm90aFwiXG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17b25JdGVtSG92ZXJlZH1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Um93VGhlbWVPdmVycmlkZT17Z2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNwYW5DZWxsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwLCB0cnVlLCB0cnVlKTtcblxuICAgIGNvbnN0IG1hbmdsZWRHZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrPHR5cGVvZiBnZXRDZWxsQ29udGVudD4oXG4gICAgICAgIGNlbGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAocm93ID09PSA2ICYmIGNvbCA+PSAzICYmIGNvbCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IFszLCA0XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cgPT09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogXCJTcGFuIENlbGwgdGhhdCBpcyB2ZXJ5IGxvbmcgYW5kIHdpbGwgZ28gcGFzdCB0aGUgY2VsbCBsaW1pdHNcIixcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogWzAsIDk5XSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFwiU3BhbiBDZWxsIHRoYXQgaXMgdmVyeSBsb25nIGFuZCB3aWxsIGdvIHBhc3QgdGhlIGNlbGwgbGltaXRzXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChjZWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldENlbGxDb250ZW50XVxuICAgICk7XG5cbiAgICBjb25zdCBnZXRDZWxsc0ZvclNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoc2VsZWN0aW9uOiBSZWN0YW5nbGUpOiBDZWxsQXJyYXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBHcmlkQ2VsbFtdW10gPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHNlbGVjdGlvbi55OyB5IDwgc2VsZWN0aW9uLnkgKyBzZWxlY3Rpb24uaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3c6IEdyaWRDZWxsW10gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gc2VsZWN0aW9uLng7IHggPCBzZWxlY3Rpb24ueCArIHNlbGVjdGlvbi53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKG1hbmdsZWRHZXRDZWxsQ29udGVudChbeCwgeV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgW21hbmdsZWRHZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiU3BhbnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgQnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnNwYW48L1Byb3BOYW1lPiBvZiBhIGNlbGwgeW91IGNhbiBjcmVhdGUgc3BhbnMgaW4geW91ciBncmlkLiBBbGwgY2VsbHNcbiAgICAgICAgICAgICAgICAgICAgd2l0aGluIGEgc3BhbiBtdXN0IHJldHVybiBjb25zaXN0ZW50IGRhdGEgZm9yIGRlZmluZWQgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIDxNb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNwYW5zIHdpbGwgYWx3YXlzIGJlIHNwbGl0IGlmIHRoZXkgc3BhbiBmcm96ZW4gYW5kIG5vbi1mcm96ZW4gY29sdW1ucy4gQnkgZGVmYXVsdCBzZWxlY3Rpb25zIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzIGV4cGFuZGVkIHRvIGluY2x1ZGUgYSBzcGFuLiBUaGlzIGNhbiBiZSBkaXNhYmxlZCB1c2luZyB0aGV7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+c3BhblJhbmdlQmVoYXZpb3I8L1Byb3BOYW1lPiBwcm9wLlxuICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXttYW5nbGVkR2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17Mn1cbiAgICAgICAgICAgICAgICByb3dzPXszMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFNwYW5DZWxsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmNvbnN0IHplcm9Cb3VuZHMgPSB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICByaWdodDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBUb29sdGlwczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDYpO1xuXG4gICAgY29uc3QgW3Rvb2x0aXAsIHNldFRvb2x0aXBdID0gUmVhY3QudXNlU3RhdGU8eyB2YWw6IHN0cmluZzsgYm91bmRzOiBJQm91bmRzIH0gfCB1bmRlZmluZWQ+KCk7XG5cbiAgICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzOiBHcmlkTW91c2VFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gXCJjZWxsXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHNldFRvb2x0aXAodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUb29sdGlwKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBgVG9vbHRpcCBmb3IgJHthcmdzLmxvY2F0aW9uWzBdfSwgJHthcmdzLmxvY2F0aW9uWzFdfWAsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIHJlYWN0LWxhYWcgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFyZ3MuYm91bmRzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGFyZ3MuYm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGFyZ3MuYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBhcmdzLmJvdW5kcy54ICsgYXJncy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGFyZ3MuYm91bmRzLnkgKyBhcmdzLmJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IDA7XG4gICAgICAgICAgICBzZXRUb29sdGlwKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpLCBbXSk7XG5cbiAgICBjb25zdCBpc09wZW4gPSB0b29sdGlwICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyByZW5kZXJMYXllciwgbGF5ZXJQcm9wcyB9ID0gdXNlTGF5ZXIoe1xuICAgICAgICBpc09wZW4sXG4gICAgICAgIHRyaWdnZXJPZmZzZXQ6IDQsXG4gICAgICAgIGF1dG86IHRydWUsXG4gICAgICAgIGNvbnRhaW5lcjogXCJwb3J0YWxcIixcbiAgICAgICAgdHJpZ2dlcjoge1xuICAgICAgICAgICAgZ2V0Qm91bmRzOiAoKSA9PiB0b29sdGlwPy5ib3VuZHMgPz8gemVyb0JvdW5kcyxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgICAgIHRpdGxlPVwiVG9vbHRpcHNcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvdWJsZVwiXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBVc2luZyB0aGUgPFByb3BOYW1lPm9uSXRlbUhvdmVyZWQ8L1Byb3BOYW1lPiBldmVudCBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSB0b29sdGlwcy4gVGhpcyBzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgaXMgaW50ZW50aW9uYWxseSBmb3JjZWQgdG8gc2Nyb2xsIHZlcnRpY2FsbHkgc28gbGF5b3V0IGluIHNjcm9sbGluZyBkb2N1bWVudHMgY2FuIGJlIGNvbmZpcm1lZC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICB9PlxuICAgICAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ9e29uSXRlbUhvdmVyZWR9XG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICAgICAgICAge2lzT3BlbiAmJlxuICAgICAgICAgICAgICAgIHJlbmRlckxheWVyKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4ubGF5ZXJQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGF5ZXJQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjhweCAxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250OiBcIjUwMCAxM3B4IEludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC44NSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0b29sdGlwLnZhbH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgPC8+XG4gICAgKTtcbn07XG4oVG9vbHRpcHMgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IENvbnRyb2xsZWRTZWxlY3Rpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigzMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkNvbnRyb2xsZWQgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBzZWxlY3Rpb24gb2YgdGhlIGdyaWQgY2FuIGJlIGNvbnRyb2xsZWQgdmlhIDxQcm9wTmFtZT5HcmlkU2VsZWN0aW9uPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICA8UHJvcE5hbWU+b25HcmlkU2VsZWN0aW9uQ2hhbmdlPC9Qcm9wTmFtZT4uXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbj17MH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heD17Mjl9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2VsZWN0aW9uLmN1cnJlbnQ/LmNlbGxbMF0gPz8gMH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2wgPSBlLnRhcmdldC52YWx1ZUFzTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvbihjdiA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbDogW25ld0NvbCwgY3YuY3VycmVudD8uY2VsbFsxXSA/PyAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogbmV3Q29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN2LmN1cnJlbnQ/LmNlbGxbMV0gPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFjazogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4PXs5OX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxlY3Rpb24uY3VycmVudD8uY2VsbFsxXSA/PyAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGUudGFyZ2V0LnZhbHVlQXNOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKGN2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsOiBbY3YuY3VycmVudD8uY2VsbFswXSA/PyAwLCBuZXdSb3ddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjdi5jdXJyZW50Py5jZWxsWzBdID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogbmV3Um93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgb25HcmlkU2VsZWN0aW9uQ2hhbmdlPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTmV3Q29sdW1uQnV0dG9uOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAsIHRydWUpO1xuXG4gICAgY29uc3QgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29scy5tYXAoYyA9PiAoeyAuLi5jLCBncm93OiAxIH0pKSwgW2NvbHNdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIk5ldyBjb2x1bW4gYnV0dG9uXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIEEgbmV3IGNvbHVtbiBidXR0b24gY2FuIGJlIGNyZWF0ZWQgdXNpbmcgdGhlIDxQcm9wTmFtZT5yaWdodEVsZW1lbnQ8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnQ9e1xuICAgICAgICAgICAgICAgICAgICA8Q29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB3aW5kb3cuYWxlcnQoXCJBZGQgYSBjb2x1bW4hXCIpfT4rPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvQ29sdW1uQWRkQnV0dG9uPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByaWdodEVsZW1lbnRQcm9wcz17e1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ3VzdG9tSGVhZGVyOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkcmF3SGVhZGVyOiBEcmF3SGVhZGVyQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhhcmdzID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHJlY3QgfSA9IGFyZ3M7XG4gICAgICAgIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGxnID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIHJlY3QueSwgMCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICBsZy5hZGRDb2xvclN0b3AoMCwgXCIjZmYwMGQ5MzRcIik7XG4gICAgICAgIGxnLmFkZENvbG9yU3RvcCgxLCBcIiMwMGEyZmYzNFwiKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxnO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXIgdGl0bGU9XCJDdXN0b20gSGVhZGVyXCIgZGVzY3JpcHRpb249ezxEZXNjcmlwdGlvbj5NYWtlIGl0IGFzIGZhbmN5IGFzIHlvdSBsaWtlLjwvRGVzY3JpcHRpb24+fT5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtkcmF3SGVhZGVyfVxuICAgICAgICAgICAgICAgIHJvd3M9ezMwMDB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKEN1c3RvbUhlYWRlciBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5pbnRlcmZhY2UgUGFkZGluZ1Byb3BzIHtcbiAgICBwYWRkaW5nUmlnaHQ6IG51bWJlcjtcbiAgICBwYWRkaW5nQm90dG9tOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBQYWRkaW5nOiBSZWFjdC5WRkM8UGFkZGluZ1Byb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBwO1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQgfSA9IHVzZU1vY2tEYXRhR2VuZXJhdG9yKDIwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlBhZGRpbmdcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gYWRkIHBhZGRpbmcgYXQgdGhlIGVuZHMgb2YgdGhlIGdyaWQgYnkgc2V0dGluZyB0aGUgPFByb3BOYW1lPnBhZGRpbmdSaWdodDwvUHJvcE5hbWU+IGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm9wTmFtZT5wYWRkaW5nQm90dG9tPC9Qcm9wTmFtZT4gcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz17XCJib3RoXCJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt7IHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSB9fVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdUeXBlcyA9IHtcbiAgICBwYWRkaW5nUmlnaHQ6IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiA2MDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwYWRkaW5nQm90dG9tOiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogNjAwLFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuKFBhZGRpbmcgYXMgYW55KS5hcmdzID0ge1xuICAgIHBhZGRpbmdSaWdodDogMjAwLFxuICAgIHBhZGRpbmdCb3R0b206IDIwMCxcbn07XG4oUGFkZGluZyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IHRydWUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHRDZWxsczogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDApO1xuXG4gICAgY29uc3QgW2dyaWRTZWxlY3Rpb24sIHNldEdyaWRTZWxlY3Rpb25dID0gUmVhY3QudXNlU3RhdGU8R3JpZFNlbGVjdGlvbj4oe1xuICAgICAgICBjb2x1bW5zOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGhpZ2hsaWdodHMgPSBSZWFjdC51c2VNZW1vPERhdGFFZGl0b3JQcm9wc1tcImhpZ2hsaWdodFJlZ2lvbnNcIl0+KCgpID0+IHtcbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGw7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFwiIzQ0QkIwMDIyXCIsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29sICsgMixcbiAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjYjAwMGIwMjFcIixcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJvdyArIDIsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSwgW2dyaWRTZWxlY3Rpb25dKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIkhpZ2hsaWdodENlbGxzXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIFRoZSA8UHJvcE5hbWU+aGlnaGxpZ2h0UmVnaW9uczwvUHJvcE5hbWU+IHByb3AgY2FuIGJlIHNldCB0byBwcm92aWRlIGFkZGl0aW9uYWwgaGludGluZyBvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICBncmlkU2VsZWN0aW9uPXtncmlkU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIG9uR3JpZFNlbGVjdGlvbkNoYW5nZT17c2V0R3JpZFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17Z2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbHNGb3JTZWxlY3Rpb249e2dldENlbGxzRm9yU2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgdmVydGljYWxCb3JkZXI9e2MgPT4gYyA+IDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwMH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvQmVhdXRpZnVsV3JhcHBlcj5cbiAgICApO1xufTtcbihIaWdobGlnaHRDZWxscyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgTGF5b3V0SW50ZWdyYXRpb246IFJlYWN0LlZGQyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbHMsIGdldENlbGxDb250ZW50IH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigxMDAwLCB0cnVlLCB0cnVlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxTdHlsZT5cbiAgICAgICAgICAgIDxoMT5MYXlvdXQgSW50ZWdyYXRpb248L2gxPlxuICAgICAgICAgICAgPERlc2NyaXB0aW9uPlRyeWluZyB0aGUgZ3JpZCBpbiBkaWZmZXJlbnQgc2l0dWF0aW9uczwvRGVzY3JpcHRpb24+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93cz17MTB9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIGhlaWdodD17MjAwfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxEYXRhRWRpdG9yIHsuLi5kZWZhdWx0UHJvcHN9IGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH0gY29sdW1ucz17Y29sc30gcm93cz17MTB9IHJvd01hcmtlcnM9XCJib3RoXCIgLz5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGhlaWdodDogXCIzMDBweFwiIH19PlxuICAgICAgICAgICAgICAgIDxEYXRhRWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICAgICAgcm93cz17MTB9XG4gICAgICAgICAgICAgICAgICAgIHJvd01hcmtlcnM9XCJib3RoXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleFNocmluazogMCB9fT5UaGlzIGlzIHNvbWUgdGV4dCB3aGF0IGhhcHBlbnMgaGVyZT88L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0JlYXV0aWZ1bFN0eWxlPlxuICAgICk7XG59O1xuKExheW91dEludGVncmF0aW9uIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBEcmFnU291cmNlOiBSZWFjdC5WRkM8eyBpc0RyYWdnYWJsZTogYm9vbGVhbiB8IFwiaGVhZGVyXCIgfCBcImNlbGxcIiB9PiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplIH0gPSB1c2VNb2NrRGF0YUdlbmVyYXRvcigyMDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFdyYXBwZXJcbiAgICAgICAgICAgIHRpdGxlPVwiRHJhZyBzb3VyY2VcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249e1xuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxEZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmcgdGhlIDxQcm9wTmFtZT5pc0RyYWdnYWJsZTwvUHJvcE5hbWU+IHByb3AgY2FuIGFsbG93IGZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wgb3ZlciB3aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyBkcmFnZ2FibGUgaW4gdGhlIGdyaWQgdmlhIEhUTUwgZHJhZyBhbmQgZHJvcC5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcm93TWFya2Vycz1cImJvdGhcIlxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17KHMsIGUpID0+IHdpbmRvdy5hbGVydChgTW92ZWQgcm93ICR7c30gdG8gJHtlfWApfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9eyhzLCBlKSA9PiB3aW5kb3cuYWxlcnQoYE1vdmVkIGNvbCAke3N9IHRvICR7ZX1gKX1cbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZT17b25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIFwiRHJhZyBkYXRhIGhlcmUhXCIpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJhZ1NvdXJjZSBhcyBhbnkpLmFyZ1R5cGVzID0ge1xuICAgIGlzRHJhZ2dhYmxlOiB7XG4gICAgICAgIGNvbnRyb2w6IHsgdHlwZTogXCJzZWxlY3RcIiwgb3B0aW9uczogW3RydWUsIGZhbHNlLCBcImNlbGxcIiwgXCJoZWFkZXJcIl0gfSxcbiAgICB9LFxufTtcbihEcmFnU291cmNlIGFzIGFueSkuYXJncyA9IHtcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG59O1xuKERyYWdTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiB0cnVlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgUHJldmVudERpYWdvbmFsU2Nyb2xsOiBSZWFjdC5WRkMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb2xzLCBnZXRDZWxsQ29udGVudCB9ID0gdXNlTW9ja0RhdGFHZW5lcmF0b3IoMjAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCZWF1dGlmdWxXcmFwcGVyXG4gICAgICAgICAgICB0aXRsZT1cIlByZXZlbnQgRGlhZ29uYWwgU2Nyb2xsXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICA8RGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICBEaWFnb25hbCBzY3JvbGxpbmcgY2FuIGJlIHByZXZlbnRlZCBieSBzZXR0aW5nIDxQcm9wTmFtZT5wcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc8L1Byb3BOYW1lPi5cbiAgICAgICAgICAgICAgICAgICAgPC9EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIH0+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nPXt0cnVlfVxuICAgICAgICAgICAgICAgIHJvd3M9ezUwMDB9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oUHJldmVudERpYWdvbmFsU2Nyb2xsIGFzIGFueSkucGFyYW1ldGVycyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHNob3dQYW5lbDogZmFsc2UsXG4gICAgfSxcbn07XG5cbi8vIEEgZmV3IHN1cHBvcnRlZCBtaW1lIHR5cGVzIGZvciBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMuXG5jb25zdCBTVVBQT1JURURfSU1BR0VfVFlQRVMgPSBuZXcgU2V0KFtcImltYWdlL3BuZ1wiLCBcImltYWdlL2dpZlwiLCBcImltYWdlL2JtcFwiLCBcImltYWdlL2pwZWdcIl0pO1xuXG5leHBvcnQgY29uc3QgRHJvcEV2ZW50czogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY29scywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uUmVzaXplLCBzZXRDZWxsVmFsdWUgfSA9IHVzZUFsbE1vY2tlZEtpbmRzKCk7XG5cbiAgICBjb25zdCBbaGlnaGxpZ2h0cywgc2V0SGlnaGxpZ2h0c10gPSBSZWFjdC51c2VTdGF0ZTxEYXRhRWRpdG9yUHJvcHNbXCJoaWdobGlnaHRSZWdpb25zXCJdPihbXSk7XG5cbiAgICBjb25zdCBbbGFzdERyb3BDZWxsLCBzZXRMYXN0RHJvcENlbGxdID0gUmVhY3QudXNlU3RhdGU8SXRlbSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IG9uRHJvcCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoY2VsbDogSXRlbSwgZGF0YVRyYW5zZmVyOiBEYXRhVHJhbnNmZXIgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcblxuICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBmaWxlcyB9ID0gZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IHN1cHBvcnRzIG9uZSBpbWFnZSwgZm9yIHNpbXBsaWNpdHkuXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBbZmlsZV0gPSBmaWxlcztcbiAgICAgICAgICAgIGlmICghU1VQUE9SVEVEX0lNQUdFX1RZUEVTLmhhcyhmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbWdVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuXG4gICAgICAgICAgICBzZXRDZWxsVmFsdWUoXG4gICAgICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5JbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2ltZ1VybF0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dBZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzZXRMYXN0RHJvcENlbGwoY2VsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtzZXRDZWxsVmFsdWVdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ092ZXJDZWxsID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChjZWxsOiBJdGVtLCBkYXRhVHJhbnNmZXI6IERhdGFUcmFuc2ZlciB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbXMgfSA9IGRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIC8vIFRoaXMgb25seSBzdXBwb3J0cyBvbmUgaW1hZ2UsIGZvciBzaW1wbGljaXR5LlxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2l0ZW1dID0gaXRlbXM7XG4gICAgICAgICAgICBpZiAoIVNVUFBPUlRFRF9JTUFHRV9UWVBFUy5oYXMoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgICAgICBpZiAoZ2V0Q2VsbENvbnRlbnQoY2VsbCkua2luZCA9PT0gR3JpZENlbGxLaW5kLkltYWdlKSB7XG4gICAgICAgICAgICAgICAgc2V0SGlnaGxpZ2h0cyhbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiM0NEJCMDAyMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEhpZ2hsaWdodHMoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbZ2V0Q2VsbENvbnRlbnRdXG4gICAgKTtcblxuICAgIGNvbnN0IG9uRHJhZ0xlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRIaWdobGlnaHRzKFtdKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlclxuICAgICAgICAgICAgdGl0bGU9XCJEcm9wIGV2ZW50c1wiXG4gICAgICAgICAgICBkZXNjcmlwdGlvbj17XG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPERlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBkcmFnIGFuZCBkcm9wIGludG8gY2VsbHMgYnkgdXNpbmcgPFByb3BOYW1lPm9uRHJhZ092ZXJDZWxsPC9Qcm9wTmFtZT4gYW5ke1wiIFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPFByb3BOYW1lPm9uRHJvcDwvUHJvcE5hbWU+LlxuICAgICAgICAgICAgICAgICAgICA8L0Rlc2NyaXB0aW9uPlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7bGFzdERyb3BDZWxsID09PSB1bmRlZmluZWQgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPk5vdGhpbmcgZHJvcHBlZCwgeWV0PC9Nb3JlSW5mbz5cbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWW91IGxhc3QgZHJvcHBlZCBpbiBjZWxsIDxQcm9wTmFtZT57SlNPTi5zdHJpbmdpZnkobGFzdERyb3BDZWxsKX08L1Byb3BOYW1lPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L01vcmVJbmZvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIGdldENlbGxDb250ZW50PXtnZXRDZWxsQ29udGVudH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2xzfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17c2V0Q2VsbFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPXtvbkNvbHVtblJlc2l6ZX1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDAwfVxuICAgICAgICAgICAgICAgIG9uRHJvcD17b25Ecm9wfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtvbkRyYWdPdmVyQ2VsbH1cbiAgICAgICAgICAgICAgICBvbkRyYWdMZWF2ZT17b25EcmFnTGVhdmV9XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0UmVnaW9ucz17aGlnaGxpZ2h0c31cbiAgICAgICAgICAgICAgICByb3dNYXJrZXJzPVwibm9uZVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0JlYXV0aWZ1bFdyYXBwZXI+XG4gICAgKTtcbn07XG4oRHJvcEV2ZW50cyBhcyBhbnkpLnBhcmFtZXRlcnMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBzaG93UGFuZWw6IGZhbHNlLFxuICAgIH0sXG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".b1nvh7n2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.b1nvh7n2 > a{margin-bottom:20px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItcmVwcm9zLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5iMW52aDduMiJdLCJtYXBwaW5ncyI6IkFBOEJNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLXJlcHJvcy5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gXCJAc3Rvcnlib29rL2FkZG9uc1wiO1xuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB0aXRsZTogXCJUZXN0cy9UZXN0Q2FzZXMvQnVnc1wiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxMDAwfSBoZWlnaHQ9ezgwMH0+XG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGJ1ZzcwR2VuID0gKFssIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTnVtYmVyLFxuICAgIGRhdGE6IHJvdyxcbiAgICBkaXNwbGF5RGF0YTogcm93LnRvU3RyaW5nKCksXG59KTtcblxuY29uc3QgaWdub3JlID0gKCkgPT4gdW5kZWZpbmVkO1xuXG5jb25zdCBCdWc3MFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICA+IGEge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBCdWc3MCgpIHtcbiAgICBjb25zdCBjb2xzID0gW1xuICAgICAgICB7IHRpdGxlOiBcIkNvbDFcIiwgd2lkdGg6IDEwMCB9LFxuICAgICAgICB7IHRpdGxlOiBcIkNvbDJcIiwgd2lkdGg6IDEwMCB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XCJBcHBcIj5cbiAgICAgICAgICAgIDxwPlRvIGNhdXNlIGVycm9yOiBzY3JvbGwgZG93biBhdCBsZWFzdCBvbmUgcm93LCBlZGl0IGEgY2VsbCBpbiBDb2wyLCBhbmQgaGl0IFRhYjwvcD5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9pc3N1ZXMvNzBcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+XG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXs1MDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2J1ZzcwR2VufVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CdWc3MFN0eWxlPlxuICAgICk7XG59XG5cbmNvbnN0IGZpbHRlckNvbHVtbnNHZW4gPSAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgIGRhdGE6IGAke2NvbH0gLSAke3Jvd31gLFxuICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcbn0pO1xuXG5jb25zdCBmaWx0ZXJpbmdDb2x1bW5zID0gW1xuICAgIHsgdGl0bGU6IFwiQ29sIEFBQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFBQVwiLCB3aWR0aDogMTIwIH0sXG4gICAgeyB0aXRsZTogXCJDb2wgQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sXCIsIHdpZHRoOiAxMjAgfSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBGaWx0ZXJDb2x1bW5zKCkge1xuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gICAgY29uc3QgY29scyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2VhcmNoVGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmluZ0NvbHVtbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucy5maWx0ZXIoYyA9PiBjLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgfSwgW3NlYXJjaFRleHRdKTtcblxuICAgIGNvbnN0IG9uSW5wdXRDaGFuZ2UgPSAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgc2V0U2VhcmNoVGV4dChlLnRhcmdldC52YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9e3NlYXJjaFRleHR9IG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfSAvPlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB3aWR0aD17MTAwMH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17ZmlsdGVyQ29sdW1uc0dlbn1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXt0cnVlfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufVxuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-editor/stories/packages/core/src/data-editor/stories/data-editor-repros.stories.tsx","webpack://./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx"],"names":[".b1nvh7n2"],"mappings":"AA8BMA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,cAAAA,kBAAAA,CAAAA;AC7BN,mwIAAmwI","sourcesContent":["import * as React from \"react\";\n\nimport { useState, useMemo } from \"@storybook/addons\";\nimport { BuilderThemeWrapper } from \"../../stories/story-utils\";\n\nimport { GridCell, GridCellKind, Item } from \"../../data-grid/data-grid-types\";\nimport { DataEditor } from \"../data-editor\";\nimport { styled } from \"@linaria/react\";\n\nexport default {\n    title: \"Tests/TestCases/Bugs\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <BuilderThemeWrapper width={1000} height={800}>\n                <Story />\n            </BuilderThemeWrapper>\n        ),\n    ],\n};\n\nconst bug70Gen = ([, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Number,\n    data: row,\n    displayData: row.toString(),\n});\n\nconst ignore = () => undefined;\n\nconst Bug70Style = styled.div`\n    display: flex;\n    flex-direction: column;\n\n    > a {\n        margin-bottom: 20px;\n    }\n`;\n\nexport function Bug70() {\n    const cols = [\n        { title: \"Col1\", width: 100 },\n        { title: \"Col2\", width: 100 },\n    ];\n\n    return (\n        <Bug70Style className=\"App\">\n            <p>To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab</p>\n            <a href=\"https://github.com/glideapps/glide-data-grid/issues/70\" target=\"_blank\" rel=\"noreferrer\">\n                Original report\n            </a>\n            <DataEditor\n                width={500}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={bug70Gen}\n                onCellEdited={ignore}\n            />\n        </Bug70Style>\n    );\n}\n\nconst filterColumnsGen = ([col, row]: Item): GridCell => ({\n    allowOverlay: true,\n    kind: GridCellKind.Text,\n    data: `${col} - ${row}`,\n    displayData: `${col} - ${row}`,\n});\n\nconst filteringColumns = [\n    { title: \"Col AAAA\", width: 120 },\n    { title: \"Col AAA\", width: 120 },\n    { title: \"Col AA\", width: 120 },\n    { title: \"Col A\", width: 120 },\n    { title: \"Col\", width: 120 },\n];\n\nexport function FilterColumns() {\n    const [searchText, setSearchText] = useState(\"\");\n\n    const cols = useMemo(() => {\n        if (searchText === \"\") {\n            return filteringColumns;\n        }\n\n        return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));\n    }, [searchText]);\n\n    const onInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        setSearchText(e.target.value);\n    };\n\n    return (\n        <div>\n            <input value={searchText} onChange={onInputChange} />\n            <DataEditor\n                width={1000}\n                height={500}\n                rows={100}\n                columns={cols}\n                getCellContent={filterColumnsGen}\n                smoothScrollX={true}\n                smoothScrollY={true}\n            />\n        </div>\n    );\n}\n",".b1nvh7n2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.b1nvh7n2 > a{margin-bottom:20px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvZGF0YS1lZGl0b3ItcmVwcm9zLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5iMW52aDduMiJdLCJtYXBwaW5ncyI6IkFBOEJNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL2RhdGEtZWRpdG9yLXJlcHJvcy5zdG9yaWVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gXCJAc3Rvcnlib29rL2FkZG9uc1wiO1xuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi8uLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5cbmltcG9ydCB7IEdyaWRDZWxsLCBHcmlkQ2VsbEtpbmQsIEl0ZW0gfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciB9IGZyb20gXCIuLi9kYXRhLWVkaXRvclwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICB0aXRsZTogXCJUZXN0cy9UZXN0Q2FzZXMvQnVnc1wiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxCdWlsZGVyVGhlbWVXcmFwcGVyIHdpZHRoPXsxMDAwfSBoZWlnaHQ9ezgwMH0+XG4gICAgICAgICAgICAgICAgPFN0b3J5IC8+XG4gICAgICAgICAgICA8L0J1aWxkZXJUaGVtZVdyYXBwZXI+XG4gICAgICAgICksXG4gICAgXSxcbn07XG5cbmNvbnN0IGJ1ZzcwR2VuID0gKFssIHJvd106IEl0ZW0pOiBHcmlkQ2VsbCA9PiAoe1xuICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTnVtYmVyLFxuICAgIGRhdGE6IHJvdyxcbiAgICBkaXNwbGF5RGF0YTogcm93LnRvU3RyaW5nKCksXG59KTtcblxuY29uc3QgaWdub3JlID0gKCkgPT4gdW5kZWZpbmVkO1xuXG5jb25zdCBCdWc3MFN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICA+IGEge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBmdW5jdGlvbiBCdWc3MCgpIHtcbiAgICBjb25zdCBjb2xzID0gW1xuICAgICAgICB7IHRpdGxlOiBcIkNvbDFcIiwgd2lkdGg6IDEwMCB9LFxuICAgICAgICB7IHRpdGxlOiBcIkNvbDJcIiwgd2lkdGg6IDEwMCB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QnVnNzBTdHlsZSBjbGFzc05hbWU9XCJBcHBcIj5cbiAgICAgICAgICAgIDxwPlRvIGNhdXNlIGVycm9yOiBzY3JvbGwgZG93biBhdCBsZWFzdCBvbmUgcm93LCBlZGl0IGEgY2VsbCBpbiBDb2wyLCBhbmQgaGl0IFRhYjwvcD5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9pc3N1ZXMvNzBcIiB0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub3JlZmVycmVyXCI+XG4gICAgICAgICAgICAgICAgT3JpZ2luYWwgcmVwb3J0XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8RGF0YUVkaXRvclxuICAgICAgICAgICAgICAgIHdpZHRoPXs1MDB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXs1MDB9XG4gICAgICAgICAgICAgICAgcm93cz17MTAwfVxuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2J1ZzcwR2VufVxuICAgICAgICAgICAgICAgIG9uQ2VsbEVkaXRlZD17aWdub3JlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CdWc3MFN0eWxlPlxuICAgICk7XG59XG5cbmNvbnN0IGZpbHRlckNvbHVtbnNHZW4gPSAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgIGRhdGE6IGAke2NvbH0gLSAke3Jvd31gLFxuICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9IC0gJHtyb3d9YCxcbn0pO1xuXG5jb25zdCBmaWx0ZXJpbmdDb2x1bW5zID0gW1xuICAgIHsgdGl0bGU6IFwiQ29sIEFBQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFBQVwiLCB3aWR0aDogMTIwIH0sXG4gICAgeyB0aXRsZTogXCJDb2wgQUFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sIEFcIiwgd2lkdGg6IDEyMCB9LFxuICAgIHsgdGl0bGU6IFwiQ29sXCIsIHdpZHRoOiAxMjAgfSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBGaWx0ZXJDb2x1bW5zKCkge1xuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gICAgY29uc3QgY29scyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2VhcmNoVGV4dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmluZ0NvbHVtbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyaW5nQ29sdW1ucy5maWx0ZXIoYyA9PiBjLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgfSwgW3NlYXJjaFRleHRdKTtcblxuICAgIGNvbnN0IG9uSW5wdXRDaGFuZ2UgPSAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgc2V0U2VhcmNoVGV4dChlLnRhcmdldC52YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9e3NlYXJjaFRleHR9IG9uQ2hhbmdlPXtvbklucHV0Q2hhbmdlfSAvPlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB3aWR0aD17MTAwMH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezUwMH1cbiAgICAgICAgICAgICAgICByb3dzPXsxMDB9XG4gICAgICAgICAgICAgICAgY29sdW1ucz17Y29sc31cbiAgICAgICAgICAgICAgICBnZXRDZWxsQ29udGVudD17ZmlsdGVyQ29sdW1uc0dlbn1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxYPXt0cnVlfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufVxuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".c4uqbye{width:120px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#f1f1f1;height:100%;}.c4uqbye button{border:none;outline:none;height:37px;width:120px;font-size:20px;background-color:#f7f7f8;color:#000000dd;border-bottom:1px solid #e1e2e5;-webkit-transition:background-color 200ms;transition:background-color 200ms;cursor:pointer;}.c4uqbye button:hover{background-color:#efeff1;}\n.b1bsqg7n{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b1bsqg7n.double{height:200vh;}.b1bsqg7n > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b1bsqg7n .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b1bsqg7n .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}.b1bsqg7n.firefox .sizer{border-radius:0;box-shadow:unset;}.b1bsqg7n.firefox .sizer .sizer-clip{border-radius:0;}.b1bsqg7n .white{background-color:white;}\n.piiq54i{font-family:monospace;font-weight:500;color:#ffe394;}\n.d1k3yj19{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.m1j0dy02{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1j0dy02 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5jNHVxYnllIiwiLmIxYnNxZzduIiwiLnBpaXE1NGkiLCIuZDFrM3lqMTkiLCIubTFqMGR5MDIiXSwibWFwcGluZ3MiOiJBQXdIYUE7QUF5QkFDO0FBdURBQztBQU1BQztBQU1BQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL3V0aWxzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQge1xuICAgIENlbGxBcnJheSxcbiAgICBFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEdyaWRDZWxsLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBHcmlkQ29sdW1uLFxuICAgIEdyaWRDb2x1bW5JY29uLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBpc1RleHRFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEl0ZW0sXG4gICAgUmVjdGFuZ2xlLFxufSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBpc0FycmF5IGZyb20gXCJsb2Rhc2gvaXNBcnJheS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3N1cHBvcnRcIjtcbmltcG9ydCB7IGJyb3dzZXJJc0ZpcmVmb3ggfSBmcm9tIFwiLi4vLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCJyZWFjdC1yZXNpemUtZGV0ZWN0b3JcIjtcblxuZmFrZXIuc2VlZCgxMzM3KTtcblxuZnVuY3Rpb24gaXNUcnV0aHkoeDogYW55KTogYm9vbGVhbiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgIHJldHVybiB4ID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNvcHkgZGF0YSBiZXR3ZWVuIGdyaWQgY2VsbHMgb2YgYW55IGtpbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3NzeUNvcHlEYXRhPFQgZXh0ZW5kcyBFZGl0YWJsZUdyaWRDZWxsPihzb3VyY2U6IEVkaXRhYmxlR3JpZENlbGwsIHRhcmdldDogVCk6IEVkaXRhYmxlR3JpZENlbGwge1xuICAgIGNvbnN0IHNvdXJjZURhdGEgPSBzb3VyY2UuZGF0YTtcbiAgICBpZiAodHlwZW9mIHNvdXJjZURhdGEgPT09IHR5cGVvZiB0YXJnZXQuZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YSBhcyBhbnksXG4gICAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICAgIHN3aXRjaCAodGFyZ2V0LmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uua2luZCA9PT0gR3JpZENlbGxLaW5kLkJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGlzVHJ1dGh5KHNvdXJjZURhdGEpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbc291cmNlRGF0YVswXV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW3NvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIl0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk51bWJlcjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVGV4dDpcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk1hcmtkb3duOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlLmRhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQ3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIGRlZmF1bHRcbiAgICAgICAgfVxuICAgIGFzc2VydE5ldmVyKHRhcmdldCk7XG59XG5cbmV4cG9ydCB0eXBlIEdyaWRDb2x1bW5XaXRoTW9ja2luZ0luZm8gPSBHcmlkQ29sdW1uICYge1xuICAgIGdldENvbnRlbnQoKTogR3JpZENlbGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R3JpZENvbHVtbihjb2x1bW5XaXRoTW9jazogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mbyk6IEdyaWRDb2x1bW4ge1xuICAgIGNvbnN0IHsgZ2V0Q29udGVudCwgLi4ucmVzdCB9ID0gY29sdW1uV2l0aE1vY2s7XG5cbiAgICByZXR1cm4gcmVzdDtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkFkZEJ1dHRvbiA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDEyMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjFmMWYxO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBidXR0b24ge1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGhlaWdodDogMzdweDtcbiAgICAgICAgd2lkdGg6IDEyMHB4O1xuICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjg7XG4gICAgICAgIGNvbG9yOiAjMDAwMDAwZGQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTFlMmU1O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VmZWZmMTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmLmRvdWJsZSB7XG4gICAgICAgIGhlaWdodDogMjAwdmg7XG4gICAgfVxuXG4gICAgJiA+IGgxIHtcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xuICAgIH1cblxuICAgIC5zaXplciB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcblxuICAgICAgICAuc2l6ZXItY2xpcCB7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcblxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5maXJlZm94IC5zaXplciB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIGJveC1zaGFkb3c6IHVuc2V0O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAud2hpdGUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxXcmFwcGVyOiBSZWFjdC5GQzxCZWF1dGlmdWxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24sIGNsYXNzTmFtZSB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlIGNsYXNzTmFtZT17Y2xhc3NOYW1lICsgKGJyb3dzZXJJc0ZpcmVmb3gudmFsdWUgPyBcIiBmaXJlZm94XCIgOiBcIlwiKX0+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dENvbHVtbkluZm8oaW5kZXg6IG51bWJlciwgZ3JvdXA6IGJvb2xlYW4pOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogYENvbHVtbiAke2luZGV4fWAsXG4gICAgICAgIGlkOiBgQ29sdW1uICR7aW5kZXh9YCxcbiAgICAgICAgZ3JvdXA6IGdyb3VwID8gYEdyb3VwICR7TWF0aC5yb3VuZChpbmRleCAvIDMpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBmYWtlci5sb3JlbS53b3JkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6YWJsZUNvbHVtbnMoYW1vdW50OiBudW1iZXIsIGdyb3VwOiBib29sZWFuKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sdW1uczogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIk5hbWVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TmFtZSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTGFzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJMYXN0IG5hbWVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiTmFtZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGFzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkF2YXRhclwiLFxuICAgICAgICAgICAgaWQ6IFwiQXZhdGFyXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYGh0dHBzOi8vcGljc3VtLnBob3Rvcy9pZC8ke259LzkwMC85MDBgXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFtgaHR0cHM6Ly9waWNzdW0ucGhvdG9zL2lkLyR7bn0vNDAvNDBgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0FkZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJFbWFpbFwiLFxuICAgICAgICAgICAgaWQ6IFwiRW1haWxcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBmYWtlci5pbnRlcm5ldC5lbWFpbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgaWQ6IFwiVGl0bGVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFueSA9IGZha2VyLm5hbWUuam9iVGl0bGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1vcmUgSW5mb1wiLFxuICAgICAgICAgICAgaWQ6IFwiTW9yZSBJbmZvXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclVyaSxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGZha2VyLmludGVybmV0LnVybCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5VcmksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgaWYgKGFtb3VudCA8IGRlZmF1bHRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvbHVtbnMuc2xpY2UoMCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYUNvbHVtbnNBbW91bnQgPSBhbW91bnQgLSBkZWZhdWx0Q29sdW1ucy5sZW5ndGg7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1uZXctYXJyYXlcbiAgICBjb25zdCBleHRyYUNvbHVtbnMgPSBbLi4ubmV3IEFycmF5KGV4dHJhQ29sdW1uc0Ftb3VudCldLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAgIGNyZWF0ZVRleHRDb2x1bW5JbmZvKGluZGV4ICsgZGVmYXVsdENvbHVtbnMubGVuZ3RoLCBncm91cClcbiAgICApO1xuXG4gICAgcmV0dXJuIFsuLi5kZWZhdWx0Q29sdW1ucywgLi4uZXh0cmFDb2x1bW5zXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRDYWNoZSB7XG4gICAgLy8gY29sdW1uIC0+IHJvdyAtPiB2YWx1ZVxuICAgIHByaXZhdGUgY2FjaGVkQ29udGVudDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgR3JpZENlbGw+PiA9IG5ldyBNYXAoKTtcblxuICAgIGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY29sQ2FjaGUgPSB0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCk7XG5cbiAgICAgICAgaWYgKGNvbENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sQ2FjaGUuZ2V0KHJvdyk7XG4gICAgfVxuXG4gICAgc2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IEdyaWRDZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRDb250ZW50LnNldChjb2wsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3dDYWNoZSA9IHRoaXMuY2FjaGVkQ29udGVudC5nZXQoY29sKSBhcyBNYXA8bnVtYmVyLCBHcmlkQ2VsbD47XG4gICAgICAgIHJvd0NhY2hlLnNldChyb3csIHZhbHVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2NrRGF0YUdlbmVyYXRvcihudW1Db2xzOiBudW1iZXIsIHJlYWRvbmx5OiBib29sZWFuID0gdHJ1ZSwgZ3JvdXA6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGdldFJlc2l6YWJsZUNvbHVtbnMobnVtQ29scywgZ3JvdXApKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAoZ2V0UmVzaXphYmxlQ29sdW1ucyhudW1Db2xzLCBncm91cCkpO1xuICAgIH0sIFtncm91cCwgbnVtQ29sc10pO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgY29sc01hcFJlZiA9IFJlYWN0LnVzZVJlZihjb2xzTWFwKTtcbiAgICBjb2xzTWFwUmVmLmN1cnJlbnQgPSBjb2xzTWFwO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGNvbHNNYXBSZWYuY3VycmVudFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRvbmx5ICYmIGlzVGV4dEVkaXRhYmxlR3JpZENlbGwodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB7IC4uLnZhbCwgcmVhZG9ubHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbcmVhZG9ubHldXG4gICAgKTtcblxuICAgIGNvbnN0IGdldENlbGxzRm9yU2VsZWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChzZWxlY3Rpb246IFJlY3RhbmdsZSk6IENlbGxBcnJheSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEdyaWRDZWxsW11bXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gc2VsZWN0aW9uLnk7IHkgPCBzZWxlY3Rpb24ueSArIHNlbGVjdGlvbi5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdzogR3JpZENlbGxbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBzZWxlY3Rpb24ueDsgeCA8IHNlbGVjdGlvbi54ICsgc2VsZWN0aW9uLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZ2V0Q2VsbENvbnRlbnQoW3gsIHldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIFtnZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlUmF3ID0gUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd106IEl0ZW0sIHZhbDogR3JpZENlbGwpOiB2b2lkID0+IHtcbiAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlR3JpZENlbGwodmFsKSAmJiBpc0VkaXRhYmxlR3JpZENlbGwoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWQgPSBsb3NzeUNvcHlEYXRhKHZhbCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29waWVkLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdHlwZW9mIGNvcGllZC5kYXRhID09PSBcInN0cmluZ1wiID8gY29waWVkLmRhdGEgOiAoY29waWVkIGFzIGFueSkuZGlzcGxheURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtjb2xzTWFwXVxuICAgICk7XG5cbiAgICByZXR1cm4geyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24sIHNldENlbGxWYWx1ZVJhdyB9O1xufVxuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-editor/stories/packages/core/src/data-editor/stories/utils.tsx","webpack://./packages/core/src/data-editor/stories/utils.tsx"],"names":[".c4uqbye",".b1bsqg7n",".piiq54i",".d1k3yj19",".m1j0dy02"],"mappings":"AAwHaA,SAAAA,WAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,wBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,gBAAAA,WAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,wBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,wBAAAA,CAAAA;AAyBAC,UAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iBAAAA,YAAAA,CAAAA,CAAAA,eAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,6BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yBAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,qCAAAA,eAAAA,CAAAA,CAAAA,iBAAAA,sBAAAA,CAAAA;AAuDAC,SAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA;AAMAC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AAMAC,UAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,iBAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA;AC/Mb,u1oBAAu1oB","sourcesContent":["import * as React from \"react\";\n\nimport {\n    CellArray,\n    EditableGridCell,\n    GridCell,\n    GridCellKind,\n    GridColumn,\n    GridColumnIcon,\n    isEditableGridCell,\n    isTextEditableGridCell,\n    Item,\n    Rectangle,\n} from \"../../data-grid/data-grid-types\";\n\nimport faker from \"faker\";\nimport { styled } from \"@linaria/react\";\nimport isArray from \"lodash/isArray.js\";\nimport { assertNever } from \"../../common/support\";\nimport { browserIsFirefox } from \"../../common/browser-detect\";\nimport { useResizeDetector } from \"react-resize-detector\";\n\nfaker.seed(1337);\n\nfunction isTruthy(x: any): boolean {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    return x ? true : false;\n}\n\n/**\n * Attempts to copy data between grid cells of any kind.\n */\nexport function lossyCopyData<T extends EditableGridCell>(source: EditableGridCell, target: T): EditableGridCell {\n    const sourceData = source.data;\n    if (typeof sourceData === typeof target.data) {\n        return {\n            ...target,\n            data: sourceData as any,\n        };\n    } else\n        switch (target.kind) {\n            case GridCellKind.Uri: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0],\n                    };\n                }\n                return {\n                    ...target,\n                    data: sourceData?.toString() ?? \"\",\n                };\n            }\n            case GridCellKind.Boolean: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0] !== undefined,\n                    };\n                } else if (source.kind === GridCellKind.Boolean) {\n                    return {\n                        ...target,\n                        data: source.data,\n                    };\n                }\n                return {\n                    ...target,\n                    data: isTruthy(sourceData) ? true : false,\n                };\n            }\n            case GridCellKind.Image: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: [sourceData[0]],\n                    };\n                }\n                return {\n                    ...target,\n                    data: [sourceData?.toString() ?? \"\"],\n                };\n            }\n            case GridCellKind.Number: {\n                return {\n                    ...target,\n                    data: 0,\n                };\n            }\n            case GridCellKind.Text:\n            case GridCellKind.Markdown: {\n                if (isArray(sourceData)) {\n                    return {\n                        ...target,\n                        data: sourceData[0].toString() ?? \"\",\n                    };\n                }\n\n                return {\n                    ...target,\n                    data: source.data?.toString() ?? \"\",\n                };\n            }\n            case GridCellKind.Custom: {\n                return target;\n            }\n            // No default\n        }\n    assertNever(target);\n}\n\nexport type GridColumnWithMockingInfo = GridColumn & {\n    getContent(): GridCell;\n};\n\nexport function getGridColumn(columnWithMock: GridColumnWithMockingInfo): GridColumn {\n    const { getContent, ...rest } = columnWithMock;\n\n    return rest;\n}\n\nexport const ColumnAddButton = styled.div`\n    width: 120px;\n    display: flex;\n    flex-direction: column;\n    background-color: #f1f1f1;\n    height: 100%;\n    button {\n        border: none;\n        outline: none;\n        height: 37px;\n        width: 120px;\n        font-size: 20px;\n        background-color: #f7f7f8;\n        color: #000000dd;\n        border-bottom: 1px solid #e1e2e5;\n\n        transition: background-color 200ms;\n\n        cursor: pointer;\n        :hover {\n            background-color: #efeff1;\n        }\n    }\n`;\n\nexport const BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    &.double {\n        height: 200vh;\n    }\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n\n    &.firefox .sizer {\n        border-radius: 0;\n        box-shadow: unset;\n\n        .sizer-clip {\n            border-radius: 0;\n        }\n    }\n\n    .white {\n        background-color: white;\n    }\n`;\n\nexport const PropName = styled.span`\n    font-family: monospace;\n    font-weight: 500;\n    color: #ffe394;\n`;\n\nexport const Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n    className?: string;\n}\n\nexport const BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description, className } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle className={className + (browserIsFirefox.value ? \" firefox\" : \"\")}>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nfunction createTextColumnInfo(index: number, group: boolean): GridColumnWithMockingInfo {\n    return {\n        title: `Column ${index}`,\n        id: `Column ${index}`,\n        group: group ? `Group ${Math.round(index / 3)}` : undefined,\n        icon: GridColumnIcon.HeaderString,\n        hasMenu: false,\n        getContent: () => {\n            const text = faker.lorem.word();\n\n            return {\n                kind: GridCellKind.Text,\n                data: text,\n                displayData: text,\n                allowOverlay: true,\n                readonly: true,\n            };\n        },\n    };\n}\n\nfunction getResizableColumns(amount: number, group: boolean): GridColumnWithMockingInfo[] {\n    const defaultColumns: GridColumnWithMockingInfo[] = [\n        {\n            title: \"First name\",\n            id: \"First name\",\n            group: group ? \"Name\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const firstName = faker.name.firstName();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: firstName,\n                    data: firstName,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Last name\",\n            id: \"Last name\",\n            group: group ? \"Name\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const lastName = faker.name.lastName();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: lastName,\n                    data: lastName,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Avatar\",\n            id: \"Avatar\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderImage,\n            hasMenu: false,\n            getContent: () => {\n                const n = Math.round(Math.random() * 100);\n                return {\n                    kind: GridCellKind.Image,\n                    data: [`https://picsum.photos/id/${n}/900/900`],\n                    displayData: [`https://picsum.photos/id/${n}/40/40`],\n                    allowOverlay: true,\n                    allowAdd: false,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Email\",\n            id: \"Email\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const email = faker.internet.email();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: email,\n                    data: email,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"Title\",\n            id: \"Title\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderString,\n            hasMenu: false,\n            getContent: () => {\n                const company = faker.name.jobTitle();\n                return {\n                    kind: GridCellKind.Text,\n                    displayData: company,\n                    data: company,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n        {\n            title: \"More Info\",\n            id: \"More Info\",\n            group: group ? \"Info\" : undefined,\n            icon: GridColumnIcon.HeaderUri,\n            hasMenu: false,\n            getContent: () => {\n                const url = faker.internet.url();\n                return {\n                    kind: GridCellKind.Uri,\n                    displayData: url,\n                    data: url,\n                    allowOverlay: true,\n                    readonly: true,\n                };\n            },\n        },\n    ];\n\n    if (amount < defaultColumns.length) {\n        return defaultColumns.slice(0, amount);\n    }\n\n    const extraColumnsAmount = amount - defaultColumns.length;\n\n    // eslint-disable-next-line unicorn/no-new-array\n    const extraColumns = [...new Array(extraColumnsAmount)].map((_, index) =>\n        createTextColumnInfo(index + defaultColumns.length, group)\n    );\n\n    return [...defaultColumns, ...extraColumns];\n}\n\nexport class ContentCache {\n    // column -> row -> value\n    private cachedContent: Map<number, Map<number, GridCell>> = new Map();\n\n    get(col: number, row: number) {\n        const colCache = this.cachedContent.get(col);\n\n        if (colCache === undefined) {\n            return undefined;\n        }\n\n        return colCache.get(row);\n    }\n\n    set(col: number, row: number, value: GridCell) {\n        if (this.cachedContent.get(col) === undefined) {\n            this.cachedContent.set(col, new Map());\n        }\n\n        const rowCache = this.cachedContent.get(col) as Map<number, GridCell>;\n        rowCache.set(row, value);\n    }\n}\n\nexport function useMockDataGenerator(numCols: number, readonly: boolean = true, group: boolean = false) {\n    const cache = React.useRef<ContentCache>(new ContentCache());\n\n    const [colsMap, setColsMap] = React.useState(() => getResizableColumns(numCols, group));\n\n    React.useEffect(() => {\n        setColsMap(getResizableColumns(numCols, group));\n    }, [group, numCols]);\n\n    const onColumnResize = React.useCallback((column: GridColumn, newSize: number) => {\n        setColsMap(prevColsMap => {\n            const index = prevColsMap.findIndex(ci => ci.title === column.title);\n            const newArray = [...prevColsMap];\n            newArray.splice(index, 1, {\n                ...prevColsMap[index],\n                width: newSize,\n            });\n            return newArray;\n        });\n    }, []);\n\n    const cols = React.useMemo(() => {\n        return colsMap.map(getGridColumn);\n    }, [colsMap]);\n\n    const colsMapRef = React.useRef(colsMap);\n    colsMapRef.current = colsMap;\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => {\n            let val = cache.current.get(col, row);\n            if (val === undefined) {\n                val = colsMapRef.current[col].getContent();\n                if (!readonly && isTextEditableGridCell(val)) {\n                    val = { ...val, readonly };\n                }\n                cache.current.set(col, row, val);\n            }\n            return val;\n        },\n        [readonly]\n    );\n\n    const getCellsForSelection = React.useCallback(\n        (selection: Rectangle): CellArray => {\n            const result: GridCell[][] = [];\n\n            for (let y = selection.y; y < selection.y + selection.height; y++) {\n                const row: GridCell[] = [];\n                for (let x = selection.x; x < selection.x + selection.width; x++) {\n                    row.push(getCellContent([x, y]));\n                }\n                result.push(row);\n            }\n\n            return result;\n        },\n        [getCellContent]\n    );\n\n    const setCellValueRaw = React.useCallback(([col, row]: Item, val: GridCell): void => {\n        cache.current.set(col, row, val);\n    }, []);\n\n    const setCellValue = React.useCallback(\n        ([col, row]: Item, val: GridCell): void => {\n            let current = cache.current.get(col, row);\n            if (current === undefined) {\n                current = colsMap[col].getContent();\n            }\n            if (isEditableGridCell(val) && isEditableGridCell(current)) {\n                const copied = lossyCopyData(val, current);\n                cache.current.set(col, row, {\n                    ...copied,\n                    displayData: typeof copied.data === \"string\" ? copied.data : (copied as any).displayData,\n                    lastUpdated: performance.now(),\n                } as any);\n            }\n        },\n        [colsMap]\n    );\n\n    return { cols, getCellContent, onColumnResize, setCellValue, getCellsForSelection, setCellValueRaw };\n}\n",".c4uqbye{width:120px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#f1f1f1;height:100%;}.c4uqbye button{border:none;outline:none;height:37px;width:120px;font-size:20px;background-color:#f7f7f8;color:#000000dd;border-bottom:1px solid #e1e2e5;-webkit-transition:background-color 200ms;transition:background-color 200ms;cursor:pointer;}.c4uqbye button:hover{background-color:#efeff1;}\n.b1bsqg7n{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.b1bsqg7n.double{height:200vh;}.b1bsqg7n > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.b1bsqg7n .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.b1bsqg7n .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}.b1bsqg7n.firefox .sizer{border-radius:0;box-shadow:unset;}.b1bsqg7n.firefox .sizer .sizer-clip{border-radius:0;}.b1bsqg7n .white{background-color:white;}\n.piiq54i{font-family:monospace;font-weight:500;color:#ffe394;}\n.d1k3yj19{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.m1j0dy02{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.m1j0dy02 button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZWRpdG9yL3N0b3JpZXMvdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5jNHVxYnllIiwiLmIxYnNxZzduIiwiLnBpaXE1NGkiLCIuZDFrM3lqMTkiLCIubTFqMGR5MDIiXSwibWFwcGluZ3MiOiJBQXdIYUE7QUF5QkFDO0FBdURBQztBQU1BQztBQU1BQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWVkaXRvci9zdG9yaWVzL3V0aWxzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQge1xuICAgIENlbGxBcnJheSxcbiAgICBFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEdyaWRDZWxsLFxuICAgIEdyaWRDZWxsS2luZCxcbiAgICBHcmlkQ29sdW1uLFxuICAgIEdyaWRDb2x1bW5JY29uLFxuICAgIGlzRWRpdGFibGVHcmlkQ2VsbCxcbiAgICBpc1RleHRFZGl0YWJsZUdyaWRDZWxsLFxuICAgIEl0ZW0sXG4gICAgUmVjdGFuZ2xlLFxufSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuXG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCBpc0FycmF5IGZyb20gXCJsb2Rhc2gvaXNBcnJheS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3N1cHBvcnRcIjtcbmltcG9ydCB7IGJyb3dzZXJJc0ZpcmVmb3ggfSBmcm9tIFwiLi4vLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCJyZWFjdC1yZXNpemUtZGV0ZWN0b3JcIjtcblxuZmFrZXIuc2VlZCgxMzM3KTtcblxuZnVuY3Rpb24gaXNUcnV0aHkoeDogYW55KTogYm9vbGVhbiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgIHJldHVybiB4ID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNvcHkgZGF0YSBiZXR3ZWVuIGdyaWQgY2VsbHMgb2YgYW55IGtpbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3NzeUNvcHlEYXRhPFQgZXh0ZW5kcyBFZGl0YWJsZUdyaWRDZWxsPihzb3VyY2U6IEVkaXRhYmxlR3JpZENlbGwsIHRhcmdldDogVCk6IEVkaXRhYmxlR3JpZENlbGwge1xuICAgIGNvbnN0IHNvdXJjZURhdGEgPSBzb3VyY2UuZGF0YTtcbiAgICBpZiAodHlwZW9mIHNvdXJjZURhdGEgPT09IHR5cGVvZiB0YXJnZXQuZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGFyZ2V0LFxuICAgICAgICAgICAgZGF0YTogc291cmNlRGF0YSBhcyBhbnksXG4gICAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICAgIHN3aXRjaCAodGFyZ2V0LmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQm9vbGVhbjoge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzb3VyY2VEYXRhWzBdICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uua2luZCA9PT0gR3JpZENlbGxLaW5kLkJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGlzVHJ1dGh5KHNvdXJjZURhdGEpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZToge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbc291cmNlRGF0YVswXV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW3NvdXJjZURhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIl0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk51bWJlcjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVGV4dDpcbiAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk1hcmtkb3duOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvdXJjZURhdGFbMF0udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc291cmNlLmRhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQ3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIGRlZmF1bHRcbiAgICAgICAgfVxuICAgIGFzc2VydE5ldmVyKHRhcmdldCk7XG59XG5cbmV4cG9ydCB0eXBlIEdyaWRDb2x1bW5XaXRoTW9ja2luZ0luZm8gPSBHcmlkQ29sdW1uICYge1xuICAgIGdldENvbnRlbnQoKTogR3JpZENlbGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R3JpZENvbHVtbihjb2x1bW5XaXRoTW9jazogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mbyk6IEdyaWRDb2x1bW4ge1xuICAgIGNvbnN0IHsgZ2V0Q29udGVudCwgLi4ucmVzdCB9ID0gY29sdW1uV2l0aE1vY2s7XG5cbiAgICByZXR1cm4gcmVzdDtcbn1cblxuZXhwb3J0IGNvbnN0IENvbHVtbkFkZEJ1dHRvbiA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDEyMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjFmMWYxO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBidXR0b24ge1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGhlaWdodDogMzdweDtcbiAgICAgICAgd2lkdGg6IDEyMHB4O1xuICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjg7XG4gICAgICAgIGNvbG9yOiAjMDAwMDAwZGQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTFlMmU1O1xuXG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMjAwbXM7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2VmZWZmMTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmLmRvdWJsZSB7XG4gICAgICAgIGhlaWdodDogMjAwdmg7XG4gICAgfVxuXG4gICAgJiA+IGgxIHtcbiAgICAgICAgZm9udC1zaXplOiA1MHB4O1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgbWFyZ2luOiAwIDAgMTJweCAwO1xuICAgIH1cblxuICAgIC5zaXplciB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICBib3gtc2hhZG93OiByZ2JhKDksIDMwLCA2NiwgMC4yNSkgMHB4IDRweCA4cHggLTJweCwgcmdiYSg5LCAzMCwgNjYsIDAuMDgpIDBweCAwcHggMHB4IDFweDtcblxuICAgICAgICAuc2l6ZXItY2xpcCB7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcblxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJi5maXJlZm94IC5zaXplciB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIGJveC1zaGFkb3c6IHVuc2V0O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAud2hpdGUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBCZWF1dGlmdWxQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBCZWF1dGlmdWxXcmFwcGVyOiBSZWFjdC5GQzxCZWF1dGlmdWxQcm9wcz4gPSBwID0+IHtcbiAgICBjb25zdCB7IHRpdGxlLCBjaGlsZHJlbiwgZGVzY3JpcHRpb24sIGNsYXNzTmFtZSB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlIGNsYXNzTmFtZT17Y2xhc3NOYW1lICsgKGJyb3dzZXJJc0ZpcmVmb3gudmFsdWUgPyBcIiBmaXJlZm94XCIgOiBcIlwiKX0+XG4gICAgICAgICAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNpemVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplci1jbGlwXCIgcmVmPXtyZWZ9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoID8/IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dENvbHVtbkluZm8oaW5kZXg6IG51bWJlciwgZ3JvdXA6IGJvb2xlYW4pOiBHcmlkQ29sdW1uV2l0aE1vY2tpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogYENvbHVtbiAke2luZGV4fWAsXG4gICAgICAgIGlkOiBgQ29sdW1uICR7aW5kZXh9YCxcbiAgICAgICAgZ3JvdXA6IGdyb3VwID8gYEdyb3VwICR7TWF0aC5yb3VuZChpbmRleCAvIDMpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBmYWtlci5sb3JlbS53b3JkKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdGV4dCxcbiAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6YWJsZUNvbHVtbnMoYW1vdW50OiBudW1iZXIsIGdyb3VwOiBib29sZWFuKTogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdIHtcbiAgICBjb25zdCBkZWZhdWx0Q29sdW1uczogR3JpZENvbHVtbldpdGhNb2NraW5nSW5mb1tdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJGaXJzdCBuYW1lXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIk5hbWVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclN0cmluZyxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TmFtZSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBmaXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6IFwiTGFzdCBuYW1lXCIsXG4gICAgICAgICAgICBpZDogXCJMYXN0IG5hbWVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiTmFtZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBmYWtlci5uYW1lLmxhc3ROYW1lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBsYXN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbGFzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkF2YXRhclwiLFxuICAgICAgICAgICAgaWQ6IFwiQXZhdGFyXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlckltYWdlLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkltYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYGh0dHBzOi8vcGljc3VtLnBob3Rvcy9pZC8ke259LzkwMC85MDBgXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IFtgaHR0cHM6Ly9waWNzdW0ucGhvdG9zL2lkLyR7bn0vNDAvNDBgXSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0FkZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJFbWFpbFwiLFxuICAgICAgICAgICAgaWQ6IFwiRW1haWxcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSBmYWtlci5pbnRlcm5ldC5lbWFpbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5UZXh0LFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd092ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgaWQ6IFwiVGl0bGVcIixcbiAgICAgICAgICAgIGdyb3VwOiBncm91cCA/IFwiSW5mb1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWNvbjogR3JpZENvbHVtbkljb24uSGVhZGVyU3RyaW5nLFxuICAgICAgICAgICAgaGFzTWVudTogZmFsc2UsXG4gICAgICAgICAgICBnZXRDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFueSA9IGZha2VyLm5hbWUuam9iVGl0bGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbXBhbnksXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIk1vcmUgSW5mb1wiLFxuICAgICAgICAgICAgaWQ6IFwiTW9yZSBJbmZvXCIsXG4gICAgICAgICAgICBncm91cDogZ3JvdXAgPyBcIkluZm9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGljb246IEdyaWRDb2x1bW5JY29uLkhlYWRlclVyaSxcbiAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0Q29udGVudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGZha2VyLmludGVybmV0LnVybCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5VcmksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRhOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgaWYgKGFtb3VudCA8IGRlZmF1bHRDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdENvbHVtbnMuc2xpY2UoMCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYUNvbHVtbnNBbW91bnQgPSBhbW91bnQgLSBkZWZhdWx0Q29sdW1ucy5sZW5ndGg7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1uZXctYXJyYXlcbiAgICBjb25zdCBleHRyYUNvbHVtbnMgPSBbLi4ubmV3IEFycmF5KGV4dHJhQ29sdW1uc0Ftb3VudCldLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAgIGNyZWF0ZVRleHRDb2x1bW5JbmZvKGluZGV4ICsgZGVmYXVsdENvbHVtbnMubGVuZ3RoLCBncm91cClcbiAgICApO1xuXG4gICAgcmV0dXJuIFsuLi5kZWZhdWx0Q29sdW1ucywgLi4uZXh0cmFDb2x1bW5zXTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRlbnRDYWNoZSB7XG4gICAgLy8gY29sdW1uIC0+IHJvdyAtPiB2YWx1ZVxuICAgIHByaXZhdGUgY2FjaGVkQ29udGVudDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgR3JpZENlbGw+PiA9IG5ldyBNYXAoKTtcblxuICAgIGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY29sQ2FjaGUgPSB0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCk7XG5cbiAgICAgICAgaWYgKGNvbENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sQ2FjaGUuZ2V0KHJvdyk7XG4gICAgfVxuXG4gICAgc2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IEdyaWRDZWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENvbnRlbnQuZ2V0KGNvbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRDb250ZW50LnNldChjb2wsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3dDYWNoZSA9IHRoaXMuY2FjaGVkQ29udGVudC5nZXQoY29sKSBhcyBNYXA8bnVtYmVyLCBHcmlkQ2VsbD47XG4gICAgICAgIHJvd0NhY2hlLnNldChyb3csIHZhbHVlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2NrRGF0YUdlbmVyYXRvcihudW1Db2xzOiBudW1iZXIsIHJlYWRvbmx5OiBib29sZWFuID0gdHJ1ZSwgZ3JvdXA6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPENvbnRlbnRDYWNoZT4obmV3IENvbnRlbnRDYWNoZSgpKTtcblxuICAgIGNvbnN0IFtjb2xzTWFwLCBzZXRDb2xzTWFwXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGdldFJlc2l6YWJsZUNvbHVtbnMobnVtQ29scywgZ3JvdXApKTtcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldENvbHNNYXAoZ2V0UmVzaXphYmxlQ29sdW1ucyhudW1Db2xzLCBncm91cCkpO1xuICAgIH0sIFtncm91cCwgbnVtQ29sc10pO1xuXG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sdW1uOiBHcmlkQ29sdW1uLCBuZXdTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0Q29sc01hcChwcmV2Q29sc01hcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHByZXZDb2xzTWFwLmZpbmRJbmRleChjaSA9PiBjaS50aXRsZSA9PT0gY29sdW1uLnRpdGxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gWy4uLnByZXZDb2xzTWFwXTtcbiAgICAgICAgICAgIG5ld0FycmF5LnNwbGljZShpbmRleCwgMSwge1xuICAgICAgICAgICAgICAgIC4uLnByZXZDb2xzTWFwW2luZGV4XSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xzTWFwLm1hcChnZXRHcmlkQ29sdW1uKTtcbiAgICB9LCBbY29sc01hcF0pO1xuXG4gICAgY29uc3QgY29sc01hcFJlZiA9IFJlYWN0LnVzZVJlZihjb2xzTWFwKTtcbiAgICBjb2xzTWFwUmVmLmN1cnJlbnQgPSBjb2xzTWFwO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtKTogR3JpZENlbGwgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGNvbHNNYXBSZWYuY3VycmVudFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRvbmx5ICYmIGlzVGV4dEVkaXRhYmxlR3JpZENlbGwodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB7IC4uLnZhbCwgcmVhZG9ubHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBbcmVhZG9ubHldXG4gICAgKTtcblxuICAgIGNvbnN0IGdldENlbGxzRm9yU2VsZWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChzZWxlY3Rpb246IFJlY3RhbmdsZSk6IENlbGxBcnJheSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEdyaWRDZWxsW11bXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gc2VsZWN0aW9uLnk7IHkgPCBzZWxlY3Rpb24ueSArIHNlbGVjdGlvbi5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdzogR3JpZENlbGxbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBzZWxlY3Rpb24ueDsgeCA8IHNlbGVjdGlvbi54ICsgc2VsZWN0aW9uLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZ2V0Q2VsbENvbnRlbnQoW3gsIHldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIFtnZXRDZWxsQ29udGVudF1cbiAgICApO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlUmF3ID0gUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd106IEl0ZW0sIHZhbDogR3JpZENlbGwpOiB2b2lkID0+IHtcbiAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHZhbCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2V0Q2VsbFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChbY29sLCByb3ddOiBJdGVtLCB2YWw6IEdyaWRDZWxsKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNhY2hlLmN1cnJlbnQuZ2V0KGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29sc01hcFtjb2xdLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlR3JpZENlbGwodmFsKSAmJiBpc0VkaXRhYmxlR3JpZENlbGwoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWQgPSBsb3NzeUNvcHlEYXRhKHZhbCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY2FjaGUuY3VycmVudC5zZXQoY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29waWVkLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YTogdHlwZW9mIGNvcGllZC5kYXRhID09PSBcInN0cmluZ1wiID8gY29waWVkLmRhdGEgOiAoY29waWVkIGFzIGFueSkuZGlzcGxheURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtjb2xzTWFwXVxuICAgICk7XG5cbiAgICByZXR1cm4geyBjb2xzLCBnZXRDZWxsQ29udGVudCwgb25Db2x1bW5SZXNpemUsIHNldENlbGxWYWx1ZSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24sIHNldENlbGxWYWx1ZVJhdyB9O1xufVxuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".dpsd959{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:hidden;box-sizing:border-box;--overlay-top:var(--dpsd959-0);left:var(--dpsd959-1);top:var(--dpsd959-2);min-width:var(--dpsd959-3);min-height:var(--dpsd959-4);width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:400px;max-height:calc(100vh - var(--dpsd959-5));font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);text-align:start;}@-webkit-keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}@keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}.dpsd959.gdg-style{border-radius:2px;background-color:var(--gdg-bg-cell);box-shadow:0 0 0 1px var(--gdg-accent-color),0px 0px 1px rgba(62,65,86,0.4), 0px 6px 12px rgba(62,65,86,0.15);-webkit-animation:glide_fade_in-dpsd959 60ms 1;animation:glide_fade_in-dpsd959 60ms 1;}.dpsd959.pad{padding:var(--dpsd959-6) 8.5px 3px;}.dpsd959 .clip-region{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow-y:auto;overflow-x:hidden;border-radius:2px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.dpsd959 .clip-region .gdg-growing-entry{height:100%;}.dpsd959 .clip-region input.gdg-input{width:100%;border:none;border-width:0;outline:none;}.dpsd959 .clip-region textarea.gdg-input{border:none;border-width:0;outline:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5kcHNkOTU5Il0sIm1hcHBpbmdzIjoiQUFRYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICB0YXJnZXRYOiBudW1iZXI7XG4gICAgdGFyZ2V0WTogbnVtYmVyO1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG4gICAgdGFyZ2V0SGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgRGF0YUdyaWRPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2PFByb3BzPmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgLS1vdmVybGF5LXRvcDogJHtwID0+IHAudGFyZ2V0WX1weDtcblxuICAgIGxlZnQ6ICR7cCA9PiBwLnRhcmdldFggLSAxfXB4O1xuICAgIHRvcDogJHtwID0+IHAudGFyZ2V0WSAtIDF9cHg7XG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aCArIDJ9cHg7XG4gICAgbWluLWhlaWdodDogJHtwID0+IHAudGFyZ2V0SGVpZ2h0ICsgMn1weDtcbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gJHtwID0+IHAudGFyZ2V0WSArIDEwfXB4KTtcblxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZ2RnLWVkaXRvci1mb250LXNpemUpO1xuXG4gICAgQGtleWZyYW1lcyBnbGlkZV9mYWRlX2luIHtcbiAgICAgICAgZnJvbSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmdkZy1zdHlsZSB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYWNjZW50LWNvbG9yKSwgMHB4IDBweCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLFxuICAgICAgICAgICAgMHB4IDZweCAxMnB4IHJnYmEoNjIsIDY1LCA4NiwgMC4xNSk7XG5cbiAgICAgICAgYW5pbWF0aW9uOiBnbGlkZV9mYWRlX2luIDYwbXMgMTtcbiAgICB9XG5cbiAgICAmLnBhZCB7XG4gICAgICAgIHBhZGRpbmc6ICR7cCA9PiBNYXRoLm1heCgwLCAocC50YXJnZXRIZWlnaHQgLSAyOCkgLyAyKX1weCA4LjVweCAzcHg7XG4gICAgfVxuXG4gICAgLmNsaXAtcmVnaW9uIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICAuZ2RnLWdyb3dpbmctZW50cnkge1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG5cbiAgICAgICAgJiBpbnB1dC5nZGctaW5wdXQge1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgJiB0ZXh0YXJlYS5nZGctaW5wdXQge1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHQtYWxpZ246IHN0YXJ0O1xuYDtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-grid-overlay-editor/packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx"],"names":[".dpsd959"],"mappings":"AAQaA,SAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,8BAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,0BAAAA,CAAAA,2BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,yCAAAA,CAAAA,kCAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,yCAAAA,KAAAA,UAAAA,CAAAA,CAAAA,GAAAA,YAAAA,CAAAA,CAAAA,CAAAA,iCAAAA,KAAAA,UAAAA,CAAAA,CAAAA,GAAAA,YAAAA,CAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,mCAAAA,CAAAA,6GAAAA,CAAAA,8CAAAA,CAAAA,sCAAAA,CAAAA,CAAAA,aAAAA,kCAAAA,CAAAA,CAAAA,sBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,CAAAA,sCAAAA,UAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA,CAAAA,yCAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA;ACPb,20FAA20F","sourcesContent":["import { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetX: number;\n    targetY: number;\n    targetWidth: number;\n    targetHeight: number;\n}\nexport const DataGridOverlayEditorStyle = styled.div<Props>`\n    position: absolute;\n\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    box-sizing: border-box;\n\n    --overlay-top: ${p => p.targetY}px;\n\n    left: ${p => p.targetX - 1}px;\n    top: ${p => p.targetY - 1}px;\n    min-width: ${p => p.targetWidth + 2}px;\n    min-height: ${p => p.targetHeight + 2}px;\n    width: max-content;\n    max-width: 400px;\n    max-height: calc(100vh - ${p => p.targetY + 10}px);\n\n    font-family: var(--gdg-font-family);\n    font-size: var(--gdg-editor-font-size);\n\n    @keyframes glide_fade_in {\n        from {\n            opacity: 0%;\n        }\n\n        to {\n            opacity: 100%;\n        }\n    }\n\n    &.gdg-style {\n        border-radius: 2px;\n        background-color: var(--gdg-bg-cell);\n\n        box-shadow: 0 0 0 1px var(--gdg-accent-color), 0px 0px 1px rgba(62, 65, 86, 0.4),\n            0px 6px 12px rgba(62, 65, 86, 0.15);\n\n        animation: glide_fade_in 60ms 1;\n    }\n\n    &.pad {\n        padding: ${p => Math.max(0, (p.targetHeight - 28) / 2)}px 8.5px 3px;\n    }\n\n    .clip-region {\n        display: flex;\n        flex-direction: column;\n        overflow-y: auto;\n        overflow-x: hidden;\n        border-radius: 2px;\n        flex-grow: 1;\n\n        .gdg-growing-entry {\n            height: 100%;\n        }\n\n        & input.gdg-input {\n            width: 100%;\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n\n        & textarea.gdg-input {\n            border: none;\n            border-width: 0;\n            outline: none;\n        }\n    }\n\n    text-align: start;\n`;\n",".dpsd959{position:absolute;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow:hidden;box-sizing:border-box;--overlay-top:var(--dpsd959-0);left:var(--dpsd959-1);top:var(--dpsd959-2);min-width:var(--dpsd959-3);min-height:var(--dpsd959-4);width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:400px;max-height:calc(100vh - var(--dpsd959-5));font-family:var(--gdg-font-family);font-size:var(--gdg-editor-font-size);text-align:start;}@-webkit-keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}@keyframes glide_fade_in-dpsd959{from{opacity:0%;}to{opacity:100%;}}.dpsd959.gdg-style{border-radius:2px;background-color:var(--gdg-bg-cell);box-shadow:0 0 0 1px var(--gdg-accent-color),0px 0px 1px rgba(62,65,86,0.4), 0px 6px 12px rgba(62,65,86,0.15);-webkit-animation:glide_fade_in-dpsd959 60ms 1;animation:glide_fade_in-dpsd959 60ms 1;}.dpsd959.pad{padding:var(--dpsd959-6) 8.5px 3px;}.dpsd959 .clip-region{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;overflow-y:auto;overflow-x:hidden;border-radius:2px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.dpsd959 .clip-region .gdg-growing-entry{height:100%;}.dpsd959 .clip-region input.gdg-input{width:100%;border:none;border-width:0;outline:none;}.dpsd959 .clip-region textarea.gdg-input{border:none;border-width:0;outline:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5kcHNkOTU5Il0sIm1hcHBpbmdzIjoiQUFRYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgICB0YXJnZXRYOiBudW1iZXI7XG4gICAgdGFyZ2V0WTogbnVtYmVyO1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG4gICAgdGFyZ2V0SGVpZ2h0OiBudW1iZXI7XG59XG5leHBvcnQgY29uc3QgRGF0YUdyaWRPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2PFByb3BzPmBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgLS1vdmVybGF5LXRvcDogJHtwID0+IHAudGFyZ2V0WX1weDtcblxuICAgIGxlZnQ6ICR7cCA9PiBwLnRhcmdldFggLSAxfXB4O1xuICAgIHRvcDogJHtwID0+IHAudGFyZ2V0WSAtIDF9cHg7XG4gICAgbWluLXdpZHRoOiAke3AgPT4gcC50YXJnZXRXaWR0aCArIDJ9cHg7XG4gICAgbWluLWhlaWdodDogJHtwID0+IHAudGFyZ2V0SGVpZ2h0ICsgMn1weDtcbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gJHtwID0+IHAudGFyZ2V0WSArIDEwfXB4KTtcblxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1nZGctZm9udC1mYW1pbHkpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZ2RnLWVkaXRvci1mb250LXNpemUpO1xuXG4gICAgQGtleWZyYW1lcyBnbGlkZV9mYWRlX2luIHtcbiAgICAgICAgZnJvbSB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAmLmdkZy1zdHlsZSB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYWNjZW50LWNvbG9yKSwgMHB4IDBweCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLFxuICAgICAgICAgICAgMHB4IDZweCAxMnB4IHJnYmEoNjIsIDY1LCA4NiwgMC4xNSk7XG5cbiAgICAgICAgYW5pbWF0aW9uOiBnbGlkZV9mYWRlX2luIDYwbXMgMTtcbiAgICB9XG5cbiAgICAmLnBhZCB7XG4gICAgICAgIHBhZGRpbmc6ICR7cCA9PiBNYXRoLm1heCgwLCAocC50YXJnZXRIZWlnaHQgLSAyOCkgLyAyKX1weCA4LjVweCAzcHg7XG4gICAgfVxuXG4gICAgLmNsaXAtcmVnaW9uIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcblxuICAgICAgICAuZ2RnLWdyb3dpbmctZW50cnkge1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG5cbiAgICAgICAgJiBpbnB1dC5nZGctaW5wdXQge1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBib3JkZXItd2lkdGg6IDA7XG4gICAgICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgJiB0ZXh0YXJlYS5nZGctaW5wdXQge1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHQtYWxpZ246IHN0YXJ0O1xuYDtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".bvh4xn4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.bvh4xn4 .boe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:20px;background-color:var(--gdg-bg-bubble);color:var(--gdg-text-dark);margin:2px;}.bvh4xn4 textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2J1YmJsZXMtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5idmg0eG40Il0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEJ1YmJsZXNPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuXG4gICAgLmJvZS1idWJibGUge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcblxuICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1idWJibGUpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIG1hcmdpbjogMnB4O1xuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx"],"names":[".bvh4xn4"],"mappings":"AAEaA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,qCAAAA,CAAAA,0BAAAA,CAAAA,UAAAA,CAAAA,CAAAA,kBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDb,2sCAA2sC","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const BubblesOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .boe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 20px;\n\n        background-color: var(--gdg-bg-bubble);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n",".bvh4xn4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.bvh4xn4 .boe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:20px;background-color:var(--gdg-bg-bubble);color:var(--gdg-text-dark);margin:2px;}.bvh4xn4 textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2J1YmJsZXMtb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Il0sIm5hbWVzIjpbIi5idmg0eG40Il0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEJ1YmJsZXNPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuXG4gICAgLmJvZS1idWJibGUge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDBweDtcblxuICAgICAgICBwYWRkaW5nOiAwIDhweDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1idWJibGUpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG4gICAgICAgIG1hcmdpbjogMnB4O1xuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".d11gcyta{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.d11gcyta .doe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:24px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);margin:2px;border-radius:6px;box-shadow:0 0 1px rgba(62,65,86,0.4),0 1px 3px rgba(62,65,86,0.4);}.d11gcyta .doe-bubble img{height:16px;object-fit:contain;margin-right:4px;}.d11gcyta textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2RyaWxsZG93bi1vdmVybGF5LWVkaXRvci50c3giXSwibmFtZXMiOlsiLmQxMWdjeXRhIl0sIm1hcHBpbmdzIjoiQUFJTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvZHJpbGxkb3duLW92ZXJsYXktZWRpdG9yLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRHJpbGxkb3duQ2VsbERhdGEgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcblxuICAgIC5kb2UtYnViYmxlIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG5cbiAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgbWFyZ2luOiAycHg7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLCAwIDFweCAzcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpO1xuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuXG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgZHJpbGxkb3duczogcmVhZG9ubHkgRHJpbGxkb3duQ2VsbERhdGFbXTtcbn1cblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBkcmlsbGRvd25zIH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxEcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgICAgICAgICB7ZHJpbGxkb3ducy5tYXAoKGQsIGkpID0+IChcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwiZG9lLWJ1YmJsZVwiPlxuICAgICAgICAgICAgICAgICAgICB7ZC5pbWcgIT09IHVuZGVmaW5lZCAmJiA8aW1nIHNyYz17ZC5pbWd9IC8+fVxuICAgICAgICAgICAgICAgICAgICA8ZGl2PntkLnRleHR9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgPC9EcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yO1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx"],"names":[".d11gcyta"],"mappings":"AAIMA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,CAAAA,sBAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,mCAAAA,CAAAA,0BAAAA,CAAAA,UAAAA,CAAAA,iBAAAA,CAAAA,kEAAAA,CAAAA,CAAAA,0BAAAA,WAAAA,CAAAA,kBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACHN,24EAA24E","sourcesContent":["import type { DrilldownCellData } from \"../../data-grid/data-grid-types\";\nimport * as React from \"react\";\nimport { styled } from \"@linaria/react\";\n\nconst DrilldownOverlayEditorStyle = styled.div`\n    display: flex;\n    flex-wrap: wrap;\n\n    .doe-bubble {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        border-radius: 100px;\n\n        padding: 0 8px;\n        height: 24px;\n\n        background-color: var(--gdg-bg-cell);\n        color: var(--gdg-text-dark);\n        margin: 2px;\n\n        border-radius: 6px;\n\n        box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n\n        img {\n            height: 16px;\n            object-fit: contain;\n\n            margin-right: 4px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n\ninterface Props {\n    readonly drilldowns: readonly DrilldownCellData[];\n}\n\nconst DrilldownOverlayEditor: React.FunctionComponent<Props> = p => {\n    const { drilldowns } = p;\n    return (\n        <DrilldownOverlayEditorStyle>\n            {drilldowns.map((d, i) => (\n                <div key={i} className=\"doe-bubble\">\n                    {d.img !== undefined && <img src={d.img} />}\n                    <div>{d.text}</div>\n                </div>\n            ))}\n        </DrilldownOverlayEditorStyle>\n    );\n};\nexport default DrilldownOverlayEditor;\n",".d11gcyta{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}.d11gcyta .doe-bubble{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:100px;padding:0 8px;height:24px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);margin:2px;border-radius:6px;box-shadow:0 0 1px rgba(62,65,86,0.4),0 1px 3px rgba(62,65,86,0.4);}.d11gcyta .doe-bubble img{height:16px;object-fit:contain;margin-right:4px;}.d11gcyta textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2RyaWxsZG93bi1vdmVybGF5LWVkaXRvci50c3giXSwibmFtZXMiOlsiLmQxMWdjeXRhIl0sIm1hcHBpbmdzIjoiQUFJTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvZHJpbGxkb3duLW92ZXJsYXktZWRpdG9yLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRHJpbGxkb3duQ2VsbERhdGEgfSBmcm9tIFwiLi4vLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcblxuICAgIC5kb2UtYnViYmxlIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwcHg7XG5cbiAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYmctY2VsbCk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcbiAgICAgICAgbWFyZ2luOiAycHg7XG5cbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpLCAwIDFweCAzcHggcmdiYSg2MiwgNjUsIDg2LCAwLjQpO1xuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xuXG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gICAgcmVhZG9ubHkgZHJpbGxkb3duczogcmVhZG9ubHkgRHJpbGxkb3duQ2VsbERhdGFbXTtcbn1cblxuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3QgeyBkcmlsbGRvd25zIH0gPSBwO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxEcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgICAgICAgICB7ZHJpbGxkb3ducy5tYXAoKGQsIGkpID0+IChcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwiZG9lLWJ1YmJsZVwiPlxuICAgICAgICAgICAgICAgICAgICB7ZC5pbWcgIT09IHVuZGVmaW5lZCAmJiA8aW1nIHNyYz17ZC5pbWd9IC8+fVxuICAgICAgICAgICAgICAgICAgICA8ZGl2PntkLnRleHR9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgPC9EcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGU+XG4gICAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".i1v3763o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100%;}.i1v3763o .centering-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}.i1v3763o .centering-container img,.i1v3763o .centering-container canvas{max-height:calc(100vh - var(--overlay-top) - 20px);object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.i1v3763o .centering-container canvas{max-width:380px;}.i1v3763o .edit-icon{position:absolute;top:12px;right:0;width:48px;height:48px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.i1v3763o .edit-icon > *{width:24px;height:24px;}.i1v3763o textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuaTF2Mzc2M28iXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9pbWFnZS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEltYWdlT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgLmNlbnRlcmluZy1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAgICAgaW1nLFxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtIHZhcigtLW92ZXJsYXktdG9wKSAtIDIwcHgpO1xuICAgICAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzIHtcbiAgICAgICAgICAgIG1heC13aWR0aDogMzgwcHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDEycHg7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx"],"names":[".i1v3763o"],"mappings":"AAEaA,UAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,CAAAA,+BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,yEAAAA,kDAAAA,CAAAA,kBAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,qBAAAA,iBAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,yBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,mBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDb,uyDAAuyD","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const ImageOverlayEditorStyle = styled.div`\n    display: flex;\n\n    height: 100%;\n\n    .centering-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        height: 100%;\n\n        img,\n        canvas {\n            max-height: calc(100vh - var(--overlay-top) - 20px);\n            object-fit: contain;\n            user-select: none;\n        }\n\n        canvas {\n            max-width: 380px;\n        }\n    }\n\n    .edit-icon {\n        position: absolute;\n        top: 12px;\n        right: 0;\n        width: 48px;\n        height: 48px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n",".i1v3763o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100%;}.i1v3763o .centering-container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}.i1v3763o .centering-container img,.i1v3763o .centering-container canvas{max-height:calc(100vh - var(--overlay-top) - 20px);object-fit:contain;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.i1v3763o .centering-container canvas{max-width:380px;}.i1v3763o .edit-icon{position:absolute;top:12px;right:0;width:48px;height:48px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.i1v3763o .edit-icon > *{width:24px;height:24px;}.i1v3763o textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIuaTF2Mzc2M28iXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9pbWFnZS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IEltYWdlT3ZlcmxheUVkaXRvclN0eWxlID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuXG4gICAgaGVpZ2h0OiAxMDAlO1xuXG4gICAgLmNlbnRlcmluZy1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgICAgICBoZWlnaHQ6IDEwMCU7XG5cbiAgICAgICAgaW1nLFxuICAgICAgICBjYW52YXMge1xuICAgICAgICAgICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtIHZhcigtLW92ZXJsYXktdG9wKSAtIDIwcHgpO1xuICAgICAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzIHtcbiAgICAgICAgICAgIG1heC13aWR0aDogMzgwcHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDEycHg7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".m1bd3197{min-width:var(--m1bd3197-0);width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;position:relative;color:var(--gdg-text-dark);}.m1bd3197 .gecuh31{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;min-width:0;}.m1bd3197 .spacer{-webkit-flex:1;-ms-flex:1;flex:1;}.m1bd3197 .edit-icon{position:relative;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--gdg-accent-color);padding:0;height:24px;width:24px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:all \"0.125s ease\";transition:all \"0.125s ease\";border-radius:6px;}.m1bd3197 .edit-icon > *{width:16px;height:16px;}.m1bd3197 .edit-hover:hover{background-color:var(--gdg-accent-light);-webkit-transition:background-color 150ms;transition:background-color 150ms;}.m1bd3197 .checkmark-hover:hover{color:#ffffff;background-color:var(--gdg-accent-color);}.m1bd3197 .md-edit-textarea{position:relative;top:0px;left:0px;width:0px;height:0px;margin-top:25px;opacity:0;padding:0;}.m1bd3197 .ml-6{margin-left:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIubTFiZDMxOTciXSwibWFwcGluZ3MiOiJBQU9hQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9tYXJrZG93bi1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcm93aW5nRW50cnlTdHlsZSB9IGZyb20gXCIuLi8uLi9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGVcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bk92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXY8UHJvcHM+YFxuICAgIG1pbi13aWR0aDogJHtwID0+IHAudGFyZ2V0V2lkdGh9cHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgICR7R3Jvd2luZ0VudHJ5U3R5bGV9IHtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICB9XG5cbiAgICAuc3BhY2VyIHtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuXG4gICAgICAgIHBhZGRpbmc6IDA7XG5cbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIFwiMC4xMjVzIGVhc2VcIjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmVkaXQtaG92ZXIge1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE1MG1zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmNoZWNrbWFyay1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogI2ZmZmZmZjtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLm1kLWVkaXQtdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAyNXB4O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cblxuICAgIC5tbC02IHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICB9XG5gO1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx"],"names":[".m1bd3197"],"mappings":"AAOaA,UAAAA,2BAAAA,CAAAA,UAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,8BAAAA,CAAAA,4BAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,wBAAAA,CAAAA,qCAAAA,CAAAA,qBAAAA,CAAAA,6BAAAA,CAAAA,iBAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,mBAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,WAAAA,CAAAA,CAAAA,kBAAAA,cAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAAA,CAAAA,qBAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,6BAAAA,CAAAA,SAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,oCAAAA,CAAAA,4BAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,yBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,4BAAAA,wCAAAA,CAAAA,yCAAAA,CAAAA,iCAAAA,CAAAA,CAAAA,iCAAAA,aAAAA,CAAAA,wCAAAA,CAAAA,CAAAA,4BAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,SAAAA,CAAAA,SAAAA,CAAAA,CAAAA,gBAAAA,eAAAA,CAAAA;ACNb,+/EAA+/E","sourcesContent":["import { GrowingEntryStyle } from \"../../growing-entry/growing-entry-style\";\nimport { styled } from \"@linaria/react\";\n\ninterface Props {\n    targetWidth: number;\n}\n\nexport const MarkdownOverlayEditorStyle = styled.div<Props>`\n    min-width: ${p => p.targetWidth}px;\n    width: 100%;\n    display: flex;\n    align-items: flex-start;\n    justify-content: space-between;\n    position: relative;\n    color: var(--gdg-text-dark);\n\n    ${GrowingEntryStyle} {\n        flex-shrink: 1;\n        min-width: 0;\n    }\n\n    .spacer {\n        flex: 1;\n    }\n\n    .edit-icon {\n        position: relative;\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        color: var(--gdg-accent-color);\n\n        padding: 0;\n\n        height: 24px;\n        width: 24px;\n        flex-shrink: 0;\n\n        transition: all \"0.125s ease\";\n\n        border-radius: 6px;\n\n        > * {\n            width: 16px;\n            height: 16px;\n        }\n    }\n\n    .edit-hover {\n        :hover {\n            background-color: var(--gdg-accent-light);\n            transition: background-color 150ms;\n        }\n    }\n\n    .checkmark-hover {\n        :hover {\n            color: #ffffff;\n            background-color: var(--gdg-accent-color);\n        }\n    }\n\n    .md-edit-textarea {\n        position: relative;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n        margin-top: 25px;\n        opacity: 0;\n        padding: 0;\n    }\n\n    .ml-6 {\n        margin-left: 6px;\n    }\n`;\n",".m1bd3197{min-width:var(--m1bd3197-0);width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;position:relative;color:var(--gdg-text-dark);}.m1bd3197 .gecuh31{-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;min-width:0;}.m1bd3197 .spacer{-webkit-flex:1;-ms-flex:1;flex:1;}.m1bd3197 .edit-icon{position:relative;cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:var(--gdg-accent-color);padding:0;height:24px;width:24px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:all \"0.125s ease\";transition:all \"0.125s ease\";border-radius:6px;}.m1bd3197 .edit-icon > *{width:16px;height:16px;}.m1bd3197 .edit-hover:hover{background-color:var(--gdg-accent-light);-webkit-transition:background-color 150ms;transition:background-color 150ms;}.m1bd3197 .checkmark-hover:hover{color:#ffffff;background-color:var(--gdg-accent-color);}.m1bd3197 .md-edit-textarea{position:relative;top:0px;left:0px;width:0px;height:0px;margin-top:25px;opacity:0;padding:0;}.m1bd3197 .ml-6{margin-left:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLXN0eWxlLnRzeCJdLCJuYW1lcyI6WyIubTFiZDMxOTciXSwibWFwcGluZ3MiOiJBQU9hQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9tYXJrZG93bi1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcm93aW5nRW50cnlTdHlsZSB9IGZyb20gXCIuLi8uLi9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGVcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHRhcmdldFdpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBNYXJrZG93bk92ZXJsYXlFZGl0b3JTdHlsZSA9IHN0eWxlZC5kaXY8UHJvcHM+YFxuICAgIG1pbi13aWR0aDogJHtwID0+IHAudGFyZ2V0V2lkdGh9cHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1kYXJrKTtcblxuICAgICR7R3Jvd2luZ0VudHJ5U3R5bGV9IHtcbiAgICAgICAgZmxleC1zaHJpbms6IDE7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICB9XG5cbiAgICAuc3BhY2VyIHtcbiAgICAgICAgZmxleDogMTtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuXG4gICAgICAgIHBhZGRpbmc6IDA7XG5cbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG5cbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIFwiMC4xMjVzIGVhc2VcIjtcblxuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG5cbiAgICAgICAgPiAqIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmVkaXQtaG92ZXIge1xuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1saWdodCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE1MG1zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLmNoZWNrbWFyay1ob3ZlciB7XG4gICAgICAgIDpob3ZlciB7XG4gICAgICAgICAgICBjb2xvcjogI2ZmZmZmZjtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLm1kLWVkaXQtdGV4dGFyZWEge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG4gICAgICAgIHdpZHRoOiAwcHg7XG4gICAgICAgIGhlaWdodDogMHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAyNXB4O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cblxuICAgIC5tbC02IHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDZweDtcbiAgICB9XG5gO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".uvnt6gu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:21px;}.uvnt6gu .link-area{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;cursor:pointer;margin-right:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--gdg-link-color);-webkit-text-decoration:underline !important;text-decoration:underline !important;}.uvnt6gu .edit-icon{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:32px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.uvnt6gu .edit-icon > *{width:24px;height:24px;}.uvnt6gu textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL3VyaS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLnV2bnQ2Z3UiXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS91cmktb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVcmlPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgbWluLWhlaWdodDogMjFweDtcblxuICAgIC5saW5rLWFyZWEge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAxO1xuXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1saW5rLWNvbG9yKTtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIHdpZHRoOiAzMnB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-grid-overlay-editor/private/packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx","webpack://./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx"],"names":[".uvnt6gu"],"mappings":"AAEaA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,eAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,2BAAAA,CAAAA,4CAAAA,CAAAA,oCAAAA,CAAAA,CAAAA,oBAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,wBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,kBAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA;ACDb,uqDAAuqD","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const UriOverlayEditorStyle = styled.div`\n    display: flex;\n\n    flex-grow: 1;\n\n    align-items: center;\n\n    min-height: 21px;\n\n    .link-area {\n        flex-grow: 1;\n        flex-shrink: 1;\n\n        cursor: pointer;\n\n        margin-right: 8px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n\n        color: var(--gdg-link-color);\n        text-decoration: underline !important;\n    }\n\n    .edit-icon {\n        flex-shrink: 0;\n        width: 32px;\n        color: var(--gdg-accent-color);\n\n        cursor: pointer;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n\n        > * {\n            width: 24px;\n            height: 24px;\n        }\n    }\n\n    textarea {\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        width: 0px;\n        height: 0px;\n\n        opacity: 0;\n    }\n`;\n",".uvnt6gu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:21px;}.uvnt6gu .link-area{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;-webkit-flex-shrink:1;-ms-flex-negative:1;flex-shrink:1;cursor:pointer;margin-right:8px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--gdg-link-color);-webkit-text-decoration:underline !important;text-decoration:underline !important;}.uvnt6gu .edit-icon{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:32px;color:var(--gdg-accent-color);cursor:pointer;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.uvnt6gu .edit-icon > *{width:24px;height:24px;}.uvnt6gu textarea{position:absolute;top:0px;left:0px;width:0px;height:0px;opacity:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL3VyaS1vdmVybGF5LWVkaXRvci1zdHlsZS50c3giXSwibmFtZXMiOlsiLnV2bnQ2Z3UiXSwibWFwcGluZ3MiOiJBQUVhQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS91cmktb3ZlcmxheS1lZGl0b3Itc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBVcmlPdmVybGF5RWRpdG9yU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG5cbiAgICBmbGV4LWdyb3c6IDE7XG5cbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgbWluLWhlaWdodDogMjFweDtcblxuICAgIC5saW5rLWFyZWEge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAxO1xuXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcblxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLWdkZy1saW5rLWNvbG9yKTtcbiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAuZWRpdC1pY29uIHtcbiAgICAgICAgZmxleC1zaHJpbms6IDA7XG4gICAgICAgIHdpZHRoOiAzMnB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLWFjY2VudC1jb2xvcik7XG5cbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRhcmVhIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4O1xuICAgICAgICB3aWR0aDogMHB4O1xuICAgICAgICBoZWlnaHQ6IDBweDtcblxuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbmA7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s11k75lr{position:absolute;top:4px;right:20px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);padding:8px;border:1px solid var(--gdg-border-color);border-radius:6px;font-size:var(--gdg-editor-font-size);-webkit-transform:translateX(var(--s11k75lr-0));-ms-transform:translateX(var(--s11k75lr-0));transform:translateX(var(--s11k75lr-0));-webkit-transition:-webkit-transform 0.15s;-webkit-transition:transform 0.15s;transition:transform 0.15s;}.s11k75lr .search-bar-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.s11k75lr .search-status{padding-top:4px;font-size:11px;}.s11k75lr .search-progress{position:absolute;height:4px;left:0;bottom:0;background-color:var(--gdg-text-light);}.s11k75lr input{width:220px;color:var(--gdg-textDark);background-color:var(--gdg-bg-cell);border:none;border-width:0;outline:none;}.s11k75lr button{width:24px;height:24px;padding:0;border:none;outline:none;background:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;color:var(--gdg-text-medium);}.s11k75lr button:hover{color:var(--gdg-text-dark);}.s11k75lr button .button-icon{width:16px;height:16px;}.s11k75lr button:disabled{opacity:0.4;pointer-events:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1zZWFyY2gvZGF0YS1ncmlkLXNlYXJjaC1zdHlsZS50c3giXSwibmFtZXMiOlsiLnMxMWs3NWxyIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgU2VhcmNoV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBzaG93U2VhcmNoOiBib29sZWFuIH0+YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDRweDtcbiAgICByaWdodDogMjBweDtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICBwYWRkaW5nOiA4cHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG5cbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoJHtwID0+IChwLnNob3dTZWFyY2ggPyAwIDogNDAwKX1weCk7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTVzO1xuXG4gICAgLnNlYXJjaC1iYXItaW5uZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtc3RhdHVzIHtcbiAgICAgICAgcGFkZGluZy10b3A6IDRweDtcbiAgICAgICAgZm9udC1zaXplOiAxMXB4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtcHJvZ3Jlc3Mge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuICAgIH1cblxuICAgIGlucHV0IHtcbiAgICAgICAgd2lkdGg6IDIyMHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHREYXJrKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG5cbiAgICBidXR0b24ge1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBwYWRkaW5nOiAwO1xuXG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgLmJ1dHRvbi1pY29uIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgOmRpc2FibGVkIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuYDtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/core/src/data-grid-search/packages/core/src/data-grid-search/data-grid-search-style.tsx","webpack://./packages/core/src/data-grid-search/data-grid-search-style.tsx"],"names":[".s11k75lr"],"mappings":"AAEaA,UAAAA,iBAAAA,CAAAA,OAAAA,CAAAA,UAAAA,CAAAA,mCAAAA,CAAAA,0BAAAA,CAAAA,WAAAA,CAAAA,wCAAAA,CAAAA,iBAAAA,CAAAA,qCAAAA,CAAAA,+CAAAA,CAAAA,2CAAAA,CAAAA,uCAAAA,CAAAA,0CAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,CAAAA,4BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,CAAAA,yBAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,2BAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,sCAAAA,CAAAA,CAAAA,gBAAAA,WAAAA,CAAAA,yBAAAA,CAAAA,mCAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA,YAAAA,CAAAA,CAAAA,iBAAAA,UAAAA,CAAAA,WAAAA,CAAAA,SAAAA,CAAAA,WAAAA,CAAAA,YAAAA,CAAAA,eAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,uBAAAA,CAAAA,8BAAAA,CAAAA,oBAAAA,CAAAA,sBAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,cAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,uBAAAA,0BAAAA,CAAAA,CAAAA,8BAAAA,UAAAA,CAAAA,WAAAA,CAAAA,CAAAA,0BAAAA,WAAAA,CAAAA,mBAAAA,CAAAA;ACDb,26EAA26E","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const SearchWrapper = styled.div<{ showSearch: boolean }>`\n    position: absolute;\n    top: 4px;\n    right: 20px;\n\n    background-color: var(--gdg-bg-cell);\n    color: var(--gdg-text-dark);\n\n    padding: 8px;\n    border: 1px solid var(--gdg-border-color);\n    border-radius: 6px;\n\n    font-size: var(--gdg-editor-font-size);\n\n    transform: translateX(${p => (p.showSearch ? 0 : 400)}px);\n    transition: transform 0.15s;\n\n    .search-bar-inner {\n        display: flex;\n    }\n\n    .search-status {\n        padding-top: 4px;\n        font-size: 11px;\n    }\n\n    .search-progress {\n        position: absolute;\n        height: 4px;\n        left: 0;\n        bottom: 0;\n\n        background-color: var(--gdg-text-light);\n    }\n\n    input {\n        width: 220px;\n        color: var(--gdg-textDark);\n        background-color: var(--gdg-bg-cell);\n        border: none;\n        border-width: 0;\n        outline: none;\n    }\n\n    button {\n        width: 24px;\n        height: 24px;\n        padding: 0;\n\n        border: none;\n        outline: none;\n        background: none;\n\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        cursor: pointer;\n        color: var(--gdg-text-medium);\n\n        :hover {\n            color: var(--gdg-text-dark);\n        }\n\n        .button-icon {\n            width: 16px;\n            height: 16px;\n        }\n\n        :disabled {\n            opacity: 0.4;\n            pointer-events: none;\n        }\n    }\n`;\n",".s11k75lr{position:absolute;top:4px;right:20px;background-color:var(--gdg-bg-cell);color:var(--gdg-text-dark);padding:8px;border:1px solid var(--gdg-border-color);border-radius:6px;font-size:var(--gdg-editor-font-size);-webkit-transform:translateX(var(--s11k75lr-0));-ms-transform:translateX(var(--s11k75lr-0));transform:translateX(var(--s11k75lr-0));-webkit-transition:-webkit-transform 0.15s;-webkit-transition:transform 0.15s;transition:transform 0.15s;}.s11k75lr .search-bar-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.s11k75lr .search-status{padding-top:4px;font-size:11px;}.s11k75lr .search-progress{position:absolute;height:4px;left:0;bottom:0;background-color:var(--gdg-text-light);}.s11k75lr input{width:220px;color:var(--gdg-textDark);background-color:var(--gdg-bg-cell);border:none;border-width:0;outline:none;}.s11k75lr button{width:24px;height:24px;padding:0;border:none;outline:none;background:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;color:var(--gdg-text-medium);}.s11k75lr button:hover{color:var(--gdg-text-dark);}.s11k75lr button .button-icon{width:16px;height:16px;}.s11k75lr button:disabled{opacity:0.4;pointer-events:none;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RhdGEtZ3JpZC1zZWFyY2gvZGF0YS1ncmlkLXNlYXJjaC1zdHlsZS50c3giXSwibmFtZXMiOlsiLnMxMWs3NWxyIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgU2VhcmNoV3JhcHBlciA9IHN0eWxlZC5kaXY8eyBzaG93U2VhcmNoOiBib29sZWFuIH0+YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDRweDtcbiAgICByaWdodDogMjBweDtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1jZWxsKTtcbiAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtZGFyayk7XG5cbiAgICBwYWRkaW5nOiA4cHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG5cbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoJHtwID0+IChwLnNob3dTZWFyY2ggPyAwIDogNDAwKX1weCk7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTVzO1xuXG4gICAgLnNlYXJjaC1iYXItaW5uZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtc3RhdHVzIHtcbiAgICAgICAgcGFkZGluZy10b3A6IDRweDtcbiAgICAgICAgZm9udC1zaXplOiAxMXB4O1xuICAgIH1cblxuICAgIC5zZWFyY2gtcHJvZ3Jlc3Mge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogNHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLXRleHQtbGlnaHQpO1xuICAgIH1cblxuICAgIGlucHV0IHtcbiAgICAgICAgd2lkdGg6IDIyMHB4O1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHREYXJrKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci13aWR0aDogMDtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG5cbiAgICBidXR0b24ge1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBwYWRkaW5nOiAwO1xuXG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcblxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBjb2xvcjogdmFyKC0tZ2RnLXRleHQtbWVkaXVtKTtcblxuICAgICAgICA6aG92ZXIge1xuICAgICAgICAgICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgLmJ1dHRvbi1pY29uIHtcbiAgICAgICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgOmRpc2FibGVkIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB9XG4gICAgfVxuYDtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".w1gh5fuv{overflow:hidden;position:relative;border-radius:12px;box-shadow:0 2px 5px rgba(0,0,0,0.2),0 0 1px rgba(0,0,0,0.4);width:100%;height:var(--w1gh5fuv-0);margin:24px 0;}.w1gh5fuv > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n.b1bk6rj1{background:white;color:#222222;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;font-family:sans-serif;}.b1bk6rj1 .inner{position:relative;width:900px;}.b1bk6rj1 .inner > pre{font-size:14px;border-radius:9px;}.b1bk6rj1 .marked{font-family:Helvetica,arial,sans-serif;font-size:18px;line-height:1.6;}.b1bk6rj1 .marked > *:first-child{margin-top:0 !important;}.b1bk6rj1 .marked > *:last-child{margin-bottom:0 !important;}.b1bk6rj1 .marked a{color:#4183c4;}.b1bk6rj1 .marked a.absent{color:#cc0000;}.b1bk6rj1 .marked a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0;}.b1bk6rj1 .marked h1,.b1bk6rj1 .marked h2,.b1bk6rj1 .marked h3,.b1bk6rj1 .marked h4,.b1bk6rj1 .marked h5,.b1bk6rj1 .marked h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased;cursor:text;position:relative;}.b1bk6rj1 .marked h1:hover a.anchor,.b1bk6rj1 .marked h2:hover a.anchor,.b1bk6rj1 .marked h3:hover a.anchor,.b1bk6rj1 .marked h4:hover a.anchor,.b1bk6rj1 .marked h5:hover a.anchor,.b1bk6rj1 .marked h6:hover a.anchor{-webkit-text-decoration:none;text-decoration:none;}.b1bk6rj1 .marked h1 tt,.b1bk6rj1 .marked h1 code{font-size:inherit;}.b1bk6rj1 .marked h2 tt,.b1bk6rj1 .marked h2 code{font-size:inherit;}.b1bk6rj1 .marked h3 tt,.b1bk6rj1 .marked h3 code{font-size:inherit;}.b1bk6rj1 .marked h4 tt,.b1bk6rj1 .marked h4 code{font-size:inherit;}.b1bk6rj1 .marked h5 tt,.b1bk6rj1 .marked h5 code{font-size:inherit;}.b1bk6rj1 .marked h6 tt,.b1bk6rj1 .marked h6 code{font-size:inherit;}.b1bk6rj1 .marked h1{font-size:32px;color:black;}.b1bk6rj1 .marked h2{font-size:28px;border-bottom:1px solid #cccccc;color:black;}.b1bk6rj1 .marked h3{font-size:22px;}.b1bk6rj1 .marked h4{font-size:20px;}.b1bk6rj1 .marked h5{font-size:18px;}.b1bk6rj1 .marked h6{color:#777777;font-size:18px;}.b1bk6rj1 .marked p,.b1bk6rj1 .marked blockquote,.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol,.b1bk6rj1 .marked dl,.b1bk6rj1 .marked li,.b1bk6rj1 .marked table,.b1bk6rj1 .marked pre{margin:20px 0;}.b1bk6rj1 .marked hr{border:0 none;color:#cccccc;height:4px;padding:0;}.b1bk6rj1 .marked > h2:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child + h2{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h3:first-child,.b1bk6rj1 .marked > h4:first-child,.b1bk6rj1 .marked > h5:first-child,.b1bk6rj1 .marked > h6:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked a:first-child h1,.b1bk6rj1 .marked a:first-child h2,.b1bk6rj1 .marked a:first-child h3,.b1bk6rj1 .marked a:first-child h4,.b1bk6rj1 .marked a:first-child h5,.b1bk6rj1 .marked a:first-child h6{margin-top:0;padding-top:0;}.b1bk6rj1 .marked h1 p,.b1bk6rj1 .marked h2 p,.b1bk6rj1 .marked h3 p,.b1bk6rj1 .marked h4 p,.b1bk6rj1 .marked h5 p,.b1bk6rj1 .marked h6 p{margin-top:0;}.b1bk6rj1 .marked li p.first{display:inline-block;}.b1bk6rj1 .marked li{margin:0;}.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol{padding-left:30px;}.b1bk6rj1 .marked ul :first-child,.b1bk6rj1 .marked ol :first-child{margin-top:0;}.b1bk6rj1 .marked dl{padding:0;}.b1bk6rj1 .marked dl dt{font-size:18px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px;}.b1bk6rj1 .marked dl dt:first-child{padding:0;}.b1bk6rj1 .marked dl dt > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dt > :last-child{margin-bottom:0;}.b1bk6rj1 .marked dl dd{margin:0 0 15px;padding:0 15px;}.b1bk6rj1 .marked dl dd > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dd > :last-child{margin-bottom:0;}.b1bk6rj1 .marked blockquote{border-left:4px solid #dddddd;padding:0 15px;color:#777777;}.b1bk6rj1 .marked blockquote > :first-child{margin-top:0;}.b1bk6rj1 .marked blockquote > :last-child{margin-bottom:0;}.b1bk6rj1 .marked table{font-size:14px;padding:0;border-collapse:collapse;}.b1bk6rj1 .marked table tr{border-top:1px solid #cccccc;background-color:white;margin:0;padding:0;}.b1bk6rj1 .marked table tr:nth-child(2n){background-color:#f8f8f8;}.b1bk6rj1 .marked table tr th{font-weight:bold;border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr td{border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr th :first-child,.b1bk6rj1 .marked table tr td :first-child{margin-top:0;}.b1bk6rj1 .marked table tr th :last-child,.b1bk6rj1 .marked table tr td :last-child{margin-bottom:0;}.b1bk6rj1 .marked img{max-width:100%;}.b1bk6rj1 .marked span.frame{display:block;overflow:hidden;}.b1bk6rj1 .marked span.frame > span{border:1px solid #dddddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto;}.b1bk6rj1 .marked span.frame span img{display:block;float:left;}.b1bk6rj1 .marked span.frame span span{clear:both;color:#333333;display:block;padding:5px 0 0;}.b1bk6rj1 .marked span.align-center{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center;}.b1bk6rj1 .marked span.align-center span img{margin:0 auto;text-align:center;}.b1bk6rj1 .marked span.align-right{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right;}.b1bk6rj1 .marked span.align-right span img{margin:0;text-align:right;}.b1bk6rj1 .marked span.float-left{display:block;margin-right:13px;overflow:hidden;float:left;}.b1bk6rj1 .marked span.float-left span{margin:13px 0 0;}.b1bk6rj1 .marked span.float-right{display:block;margin-left:13px;overflow:hidden;float:right;}.b1bk6rj1 .marked span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right;}.b1bk6rj1 .marked code,.b1bk6rj1 .marked tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;}.b1bk6rj1 .marked pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent;}.b1bk6rj1 .marked .highlight pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre code,.b1bk6rj1 .marked pre tt{background-color:transparent;border:none;}.b1bk6rj1 .marked sup{font-size:0.83em;vertical-align:super;line-height:0;}.b1bk6rj1 .marked *{-webkit-print-color-adjust:exact;}\n.p65g85a{font-family:monospace;font-weight:500;color:#ffe394;}\n.d2b9oy3{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.mnvl60p{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.mnvl60p button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RvY3MvZG9jLXdyYXBwZXIudHN4Il0sIm5hbWVzIjpbIi53MWdoNWZ1diIsIi5iMWJrNnJqMSIsIi5wNjVnODVhIiwiLmQyYjlveTMiLCIubW52bDYwcCJdLCJtYXBwaW5ncyI6IkFBVWFBO0FBNkNQQztBQStaT0M7QUFNQUM7QUFNQUMiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZG9jcy9kb2Mtd3JhcHBlci50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gXCJtYXJrZWRcIjtcbmltcG9ydCBTeW50YXhIaWdobGlnaHRlciBmcm9tIFwicmVhY3Qtc3ludGF4LWhpZ2hsaWdodGVyXCI7XG5pbXBvcnQgaGlnaGxpZ2h0U3R5bGUgZnJvbSBcInJlYWN0LXN5bnRheC1oaWdobGlnaHRlci9kaXN0L2VzbS9zdHlsZXMvaGxqcy9naXRodWJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGhlaWdodDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8V3JhcHBlclByb3BzPmBcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG5cbiAgICBib3gtc2hhZG93OiAwIDJweCA1cHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcblxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuXG4gICAgbWFyZ2luOiAyNHB4IDA7XG5cbiAgICA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHQ6IFJlYWN0LlZGQzx7IGNoaWxkcmVuOiBzdHJpbmcgfT4gPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8U3ludGF4SGlnaGxpZ2h0ZXJcbiAgICAgICAgICAgIHN0eWxlPXtoaWdobGlnaHRTdHlsZX1cbiAgICAgICAgICAgIHNob3dMaW5lTnVtYmVycz17dHJ1ZX1cbiAgICAgICAgICAgIGxpbmVOdW1iZXJTdHlsZT17eyBvcGFjaXR5OiAwLjUgfX1cbiAgICAgICAgICAgIGxhbmd1YWdlPVwidHlwZXNjcmlwdFwiPlxuICAgICAgICAgICAge3AuY2hpbGRyZW4udHJpbSgpfVxuICAgICAgICA8L1N5bnRheEhpZ2hsaWdodGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTWFya2VkOiBSZWFjdC5WRkM8eyBjaGlsZHJlbjogc3RyaW5nIH0+ID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWFya2VkXCJcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgICAgICAgICAgX19odG1sOiBtYXJrZWQocC5jaGlsZHJlbiksXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICk7XG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgY29sb3I6ICMyMjIyMjI7XG5cbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcblxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuXG4gICAgJiAuaW5uZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiA5MDBweDtcblxuICAgICAgICA+IHByZSB7XG4gICAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWFya2VkIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuNjtcblxuICAgICAgICA+ICo6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgID4gKjpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAgIWltcG9ydGFudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGEge1xuICAgICAgICAgICAgY29sb3I6ICM0MTgzYzQ7XG4gICAgICAgIH1cbiAgICAgICAgYS5hYnNlbnQge1xuICAgICAgICAgICAgY29sb3I6ICNjYzAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgYS5hbmNob3Ige1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6IDMwcHg7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogLTMwcHg7XG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEsXG4gICAgICAgIGgyLFxuICAgICAgICBoMyxcbiAgICAgICAgaDQsXG4gICAgICAgIGg1LFxuICAgICAgICBoNiB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMCAxMHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgICAgICAgICBjdXJzb3I6IHRleHQ7XG4gICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICBoMTpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDI6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGgzOmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoNDpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDU6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGg2OmhvdmVyIGEuYW5jaG9yIHtcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHR0LFxuICAgICAgICBoMSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHR0LFxuICAgICAgICBoMiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgzIHR0LFxuICAgICAgICBoMyBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg0IHR0LFxuICAgICAgICBoNCBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg1IHR0LFxuICAgICAgICBoNSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg2IHR0LFxuICAgICAgICBoNiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcbiAgICAgICAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjhweDtcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaDMge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDQge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDUge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDYge1xuICAgICAgICAgICAgY29sb3I6ICM3Nzc3Nzc7XG4gICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICAgIH1cblxuICAgICAgICBwLFxuICAgICAgICBibG9ja3F1b3RlLFxuICAgICAgICB1bCxcbiAgICAgICAgb2wsXG4gICAgICAgIGRsLFxuICAgICAgICBsaSxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhyIHtcbiAgICAgICAgICAgIGJvcmRlcjogMCBub25lO1xuICAgICAgICAgICAgY29sb3I6ICNjY2NjY2M7XG4gICAgICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cblxuICAgICAgICA+IGgyOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkICsgaDIge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDM6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDQ6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDU6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDY6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMixcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMyxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNCxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNiB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBoMSBwLFxuICAgICAgICBoMiBwLFxuICAgICAgICBoMyBwLFxuICAgICAgICBoNCBwLFxuICAgICAgICBoNSBwLFxuICAgICAgICBoNiBwIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsaSBwLmZpcnN0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgfVxuICAgICAgICBsaSB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIH1cbiAgICAgICAgdWwsXG4gICAgICAgIG9sIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVsIDpmaXJzdC1jaGlsZCxcbiAgICAgICAgb2wgOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkbCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0IHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwIDVweDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkdDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0ID4gOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQgPiA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGRkIHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDE1cHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDE1cHg7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZGQgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkZCA+IDpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICAgIH1cblxuICAgICAgICBibG9ja3F1b3RlIHtcbiAgICAgICAgICAgIGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2RkZGRkZDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICAgICAgICAgIGNvbG9yOiAjNzc3Nzc3O1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrcXVvdGUgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3F1b3RlID4gOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHtcbiAgICAgICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyOm50aC1jaGlsZCgybikge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCB7XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTNweDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0ZCB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDEzcHg7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHIgdGggOmZpcnN0LWNoaWxkLFxuICAgICAgICB0YWJsZSB0ciB0ZCA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCA6bGFzdC1jaGlsZCxcbiAgICAgICAgdGFibGUgdHIgdGQgOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIH1cblxuICAgICAgICBzcGFuLmZyYW1lIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZyYW1lID4gc3BhbiB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkZGRkO1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgcGFkZGluZzogN3B4O1xuICAgICAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mcmFtZSBzcGFuIGltZyB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZnJhbWUgc3BhbiBzcGFuIHtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICAgICAgY29sb3I6ICMzMzMzMzM7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIHBhZGRpbmc6IDVweCAwIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgc3BhbiBpbWcge1xuICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBjbGVhcjogYm90aDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0ID4gc3BhbiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCBzcGFuIGltZyB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LWxlZnQge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mbG9hdC1sZWZ0IHNwYW4ge1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IDAgMDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LXJpZ2h0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtcmlnaHQgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHR0IHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAycHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDVweDtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSBjb2RlIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAuaGlnaGxpZ2h0IHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuICAgICAgICBwcmUgY29kZSxcbiAgICAgICAgcHJlIHR0IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMC44M2VtO1xuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IHN1cGVyO1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgKiB7XG4gICAgICAgICAgICAtd2Via2l0LXByaW50LWNvbG9yLWFkanVzdDogZXhhY3Q7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBEb2NXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbm5lclwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/core/src/docs/packages/core/src/docs/doc-wrapper.tsx","webpack://./packages/core/src/docs/doc-wrapper.tsx"],"names":[".w1gh5fuv",".b1bk6rj1",".p65g85a",".d2b9oy3",".mnvl60p"],"mappings":"AAUaA,UAAAA,eAAAA,CAAAA,iBAAAA,CAAAA,kBAAAA,CAAAA,4DAAAA,CAAAA,UAAAA,CAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,yBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;AA6CPC,UAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,0BAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,kBAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,gBAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,uBAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,kBAAAA,sCAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,CAAAA,kCAAAA,uBAAAA,CAAAA,CAAAA,iCAAAA,0BAAAA,CAAAA,CAAAA,oBAAAA,aAAAA,CAAAA,CAAAA,2BAAAA,aAAAA,CAAAA,CAAAA,2BAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,KAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,CAAAA,8HAAAA,kBAAAA,CAAAA,SAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,wNAAAA,4BAAAA,CAAAA,oBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,kDAAAA,iBAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,WAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,+BAAAA,CAAAA,WAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,cAAAA,CAAAA,CAAAA,qBAAAA,aAAAA,CAAAA,cAAAA,CAAAA,CAAAA,mLAAAA,aAAAA,CAAAA,CAAAA,qBAAAA,aAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,SAAAA,CAAAA,CAAAA,mCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,mCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,wCAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,4IAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,kNAAAA,YAAAA,CAAAA,aAAAA,CAAAA,CAAAA,0IAAAA,YAAAA,CAAAA,CAAAA,6BAAAA,oBAAAA,CAAAA,CAAAA,qBAAAA,QAAAA,CAAAA,CAAAA,0CAAAA,iBAAAA,CAAAA,CAAAA,oEAAAA,YAAAA,CAAAA,CAAAA,qBAAAA,SAAAA,CAAAA,CAAAA,wBAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,SAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oCAAAA,SAAAA,CAAAA,CAAAA,uCAAAA,YAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,wBAAAA,eAAAA,CAAAA,cAAAA,CAAAA,CAAAA,uCAAAA,YAAAA,CAAAA,CAAAA,sCAAAA,eAAAA,CAAAA,CAAAA,6BAAAA,6BAAAA,CAAAA,cAAAA,CAAAA,aAAAA,CAAAA,CAAAA,4CAAAA,YAAAA,CAAAA,CAAAA,2CAAAA,eAAAA,CAAAA,CAAAA,wBAAAA,cAAAA,CAAAA,SAAAA,CAAAA,wBAAAA,CAAAA,CAAAA,2BAAAA,4BAAAA,CAAAA,sBAAAA,CAAAA,QAAAA,CAAAA,SAAAA,CAAAA,CAAAA,yCAAAA,wBAAAA,CAAAA,CAAAA,8BAAAA,gBAAAA,CAAAA,wBAAAA,CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,8BAAAA,wBAAAA,CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,sFAAAA,YAAAA,CAAAA,CAAAA,oFAAAA,eAAAA,CAAAA,CAAAA,sBAAAA,cAAAA,CAAAA,CAAAA,6BAAAA,aAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oCAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,UAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,UAAAA,CAAAA,CAAAA,sCAAAA,aAAAA,CAAAA,UAAAA,CAAAA,CAAAA,uCAAAA,UAAAA,CAAAA,aAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,CAAAA,oCAAAA,aAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,2CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,kBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,6CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,mCAAAA,aAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,0CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,eAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,4CAAAA,QAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,kCAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,eAAAA,CAAAA,UAAAA,CAAAA,CAAAA,uCAAAA,eAAAA,CAAAA,CAAAA,mCAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,CAAAA,0CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,kBAAAA,CAAAA,gBAAAA,CAAAA,CAAAA,4CAAAA,YAAAA,CAAAA,aAAAA,CAAAA,kBAAAA,CAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,2BAAAA,QAAAA,CAAAA,SAAAA,CAAAA,eAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,iCAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,sBAAAA,wBAAAA,CAAAA,wBAAAA,CAAAA,cAAAA,CAAAA,gBAAAA,CAAAA,aAAAA,CAAAA,gBAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oDAAAA,4BAAAA,CAAAA,WAAAA,CAAAA,CAAAA,sBAAAA,gBAAAA,CAAAA,oBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,oBAAAA,gCAAAA,CAAAA;AA+ZOC,SAAAA,qBAAAA,CAAAA,eAAAA,CAAAA,aAAAA,CAAAA;AAMAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AAMAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,gBAAAA,wBAAAA,CAAAA,aAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,cAAAA,CAAAA,iBAAAA,CAAAA,gCAAAA,CAAAA,cAAAA,CAAAA,WAAAA,CAAAA,cAAAA,CAAAA;AC7db,uneAAune","sourcesContent":["import React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport { marked } from \"marked\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\nimport highlightStyle from \"react-syntax-highlighter/dist/esm/styles/hljs/github\";\n\nexport interface WrapperProps {\n    height: number;\n}\n\nexport const Wrapper = styled.div<WrapperProps>`\n    overflow: hidden;\n    position: relative;\n\n    border-radius: 12px;\n\n    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2), 0 0 1px rgba(0, 0, 0, 0.4);\n\n    width: 100%;\n    height: ${p => p.height}px;\n\n    margin: 24px 0;\n\n    > :first-child {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nexport const Highlight: React.VFC<{ children: string }> = p => {\n    return (\n        <SyntaxHighlighter\n            style={highlightStyle}\n            showLineNumbers={true}\n            lineNumberStyle={{ opacity: 0.5 }}\n            language=\"typescript\">\n            {p.children.trim()}\n        </SyntaxHighlighter>\n    );\n};\n\nexport const Marked: React.VFC<{ children: string }> = p => {\n    return (\n        <div\n            className=\"marked\"\n            dangerouslySetInnerHTML={{\n                __html: marked(p.children),\n            }}\n        />\n    );\n};\n\nconst BeautifulStyle = styled.div`\n    background: white;\n    color: #222222;\n\n    padding: 32px 48px;\n\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n    min-height: 100vh;\n\n    font-family: sans-serif;\n\n    & .inner {\n        position: relative;\n        width: 900px;\n\n        > pre {\n            font-size: 14px;\n            border-radius: 9px;\n        }\n    }\n\n    .marked {\n        font-family: Helvetica, arial, sans-serif;\n        font-size: 18px;\n        line-height: 1.6;\n\n        > *:first-child {\n            margin-top: 0 !important;\n        }\n        > *:last-child {\n            margin-bottom: 0 !important;\n        }\n\n        a {\n            color: #4183c4;\n        }\n        a.absent {\n            color: #cc0000;\n        }\n        a.anchor {\n            display: block;\n            padding-left: 30px;\n            margin-left: -30px;\n            cursor: pointer;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n            margin: 20px 0 10px;\n            padding: 0;\n            font-weight: bold;\n            -webkit-font-smoothing: antialiased;\n            cursor: text;\n            position: relative;\n        }\n\n        h1:hover a.anchor,\n        h2:hover a.anchor,\n        h3:hover a.anchor,\n        h4:hover a.anchor,\n        h5:hover a.anchor,\n        h6:hover a.anchor {\n            text-decoration: none;\n        }\n\n        h1 tt,\n        h1 code {\n            font-size: inherit;\n        }\n\n        h2 tt,\n        h2 code {\n            font-size: inherit;\n        }\n\n        h3 tt,\n        h3 code {\n            font-size: inherit;\n        }\n\n        h4 tt,\n        h4 code {\n            font-size: inherit;\n        }\n\n        h5 tt,\n        h5 code {\n            font-size: inherit;\n        }\n\n        h6 tt,\n        h6 code {\n            font-size: inherit;\n        }\n\n        h1 {\n            font-size: 32px;\n            color: black;\n        }\n\n        h2 {\n            font-size: 28px;\n            border-bottom: 1px solid #cccccc;\n            color: black;\n        }\n\n        h3 {\n            font-size: 22px;\n        }\n\n        h4 {\n            font-size: 20px;\n        }\n\n        h5 {\n            font-size: 18px;\n        }\n\n        h6 {\n            color: #777777;\n            font-size: 18px;\n        }\n\n        p,\n        blockquote,\n        ul,\n        ol,\n        dl,\n        li,\n        table,\n        pre {\n            margin: 20px 0;\n        }\n\n        hr {\n            border: 0 none;\n            color: #cccccc;\n            height: 4px;\n            padding: 0;\n        }\n\n        > h2:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h1:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h1:first-child + h2 {\n            margin-top: 0;\n            padding-top: 0;\n        }\n        > h3:first-child,\n        > h4:first-child,\n        > h5:first-child,\n        > h6:first-child {\n            margin-top: 0;\n            padding-top: 0;\n        }\n\n        a:first-child h1,\n        a:first-child h2,\n        a:first-child h3,\n        a:first-child h4,\n        a:first-child h5,\n        a:first-child h6 {\n            margin-top: 0;\n            padding-top: 0;\n        }\n\n        h1 p,\n        h2 p,\n        h3 p,\n        h4 p,\n        h5 p,\n        h6 p {\n            margin-top: 0;\n        }\n\n        li p.first {\n            display: inline-block;\n        }\n        li {\n            margin: 0;\n        }\n        ul,\n        ol {\n            padding-left: 30px;\n        }\n\n        ul :first-child,\n        ol :first-child {\n            margin-top: 0;\n        }\n\n        dl {\n            padding: 0;\n        }\n        dl dt {\n            font-size: 18px;\n            font-weight: bold;\n            font-style: italic;\n            padding: 0;\n            margin: 15px 0 5px;\n        }\n        dl dt:first-child {\n            padding: 0;\n        }\n        dl dt > :first-child {\n            margin-top: 0;\n        }\n        dl dt > :last-child {\n            margin-bottom: 0;\n        }\n        dl dd {\n            margin: 0 0 15px;\n            padding: 0 15px;\n        }\n        dl dd > :first-child {\n            margin-top: 0;\n        }\n        dl dd > :last-child {\n            margin-bottom: 0;\n        }\n\n        blockquote {\n            border-left: 4px solid #dddddd;\n            padding: 0 15px;\n            color: #777777;\n        }\n        blockquote > :first-child {\n            margin-top: 0;\n        }\n        blockquote > :last-child {\n            margin-bottom: 0;\n        }\n\n        table {\n            font-size: 14px;\n            padding: 0;\n            border-collapse: collapse;\n        }\n        table tr {\n            border-top: 1px solid #cccccc;\n            background-color: white;\n            margin: 0;\n            padding: 0;\n        }\n        table tr:nth-child(2n) {\n            background-color: #f8f8f8;\n        }\n        table tr th {\n            font-weight: bold;\n            border: 1px solid #cccccc;\n            margin: 0;\n            padding: 6px 13px;\n        }\n        table tr td {\n            border: 1px solid #cccccc;\n            margin: 0;\n            padding: 6px 13px;\n        }\n        table tr th :first-child,\n        table tr td :first-child {\n            margin-top: 0;\n        }\n        table tr th :last-child,\n        table tr td :last-child {\n            margin-bottom: 0;\n        }\n\n        img {\n            max-width: 100%;\n        }\n\n        span.frame {\n            display: block;\n            overflow: hidden;\n        }\n        span.frame > span {\n            border: 1px solid #dddddd;\n            display: block;\n            float: left;\n            overflow: hidden;\n            margin: 13px 0 0;\n            padding: 7px;\n            width: auto;\n        }\n        span.frame span img {\n            display: block;\n            float: left;\n        }\n        span.frame span span {\n            clear: both;\n            color: #333333;\n            display: block;\n            padding: 5px 0 0;\n        }\n        span.align-center {\n            display: block;\n            overflow: hidden;\n            clear: both;\n        }\n        span.align-center > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px auto 0;\n            text-align: center;\n        }\n        span.align-center span img {\n            margin: 0 auto;\n            text-align: center;\n        }\n        span.align-right {\n            display: block;\n            overflow: hidden;\n            clear: both;\n        }\n        span.align-right > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px 0 0;\n            text-align: right;\n        }\n        span.align-right span img {\n            margin: 0;\n            text-align: right;\n        }\n        span.float-left {\n            display: block;\n            margin-right: 13px;\n            overflow: hidden;\n            float: left;\n        }\n        span.float-left span {\n            margin: 13px 0 0;\n        }\n        span.float-right {\n            display: block;\n            margin-left: 13px;\n            overflow: hidden;\n            float: right;\n        }\n        span.float-right > span {\n            display: block;\n            overflow: hidden;\n            margin: 13px auto 0;\n            text-align: right;\n        }\n\n        code,\n        tt {\n            margin: 0 2px;\n            padding: 0 5px;\n            white-space: nowrap;\n            border: 1px solid #eaeaea;\n            background-color: #f8f8f8;\n            border-radius: 3px;\n        }\n\n        pre code {\n            margin: 0;\n            padding: 0;\n            white-space: pre;\n            border: none;\n            background: transparent;\n        }\n\n        .highlight pre {\n            background-color: #f8f8f8;\n            border: 1px solid #cccccc;\n            font-size: 17px;\n            line-height: 23px;\n            overflow: auto;\n            padding: 6px 10px;\n            border-radius: 3px;\n        }\n\n        pre {\n            background-color: #f8f8f8;\n            border: 1px solid #cccccc;\n            font-size: 17px;\n            line-height: 23px;\n            overflow: auto;\n            padding: 6px 10px;\n            border-radius: 3px;\n        }\n        pre code,\n        pre tt {\n            background-color: transparent;\n            border: none;\n        }\n\n        sup {\n            font-size: 0.83em;\n            vertical-align: super;\n            line-height: 0;\n        }\n        * {\n            -webkit-print-color-adjust: exact;\n        }\n    }\n`;\n\nexport const PropName = styled.span`\n    font-family: monospace;\n    font-weight: 500;\n    color: #ffe394;\n`;\n\nexport const Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nexport const MoreInfo = styled.p`\n    font-size: 14px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n\n    button {\n        background-color: #f4f4f4;\n        color: #2b2b2b;\n        padding: 2px 6px;\n        font-family: monospace;\n        font-size: 14px;\n        border-radius: 4px;\n        box-shadow: 0px 1px 2px #00000040;\n        margin: 0 0.1em;\n        border: none;\n        cursor: pointer;\n    }\n`;\n\nexport const DocWrapper: React.FC = p => {\n    const { children } = p;\n    return (\n        <BeautifulStyle>\n            <div className=\"inner\">{children}</div>\n        </BeautifulStyle>\n    );\n};\n",".w1gh5fuv{overflow:hidden;position:relative;border-radius:12px;box-shadow:0 2px 5px rgba(0,0,0,0.2),0 0 1px rgba(0,0,0,0.4);width:100%;height:var(--w1gh5fuv-0);margin:24px 0;}.w1gh5fuv > :first-child{position:absolute;left:0;top:0;width:100%;height:100%;}\n.b1bk6rj1{background:white;color:#222222;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;font-family:sans-serif;}.b1bk6rj1 .inner{position:relative;width:900px;}.b1bk6rj1 .inner > pre{font-size:14px;border-radius:9px;}.b1bk6rj1 .marked{font-family:Helvetica,arial,sans-serif;font-size:18px;line-height:1.6;}.b1bk6rj1 .marked > *:first-child{margin-top:0 !important;}.b1bk6rj1 .marked > *:last-child{margin-bottom:0 !important;}.b1bk6rj1 .marked a{color:#4183c4;}.b1bk6rj1 .marked a.absent{color:#cc0000;}.b1bk6rj1 .marked a.anchor{display:block;padding-left:30px;margin-left:-30px;cursor:pointer;position:absolute;top:0;left:0;bottom:0;}.b1bk6rj1 .marked h1,.b1bk6rj1 .marked h2,.b1bk6rj1 .marked h3,.b1bk6rj1 .marked h4,.b1bk6rj1 .marked h5,.b1bk6rj1 .marked h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased;cursor:text;position:relative;}.b1bk6rj1 .marked h1:hover a.anchor,.b1bk6rj1 .marked h2:hover a.anchor,.b1bk6rj1 .marked h3:hover a.anchor,.b1bk6rj1 .marked h4:hover a.anchor,.b1bk6rj1 .marked h5:hover a.anchor,.b1bk6rj1 .marked h6:hover a.anchor{-webkit-text-decoration:none;text-decoration:none;}.b1bk6rj1 .marked h1 tt,.b1bk6rj1 .marked h1 code{font-size:inherit;}.b1bk6rj1 .marked h2 tt,.b1bk6rj1 .marked h2 code{font-size:inherit;}.b1bk6rj1 .marked h3 tt,.b1bk6rj1 .marked h3 code{font-size:inherit;}.b1bk6rj1 .marked h4 tt,.b1bk6rj1 .marked h4 code{font-size:inherit;}.b1bk6rj1 .marked h5 tt,.b1bk6rj1 .marked h5 code{font-size:inherit;}.b1bk6rj1 .marked h6 tt,.b1bk6rj1 .marked h6 code{font-size:inherit;}.b1bk6rj1 .marked h1{font-size:32px;color:black;}.b1bk6rj1 .marked h2{font-size:28px;border-bottom:1px solid #cccccc;color:black;}.b1bk6rj1 .marked h3{font-size:22px;}.b1bk6rj1 .marked h4{font-size:20px;}.b1bk6rj1 .marked h5{font-size:18px;}.b1bk6rj1 .marked h6{color:#777777;font-size:18px;}.b1bk6rj1 .marked p,.b1bk6rj1 .marked blockquote,.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol,.b1bk6rj1 .marked dl,.b1bk6rj1 .marked li,.b1bk6rj1 .marked table,.b1bk6rj1 .marked pre{margin:20px 0;}.b1bk6rj1 .marked hr{border:0 none;color:#cccccc;height:4px;padding:0;}.b1bk6rj1 .marked > h2:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h1:first-child + h2{margin-top:0;padding-top:0;}.b1bk6rj1 .marked > h3:first-child,.b1bk6rj1 .marked > h4:first-child,.b1bk6rj1 .marked > h5:first-child,.b1bk6rj1 .marked > h6:first-child{margin-top:0;padding-top:0;}.b1bk6rj1 .marked a:first-child h1,.b1bk6rj1 .marked a:first-child h2,.b1bk6rj1 .marked a:first-child h3,.b1bk6rj1 .marked a:first-child h4,.b1bk6rj1 .marked a:first-child h5,.b1bk6rj1 .marked a:first-child h6{margin-top:0;padding-top:0;}.b1bk6rj1 .marked h1 p,.b1bk6rj1 .marked h2 p,.b1bk6rj1 .marked h3 p,.b1bk6rj1 .marked h4 p,.b1bk6rj1 .marked h5 p,.b1bk6rj1 .marked h6 p{margin-top:0;}.b1bk6rj1 .marked li p.first{display:inline-block;}.b1bk6rj1 .marked li{margin:0;}.b1bk6rj1 .marked ul,.b1bk6rj1 .marked ol{padding-left:30px;}.b1bk6rj1 .marked ul :first-child,.b1bk6rj1 .marked ol :first-child{margin-top:0;}.b1bk6rj1 .marked dl{padding:0;}.b1bk6rj1 .marked dl dt{font-size:18px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px;}.b1bk6rj1 .marked dl dt:first-child{padding:0;}.b1bk6rj1 .marked dl dt > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dt > :last-child{margin-bottom:0;}.b1bk6rj1 .marked dl dd{margin:0 0 15px;padding:0 15px;}.b1bk6rj1 .marked dl dd > :first-child{margin-top:0;}.b1bk6rj1 .marked dl dd > :last-child{margin-bottom:0;}.b1bk6rj1 .marked blockquote{border-left:4px solid #dddddd;padding:0 15px;color:#777777;}.b1bk6rj1 .marked blockquote > :first-child{margin-top:0;}.b1bk6rj1 .marked blockquote > :last-child{margin-bottom:0;}.b1bk6rj1 .marked table{font-size:14px;padding:0;border-collapse:collapse;}.b1bk6rj1 .marked table tr{border-top:1px solid #cccccc;background-color:white;margin:0;padding:0;}.b1bk6rj1 .marked table tr:nth-child(2n){background-color:#f8f8f8;}.b1bk6rj1 .marked table tr th{font-weight:bold;border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr td{border:1px solid #cccccc;margin:0;padding:6px 13px;}.b1bk6rj1 .marked table tr th :first-child,.b1bk6rj1 .marked table tr td :first-child{margin-top:0;}.b1bk6rj1 .marked table tr th :last-child,.b1bk6rj1 .marked table tr td :last-child{margin-bottom:0;}.b1bk6rj1 .marked img{max-width:100%;}.b1bk6rj1 .marked span.frame{display:block;overflow:hidden;}.b1bk6rj1 .marked span.frame > span{border:1px solid #dddddd;display:block;float:left;overflow:hidden;margin:13px 0 0;padding:7px;width:auto;}.b1bk6rj1 .marked span.frame span img{display:block;float:left;}.b1bk6rj1 .marked span.frame span span{clear:both;color:#333333;display:block;padding:5px 0 0;}.b1bk6rj1 .marked span.align-center{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-center > span{display:block;overflow:hidden;margin:13px auto 0;text-align:center;}.b1bk6rj1 .marked span.align-center span img{margin:0 auto;text-align:center;}.b1bk6rj1 .marked span.align-right{display:block;overflow:hidden;clear:both;}.b1bk6rj1 .marked span.align-right > span{display:block;overflow:hidden;margin:13px 0 0;text-align:right;}.b1bk6rj1 .marked span.align-right span img{margin:0;text-align:right;}.b1bk6rj1 .marked span.float-left{display:block;margin-right:13px;overflow:hidden;float:left;}.b1bk6rj1 .marked span.float-left span{margin:13px 0 0;}.b1bk6rj1 .marked span.float-right{display:block;margin-left:13px;overflow:hidden;float:right;}.b1bk6rj1 .marked span.float-right > span{display:block;overflow:hidden;margin:13px auto 0;text-align:right;}.b1bk6rj1 .marked code,.b1bk6rj1 .marked tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;}.b1bk6rj1 .marked pre code{margin:0;padding:0;white-space:pre;border:none;background:transparent;}.b1bk6rj1 .marked .highlight pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre{background-color:#f8f8f8;border:1px solid #cccccc;font-size:17px;line-height:23px;overflow:auto;padding:6px 10px;border-radius:3px;}.b1bk6rj1 .marked pre code,.b1bk6rj1 .marked pre tt{background-color:transparent;border:none;}.b1bk6rj1 .marked sup{font-size:0.83em;vertical-align:super;line-height:0;}.b1bk6rj1 .marked *{-webkit-print-color-adjust:exact;}\n.p65g85a{font-family:monospace;font-weight:500;color:#ffe394;}\n.d2b9oy3{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n.mnvl60p{font-size:14px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}.mnvl60p button{background-color:#f4f4f4;color:#2b2b2b;padding:2px 6px;font-family:monospace;font-size:14px;border-radius:4px;box-shadow:0px 1px 2px #00000040;margin:0 0.1em;border:none;cursor:pointer;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2RvY3MvZG9jLXdyYXBwZXIudHN4Il0sIm5hbWVzIjpbIi53MWdoNWZ1diIsIi5iMWJrNnJqMSIsIi5wNjVnODVhIiwiLmQyYjlveTMiLCIubW52bDYwcCJdLCJtYXBwaW5ncyI6IkFBVWFBO0FBNkNQQztBQStaT0M7QUFNQUM7QUFNQUMiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvZG9jcy9kb2Mtd3JhcHBlci50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gXCJtYXJrZWRcIjtcbmltcG9ydCBTeW50YXhIaWdobGlnaHRlciBmcm9tIFwicmVhY3Qtc3ludGF4LWhpZ2hsaWdodGVyXCI7XG5pbXBvcnQgaGlnaGxpZ2h0U3R5bGUgZnJvbSBcInJlYWN0LXN5bnRheC1oaWdobGlnaHRlci9kaXN0L2VzbS9zdHlsZXMvaGxqcy9naXRodWJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXcmFwcGVyUHJvcHMge1xuICAgIGhlaWdodDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXY8V3JhcHBlclByb3BzPmBcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG5cbiAgICBib3gtc2hhZG93OiAwIDJweCA1cHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDAgMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcblxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuXG4gICAgbWFyZ2luOiAyNHB4IDA7XG5cbiAgICA+IDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHQ6IFJlYWN0LlZGQzx7IGNoaWxkcmVuOiBzdHJpbmcgfT4gPSBwID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8U3ludGF4SGlnaGxpZ2h0ZXJcbiAgICAgICAgICAgIHN0eWxlPXtoaWdobGlnaHRTdHlsZX1cbiAgICAgICAgICAgIHNob3dMaW5lTnVtYmVycz17dHJ1ZX1cbiAgICAgICAgICAgIGxpbmVOdW1iZXJTdHlsZT17eyBvcGFjaXR5OiAwLjUgfX1cbiAgICAgICAgICAgIGxhbmd1YWdlPVwidHlwZXNjcmlwdFwiPlxuICAgICAgICAgICAge3AuY2hpbGRyZW4udHJpbSgpfVxuICAgICAgICA8L1N5bnRheEhpZ2hsaWdodGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgY29uc3QgTWFya2VkOiBSZWFjdC5WRkM8eyBjaGlsZHJlbjogc3RyaW5nIH0+ID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibWFya2VkXCJcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgICAgICAgICAgX19odG1sOiBtYXJrZWQocC5jaGlsZHJlbiksXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICk7XG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgY29sb3I6ICMyMjIyMjI7XG5cbiAgICBwYWRkaW5nOiAzMnB4IDQ4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcblxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuXG4gICAgJiAuaW5uZXIge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiA5MDBweDtcblxuICAgICAgICA+IHByZSB7XG4gICAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA5cHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAubWFya2VkIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IEhlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuNjtcblxuICAgICAgICA+ICo6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgID4gKjpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAgIWltcG9ydGFudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGEge1xuICAgICAgICAgICAgY29sb3I6ICM0MTgzYzQ7XG4gICAgICAgIH1cbiAgICAgICAgYS5hYnNlbnQge1xuICAgICAgICAgICAgY29sb3I6ICNjYzAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgYS5hbmNob3Ige1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBwYWRkaW5nLWxlZnQ6IDMwcHg7XG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogLTMwcHg7XG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEsXG4gICAgICAgIGgyLFxuICAgICAgICBoMyxcbiAgICAgICAgaDQsXG4gICAgICAgIGg1LFxuICAgICAgICBoNiB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMCAxMHB4O1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgICAgICAgICBjdXJzb3I6IHRleHQ7XG4gICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICBoMTpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDI6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGgzOmhvdmVyIGEuYW5jaG9yLFxuICAgICAgICBoNDpob3ZlciBhLmFuY2hvcixcbiAgICAgICAgaDU6aG92ZXIgYS5hbmNob3IsXG4gICAgICAgIGg2OmhvdmVyIGEuYW5jaG9yIHtcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHR0LFxuICAgICAgICBoMSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHR0LFxuICAgICAgICBoMiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgzIHR0LFxuICAgICAgICBoMyBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg0IHR0LFxuICAgICAgICBoNCBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg1IHR0LFxuICAgICAgICBoNSBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGg2IHR0LFxuICAgICAgICBoNiBjb2RlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcbiAgICAgICAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGgyIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjhweDtcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaDMge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDQge1xuICAgICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDUge1xuICAgICAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaDYge1xuICAgICAgICAgICAgY29sb3I6ICM3Nzc3Nzc7XG4gICAgICAgICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICAgIH1cblxuICAgICAgICBwLFxuICAgICAgICBibG9ja3F1b3RlLFxuICAgICAgICB1bCxcbiAgICAgICAgb2wsXG4gICAgICAgIGRsLFxuICAgICAgICBsaSxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBtYXJnaW46IDIwcHggMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhyIHtcbiAgICAgICAgICAgIGJvcmRlcjogMCBub25lO1xuICAgICAgICAgICAgY29sb3I6ICNjY2NjY2M7XG4gICAgICAgICAgICBoZWlnaHQ6IDRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIH1cblxuICAgICAgICA+IGgyOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICA+IGgxOmZpcnN0LWNoaWxkICsgaDIge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG4gICAgICAgID4gaDM6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDQ6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDU6Zmlyc3QtY2hpbGQsXG4gICAgICAgID4gaDY6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMixcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoMyxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNCxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNSxcbiAgICAgICAgYTpmaXJzdC1jaGlsZCBoNiB7XG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBoMSBwLFxuICAgICAgICBoMiBwLFxuICAgICAgICBoMyBwLFxuICAgICAgICBoNCBwLFxuICAgICAgICBoNSBwLFxuICAgICAgICBoNiBwIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsaSBwLmZpcnN0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgfVxuICAgICAgICBsaSB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIH1cbiAgICAgICAgdWwsXG4gICAgICAgIG9sIHtcbiAgICAgICAgICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVsIDpmaXJzdC1jaGlsZCxcbiAgICAgICAgb2wgOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkbCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0IHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgICAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgICAgIG1hcmdpbjogMTVweCAwIDVweDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkdDpmaXJzdC1jaGlsZCB7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGR0ID4gOmZpcnN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZHQgPiA6bGFzdC1jaGlsZCB7XG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG4gICAgICAgIGRsIGRkIHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDE1cHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDE1cHg7XG4gICAgICAgIH1cbiAgICAgICAgZGwgZGQgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBkbCBkZCA+IDpsYXN0LWNoaWxkIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgICAgIH1cblxuICAgICAgICBibG9ja3F1b3RlIHtcbiAgICAgICAgICAgIGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2RkZGRkZDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICAgICAgICAgIGNvbG9yOiAjNzc3Nzc3O1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrcXVvdGUgPiA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICBibG9ja3F1b3RlID4gOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyIHtcbiAgICAgICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlIHRyOm50aC1jaGlsZCgybikge1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCB7XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTNweDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0ZCB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xuICAgICAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICAgICAgcGFkZGluZzogNnB4IDEzcHg7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgdHIgdGggOmZpcnN0LWNoaWxkLFxuICAgICAgICB0YWJsZSB0ciB0ZCA6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSB0ciB0aCA6bGFzdC1jaGlsZCxcbiAgICAgICAgdGFibGUgdHIgdGQgOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIH1cblxuICAgICAgICBzcGFuLmZyYW1lIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZyYW1lID4gc3BhbiB7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkZGRkO1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgcGFkZGluZzogN3B4O1xuICAgICAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mcmFtZSBzcGFuIGltZyB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZnJhbWUgc3BhbiBzcGFuIHtcbiAgICAgICAgICAgIGNsZWFyOiBib3RoO1xuICAgICAgICAgICAgY29sb3I6ICMzMzMzMzM7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIHBhZGRpbmc6IDVweCAwIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgY2xlYXI6IGJvdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1jZW50ZXIgc3BhbiBpbWcge1xuICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBjbGVhcjogYm90aDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFsaWduLXJpZ2h0ID4gc3BhbiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICBtYXJnaW46IDEzcHggMCAwO1xuICAgICAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hbGlnbi1yaWdodCBzcGFuIGltZyB7XG4gICAgICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LWxlZnQge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5mbG9hdC1sZWZ0IHNwYW4ge1xuICAgICAgICAgICAgbWFyZ2luOiAxM3B4IDAgMDtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmZsb2F0LXJpZ2h0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IDEzcHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZmxvYXQtcmlnaHQgPiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgICAgIG1hcmdpbjogMTNweCBhdXRvIDA7XG4gICAgICAgICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHR0IHtcbiAgICAgICAgICAgIG1hcmdpbjogMCAycHg7XG4gICAgICAgICAgICBwYWRkaW5nOiAwIDVweDtcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZWFlYWVhO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmODtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSBjb2RlIHtcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAuaGlnaGxpZ2h0IHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOGY4O1xuICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTdweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgfVxuICAgICAgICBwcmUgY29kZSxcbiAgICAgICAgcHJlIHR0IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwIHtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMC44M2VtO1xuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IHN1cGVyO1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICAgICAgKiB7XG4gICAgICAgICAgICAtd2Via2l0LXByaW50LWNvbG9yLWFkanVzdDogZXhhY3Q7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5leHBvcnQgY29uc3QgUHJvcE5hbWUgPSBzdHlsZWQuc3BhbmBcbiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgY29sb3I6ICNmZmUzOTQ7XG5gO1xuXG5leHBvcnQgY29uc3QgRGVzY3JpcHRpb24gPSBzdHlsZWQucGBcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1vcmVJbmZvID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XG4gICAgICAgIGNvbG9yOiAjMmIyYjJiO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgYm94LXNoYWRvdzogMHB4IDFweCAycHggIzAwMDAwMDQwO1xuICAgICAgICBtYXJnaW46IDAgMC4xZW07XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBEb2NXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHA7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbm5lclwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9CZWF1dGlmdWxTdHlsZT5cbiAgICApO1xufTtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".ifmjl02{position:absolute;left:0;right:0;top:0;bottom:0;width:100%;height:100%;border-radius:0px;resize:none;white-space:pre-wrap;min-width:100%;overflow:hidden;border:0;background-color:transparent;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;}.ifmjl02::-webkit-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::-moz-placeholder{color:var(--gdg-text-light);}.ifmjl02:-ms-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::placeholder{color:var(--gdg-text-light);}.invalid .ifmjl02{-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration-color:#d60606;text-decoration-color:#d60606;}\n.s71wzxx{visibility:hidden;white-space:pre-wrap;word-wrap:break-word;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;min-width:100%;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;padding-bottom:2px;}\n.gecuh31{position:relative;margin-top:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZS50c3giXSwibmFtZXMiOlsiLmlmbWpsMDIiLCIuczcxd3p4eCIsIi5nZWN1aDMxIl0sIm1hcHBpbmdzIjoiQUFFYUE7QUFtQ0FDO0FBb0JBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBJbnB1dEJveCA9IHN0eWxlZC50ZXh0YXJlYWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDBweDtcblxuICAgIHJlc2l6ZTogbm9uZTtcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gICAgbWluLXdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm9yZGVyOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgOjpwbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG4gICAgfVxuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgLmludmFsaWQgJiB7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb24tY29sb3I6ICNkNjA2MDY7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IFNoYWRvd0JveCA9IHN0eWxlZC5kaXZgXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG5cbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuXG4gICAgbWluLXdpZHRoOiAxMDAlO1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcbmA7XG5cbmV4cG9ydCBjb25zdCBHcm93aW5nRW50cnlTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG1hcmdpbi10b3A6IDZweDtcbmA7XG4iXX0=*/", "",{"version":3,"sources":["webpack://./packages/core/src/growing-entry/packages/core/src/growing-entry/growing-entry-style.tsx","webpack://./packages/core/src/growing-entry/growing-entry-style.tsx"],"names":[".ifmjl02",".s71wzxx",".gecuh31"],"mappings":"AAEaA,SAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,OAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,WAAAA,CAAAA,oBAAAA,CAAAA,cAAAA,CAAAA,eAAAA,CAAAA,QAAAA,CAAAA,4BAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAAA,CAAAA,oCAAAA,2BAAAA,CAAAA,CAAAA,2BAAAA,2BAAAA,CAAAA,CAAAA,+BAAAA,2BAAAA,CAAAA,CAAAA,sBAAAA,2BAAAA,CAAAA,CAAAA,kBAAAA,iCAAAA,CAAAA,yBAAAA,CAAAA,qCAAAA,CAAAA,6BAAAA,CAAAA;AAmCAC,SAAAA,iBAAAA,CAAAA,oBAAAA,CAAAA,oBAAAA,CAAAA,yBAAAA,CAAAA,sBAAAA,CAAAA,iBAAAA,CAAAA,cAAAA,CAAAA,cAAAA,CAAAA,qCAAAA,CAAAA,gBAAAA,CAAAA,kCAAAA,CAAAA,0BAAAA,CAAAA,SAAAA,CAAAA,QAAAA,CAAAA,kBAAAA,CAAAA;AAoBAC,SAAAA,iBAAAA,CAAAA,cAAAA,CAAAA;ACtDb,u/DAAu/D","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const InputBox = styled.textarea`\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n\n    border-radius: 0px;\n\n    resize: none;\n    white-space: pre-wrap;\n    min-width: 100%;\n    overflow: hidden;\n    border: 0;\n    background-color: transparent;\n\n    ::placeholder {\n        color: var(--gdg-text-light);\n    }\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    .invalid & {\n        text-decoration: underline;\n        text-decoration-color: #d60606;\n    }\n`;\n\nexport const ShadowBox = styled.div`\n    visibility: hidden;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n\n    width: max-content;\n    max-width: 100%;\n\n    min-width: 100%;\n\n    font-size: var(--gdg-editor-font-size);\n    line-height: 16px;\n    font-family: var(--gdg-font-family);\n    color: var(--gdg-text-dark);\n    padding: 0;\n    margin: 0;\n\n    padding-bottom: 2px;\n`;\n\nexport const GrowingEntryStyle = styled.div`\n    position: relative;\n    margin-top: 6px;\n`;\n",".ifmjl02{position:absolute;left:0;right:0;top:0;bottom:0;width:100%;height:100%;border-radius:0px;resize:none;white-space:pre-wrap;min-width:100%;overflow:hidden;border:0;background-color:transparent;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;}.ifmjl02::-webkit-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::-moz-placeholder{color:var(--gdg-text-light);}.ifmjl02:-ms-input-placeholder{color:var(--gdg-text-light);}.ifmjl02::placeholder{color:var(--gdg-text-light);}.invalid .ifmjl02{-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration-color:#d60606;text-decoration-color:#d60606;}\n.s71wzxx{visibility:hidden;white-space:pre-wrap;word-wrap:break-word;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:100%;min-width:100%;font-size:var(--gdg-editor-font-size);line-height:16px;font-family:var(--gdg-font-family);color:var(--gdg-text-dark);padding:0;margin:0;padding-bottom:2px;}\n.gecuh31{position:relative;margin-top:6px;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS1zdHlsZS50c3giXSwibmFtZXMiOlsiLmlmbWpsMDIiLCIuczcxd3p4eCIsIi5nZWN1aDMxIl0sIm1hcHBpbmdzIjoiQUFFYUE7QUFtQ0FDO0FBb0JBQyIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnktc3R5bGUudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBJbnB1dEJveCA9IHN0eWxlZC50ZXh0YXJlYWBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcblxuICAgIGJvcmRlci1yYWRpdXM6IDBweDtcblxuICAgIHJlc2l6ZTogbm9uZTtcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gICAgbWluLXdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm9yZGVyOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgOjpwbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1nZGctdGV4dC1saWdodCk7XG4gICAgfVxuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgLmludmFsaWQgJiB7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICB0ZXh0LWRlY29yYXRpb24tY29sb3I6ICNkNjA2MDY7XG4gICAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IFNoYWRvd0JveCA9IHN0eWxlZC5kaXZgXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG5cbiAgICB3aWR0aDogbWF4LWNvbnRlbnQ7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuXG4gICAgbWluLXdpZHRoOiAxMDAlO1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1nZGctZWRpdG9yLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDE2cHg7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWdkZy1mb250LWZhbWlseSk7XG4gICAgY29sb3I6IHZhcigtLWdkZy10ZXh0LWRhcmspO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgbWFyZ2luOiAwO1xuXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcbmA7XG5cbmV4cG9ydCBjb25zdCBHcm93aW5nRW50cnlTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG1hcmdpbi10b3A6IDZweDtcbmA7XG4iXX0=*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".m1fme8sm{word-break:break-word;-webkit-touch-callout:default;padding-top:6px;}.m1fme8sm > *{margin:0;}.m1fme8sm *:last-child{margin-bottom:0;}.m1fme8sm p img{width:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL21hcmtkb3duLWRpdi9wcml2YXRlL21hcmtkb3duLWNvbnRhaW5lci50c3giXSwibmFtZXMiOlsiLm0xZm1lOHNtIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgTWFya2Rvd25Db250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBkZWZhdWx0O1xuICAgIHBhZGRpbmctdG9wOiA2cHg7XG5cbiAgICA+ICoge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgfVxuXG4gICAgJiAqOmxhc3QtY2hpbGQge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgIH1cblxuICAgICYgcCBpbWcge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5gO1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/markdown-div/private/packages/core/src/markdown-div/private/markdown-container.tsx","webpack://./packages/core/src/markdown-div/private/markdown-container.tsx"],"names":[".m1fme8sm"],"mappings":"AAEaA,UAAAA,qBAAAA,CAAAA,6BAAAA,CAAAA,eAAAA,CAAAA,CAAAA,cAAAA,QAAAA,CAAAA,CAAAA,uBAAAA,eAAAA,CAAAA,CAAAA,gBAAAA,UAAAA,CAAAA;ACDb,mxBAAmxB","sourcesContent":["import { styled } from \"@linaria/react\";\n\nexport const MarkdownContainer = styled.div`\n    word-break: break-word;\n    -webkit-touch-callout: default;\n    padding-top: 6px;\n\n    > * {\n        margin: 0;\n    }\n\n    & *:last-child {\n        margin-bottom: 0;\n    }\n\n    & p img {\n        width: 100%;\n    }\n`;\n",".m1fme8sm{word-break:break-word;-webkit-touch-callout:default;padding-top:6px;}.m1fme8sm > *{margin:0;}.m1fme8sm *:last-child{margin-bottom:0;}.m1fme8sm p img{width:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL21hcmtkb3duLWRpdi9wcml2YXRlL21hcmtkb3duLWNvbnRhaW5lci50c3giXSwibmFtZXMiOlsiLm0xZm1lOHNtIl0sIm1hcHBpbmdzIjoiQUFFYUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgTWFya2Rvd25Db250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBkZWZhdWx0O1xuICAgIHBhZGRpbmctdG9wOiA2cHg7XG5cbiAgICA+ICoge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgfVxuXG4gICAgJiAqOmxhc3QtY2hpbGQge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgIH1cblxuICAgICYgcCBpbWcge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5gO1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s3se5hb .dvn-scroller{overflow:var(--s3se5hb-0);-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0);}.s3se5hb .hidden{visibility:hidden;}.s3se5hb .dvn-scroll-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;pointer-events:none;}.s3se5hb .dvn-scroll-inner > *{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}.s3se5hb .dvn-scroll-inner .dvn-spacer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.s3se5hb .dvn-scroll-inner .dvn-stack{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.s3se5hb .dvn-underlay > *{position:absolute;left:0;top:0;}.s3se5hb canvas{outline:none;}.s3se5hb canvas *{height:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Il0sIm5hbWVzIjpbIi5zM3NlNWhiIl0sIm1hcHBpbmdzIjoiQUE2Qk1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCIuLi9jb21tb24vcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQgeyBicm93c2VySXNTYWZhcmkgfSBmcm9tIFwiLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uL2NvbW1vbi91dGlsc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZT86IHN0cmluZztcbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGRyYWdnYWJsZTogYm9vbGVhbjtcbiAgICByZWFkb25seSBwYWRkaW5nUmlnaHQ/OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgcGFkZGluZ0JvdHRvbT86IG51bWJlcjtcbiAgICByZWFkb25seSBjbGllbnRIZWlnaHQ6IG51bWJlcjtcbiAgICByZWFkb25seSBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kPzogYm9vbGVhbjtcbiAgICByZWFkb25seSBpbml0aWFsU2Nyb2xsUG9zaXRpb24/OiByZWFkb25seSBbc2Nyb2xsWDogbnVtYmVyLCBzY3JvbGxZOiBudW1iZXJdO1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplPzogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wcz86IHtcbiAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgfTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgbWluaW1hcD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICByZWFkb25seSBzY3JvbGxSZWY/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD47XG4gICAgcmVhZG9ubHkgdXBkYXRlOiAocmVnaW9uOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNjcm9sbFJlZ2lvblN0eWxlID0gc3R5bGVkLmRpdjx7IGlzU2FmYXJpOiBib29sZWFuIH0+YFxuICAgIC5kdm4tc2Nyb2xsZXIge1xuICAgICAgICBvdmVyZmxvdzogJHtwID0+IChwLmlzU2FmYXJpID8gXCJzY3JvbGxcIiA6IFwiYXV0b1wiKX07XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgLmhpZGRlbiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuZHZuLXNjcm9sbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3BhY2VyIHtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3RhY2sge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZHZuLXVuZGVybGF5ID4gKiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgIH1cblxuICAgIGNhbnZhcyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG5cbiAgICAgICAgKiB7XG4gICAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG50eXBlIFNjcm9sbExvY2sgPSBbdW5kZWZpbmVkLCBudW1iZXJdIHwgW251bWJlciwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZWF0RXZlbnQoZTogUmVhY3QuTW91c2VFdmVudCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVRvdWNoVXBEZWxheWVkKGRlbGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBbaGFzVG91Y2hlcywgc2V0SGFzVG91Y2hlc10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBjYlRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNiVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRIYXNUb3VjaGVzKHRydWUpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHNldEhhc1RvdWNoZXMoZmFsc2UpLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtkZWxheV1cbiAgICAgICAgKSxcbiAgICAgICAgd2luZG93LFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuZXhwb3J0IGNvbnN0IEluZmluaXRlU2Nyb2xsZXI6IFJlYWN0LkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwLFxuICAgICAgICBwYWRkaW5nUmlnaHQgPSAwLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgbWluaW1hcCxcbiAgICB9ID0gcDtcbiAgICBjb25zdCBwYWRkZXJzOiBSZWFjdC5SZWFjdE5vZGVbXSA9IFtdO1xuXG4gICAgY29uc3QgcmlnaHRFbGVtZW50U3RpY2t5ID0gcmlnaHRFbGVtZW50UHJvcHM/LnN0aWNreSA/PyBmYWxzZTtcbiAgICBjb25zdCByaWdodEVsZW1lbnRGaWxsID0gcmlnaHRFbGVtZW50UHJvcHM/LmZpbGwgPz8gZmFsc2U7XG5cbiAgICBjb25zdCBvZmZzZXRZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IHNjcm9sbGVyID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IHNjcm9sbFRvRW5kICE9PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGg7XG4gICAgfSwgW3Njcm9sbFRvRW5kXSk7XG5cbiAgICBjb25zdCBsYXN0U2Nyb2xsUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIGxvY2tEaXJlY3Rpb246IHVuZGVmaW5lZCBhcyBTY3JvbGxMb2NrLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmlnaHRXcmFwUmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBoYXNUb3VjaGVzID0gdXNlVG91Y2hVcERlbGF5ZWQoMjAwKTtcbiAgICBjb25zdCBbaXNJZGxlLCBzZXRJc0lkbGVdID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgaWRsZVRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0lkbGUgfHwgaGFzVG91Y2hlcyB8fCBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgICAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgW2x4LCBseV0gPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuICAgICAgICBpZiAobHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGx4O1xuICAgICAgICB9IGVsc2UgaWYgKGx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcCA9IGx5O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSwgW2hhc1RvdWNoZXMsIGlzSWRsZV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsVG9wID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsTGVmdCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgY29uc3QgZHggPSBzY3JvbGxMZWZ0IC0gbGFzdFNjcm9sbExlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gc2Nyb2xsVG9wIC0gbGFzdFNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNUb3VjaGVzICYmXG4gICAgICAgICAgICBkeCAhPT0gMCAmJlxuICAgICAgICAgICAgZHkgIT09IDAgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhkeCkgPiAzIHx8IE1hdGguYWJzKGR5KSA+IDMpICYmXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcgJiZcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPVxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGR4KSA8IE1hdGguYWJzKGR5KSA/IFtsYXN0U2Nyb2xsTGVmdCwgdW5kZWZpbmVkXSA6IFt1bmRlZmluZWQsIGxhc3RTY3JvbGxUb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jayA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb247XG5cbiAgICAgICAgc2Nyb2xsTGVmdCA9IGxvY2s/LlswXSA/PyBzY3JvbGxMZWZ0O1xuICAgICAgICBzY3JvbGxUb3AgPSBsb2NrPy5bMV0gPz8gc2Nyb2xsVG9wO1xuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGNvbnN0IG5ld1kgPSBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbGFzdFNjcm9sbFkuY3VycmVudCAtIG5ld1k7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxhc3RTY3JvbGxZLmN1cnJlbnQgPSBuZXdZO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNjcm9sbGFibGVIZWlnaHQgPiAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZGVsdGEpID4gMjAwMCB8fCBuZXdZID09PSAwIHx8IG5ld1kgPT09IHNjcm9sbGFibGVIZWlnaHQpICYmXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPiBlbC5zY3JvbGxIZWlnaHQgKyA1XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcHJvZyA9IG5ld1kgLyBzY3JvbGxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcmVjb21wdXRlZCA9IChzY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQpICogcHJvZztcbiAgICAgICAgICAgIG9mZnNldFkuY3VycmVudCA9IHJlY29tcHV0ZWQgLSBuZXdZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZGxlVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRJc0lkbGUoZmFsc2UpO1xuICAgICAgICAgICAgaWRsZVRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRJc0lkbGUodHJ1ZSksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgeDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IG5ld1kgKyBvZmZzZXRZLmN1cnJlbnQsXG4gICAgICAgICAgICB3aWR0aDogZWwuY2xpZW50V2lkdGggLSBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsLmNsaWVudEhlaWdodCAtIHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHJpZ2h0V3JhcFJlZi5jdXJyZW50Py5jbGllbnRXaWR0aCA/PyAwLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBzY3JvbGxIZWlnaHQsIHVwZGF0ZSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBoYXNUb3VjaGVzXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFJlZiA9IFJlYWN0LnVzZVJlZihvblNjcm9sbCk7XG4gICAgb25TY3JvbGxSZWYuY3VycmVudCA9IG9uU2Nyb2xsO1xuXG4gICAgY29uc3QgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmPHsgd2lkdGg/OiBudW1iZXI7IGhlaWdodD86IG51bWJlciB9PigpO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25TY3JvbGwoKTtcbiAgICB9LCBbb25TY3JvbGwsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodF0pO1xuXG4gICAgY29uc3Qgc2V0UmVmcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoaW5zdGFuY2U6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsZXIuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW3Njcm9sbFJlZl1cbiAgICApO1xuXG4gICAgbGV0IGtleSA9IDA7XG4gICAgbGV0IGggPSAwO1xuICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiBzY3JvbGxXaWR0aCwgaGVpZ2h0OiAwIH19IC8+KTtcbiAgICB3aGlsZSAoaCA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBjb25zdCB0b0FkZCA9IE1hdGgubWluKDVfMDAwXzAwMCwgc2Nyb2xsSGVpZ2h0IC0gaCk7XG4gICAgICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiAwLCBoZWlnaHQ6IHRvQWRkIH19IC8+KTtcbiAgICAgICAgaCArPSB0b0FkZDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3I8SFRNTERpdkVsZW1lbnQ+KGluaXRpYWxTaXplKTtcblxuICAgIGlmIChsYXN0UHJvcHMuY3VycmVudD8uaGVpZ2h0ICE9PSBoZWlnaHQgfHwgbGFzdFByb3BzLmN1cnJlbnQ/LndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBvblNjcm9sbFJlZi5jdXJyZW50KCksIDApO1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cblxuICAgIGlmICgod2lkdGggPz8gMCkgPT09IDAgfHwgKGhlaWdodCA/PyAwKSA9PT0gMCkgcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiByZWY9e3JlZn0+XG4gICAgICAgICAgICA8U2Nyb2xsUmVnaW9uU3R5bGUgaXNTYWZhcmk9e2Jyb3dzZXJJc1NhZmFyaS52YWx1ZX0+XG4gICAgICAgICAgICAgICAge21pbmltYXB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tdW5kZXJsYXlcIj57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByZWY9e3NldFJlZnN9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtsYXN0UHJvcHMuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlPXtkcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsZXIgXCIgKyAoY2xhc3NOYW1lID8/IFwiXCIpfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsLWlubmVyXCIgKyAocmlnaHRFbGVtZW50ID09PSB1bmRlZmluZWQgPyBcIiBoaWRkZW5cIiA6IFwiXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXN0YWNrXCI+e3BhZGRlcnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmlnaHRFbGVtZW50RmlsbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImR2bi1zcGFjZXJcIiAvPn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyaWdodFdyYXBSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBjbGllbnRIZWlnaHQgLSBNYXRoLmNlaWwoZHByICUgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogLTQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3c6IHJpZ2h0RWxlbWVudEZpbGwgPyAxIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodEVsZW1lbnRTdGlja3kgPyBwYWRkaW5nUmlnaHQgPz8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvU2Nyb2xsUmVnaW9uU3R5bGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuIl19*/", "",{"version":3,"sources":["webpack://./packages/core/src/scrolling-data-grid/packages/core/src/scrolling-data-grid/infinite-scroller.tsx","webpack://./packages/core/src/scrolling-data-grid/infinite-scroller.tsx"],"names":[".s3se5hb"],"mappings":"AA6BMA,uBAAAA,yBAAAA,CAAAA,oCAAAA,CAAAA,gCAAAA,CAAAA,4BAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,CAAAA,2BAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,mBAAAA,CAAAA,CAAAA,+BAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,CAAAA,uCAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,CAAAA,sCAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,2BAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,CAAAA,gBAAAA,YAAAA,CAAAA,CAAAA,kBAAAA,QAAAA,CAAAA;AC5BN,2ycAA2yc","sourcesContent":["import { styled } from \"@linaria/react\";\nimport type { Rectangle } from \"..\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"../common/resize-detector\";\nimport { browserIsSafari } from \"../common/browser-detect\";\nimport { useEventListener } from \"../common/utils\";\n\ninterface Props {\n    readonly className?: string;\n    readonly preventDiagonalScrolling?: boolean;\n    readonly draggable: boolean;\n    readonly paddingRight?: number;\n    readonly paddingBottom?: number;\n    readonly clientHeight: number;\n    readonly scrollWidth: number;\n    readonly scrollHeight: number;\n    readonly scrollToEnd?: boolean;\n    readonly initialScrollPosition?: readonly [scrollX: number, scrollY: number];\n    readonly initialSize?: readonly [width: number, height: number];\n    readonly rightElementProps?: {\n        readonly sticky?: boolean;\n        readonly fill?: boolean;\n    };\n    readonly rightElement?: React.ReactNode;\n    readonly minimap?: React.ReactNode;\n    readonly scrollRef?: React.MutableRefObject<HTMLDivElement | null>;\n    readonly update: (region: Rectangle & { paddingRight: number }) => void;\n}\n\nconst ScrollRegionStyle = styled.div<{ isSafari: boolean }>`\n    .dvn-scroller {\n        overflow: ${p => (p.isSafari ? \"scroll\" : \"auto\")};\n        transform: translate3d(0, 0, 0);\n    }\n\n    .hidden {\n        visibility: hidden;\n    }\n\n    .dvn-scroll-inner {\n        display: flex;\n        pointer-events: none;\n\n        > * {\n            flex-shrink: 0;\n        }\n\n        .dvn-spacer {\n            flex-grow: 1;\n        }\n\n        .dvn-stack {\n            display: flex;\n            flex-direction: column;\n        }\n    }\n\n    .dvn-underlay > * {\n        position: absolute;\n        left: 0;\n        top: 0;\n    }\n\n    canvas {\n        outline: none;\n\n        * {\n            height: 0;\n        }\n    }\n`;\n\ntype ScrollLock = [undefined, number] | [number, undefined] | undefined;\n\nfunction eatEvent(e: React.MouseEvent) {\n    e.stopPropagation();\n}\n\nfunction useTouchUpDelayed(delay: number): boolean {\n    const [hasTouches, setHasTouches] = React.useState(false);\n\n    const cbTimer = React.useRef(0);\n    useEventListener(\n        \"touchstart\",\n        React.useCallback(() => {\n            window.clearTimeout(cbTimer.current);\n            setHasTouches(true);\n        }, []),\n        window,\n        true,\n        false\n    );\n\n    useEventListener(\n        \"touchend\",\n        React.useCallback(\n            e => {\n                if (e.touches.length === 0) {\n                    cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\n                }\n            },\n            [delay]\n        ),\n        window,\n        true,\n        false\n    );\n\n    return hasTouches;\n}\n\nexport const InfiniteScroller: React.FC<Props> = p => {\n    const {\n        children,\n        clientHeight,\n        scrollHeight,\n        scrollWidth,\n        update,\n        draggable,\n        className,\n        preventDiagonalScrolling = false,\n        paddingBottom = 0,\n        paddingRight = 0,\n        rightElement,\n        rightElementProps,\n        scrollRef,\n        scrollToEnd,\n        initialSize,\n        minimap,\n    } = p;\n    const padders: React.ReactNode[] = [];\n\n    const rightElementSticky = rightElementProps?.sticky ?? false;\n    const rightElementFill = rightElementProps?.fill ?? false;\n\n    const offsetY = React.useRef(0);\n    const lastScrollY = React.useRef(0);\n    const scroller = React.useRef<HTMLDivElement | null>(null);\n\n    const dpr = window.devicePixelRatio;\n\n    React.useEffect(() => {\n        const el = scroller.current;\n        if (el === null || scrollToEnd !== true) return;\n\n        el.scrollLeft = el.scrollWidth - el.clientWidth;\n    }, [scrollToEnd]);\n\n    const lastScrollPosition = React.useRef({\n        scrollLeft: 0,\n        scrollTop: 0,\n        lockDirection: undefined as ScrollLock,\n    });\n\n    const rightWrapRef = React.useRef<HTMLDivElement | null>(null);\n\n    const hasTouches = useTouchUpDelayed(200);\n    const [isIdle, setIsIdle] = React.useState(true);\n    const idleTimer = React.useRef(0);\n\n    React.useEffect(() => {\n        if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;\n        const el = scroller.current;\n        if (el === null) return;\n        const [lx, ly] = lastScrollPosition.current.lockDirection;\n        if (lx !== undefined) {\n            el.scrollLeft = lx;\n        } else if (ly !== undefined) {\n            el.scrollTop = ly;\n        }\n        lastScrollPosition.current.lockDirection = undefined;\n    }, [hasTouches, isIdle]);\n\n    const onScroll = React.useCallback(() => {\n        const el = scroller.current;\n        if (el === null) return;\n\n        let scrollTop = el.scrollTop;\n        let scrollLeft = el.scrollLeft;\n        const lastScrollTop = lastScrollPosition.current.scrollTop;\n        const lastScrollLeft = lastScrollPosition.current.scrollLeft;\n\n        const dx = scrollLeft - lastScrollLeft;\n        const dy = scrollTop - lastScrollTop;\n\n        if (\n            hasTouches &&\n            dx !== 0 &&\n            dy !== 0 &&\n            (Math.abs(dx) > 3 || Math.abs(dy) > 3) &&\n            preventDiagonalScrolling &&\n            lastScrollPosition.current.lockDirection === undefined\n        ) {\n            lastScrollPosition.current.lockDirection =\n                Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];\n        }\n\n        const lock = lastScrollPosition.current.lockDirection;\n\n        scrollLeft = lock?.[0] ?? scrollLeft;\n        scrollTop = lock?.[1] ?? scrollTop;\n        lastScrollPosition.current.scrollLeft = scrollLeft;\n        lastScrollPosition.current.scrollTop = scrollTop;\n\n        const newY = scrollTop;\n        const delta = lastScrollY.current - newY;\n        const scrollableHeight = el.scrollHeight - el.clientHeight;\n        lastScrollY.current = newY;\n\n        if (\n            scrollableHeight > 0 &&\n            (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) &&\n            scrollHeight > el.scrollHeight + 5\n        ) {\n            const prog = newY / scrollableHeight;\n            const recomputed = (scrollHeight - el.clientHeight) * prog;\n            offsetY.current = recomputed - newY;\n        }\n\n        if (lock !== undefined) {\n            window.clearTimeout(idleTimer.current);\n            setIsIdle(false);\n            idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\n        }\n\n        update({\n            x: scrollLeft,\n            y: newY + offsetY.current,\n            width: el.clientWidth - paddingRight,\n            height: el.clientHeight - paddingBottom,\n            paddingRight: rightWrapRef.current?.clientWidth ?? 0,\n        });\n    }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\n\n    const onScrollRef = React.useRef(onScroll);\n    onScrollRef.current = onScroll;\n\n    const lastProps = React.useRef<{ width?: number; height?: number }>();\n\n    React.useEffect(() => {\n        onScroll();\n    }, [onScroll, paddingBottom, paddingRight]);\n\n    const setRefs = React.useCallback(\n        (instance: HTMLDivElement | null) => {\n            scroller.current = instance;\n            if (scrollRef !== undefined) {\n                scrollRef.current = instance;\n            }\n        },\n        [scrollRef]\n    );\n\n    let key = 0;\n    let h = 0;\n    padders.push(<div key={key++} style={{ width: scrollWidth, height: 0 }} />);\n    while (h < scrollHeight) {\n        const toAdd = Math.min(5_000_000, scrollHeight - h);\n        padders.push(<div key={key++} style={{ width: 0, height: toAdd }} />);\n        h += toAdd;\n    }\n\n    const { ref, width, height } = useResizeDetector<HTMLDivElement>(initialSize);\n\n    if (lastProps.current?.height !== height || lastProps.current?.width !== width) {\n        window.setTimeout(() => onScrollRef.current(), 0);\n        lastProps.current = { width, height };\n    }\n\n    if ((width ?? 0) === 0 || (height ?? 0) === 0) return <div ref={ref} />;\n\n    return (\n        <div ref={ref}>\n            <ScrollRegionStyle isSafari={browserIsSafari.value}>\n                {minimap}\n                <div className=\"dvn-underlay\">{children}</div>\n                <div\n                    ref={setRefs}\n                    style={lastProps.current}\n                    draggable={draggable}\n                    onDragStart={e => {\n                        if (!draggable) {\n                            e.stopPropagation();\n                            e.preventDefault();\n                        }\n                    }}\n                    className={\"dvn-scroller \" + (className ?? \"\")}\n                    onScroll={onScroll}>\n                    <div className={\"dvn-scroll-inner\" + (rightElement === undefined ? \" hidden\" : \"\")}>\n                        <div className=\"dvn-stack\">{padders}</div>\n                        {rightElement !== undefined && (\n                            <>\n                                {!rightElementFill && <div className=\"dvn-spacer\" />}\n                                <div\n                                    ref={rightWrapRef}\n                                    onMouseDown={eatEvent}\n                                    onMouseUp={eatEvent}\n                                    onMouseMove={eatEvent}\n                                    style={{\n                                        height,\n                                        maxHeight: clientHeight - Math.ceil(dpr % 1),\n                                        position: \"sticky\",\n                                        top: 0,\n                                        paddingLeft: 1,\n                                        marginBottom: -40,\n                                        marginRight: paddingRight,\n                                        flexGrow: rightElementFill ? 1 : undefined,\n                                        right: rightElementSticky ? paddingRight ?? 0 : undefined,\n                                        pointerEvents: \"auto\",\n                                    }}>\n                                    {rightElement}\n                                </div>\n                            </>\n                        )}\n                    </div>\n                </div>\n            </ScrollRegionStyle>\n        </div>\n    );\n};\n",".s3se5hb .dvn-scroller{overflow:var(--s3se5hb-0);-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0);}.s3se5hb .hidden{visibility:hidden;}.s3se5hb .dvn-scroll-inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;pointer-events:none;}.s3se5hb .dvn-scroll-inner > *{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}.s3se5hb .dvn-scroll-inner .dvn-spacer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}.s3se5hb .dvn-scroll-inner .dvn-stack{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.s3se5hb .dvn-underlay > *{position:absolute;left:0;top:0;}.s3se5hb canvas{outline:none;}.s3se5hb canvas *{height:0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Il0sIm5hbWVzIjpbIi5zM3NlNWhiIl0sIm1hcHBpbmdzIjoiQUE2Qk1BIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSZXNpemVEZXRlY3RvciB9IGZyb20gXCIuLi9jb21tb24vcmVzaXplLWRldGVjdG9yXCI7XG5pbXBvcnQgeyBicm93c2VySXNTYWZhcmkgfSBmcm9tIFwiLi4vY29tbW9uL2Jyb3dzZXItZGV0ZWN0XCI7XG5pbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIi4uL2NvbW1vbi91dGlsc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHJlYWRvbmx5IGNsYXNzTmFtZT86IHN0cmluZztcbiAgICByZWFkb25seSBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGRyYWdnYWJsZTogYm9vbGVhbjtcbiAgICByZWFkb25seSBwYWRkaW5nUmlnaHQ/OiBudW1iZXI7XG4gICAgcmVhZG9ubHkgcGFkZGluZ0JvdHRvbT86IG51bWJlcjtcbiAgICByZWFkb25seSBjbGllbnRIZWlnaHQ6IG51bWJlcjtcbiAgICByZWFkb25seSBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbEhlaWdodDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHNjcm9sbFRvRW5kPzogYm9vbGVhbjtcbiAgICByZWFkb25seSBpbml0aWFsU2Nyb2xsUG9zaXRpb24/OiByZWFkb25seSBbc2Nyb2xsWDogbnVtYmVyLCBzY3JvbGxZOiBudW1iZXJdO1xuICAgIHJlYWRvbmx5IGluaXRpYWxTaXplPzogcmVhZG9ubHkgW3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnRQcm9wcz86IHtcbiAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgfTtcbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgcmVhZG9ubHkgbWluaW1hcD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICByZWFkb25seSBzY3JvbGxSZWY/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD47XG4gICAgcmVhZG9ubHkgdXBkYXRlOiAocmVnaW9uOiBSZWN0YW5nbGUgJiB7IHBhZGRpbmdSaWdodDogbnVtYmVyIH0pID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNjcm9sbFJlZ2lvblN0eWxlID0gc3R5bGVkLmRpdjx7IGlzU2FmYXJpOiBib29sZWFuIH0+YFxuICAgIC5kdm4tc2Nyb2xsZXIge1xuICAgICAgICBvdmVyZmxvdzogJHtwID0+IChwLmlzU2FmYXJpID8gXCJzY3JvbGxcIiA6IFwiYXV0b1wiKX07XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgLmhpZGRlbiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuZHZuLXNjcm9sbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgICAgID4gKiB7XG4gICAgICAgICAgICBmbGV4LXNocmluazogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3BhY2VyIHtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5kdm4tc3RhY2sge1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAuZHZuLXVuZGVybGF5ID4gKiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgIH1cblxuICAgIGNhbnZhcyB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG5cbiAgICAgICAgKiB7XG4gICAgICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG50eXBlIFNjcm9sbExvY2sgPSBbdW5kZWZpbmVkLCBudW1iZXJdIHwgW251bWJlciwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZWF0RXZlbnQoZTogUmVhY3QuTW91c2VFdmVudCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVRvdWNoVXBEZWxheWVkKGRlbGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBbaGFzVG91Y2hlcywgc2V0SGFzVG91Y2hlc10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCBjYlRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNiVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRIYXNUb3VjaGVzKHRydWUpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHNldEhhc1RvdWNoZXMoZmFsc2UpLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtkZWxheV1cbiAgICAgICAgKSxcbiAgICAgICAgd2luZG93LFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuZXhwb3J0IGNvbnN0IEluZmluaXRlU2Nyb2xsZXI6IFJlYWN0LkZDPFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkcmFnZ2FibGUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwLFxuICAgICAgICBwYWRkaW5nUmlnaHQgPSAwLFxuICAgICAgICByaWdodEVsZW1lbnQsXG4gICAgICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgbWluaW1hcCxcbiAgICB9ID0gcDtcbiAgICBjb25zdCBwYWRkZXJzOiBSZWFjdC5SZWFjdE5vZGVbXSA9IFtdO1xuXG4gICAgY29uc3QgcmlnaHRFbGVtZW50U3RpY2t5ID0gcmlnaHRFbGVtZW50UHJvcHM/LnN0aWNreSA/PyBmYWxzZTtcbiAgICBjb25zdCByaWdodEVsZW1lbnRGaWxsID0gcmlnaHRFbGVtZW50UHJvcHM/LmZpbGwgPz8gZmFsc2U7XG5cbiAgICBjb25zdCBvZmZzZXRZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxZID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IHNjcm9sbGVyID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsIHx8IHNjcm9sbFRvRW5kICE9PSB0cnVlKSByZXR1cm47XG5cbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGg7XG4gICAgfSwgW3Njcm9sbFRvRW5kXSk7XG5cbiAgICBjb25zdCBsYXN0U2Nyb2xsUG9zaXRpb24gPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICAgIGxvY2tEaXJlY3Rpb246IHVuZGVmaW5lZCBhcyBTY3JvbGxMb2NrLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmlnaHRXcmFwUmVmID0gUmVhY3QudXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBoYXNUb3VjaGVzID0gdXNlVG91Y2hVcERlbGF5ZWQoMjAwKTtcbiAgICBjb25zdCBbaXNJZGxlLCBzZXRJc0lkbGVdID0gUmVhY3QudXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgaWRsZVRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0lkbGUgfHwgaGFzVG91Y2hlcyB8fCBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgICAgICBpZiAoZWwgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgY29uc3QgW2x4LCBseV0gPSBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5sb2NrRGlyZWN0aW9uO1xuICAgICAgICBpZiAobHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGx4O1xuICAgICAgICB9IGVsc2UgaWYgKGx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcCA9IGx5O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgfSwgW2hhc1RvdWNoZXMsIGlzSWRsZV0pO1xuXG4gICAgY29uc3Qgb25TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gc2Nyb2xsZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGVsID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbGV0IHNjcm9sbExlZnQgPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsVG9wID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBsYXN0U2Nyb2xsTGVmdCA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgY29uc3QgZHggPSBzY3JvbGxMZWZ0IC0gbGFzdFNjcm9sbExlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gc2Nyb2xsVG9wIC0gbGFzdFNjcm9sbFRvcDtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBoYXNUb3VjaGVzICYmXG4gICAgICAgICAgICBkeCAhPT0gMCAmJlxuICAgICAgICAgICAgZHkgIT09IDAgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhkeCkgPiAzIHx8IE1hdGguYWJzKGR5KSA+IDMpICYmXG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcgJiZcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPVxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGR4KSA8IE1hdGguYWJzKGR5KSA/IFtsYXN0U2Nyb2xsTGVmdCwgdW5kZWZpbmVkXSA6IFt1bmRlZmluZWQsIGxhc3RTY3JvbGxUb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jayA9IGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb247XG5cbiAgICAgICAgc2Nyb2xsTGVmdCA9IGxvY2s/LlswXSA/PyBzY3JvbGxMZWZ0O1xuICAgICAgICBzY3JvbGxUb3AgPSBsb2NrPy5bMV0gPz8gc2Nyb2xsVG9wO1xuICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuXG4gICAgICAgIGNvbnN0IG5ld1kgPSBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbGFzdFNjcm9sbFkuY3VycmVudCAtIG5ld1k7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxhc3RTY3JvbGxZLmN1cnJlbnQgPSBuZXdZO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNjcm9sbGFibGVIZWlnaHQgPiAwICYmXG4gICAgICAgICAgICAoTWF0aC5hYnMoZGVsdGEpID4gMjAwMCB8fCBuZXdZID09PSAwIHx8IG5ld1kgPT09IHNjcm9sbGFibGVIZWlnaHQpICYmXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPiBlbC5zY3JvbGxIZWlnaHQgKyA1XG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcHJvZyA9IG5ld1kgLyBzY3JvbGxhYmxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcmVjb21wdXRlZCA9IChzY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQpICogcHJvZztcbiAgICAgICAgICAgIG9mZnNldFkuY3VycmVudCA9IHJlY29tcHV0ZWQgLSBuZXdZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZGxlVGltZXIuY3VycmVudCk7XG4gICAgICAgICAgICBzZXRJc0lkbGUoZmFsc2UpO1xuICAgICAgICAgICAgaWRsZVRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRJc0lkbGUodHJ1ZSksIDIwMCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoe1xuICAgICAgICAgICAgeDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IG5ld1kgKyBvZmZzZXRZLmN1cnJlbnQsXG4gICAgICAgICAgICB3aWR0aDogZWwuY2xpZW50V2lkdGggLSBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsLmNsaWVudEhlaWdodCAtIHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHJpZ2h0V3JhcFJlZi5jdXJyZW50Py5jbGllbnRXaWR0aCA/PyAwLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBzY3JvbGxIZWlnaHQsIHVwZGF0ZSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBoYXNUb3VjaGVzXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFJlZiA9IFJlYWN0LnVzZVJlZihvblNjcm9sbCk7XG4gICAgb25TY3JvbGxSZWYuY3VycmVudCA9IG9uU2Nyb2xsO1xuXG4gICAgY29uc3QgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmPHsgd2lkdGg/OiBudW1iZXI7IGhlaWdodD86IG51bWJlciB9PigpO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25TY3JvbGwoKTtcbiAgICB9LCBbb25TY3JvbGwsIHBhZGRpbmdCb3R0b20sIHBhZGRpbmdSaWdodF0pO1xuXG4gICAgY29uc3Qgc2V0UmVmcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoaW5zdGFuY2U6IEhUTUxEaXZFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsZXIuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW3Njcm9sbFJlZl1cbiAgICApO1xuXG4gICAgbGV0IGtleSA9IDA7XG4gICAgbGV0IGggPSAwO1xuICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiBzY3JvbGxXaWR0aCwgaGVpZ2h0OiAwIH19IC8+KTtcbiAgICB3aGlsZSAoaCA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBjb25zdCB0b0FkZCA9IE1hdGgubWluKDVfMDAwXzAwMCwgc2Nyb2xsSGVpZ2h0IC0gaCk7XG4gICAgICAgIHBhZGRlcnMucHVzaCg8ZGl2IGtleT17a2V5Kyt9IHN0eWxlPXt7IHdpZHRoOiAwLCBoZWlnaHQ6IHRvQWRkIH19IC8+KTtcbiAgICAgICAgaCArPSB0b0FkZDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZiwgd2lkdGgsIGhlaWdodCB9ID0gdXNlUmVzaXplRGV0ZWN0b3I8SFRNTERpdkVsZW1lbnQ+KGluaXRpYWxTaXplKTtcblxuICAgIGlmIChsYXN0UHJvcHMuY3VycmVudD8uaGVpZ2h0ICE9PSBoZWlnaHQgfHwgbGFzdFByb3BzLmN1cnJlbnQ/LndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBvblNjcm9sbFJlZi5jdXJyZW50KCksIDApO1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cblxuICAgIGlmICgod2lkdGggPz8gMCkgPT09IDAgfHwgKGhlaWdodCA/PyAwKSA9PT0gMCkgcmV0dXJuIDxkaXYgcmVmPXtyZWZ9IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiByZWY9e3JlZn0+XG4gICAgICAgICAgICA8U2Nyb2xsUmVnaW9uU3R5bGUgaXNTYWZhcmk9e2Jyb3dzZXJJc1NhZmFyaS52YWx1ZX0+XG4gICAgICAgICAgICAgICAge21pbmltYXB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdm4tdW5kZXJsYXlcIj57Y2hpbGRyZW59PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICByZWY9e3NldFJlZnN9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtsYXN0UHJvcHMuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlPXtkcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsZXIgXCIgKyAoY2xhc3NOYW1lID8/IFwiXCIpfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XCJkdm4tc2Nyb2xsLWlubmVyXCIgKyAocmlnaHRFbGVtZW50ID09PSB1bmRlZmluZWQgPyBcIiBoaWRkZW5cIiA6IFwiXCIpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZHZuLXN0YWNrXCI+e3BhZGRlcnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmlnaHRFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshcmlnaHRFbGVtZW50RmlsbCAmJiA8ZGl2IGNsYXNzTmFtZT1cImR2bi1zcGFjZXJcIiAvPn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyaWdodFdyYXBSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17ZWF0RXZlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2VhdEV2ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBjbGllbnRIZWlnaHQgLSBNYXRoLmNlaWwoZHByICUgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogLTQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3c6IHJpZ2h0RWxlbWVudEZpbGwgPyAxIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodEVsZW1lbnRTdGlja3kgPyBwYWRkaW5nUmlnaHQgPz8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JpZ2h0RWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvU2Nyb2xsUmVnaW9uU3R5bGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59O1xuIl19*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".i1ua65x0{width:100%;height:100px;}.i1ua65x0 > *{position:absolute;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC5zdG9yaWVzLnRzeCJdLCJuYW1lcyI6WyIuaTF1YTY1eDAiXSwibWFwcGluZ3MiOiJBQVVNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgR3JpZFNjcm9sbGVyIGZyb20gXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgQ29tcGFjdFNlbGVjdGlvbiwgR3JpZENlbGwsIEdyaWRDZWxsS2luZCwgUmVjdGFuZ2xlLCBJdGVtIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRUaGVtZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHMvY2VsbC10eXBlc1wiO1xuaW1wb3J0IHsgQ2VsbFJlbmRlcmVycyB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHNcIjtcblxuY29uc3QgSW5uZXJDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwcHg7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuY29uc3QgZ2V0Q2VsbFJlbmRlcmVyOiBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayA9IGNlbGwgPT4ge1xuICAgIGlmIChjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFwiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPEJ1aWxkZXJUaGVtZVdyYXBwZXIgd2lkdGg9ezE1MDB9IGhlaWdodD17MTAwMH0+XG4gICAgICAgICAgICAgICAgICAgIDxJbm5lckNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgICAgICAgICA8L0lubmVyQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvQnVpbGRlclRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gU2ltcGxlbm90ZXN0KCkge1xuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XG4gICAgY29uc3QgW3ksIHNldFldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWCwgc2V0VHhdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcblxuICAgIGNvbnN0IG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQgPSBSZWFjdC51c2VDYWxsYmFjaygocmFuZ2U6IFJlY3RhbmdsZSwgdHg/OiBudW1iZXIsIHR5PzogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldFgocmFuZ2UueCk7XG4gICAgICAgIHNldFkocmFuZ2UueSk7XG4gICAgICAgIHNldFR4KHR4KTtcbiAgICAgICAgc2V0VHkodHkpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICByZXR1cm4gW1wiT25lXCIsIFwiVHdvXCIsIFwiVGhyZWVcIiwgXCJGb3VyXCIsIFwiRml2ZVwiLCBcIlNpeFwiLCBcIlNldmVuXCIsIFwiRWlnaHRcIiwgXCJOaW5lXCIsIFwiVGVuXCJdLm1hcCh0ID0+ICh7XG4gICAgICAgICAgICB0aXRsZTogdCxcbiAgICAgICAgICAgIHdpZHRoOiAxMjIgKyAoaiArPSA1MCksXG4gICAgICAgIH0pKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxuICAgICAgICAgICAgZGF0YTogYCR7Y29sfSwke3Jvd30gVGVzdGluZyB0aGluZ3MgdGhhdCBhcmUgd2F5IHRvbyBsb25nYCxcbiAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIFtdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxHcmlkU2Nyb2xsZXJcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxuICAgICAgICAgICAgb25Nb3VzZU1vdmU9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XG4gICAgICAgICAgICBjbGllbnRTaXplPXtbMTAwMCwgMTAwMF19XG4gICAgICAgICAgICBjZWxsWE9mZnNldD17eH1cbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxuICAgICAgICAgICAgZHJhd0hlYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uQ2FudmFzQmx1cj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNlbGxGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51PXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdPdmVyQ2VsbD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJvcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbktleVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBjYW52YXNSZWY9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaWxsSGFuZGxlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaXhlZFNoYWRvd1g9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZ2V0R3JvdXBEZXRhaWxzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG92ZXJzY3JvbGxZPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgc2hvd01pbmltYXA9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XG4gICAgICAgICAgICBpc0ZvY3VzZWQ9e3RydWV9XG4gICAgICAgICAgICB0aGVtZT17Z2V0RGVmYXVsdFRoZW1lKCl9XG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9ezUwMH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlIZWlnaHQ9ezUwfVxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cbiAgICAgICAgICAgIHRyYW5zbGF0ZVk9e3RyYW5zbGF0ZVl9XG4gICAgICAgICAgICBsb2NrQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGZpcnN0Q29sQWNjZXNzaWJsZT17dHJ1ZX1cbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cbiAgICAgICAgICAgIGhlYWRlckhlaWdodD17NDR9XG4gICAgICAgICAgICB0cmFpbGluZ1Jvd1R5cGU9e1wibm9uZVwifVxuICAgICAgICAgICAgcm93SGVpZ2h0PXszNH1cbiAgICAgICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ9e29uVmlzaWJsZVJlZ2lvbkNoYW5nZWR9XG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17dHJ1ZX1cbiAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgIC8+XG4gICAgKTtcbn1cbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/core/src/scrolling-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx","webpack://./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx"],"names":[".i1ua65x0"],"mappings":"AAUMA,UAAAA,UAAAA,CAAAA,YAAAA,CAAAA,CAAAA,cAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA;ACTN,+tOAA+tO","sourcesContent":["import * as React from \"react\";\n\nimport { BuilderThemeWrapper } from \"../stories/story-utils\";\nimport GridScroller from \"./scrolling-data-grid\";\nimport { styled } from \"@linaria/react\";\nimport { CompactSelection, GridCell, GridCellKind, Rectangle, Item } from \"../data-grid/data-grid-types\";\nimport { getDefaultTheme } from \"..\";\nimport type { GetCellRendererCallback } from \"../data-grid/cells/cell-types\";\nimport { CellRenderers } from \"../data-grid/cells\";\n\nconst InnerContainer = styled.div`\n    width: 100%;\n    height: 100px;\n\n    > * {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n    }\n`;\n\nconst getCellRenderer: GetCellRendererCallback = cell => {\n    if (cell.kind === GridCellKind.Custom) return undefined;\n    return CellRenderers[cell.kind] as any;\n};\n\nexport default {\n    title: \"Subcomponents/ScrollingDataGrid\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <div>\n                <BuilderThemeWrapper width={1500} height={1000}>\n                    <InnerContainer>\n                        <Story />\n                    </InnerContainer>\n                </BuilderThemeWrapper>\n            </div>\n        ),\n    ],\n};\n\nexport function Simplenotest() {\n    const [x, setX] = React.useState<number>(0);\n    const [y, setY] = React.useState<number>(0);\n    const [translateX, setTx] = React.useState<number | undefined>(0);\n    const [translateY, setTy] = React.useState<number | undefined>(0);\n\n    const onVisibleRegionChanged = React.useCallback((range: Rectangle, tx?: number, ty?: number) => {\n        setX(range.x);\n        setY(range.y);\n        setTx(tx);\n        setTy(ty);\n    }, []);\n\n    const columns = React.useMemo(() => {\n        let j = 0;\n        return [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\"].map(t => ({\n            title: t,\n            width: 122 + (j += 50),\n        }));\n    }, []);\n\n    const getCellContent = React.useCallback(\n        ([col, row]: Item): GridCell => ({\n            kind: GridCellKind.Text,\n            displayData: `${col},${row} Testing things that are way too long`,\n            data: `${col},${row} Testing things that are way too long`,\n            allowOverlay: true,\n        }),\n        []\n    );\n\n    return (\n        <GridScroller\n            getCellRenderer={getCellRenderer}\n            onMouseMove={() => undefined}\n            rows={10_000}\n            enableGroups={false}\n            clientSize={[1000, 1000]}\n            cellXOffset={x}\n            cellYOffset={y}\n            drawHeader={undefined}\n            experimental={undefined}\n            headerIcons={undefined}\n            isDraggable={undefined}\n            onCanvasBlur={() => undefined}\n            onCanvasFocused={() => undefined}\n            onCellFocused={() => undefined}\n            onContextMenu={() => undefined}\n            onDragEnd={() => undefined}\n            onDragLeave={() => undefined}\n            onDragOverCell={() => undefined}\n            onDragStart={() => undefined}\n            onDrop={() => undefined}\n            onItemHovered={() => undefined}\n            onKeyDown={() => undefined}\n            onKeyUp={() => undefined}\n            onMouseDown={() => undefined}\n            onMouseUp={() => undefined}\n            canvasRef={undefined}\n            className={undefined}\n            disabledRows={undefined}\n            fillHandle={undefined}\n            fixedShadowX={undefined}\n            fixedShadowY={undefined}\n            getGroupDetails={undefined}\n            getRowThemeOverride={undefined}\n            highlightRegions={undefined}\n            imageWindowLoader={undefined}\n            onHeaderMenuClick={undefined}\n            prelightCells={undefined}\n            drawCustomCell={undefined}\n            drawFocusRing={undefined}\n            initialSize={undefined}\n            overscrollX={undefined}\n            overscrollY={undefined}\n            preventDiagonalScrolling={undefined}\n            rightElement={undefined}\n            rightElementProps={undefined}\n            scrollRef={undefined}\n            showMinimap={undefined}\n            scrollToEnd={undefined}\n            minColumnWidth={50}\n            isFocused={true}\n            theme={getDefaultTheme()}\n            isFilling={false}\n            maxColumnWidth={500}\n            accessibilityHeight={50}\n            translateX={translateX}\n            translateY={translateY}\n            lockColumns={0}\n            selection={{\n                current: undefined,\n                rows: CompactSelection.empty(),\n                columns: CompactSelection.empty(),\n            }}\n            firstColAccessible={true}\n            groupHeaderHeight={34}\n            headerHeight={44}\n            trailingRowType={\"none\"}\n            rowHeight={34}\n            onVisibleRegionChanged={onVisibleRegionChanged}\n            columns={columns}\n            getCellContent={getCellContent}\n            freezeColumns={0}\n            verticalBorder={() => true}\n            smoothScrollX={true}\n            smoothScrollY={true}\n        />\n    );\n}\n",".i1ua65x0{width:100%;height:100px;}.i1ua65x0 > *{position:absolute;width:100%;height:100%;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC5zdG9yaWVzLnRzeCJdLCJuYW1lcyI6WyIuaTF1YTY1eDAiXSwibWFwcGluZ3MiOiJBQVVNQSIsImZpbGUiOiJwYWNrYWdlcy9jb3JlL3NyYy9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQuc3Rvcmllcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgQnVpbGRlclRoZW1lV3JhcHBlciB9IGZyb20gXCIuLi9zdG9yaWVzL3N0b3J5LXV0aWxzXCI7XG5pbXBvcnQgR3JpZFNjcm9sbGVyIGZyb20gXCIuL3Njcm9sbGluZy1kYXRhLWdyaWRcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IHsgQ29tcGFjdFNlbGVjdGlvbiwgR3JpZENlbGwsIEdyaWRDZWxsS2luZCwgUmVjdGFuZ2xlLCBJdGVtIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRUaGVtZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHR5cGUgeyBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHMvY2VsbC10eXBlc1wiO1xuaW1wb3J0IHsgQ2VsbFJlbmRlcmVycyB9IGZyb20gXCIuLi9kYXRhLWdyaWQvY2VsbHNcIjtcblxuY29uc3QgSW5uZXJDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwcHg7XG5cbiAgICA+ICoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuYDtcblxuY29uc3QgZ2V0Q2VsbFJlbmRlcmVyOiBHZXRDZWxsUmVuZGVyZXJDYWxsYmFjayA9IGNlbGwgPT4ge1xuICAgIGlmIChjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIENlbGxSZW5kZXJlcnNbY2VsbC5raW5kXSBhcyBhbnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiU3ViY29tcG9uZW50cy9TY3JvbGxpbmdEYXRhR3JpZFwiLFxuXG4gICAgZGVjb3JhdG9yczogW1xuICAgICAgICAoU3Rvcnk6IFJlYWN0LkNvbXBvbmVudFR5cGUpID0+IChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPEJ1aWxkZXJUaGVtZVdyYXBwZXIgd2lkdGg9ezE1MDB9IGhlaWdodD17MTAwMH0+XG4gICAgICAgICAgICAgICAgICAgIDxJbm5lckNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdG9yeSAvPlxuICAgICAgICAgICAgICAgICAgICA8L0lubmVyQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvQnVpbGRlclRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gU2ltcGxlbm90ZXN0KCkge1xuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMCk7XG4gICAgY29uc3QgW3ksIHNldFldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWCwgc2V0VHhdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcbiAgICBjb25zdCBbdHJhbnNsYXRlWSwgc2V0VHldID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyIHwgdW5kZWZpbmVkPigwKTtcblxuICAgIGNvbnN0IG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQgPSBSZWFjdC51c2VDYWxsYmFjaygocmFuZ2U6IFJlY3RhbmdsZSwgdHg/OiBudW1iZXIsIHR5PzogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldFgocmFuZ2UueCk7XG4gICAgICAgIHNldFkocmFuZ2UueSk7XG4gICAgICAgIHNldFR4KHR4KTtcbiAgICAgICAgc2V0VHkodHkpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICByZXR1cm4gW1wiT25lXCIsIFwiVHdvXCIsIFwiVGhyZWVcIiwgXCJGb3VyXCIsIFwiRml2ZVwiLCBcIlNpeFwiLCBcIlNldmVuXCIsIFwiRWlnaHRcIiwgXCJOaW5lXCIsIFwiVGVuXCJdLm1hcCh0ID0+ICh7XG4gICAgICAgICAgICB0aXRsZTogdCxcbiAgICAgICAgICAgIHdpZHRoOiAxMjIgKyAoaiArPSA1MCksXG4gICAgICAgIH0pKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoW2NvbCwgcm93XTogSXRlbSk6IEdyaWRDZWxsID0+ICh7XG4gICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgIGRpc3BsYXlEYXRhOiBgJHtjb2x9LCR7cm93fSBUZXN0aW5nIHRoaW5ncyB0aGF0IGFyZSB3YXkgdG9vIGxvbmdgLFxuICAgICAgICAgICAgZGF0YTogYCR7Y29sfSwke3Jvd30gVGVzdGluZyB0aGluZ3MgdGhhdCBhcmUgd2F5IHRvbyBsb25nYCxcbiAgICAgICAgICAgIGFsbG93T3ZlcmxheTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIFtdXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxHcmlkU2Nyb2xsZXJcbiAgICAgICAgICAgIGdldENlbGxSZW5kZXJlcj17Z2V0Q2VsbFJlbmRlcmVyfVxuICAgICAgICAgICAgb25Nb3VzZU1vdmU9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIHJvd3M9ezEwXzAwMH1cbiAgICAgICAgICAgIGVuYWJsZUdyb3Vwcz17ZmFsc2V9XG4gICAgICAgICAgICBjbGllbnRTaXplPXtbMTAwMCwgMTAwMF19XG4gICAgICAgICAgICBjZWxsWE9mZnNldD17eH1cbiAgICAgICAgICAgIGNlbGxZT2Zmc2V0PXt5fVxuICAgICAgICAgICAgZHJhd0hlYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZXhwZXJpbWVudGFsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoZWFkZXJJY29ucz17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uQ2FudmFzQmx1cj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25DYW52YXNGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNlbGxGb2N1c2VkPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51PXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdFbmQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbkRyYWdPdmVyQ2VsbD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IHVuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uRHJvcD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25LZXlEb3duPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbktleVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17KCkgPT4gdW5kZWZpbmVkfVxuICAgICAgICAgICAgb25Nb3VzZVVwPXsoKSA9PiB1bmRlZmluZWR9XG4gICAgICAgICAgICBjYW52YXNSZWY9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaWxsSGFuZGxlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBmaXhlZFNoYWRvd1g9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGZpeGVkU2hhZG93WT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZ2V0R3JvdXBEZXRhaWxzPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoaWdobGlnaHRSZWdpb25zPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHByZWxpZ2h0Q2VsbHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBkcmF3Rm9jdXNSaW5nPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBpbml0aWFsU2l6ZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgb3ZlcnNjcm9sbFg9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG92ZXJzY3JvbGxZPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17dW5kZWZpbmVkfVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFJlZj17dW5kZWZpbmVkfVxuICAgICAgICAgICAgc2hvd01pbmltYXA9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBtaW5Db2x1bW5XaWR0aD17NTB9XG4gICAgICAgICAgICBpc0ZvY3VzZWQ9e3RydWV9XG4gICAgICAgICAgICB0aGVtZT17Z2V0RGVmYXVsdFRoZW1lKCl9XG4gICAgICAgICAgICBpc0ZpbGxpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9ezUwMH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlIZWlnaHQ9ezUwfVxuICAgICAgICAgICAgdHJhbnNsYXRlWD17dHJhbnNsYXRlWH1cbiAgICAgICAgICAgIHRyYW5zbGF0ZVk9e3RyYW5zbGF0ZVl9XG4gICAgICAgICAgICBsb2NrQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHNlbGVjdGlvbj17e1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGZpcnN0Q29sQWNjZXNzaWJsZT17dHJ1ZX1cbiAgICAgICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0PXszNH1cbiAgICAgICAgICAgIGhlYWRlckhlaWdodD17NDR9XG4gICAgICAgICAgICB0cmFpbGluZ1Jvd1R5cGU9e1wibm9uZVwifVxuICAgICAgICAgICAgcm93SGVpZ2h0PXszNH1cbiAgICAgICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ9e29uVmlzaWJsZVJlZ2lvbkNoYW5nZWR9XG4gICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e2dldENlbGxDb250ZW50fVxuICAgICAgICAgICAgZnJlZXplQ29sdW1ucz17MH1cbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXsoKSA9PiB0cnVlfVxuICAgICAgICAgICAgc21vb3RoU2Nyb2xsWD17dHJ1ZX1cbiAgICAgICAgICAgIHNtb290aFNjcm9sbFk9e3RydWV9XG4gICAgICAgIC8+XG4gICAgKTtcbn1cbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".m3brspx{position:absolute;right:44px;bottom:44px;background-color:var(--gdg-bg-cell);background:linear-gradient(var(--gdg-bg-cell),var(--gdg-bg-cell-medium));border-radius:4px;z-index:1;box-shadow:0 0 0 1px var(--gdg-border-color),0 2px 5px rgba(0,0,0,0.08);overflow:hidden;}.m3brspx .header{position:absolute;left:0;top:0;width:100%;height:4px;background-color:var(--gdg-bg-header);box-shadow:0 0 0 1px var(--gdg-border-color);}.m3brspx .locationMarker{position:absolute;border:1px solid var(--gdg-accent-color);background-color:var(--gdg-accent-light);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC50c3giXSwibmFtZXMiOlsiLm0zYnJzcHgiXSwibWFwcGluZ3MiOiJBQW9GTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgRGF0YUdyaWREbmQsIHsgRGF0YUdyaWREbmRQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWdyaWQtZG5kL2RhdGEtZ3JpZC1kbmRcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsZXIgfSBmcm9tIFwiLi9pbmZpbml0ZS1zY3JvbGxlclwiO1xuaW1wb3J0IGNsYW1wIGZyb20gXCJsb2Rhc2gvY2xhbXAuanNcIjtcblxudHlwZSBQcm9wcyA9IE9taXQ8RGF0YUdyaWREbmRQcm9wcywgXCJ3aWR0aFwiIHwgXCJoZWlnaHRcIiB8IFwiZXZlbnRUYXJnZXRSZWZcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsaW5nRGF0YUdyaWRQcm9wcyBleHRlbmRzIFByb3BzIHtcbiAgICByZWFkb25seSBjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBvblZpc2libGVSZWdpb25DaGFuZ2VkOlxuICAgICAgICB8ICgoXG4gICAgICAgICAgICAgIHJhbmdlOiBSZWN0YW5nbGUsXG4gICAgICAgICAgICAgIGNsaWVudFdpZHRoOiBudW1iZXIsXG4gICAgICAgICAgICAgIGNsaWVudEhlaWdodDogbnVtYmVyLFxuICAgICAgICAgICAgICByaWdodEVsV2lkdGg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHk6IG51bWJlclxuICAgICAgICAgICkgPT4gdm9pZClcbiAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBncmlkIHRvIHNjcm9sbCB0byB0aGUgZW5kIHdoZW4gZmxpcHBlZCB0byB0cnVlXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBEYXRhRWRpdG9yUmVmLnNjcm9sbFRvfSBpbnN0ZWFkXG4gICAgICogQGdyb3VwIERlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzY3JvbGxUb0VuZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBzY3JvbGxSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQgfCBudWxsPiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdmVyc2Nyb2xsIHByb3BlcnRpZXMgYXJlIHVzZWQgdG8gYWxsb3cgdGhlIGdyaWQgdG8gc2Nyb2xsIHBhc3QgdGhlIGxvZ2ljYWwgZW5kIG9mIHRoZSBjb250ZW50IGJ5IGEgZml4ZWRcbiAgICAgKiBudW1iZXIgb2YgcGl4ZWxzLiBUaGlzIGlzIHVzZWZ1bCBwYXJ0aWN1bGFybHkgb24gdGhlIFggYXhpcyBpZiB5b3UgYWxsb3cgZm9yIHJlc2l6aW5nIGNvbHVtbnMgYXMgaXQgY2FuIG1ha2VcbiAgICAgKiByZXNpemluZyB0aGUgZmluYWwgY29sdW1uIHNpZ25pZmljYW50bHkgZWFzaWVyLlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgb3ZlcnNjcm9sbFg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKioge0Bpbmhlcml0RG9jIG92ZXJzY3JvbGxYfVxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IG92ZXJzY3JvbGxZOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW5pdGlhbCBzaXplIGZvciB0aGUgZ3JpZCB3aGljaCBjYW4gcHJldmVudCBhIGZsaWNrZXIgb24gbG9hZCBpZiB0aGUgaW5pdGlhbCBzaXplIGlzIGtub3duIHByaW9yIHRvXG4gICAgICogbGF5b3V0LlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgaW5pdGlhbFNpemU6IHJlYWRvbmx5IFt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcl0gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gcHJldmVudCBhbnkgZGlhZ29uYWwgc2Nyb2xsaW5nLlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHByZXZlbnREaWFnb25hbFNjcm9sbGluZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIElmIGByaWdodEVsZW1lbnRQcm9wcy5zdGlja3lgIGlzIHNldCB0byB0cnVlIHRoZSByaWdodCBlbGVtZW50IHdpbGwgYmUgdmlzaWJsZSBhdCBhbGwgdGltZXMsIG90aGVyd2lzZSB0aGUgdXNlclxuICAgICAqIHdpbGwgbmVlZCB0byBzY3JvbGwgdG8gdGhlIGVuZCB0byByZXZlYWwgaXQuXG4gICAgICpcbiAgICAgKiBJZiBgcmlnaHRFbGVtZW50UHJvcHMuZmlsbGAgaXMgc2V0LCB0aGUgcmlnaHQgZWxlbWVudHMgY29udGFpbmVyIHdpbGwgZmlsbCB0byBjb25zdW1lIGFsbCByZW1haW5pbmcgc3BhY2UgKGlmXG4gICAgICogYW55KSBhdCB0aGUgZW5kIG9mIHRoZSBncmlkLiBUaGlzIGRvZXMgbm90IHBsYXkgbmljZSB3aXRoIGdyb3dpbmcgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJpZ2h0RWxlbWVudFByb3BzOlxuICAgICAgICB8IHtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgICAgICAgfVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmlnaHQgZWxlbWVudCBpcyBhIERPTSBub2RlIHdoaWNoIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCByZWdpb24uIFRoaXMgY2FuIGJlXG4gICAgICogdXNlZCB0byBjcmVhdGUgYSByaWdodCBoYW5kbGUgcGFuZWwsIG1ha2UgYSBiaWcgYWRkIGJ1dHRvbiwgb3IgZGlzcGxheSBtZXNzYWdlcy5cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHRoZSBpbnRlcmFjdGl2ZSBtaW5pbWFwLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgZmFsc2VcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzaG93TWluaW1hcDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBjbGllbnRTaXplOiByZWFkb25seSBbbnVtYmVyLCBudW1iZXJdO1xufVxuXG5jb25zdCBNaW5pbWFwU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogNDRweDtcbiAgICBib3R0b206IDQ0cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh2YXIoLS1nZGctYmctY2VsbCksIHZhcigtLWdkZy1iZy1jZWxsLW1lZGl1bSkpO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB6LWluZGV4OiAxO1xuICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKSwgMCAycHggNXB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgLmhlYWRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiA0cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXIpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuXG4gICAgLmxvY2F0aW9uTWFya2VyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICB9XG5gO1xuXG5jb25zdCBHcmlkU2Nyb2xsZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFNjcm9sbGluZ0RhdGFHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBjb2x1bW5zLFxuICAgICAgICByb3dzLFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgICAgZ3JvdXBIZWFkZXJIZWlnaHQsXG4gICAgICAgIGVuYWJsZUdyb3VwcyxcbiAgICAgICAgZnJlZXplQ29sdW1ucyxcbiAgICAgICAgZXhwZXJpbWVudGFsLFxuICAgICAgICBjbGllbnRTaXplLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZyxcbiAgICAgICAgcmlnaHRFbGVtZW50LFxuICAgICAgICByaWdodEVsZW1lbnRQcm9wcyxcbiAgICAgICAgb3ZlcnNjcm9sbFgsXG4gICAgICAgIG92ZXJzY3JvbGxZLFxuICAgICAgICBzaG93TWluaW1hcCA9IGZhbHNlLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgc21vb3RoU2Nyb2xsWCA9IGZhbHNlLFxuICAgICAgICBzbW9vdGhTY3JvbGxZID0gZmFsc2UsXG4gICAgICAgIGlzRHJhZ2dhYmxlLFxuICAgIH0gPSBwO1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBleHBlcmltZW50YWwgPz8ge307XG5cbiAgICBjb25zdCBbY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodF0gPSBjbGllbnRTaXplO1xuICAgIGNvbnN0IGxhc3QgPSBSZWFjdC51c2VSZWY8UmVjdGFuZ2xlIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RYID0gUmVhY3QudXNlUmVmPG51bWJlciB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0WSA9IFJlYWN0LnVzZVJlZjxudW1iZXIgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFNpemUgPSBSZWFjdC51c2VSZWY8cmVhZG9ubHkgW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IHdpZHRoID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCByID0gTWF0aC5tYXgoMCwgb3ZlcnNjcm9sbFggPz8gMCk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgICByICs9IGMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSwgW2NvbHVtbnMsIG92ZXJzY3JvbGxYXSk7XG5cbiAgICBsZXQgaGVpZ2h0ID0gZW5hYmxlR3JvdXBzID8gaGVhZGVySGVpZ2h0ICsgZ3JvdXBIZWFkZXJIZWlnaHQgOiBoZWFkZXJIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHJvd3MgKiByb3dIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICAgIGhlaWdodCArPSByb3dIZWlnaHQocik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJzY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ICs9IG92ZXJzY3JvbGxZO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RBcmdzID0gUmVhY3QudXNlUmVmPFJlY3RhbmdsZSAmIHsgcGFkZGluZ1JpZ2h0OiBudW1iZXIgfT4oKTtcblxuICAgIGNvbnN0IHByb2Nlc3NBcmdzID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAobGFzdEFyZ3MuY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7IC4uLmxhc3RBcmdzLmN1cnJlbnQgfTtcblxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB0eCA9IGFyZ3MueCA8IDAgPyAtYXJncy54IDogMDtcbiAgICAgICAgbGV0IGNlbGxSaWdodCA9IDA7XG4gICAgICAgIGxldCBjZWxsWCA9IDA7XG5cbiAgICAgICAgYXJncy54ID0gYXJncy54IDwgMCA/IDAgOiBhcmdzLng7XG5cbiAgICAgICAgbGV0IHN0aWNreUNvbFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmVlemVDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIHN0aWNreUNvbFdpZHRoICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sdW1ucykge1xuICAgICAgICAgICAgY29uc3QgY3ggPSB4IC0gc3RpY2t5Q29sV2lkdGg7XG4gICAgICAgICAgICBpZiAoYXJncy54ID49IGN4ICsgYy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnggPiBjeCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSBjeCAtIGFyZ3MueDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy54ICsgYXJncy53aWR0aCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0eSA9IDA7XG4gICAgICAgIGxldCBjZWxsWSA9IDA7XG4gICAgICAgIGxldCBjZWxsQm90dG9tID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmZsb29yKGFyZ3MueSAvIHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgdHkgPSBjZWxsWSAqIHJvd0hlaWdodCAtIGFyZ3MueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmNlaWwoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxCb3R0b20gPSBNYXRoLmNlaWwoYXJncy5oZWlnaHQgLyByb3dIZWlnaHQpICsgY2VsbFk7XG4gICAgICAgICAgICBpZiAodHkgPCAwKSBjZWxsQm90dG9tKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJoID0gcm93SGVpZ2h0KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3kgPSB5ICsgKHNtb290aFNjcm9sbFkgPyAwIDogcmggLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy55ID49IHkgKyByaCkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnkgPiBjeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHkgKz0gY3kgLSBhcmdzLnk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueSArIGFyZ3MuaGVpZ2h0ID4gcmggLyAyICsgeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjdDogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogY2VsbFgsXG4gICAgICAgICAgICB5OiBjZWxsWSxcbiAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgIGhlaWdodDogY2VsbEJvdHRvbSAtIGNlbGxZLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9sZFJlY3QgPSBsYXN0LmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2xkUmVjdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBvbGRSZWN0LnkgIT09IHJlY3QueSB8fFxuICAgICAgICAgICAgb2xkUmVjdC54ICE9PSByZWN0LnggfHxcbiAgICAgICAgICAgIG9sZFJlY3QuaGVpZ2h0ICE9PSByZWN0LmhlaWdodCB8fFxuICAgICAgICAgICAgb2xkUmVjdC53aWR0aCAhPT0gcmVjdC53aWR0aCB8fFxuICAgICAgICAgICAgbGFzdFguY3VycmVudCAhPT0gdHggfHxcbiAgICAgICAgICAgIGxhc3RZLmN1cnJlbnQgIT09IHR5IHx8XG4gICAgICAgICAgICBhcmdzLndpZHRoICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMF0gfHxcbiAgICAgICAgICAgIGFyZ3MuaGVpZ2h0ICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPy4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4OiBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjZWxsQm90dG9tIC0gY2VsbFksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmdzLndpZHRoLFxuICAgICAgICAgICAgICAgIGFyZ3MuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFyZ3MucGFkZGluZ1JpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgdHgsXG4gICAgICAgICAgICAgICAgdHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsYXN0LmN1cnJlbnQgPSByZWN0O1xuICAgICAgICAgICAgbGFzdFguY3VycmVudCA9IHR4O1xuICAgICAgICAgICAgbGFzdFkuY3VycmVudCA9IHR5O1xuICAgICAgICAgICAgbGFzdFNpemUuY3VycmVudCA9IFthcmdzLndpZHRoLCBhcmdzLmhlaWdodF07XG4gICAgICAgIH1cbiAgICB9LCBbY29sdW1ucywgcm93SGVpZ2h0LCByb3dzLCBvblZpc2libGVSZWdpb25DaGFuZ2VkLCBmcmVlemVDb2x1bW5zLCBzbW9vdGhTY3JvbGxYLCBzbW9vdGhTY3JvbGxZXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoYXJnczogUmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBsYXN0QXJncy5jdXJyZW50ID0gYXJncztcbiAgICAgICAgICAgIHByb2Nlc3NBcmdzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtwcm9jZXNzQXJnc11cbiAgICApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvY2Vzc0FyZ3MoKTtcbiAgICB9LCBbcHJvY2Vzc0FyZ3NdKTtcblxuICAgIGNvbnN0IHNjcm9sbGVyID0gc2Nyb2xsUmVmPy5jdXJyZW50ID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhc3BlY3QgPSBjbGFtcCh3aWR0aCAvIGhlaWdodCwgMiAvIDMsIDEuNSk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IDIwMDtcbiAgICBjb25zdCB3ID0gYXNwZWN0ID4gMSA/IG1heFNpemUgOiBNYXRoLmNlaWwobWF4U2l6ZSAqIGFzcGVjdCk7XG4gICAgY29uc3QgaCA9IGFzcGVjdCA+IDEgPyBNYXRoLmNlaWwobWF4U2l6ZSAvIGFzcGVjdCkgOiBtYXhTaXplO1xuICAgIGNvbnN0IGhSYXRpbyA9IHcgLyB3aWR0aDtcbiAgICBjb25zdCB2UmF0aW8gPSBoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHZXaWR0aCA9IE1hdGgubWluKGNsaWVudFdpZHRoICogTWF0aC5tYXgoaFJhdGlvLCAwLjAxKSwgdyk7XG4gICAgY29uc3QgdkhlaWdodCA9IE1hdGgubWluKGNsaWVudEhlaWdodCAqIE1hdGgubWF4KHZSYXRpbywgMC4wMSksIGgpO1xuICAgIGNvbnN0IGxlZnQgPSAoKHNjcm9sbGVyPy5zY3JvbGxMZWZ0ID8/IDApIC8gKHdpZHRoIC0gY2xpZW50V2lkdGgpKSAqICh3IC0gdldpZHRoKTtcbiAgICBjb25zdCB0b3AgPSAoKHNjcm9sbGVyPy5zY3JvbGxUb3AgPz8gMCkgLyAoaGVpZ2h0IC0gY2xpZW50SGVpZ2h0KSkgKiAoaCAtIHZIZWlnaHQpO1xuXG4gICAgY29uc3QgbWluaW1hcDogUmVhY3QuUmVhY3ROb2RlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvd01pbmltYXAgfHwgdldpZHRoID09PSAwIHx8IHZIZWlnaHQgPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlTW91c2UgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSBib3VuZHMueCAtIHZXaWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gYm91bmRzLnkgLSB2SGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsTGVmdCA9ICh3aWR0aCAtIHNjcm9sbGVyLmNsaWVudFdpZHRoKSAqICh4IC8gKHcgLSB2V2lkdGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbFRvcCA9IChoZWlnaHQgLSBzY3JvbGxlci5jbGllbnRIZWlnaHQpICogKHkgLyAoaCAtIHZIZWlnaHQpKTtcblxuICAgICAgICAgICAgc2Nyb2xsZXIuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG5ld1Njcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBuZXdTY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IGUudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiA/IFwiYXV0b1wiIDogXCJzbW9vdGhcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TWluaW1hcFN0eWxlXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IHcsIGhlaWdodDogaCB9fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwibWluaW1hcC1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9ucyAhPT0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZShlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1vdXNlfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiIC8+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsb2NhdGlvbk1hcmtlclwiXG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IGUucHJldmVudERlZmF1bHQoKX1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBNYXRoLm1pbih2V2lkdGgsIHZIZWlnaHQgKiAwLjIsIDkpLFxuICAgICAgICAgICAgICAgICAgICB9fT48L2Rpdj5cbiAgICAgICAgICAgIDwvTWluaW1hcFN0eWxlPlxuICAgICAgICApO1xuICAgIH0sIFtoLCBoZWlnaHQsIGxlZnQsIHNjcm9sbGVyLCBzaG93TWluaW1hcCwgdG9wLCB2SGVpZ2h0LCB2V2lkdGgsIHcsIHdpZHRoXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8SW5maW5pdGVTY3JvbGxlclxuICAgICAgICAgICAgc2Nyb2xsUmVmPXtzY3JvbGxSZWZ9XG4gICAgICAgICAgICBtaW5pbWFwPXttaW5pbWFwfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3ByZXZlbnREaWFnb25hbFNjcm9sbGluZ31cbiAgICAgICAgICAgIGRyYWdnYWJsZT17aXNEcmFnZ2FibGUgPT09IHRydWUgfHwgdHlwZW9mIGlzRHJhZ2dhYmxlID09PSBcInN0cmluZ1wifVxuICAgICAgICAgICAgc2Nyb2xsV2lkdGg9e3dpZHRoICsgKHBhZGRpbmdSaWdodCA/PyAwKX1cbiAgICAgICAgICAgIHNjcm9sbEhlaWdodD17aGVpZ2h0ICsgKHBhZGRpbmdCb3R0b20gPz8gMCl9XG4gICAgICAgICAgICBjbGllbnRIZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17cmlnaHRFbGVtZW50fVxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbT17cGFkZGluZ0JvdHRvbX1cbiAgICAgICAgICAgIHBhZGRpbmdSaWdodD17cGFkZGluZ1JpZ2h0fVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3JpZ2h0RWxlbWVudFByb3BzfVxuICAgICAgICAgICAgdXBkYXRlPXtvblNjcm9sbFVwZGF0ZX1cbiAgICAgICAgICAgIGluaXRpYWxTaXplPXtpbml0aWFsU2l6ZX1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXtzY3JvbGxUb0VuZH0+XG4gICAgICAgICAgICA8RGF0YUdyaWREbmRcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldFJlZj17c2Nyb2xsUmVmfVxuICAgICAgICAgICAgICAgIHdpZHRoPXtjbGllbnRXaWR0aH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5SGVpZ2h0PXtwLmFjY2Vzc2liaWxpdHlIZWlnaHR9XG4gICAgICAgICAgICAgICAgY2FudmFzUmVmPXtwLmNhbnZhc1JlZn1cbiAgICAgICAgICAgICAgICBjZWxsWE9mZnNldD17cC5jZWxsWE9mZnNldH1cbiAgICAgICAgICAgICAgICBjZWxsWU9mZnNldD17cC5jZWxsWU9mZnNldH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtwLmNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXtwLmRpc2FibGVkUm93c31cbiAgICAgICAgICAgICAgICBlbmFibGVHcm91cHM9e3AuZW5hYmxlR3JvdXBzfVxuICAgICAgICAgICAgICAgIGZpbGxIYW5kbGU9e3AuZmlsbEhhbmRsZX1cbiAgICAgICAgICAgICAgICBmaXJzdENvbEFjY2Vzc2libGU9e3AuZmlyc3RDb2xBY2Nlc3NpYmxlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17cC5maXhlZFNoYWRvd1h9XG4gICAgICAgICAgICAgICAgZml4ZWRTaGFkb3dZPXtwLmZpeGVkU2hhZG93WX1cbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXtwLmZyZWV6ZUNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e3AuZ2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbFJlbmRlcmVyPXtwLmdldENlbGxSZW5kZXJlcn1cbiAgICAgICAgICAgICAgICBnZXRHcm91cERldGFpbHM9e3AuZ2V0R3JvdXBEZXRhaWxzfVxuICAgICAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3AuZ2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBncm91cEhlYWRlckhlaWdodD17cC5ncm91cEhlYWRlckhlaWdodH1cbiAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQ9e3AuaGVhZGVySGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnM9e3AuaGlnaGxpZ2h0UmVnaW9uc31cbiAgICAgICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17cC5pbWFnZVdpbmRvd0xvYWRlcn1cbiAgICAgICAgICAgICAgICBpc0ZpbGxpbmc9e3AuaXNGaWxsaW5nfVxuICAgICAgICAgICAgICAgIGlzRm9jdXNlZD17cC5pc0ZvY3VzZWR9XG4gICAgICAgICAgICAgICAgbG9ja0NvbHVtbnM9e3AubG9ja0NvbHVtbnN9XG4gICAgICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9e3AubWF4Q29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgbWluQ29sdW1uV2lkdGg9e3AubWluQ29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3Aub25IZWFkZXJNZW51Q2xpY2t9XG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e3Aub25Nb3VzZU1vdmV9XG4gICAgICAgICAgICAgICAgcHJlbGlnaHRDZWxscz17cC5wcmVsaWdodENlbGxzfVxuICAgICAgICAgICAgICAgIHJvd0hlaWdodD17cC5yb3dIZWlnaHR9XG4gICAgICAgICAgICAgICAgcm93cz17cC5yb3dzfVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbj17cC5zZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgdGhlbWU9e3AudGhlbWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dUeXBlPXtwLnRyYWlsaW5nUm93VHlwZX1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYPXtwLnRyYW5zbGF0ZVh9XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWT17cC50cmFuc2xhdGVZfVxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXtwLnZlcnRpY2FsQm9yZGVyfVxuICAgICAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXtwLmRyYXdDdXN0b21DZWxsfVxuICAgICAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3AuZHJhd0ZvY3VzUmluZ31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtwLmRyYXdIZWFkZXJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXtwLmV4cGVyaW1lbnRhbH1cbiAgICAgICAgICAgICAgICBncmlkUmVmPXtwLmdyaWRSZWZ9XG4gICAgICAgICAgICAgICAgaGVhZGVySWNvbnM9e3AuaGVhZGVySWNvbnN9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25DYW52YXNCbHVyPXtwLm9uQ2FudmFzQmx1cn1cbiAgICAgICAgICAgICAgICBvbkNhbnZhc0ZvY3VzZWQ9e3Aub25DYW52YXNGb2N1c2VkfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEZvY3VzZWQ9e3Aub25DZWxsRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtwLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e3Aub25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVFbmQ9e3Aub25Db2x1bW5SZXNpemVFbmR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVTdGFydD17cC5vbkNvbHVtblJlc2l6ZVN0YXJ0fVxuICAgICAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9e3Aub25Db250ZXh0TWVudX1cbiAgICAgICAgICAgICAgICBvbkRyYWdFbmQ9e3Aub25EcmFnRW5kfVxuICAgICAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXtwLm9uRHJhZ0xlYXZlfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtwLm9uRHJhZ092ZXJDZWxsfVxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtwLm9uRHJhZ1N0YXJ0fVxuICAgICAgICAgICAgICAgIG9uRHJvcD17cC5vbkRyb3B9XG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17cC5vbkl0ZW1Ib3ZlcmVkfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17cC5vbktleURvd259XG4gICAgICAgICAgICAgICAgb25LZXlVcD17cC5vbktleVVwfVxuICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtwLm9uTW91c2VEb3dufVxuICAgICAgICAgICAgICAgIG9uTW91c2VVcD17cC5vbk1vdXNlVXB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17cC5vblJvd01vdmVkfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3Auc21vb3RoU2Nyb2xsWH1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXtwLnNtb290aFNjcm9sbFl9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0luZmluaXRlU2Nyb2xsZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdyaWRTY3JvbGxlcjtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/core/src/scrolling-data-grid/packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx","webpack://./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx"],"names":[".m3brspx"],"mappings":"AAoFMA,SAAAA,iBAAAA,CAAAA,UAAAA,CAAAA,WAAAA,CAAAA,mCAAAA,CAAAA,wEAAAA,CAAAA,iBAAAA,CAAAA,SAAAA,CAAAA,uEAAAA,CAAAA,eAAAA,CAAAA,CAAAA,iBAAAA,iBAAAA,CAAAA,MAAAA,CAAAA,KAAAA,CAAAA,UAAAA,CAAAA,UAAAA,CAAAA,qCAAAA,CAAAA,4CAAAA,CAAAA,CAAAA,yBAAAA,iBAAAA,CAAAA,wCAAAA,CAAAA,wCAAAA,CAAAA;ACnFN,+tqBAA+tqB","sourcesContent":["import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport DataGridDnd, { DataGridDndProps } from \"../data-grid-dnd/data-grid-dnd\";\nimport type { Rectangle } from \"../data-grid/data-grid-types\";\nimport { InfiniteScroller } from \"./infinite-scroller\";\nimport clamp from \"lodash/clamp.js\";\n\ntype Props = Omit<DataGridDndProps, \"width\" | \"height\" | \"eventTargetRef\">;\n\nexport interface ScrollingDataGridProps extends Props {\n    readonly className: string | undefined;\n    readonly onVisibleRegionChanged:\n        | ((\n              range: Rectangle,\n              clientWidth: number,\n              clientHeight: number,\n              rightElWidth: number,\n              tx: number,\n              ty: number\n          ) => void)\n        | undefined;\n    /**\n     * Causes the grid to scroll to the end when flipped to true\n     * @deprecated Use {@link DataEditorRef.scrollTo} instead\n     * @group Deprecated\n     */\n    readonly scrollToEnd: boolean | undefined;\n    readonly scrollRef: React.MutableRefObject<HTMLDivElement | null> | undefined;\n\n    /**\n     * The overscroll properties are used to allow the grid to scroll past the logical end of the content by a fixed\n     * number of pixels. This is useful particularly on the X axis if you allow for resizing columns as it can make\n     * resizing the final column significantly easier.\n     *\n     * @group Advanced\n     */\n    readonly overscrollX: number | undefined;\n    /** {@inheritDoc overscrollX}\n     * @group Advanced\n     */\n    readonly overscrollY: number | undefined;\n    /**\n     * Provides an initial size for the grid which can prevent a flicker on load if the initial size is known prior to\n     * layout.\n     *\n     * @group Advanced\n     */\n    readonly initialSize: readonly [width: number, height: number] | undefined;\n    /**\n     * Set to true to prevent any diagonal scrolling.\n     * @group Advanced\n     */\n    readonly preventDiagonalScrolling: boolean | undefined;\n\n    /**\n     * If `rightElementProps.sticky` is set to true the right element will be visible at all times, otherwise the user\n     * will need to scroll to the end to reveal it.\n     *\n     * If `rightElementProps.fill` is set, the right elements container will fill to consume all remaining space (if\n     * any) at the end of the grid. This does not play nice with growing columns.\n     *\n     * @group Advanced\n     */\n    readonly rightElementProps:\n        | {\n              readonly sticky?: boolean;\n              readonly fill?: boolean;\n          }\n        | undefined;\n    /**\n     * The right element is a DOM node which can be inserted at the end of the horizontal scroll region. This can be\n     * used to create a right handle panel, make a big add button, or display messages.\n     * @group Advanced\n     */\n    readonly rightElement: React.ReactNode | undefined;\n    /**\n     * Enables/disables the interactive minimap.\n     * @defaultValue false\n     * @group Advanced\n     */\n    readonly showMinimap: boolean | undefined;\n    readonly clientSize: readonly [number, number];\n}\n\nconst MinimapStyle = styled.div`\n    position: absolute;\n    right: 44px;\n    bottom: 44px;\n    background-color: var(--gdg-bg-cell);\n    background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n    border-radius: 4px;\n    z-index: 1;\n    box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n\n    overflow: hidden;\n\n    .header {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 4px;\n        background-color: var(--gdg-bg-header);\n        box-shadow: 0 0 0 1px var(--gdg-border-color);\n    }\n\n    .locationMarker {\n        position: absolute;\n\n        border: 1px solid var(--gdg-accent-color);\n        background-color: var(--gdg-accent-light);\n    }\n`;\n\nconst GridScroller: React.FunctionComponent<ScrollingDataGridProps> = p => {\n    const {\n        columns,\n        rows,\n        rowHeight,\n        headerHeight,\n        groupHeaderHeight,\n        enableGroups,\n        freezeColumns,\n        experimental,\n        clientSize,\n        className,\n        onVisibleRegionChanged,\n        scrollToEnd,\n        scrollRef,\n        preventDiagonalScrolling,\n        rightElement,\n        rightElementProps,\n        overscrollX,\n        overscrollY,\n        showMinimap = false,\n        initialSize,\n        smoothScrollX = false,\n        smoothScrollY = false,\n        isDraggable,\n    } = p;\n    const { paddingRight, paddingBottom } = experimental ?? {};\n\n    const [clientWidth, clientHeight] = clientSize;\n    const last = React.useRef<Rectangle | undefined>();\n    const lastX = React.useRef<number | undefined>();\n    const lastY = React.useRef<number | undefined>();\n    const lastSize = React.useRef<readonly [number, number] | undefined>();\n\n    const width = React.useMemo(() => {\n        let r = Math.max(0, overscrollX ?? 0);\n        for (const c of columns) {\n            r += c.width;\n        }\n        return r;\n    }, [columns, overscrollX]);\n\n    let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n    if (typeof rowHeight === \"number\") {\n        height += rows * rowHeight;\n    } else {\n        for (let r = 0; r < rows; r++) {\n            height += rowHeight(r);\n        }\n    }\n    if (overscrollY !== undefined) {\n        height += overscrollY;\n    }\n\n    const lastArgs = React.useRef<Rectangle & { paddingRight: number }>();\n\n    const processArgs = React.useCallback(() => {\n        if (lastArgs.current === undefined) return;\n        const args = { ...lastArgs.current };\n\n        let x = 0;\n        let tx = args.x < 0 ? -args.x : 0;\n        let cellRight = 0;\n        let cellX = 0;\n\n        args.x = args.x < 0 ? 0 : args.x;\n\n        let stickyColWidth = 0;\n        for (let i = 0; i < freezeColumns; i++) {\n            stickyColWidth += columns[i].width;\n        }\n\n        for (const c of columns) {\n            const cx = x - stickyColWidth;\n            if (args.x >= cx + c.width) {\n                x += c.width;\n                cellX++;\n                cellRight++;\n            } else if (args.x > cx) {\n                x += c.width;\n                if (smoothScrollX) {\n                    tx += cx - args.x;\n                } else {\n                    cellX++;\n                }\n                cellRight++;\n            } else if (args.x + args.width > cx) {\n                x += c.width;\n                cellRight++;\n            } else {\n                break;\n            }\n        }\n\n        let ty = 0;\n        let cellY = 0;\n        let cellBottom = 0;\n        if (typeof rowHeight === \"number\") {\n            if (smoothScrollY) {\n                cellY = Math.floor(args.y / rowHeight);\n                ty = cellY * rowHeight - args.y;\n            } else {\n                cellY = Math.ceil(args.y / rowHeight);\n            }\n            cellBottom = Math.ceil(args.height / rowHeight) + cellY;\n            if (ty < 0) cellBottom++;\n        } else {\n            let y = 0;\n            for (let row = 0; row < rows; row++) {\n                const rh = rowHeight(row);\n                const cy = y + (smoothScrollY ? 0 : rh / 2);\n                if (args.y >= y + rh) {\n                    y += rh;\n                    cellY++;\n                    cellBottom++;\n                } else if (args.y > cy) {\n                    y += rh;\n                    if (smoothScrollY) {\n                        ty += cy - args.y;\n                    } else {\n                        cellY++;\n                    }\n                    cellBottom++;\n                } else if (args.y + args.height > rh / 2 + y) {\n                    y += rh;\n                    cellBottom++;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        const rect: Rectangle = {\n            x: cellX,\n            y: cellY,\n            width: cellRight - cellX,\n            height: cellBottom - cellY,\n        };\n\n        const oldRect = last.current;\n\n        if (\n            oldRect === undefined ||\n            oldRect.y !== rect.y ||\n            oldRect.x !== rect.x ||\n            oldRect.height !== rect.height ||\n            oldRect.width !== rect.width ||\n            lastX.current !== tx ||\n            lastY.current !== ty ||\n            args.width !== lastSize.current?.[0] ||\n            args.height !== lastSize.current?.[1]\n        ) {\n            onVisibleRegionChanged?.(\n                {\n                    x: cellX,\n                    y: cellY,\n                    width: cellRight - cellX,\n                    height: cellBottom - cellY,\n                },\n                args.width,\n                args.height,\n                args.paddingRight ?? 0,\n                tx,\n                ty\n            );\n            last.current = rect;\n            lastX.current = tx;\n            lastY.current = ty;\n            lastSize.current = [args.width, args.height];\n        }\n    }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\n\n    const onScrollUpdate = React.useCallback(\n        (args: Rectangle & { paddingRight: number }) => {\n            lastArgs.current = args;\n            processArgs();\n        },\n        [processArgs]\n    );\n\n    React.useEffect(() => {\n        processArgs();\n    }, [processArgs]);\n\n    const scroller = scrollRef?.current ?? undefined;\n    const aspect = clamp(width / height, 2 / 3, 1.5);\n    const maxSize = 200;\n    const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);\n    const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;\n    const hRatio = w / width;\n    const vRatio = h / height;\n    const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);\n    const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);\n    const left = ((scroller?.scrollLeft ?? 0) / (width - clientWidth)) * (w - vWidth);\n    const top = ((scroller?.scrollTop ?? 0) / (height - clientHeight)) * (h - vHeight);\n\n    const minimap: React.ReactNode = React.useMemo(() => {\n        if (!showMinimap || vWidth === 0 || vHeight === 0) return undefined;\n\n        const handleMouse = (e: React.MouseEvent) => {\n            if (scroller === undefined) return;\n            const bounds = e.currentTarget.getBoundingClientRect();\n            const x = e.clientX - bounds.x - vWidth / 2;\n            const y = e.clientY - bounds.y - vHeight / 2;\n\n            const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));\n            const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));\n\n            scroller.scrollTo({\n                left: newScrollLeft,\n                top: newScrollTop,\n                behavior: e.type === \"mousemove\" ? \"auto\" : \"smooth\",\n            });\n        };\n\n        return (\n            <MinimapStyle\n                style={{ width: w, height: h }}\n                data-testid=\"minimap-container\"\n                onMouseMove={e => {\n                    if (e.buttons !== 1) return;\n                    handleMouse(e);\n                }}\n                onClick={handleMouse}>\n                <div className=\"header\" />\n                <div\n                    className=\"locationMarker\"\n                    onDragStart={e => e.preventDefault()}\n                    style={{\n                        left,\n                        top,\n                        width: vWidth,\n                        height: vHeight,\n                        borderRadius: Math.min(vWidth, vHeight * 0.2, 9),\n                    }}></div>\n            </MinimapStyle>\n        );\n    }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);\n\n    return (\n        <InfiniteScroller\n            scrollRef={scrollRef}\n            minimap={minimap}\n            className={className}\n            preventDiagonalScrolling={preventDiagonalScrolling}\n            draggable={isDraggable === true || typeof isDraggable === \"string\"}\n            scrollWidth={width + (paddingRight ?? 0)}\n            scrollHeight={height + (paddingBottom ?? 0)}\n            clientHeight={clientHeight}\n            rightElement={rightElement}\n            paddingBottom={paddingBottom}\n            paddingRight={paddingRight}\n            rightElementProps={rightElementProps}\n            update={onScrollUpdate}\n            initialSize={initialSize}\n            scrollToEnd={scrollToEnd}>\n            <DataGridDnd\n                eventTargetRef={scrollRef}\n                width={clientWidth}\n                height={clientHeight}\n                accessibilityHeight={p.accessibilityHeight}\n                canvasRef={p.canvasRef}\n                cellXOffset={p.cellXOffset}\n                cellYOffset={p.cellYOffset}\n                columns={p.columns}\n                disabledRows={p.disabledRows}\n                enableGroups={p.enableGroups}\n                fillHandle={p.fillHandle}\n                firstColAccessible={p.firstColAccessible}\n                fixedShadowX={p.fixedShadowX}\n                fixedShadowY={p.fixedShadowY}\n                freezeColumns={p.freezeColumns}\n                getCellContent={p.getCellContent}\n                getCellRenderer={p.getCellRenderer}\n                getGroupDetails={p.getGroupDetails}\n                getRowThemeOverride={p.getRowThemeOverride}\n                groupHeaderHeight={p.groupHeaderHeight}\n                headerHeight={p.headerHeight}\n                highlightRegions={p.highlightRegions}\n                imageWindowLoader={p.imageWindowLoader}\n                isFilling={p.isFilling}\n                isFocused={p.isFocused}\n                lockColumns={p.lockColumns}\n                maxColumnWidth={p.maxColumnWidth}\n                minColumnWidth={p.minColumnWidth}\n                onHeaderMenuClick={p.onHeaderMenuClick}\n                onMouseMove={p.onMouseMove}\n                prelightCells={p.prelightCells}\n                rowHeight={p.rowHeight}\n                rows={p.rows}\n                selection={p.selection}\n                theme={p.theme}\n                trailingRowType={p.trailingRowType}\n                translateX={p.translateX}\n                translateY={p.translateY}\n                verticalBorder={p.verticalBorder}\n                drawCustomCell={p.drawCustomCell}\n                drawFocusRing={p.drawFocusRing}\n                drawHeader={p.drawHeader}\n                experimental={p.experimental}\n                gridRef={p.gridRef}\n                headerIcons={p.headerIcons}\n                isDraggable={p.isDraggable}\n                onCanvasBlur={p.onCanvasBlur}\n                onCanvasFocused={p.onCanvasFocused}\n                onCellFocused={p.onCellFocused}\n                onColumnMoved={p.onColumnMoved}\n                onColumnResize={p.onColumnResize}\n                onColumnResizeEnd={p.onColumnResizeEnd}\n                onColumnResizeStart={p.onColumnResizeStart}\n                onContextMenu={p.onContextMenu}\n                onDragEnd={p.onDragEnd}\n                onDragLeave={p.onDragLeave}\n                onDragOverCell={p.onDragOverCell}\n                onDragStart={p.onDragStart}\n                onDrop={p.onDrop}\n                onItemHovered={p.onItemHovered}\n                onKeyDown={p.onKeyDown}\n                onKeyUp={p.onKeyUp}\n                onMouseDown={p.onMouseDown}\n                onMouseUp={p.onMouseUp}\n                onRowMoved={p.onRowMoved}\n                smoothScrollX={p.smoothScrollX}\n                smoothScrollY={p.smoothScrollY}\n            />\n        </InfiniteScroller>\n    );\n};\n\nexport default GridScroller;\n",".m3brspx{position:absolute;right:44px;bottom:44px;background-color:var(--gdg-bg-cell);background:linear-gradient(var(--gdg-bg-cell),var(--gdg-bg-cell-medium));border-radius:4px;z-index:1;box-shadow:0 0 0 1px var(--gdg-border-color),0 2px 5px rgba(0,0,0,0.08);overflow:hidden;}.m3brspx .header{position:absolute;left:0;top:0;width:100%;height:4px;background-color:var(--gdg-bg-header);box-shadow:0 0 0 1px var(--gdg-border-color);}.m3brspx .locationMarker{position:absolute;border:1px solid var(--gdg-accent-color);background-color:var(--gdg-accent-light);}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC50c3giXSwibmFtZXMiOlsiLm0zYnJzcHgiXSwibWFwcGluZ3MiOiJBQW9GTUEiLCJmaWxlIjoicGFja2FnZXMvY29yZS9zcmMvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgRGF0YUdyaWREbmQsIHsgRGF0YUdyaWREbmRQcm9wcyB9IGZyb20gXCIuLi9kYXRhLWdyaWQtZG5kL2RhdGEtZ3JpZC1kbmRcIjtcbmltcG9ydCB0eXBlIHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXNcIjtcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsZXIgfSBmcm9tIFwiLi9pbmZpbml0ZS1zY3JvbGxlclwiO1xuaW1wb3J0IGNsYW1wIGZyb20gXCJsb2Rhc2gvY2xhbXAuanNcIjtcblxudHlwZSBQcm9wcyA9IE9taXQ8RGF0YUdyaWREbmRQcm9wcywgXCJ3aWR0aFwiIHwgXCJoZWlnaHRcIiB8IFwiZXZlbnRUYXJnZXRSZWZcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsaW5nRGF0YUdyaWRQcm9wcyBleHRlbmRzIFByb3BzIHtcbiAgICByZWFkb25seSBjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBvblZpc2libGVSZWdpb25DaGFuZ2VkOlxuICAgICAgICB8ICgoXG4gICAgICAgICAgICAgIHJhbmdlOiBSZWN0YW5nbGUsXG4gICAgICAgICAgICAgIGNsaWVudFdpZHRoOiBudW1iZXIsXG4gICAgICAgICAgICAgIGNsaWVudEhlaWdodDogbnVtYmVyLFxuICAgICAgICAgICAgICByaWdodEVsV2lkdGg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHg6IG51bWJlcixcbiAgICAgICAgICAgICAgdHk6IG51bWJlclxuICAgICAgICAgICkgPT4gdm9pZClcbiAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBncmlkIHRvIHNjcm9sbCB0byB0aGUgZW5kIHdoZW4gZmxpcHBlZCB0byB0cnVlXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBEYXRhRWRpdG9yUmVmLnNjcm9sbFRvfSBpbnN0ZWFkXG4gICAgICogQGdyb3VwIERlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzY3JvbGxUb0VuZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBzY3JvbGxSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQgfCBudWxsPiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvdmVyc2Nyb2xsIHByb3BlcnRpZXMgYXJlIHVzZWQgdG8gYWxsb3cgdGhlIGdyaWQgdG8gc2Nyb2xsIHBhc3QgdGhlIGxvZ2ljYWwgZW5kIG9mIHRoZSBjb250ZW50IGJ5IGEgZml4ZWRcbiAgICAgKiBudW1iZXIgb2YgcGl4ZWxzLiBUaGlzIGlzIHVzZWZ1bCBwYXJ0aWN1bGFybHkgb24gdGhlIFggYXhpcyBpZiB5b3UgYWxsb3cgZm9yIHJlc2l6aW5nIGNvbHVtbnMgYXMgaXQgY2FuIG1ha2VcbiAgICAgKiByZXNpemluZyB0aGUgZmluYWwgY29sdW1uIHNpZ25pZmljYW50bHkgZWFzaWVyLlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgb3ZlcnNjcm9sbFg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAvKioge0Bpbmhlcml0RG9jIG92ZXJzY3JvbGxYfVxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IG92ZXJzY3JvbGxZOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW5pdGlhbCBzaXplIGZvciB0aGUgZ3JpZCB3aGljaCBjYW4gcHJldmVudCBhIGZsaWNrZXIgb24gbG9hZCBpZiB0aGUgaW5pdGlhbCBzaXplIGlzIGtub3duIHByaW9yIHRvXG4gICAgICogbGF5b3V0LlxuICAgICAqXG4gICAgICogQGdyb3VwIEFkdmFuY2VkXG4gICAgICovXG4gICAgcmVhZG9ubHkgaW5pdGlhbFNpemU6IHJlYWRvbmx5IFt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcl0gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gcHJldmVudCBhbnkgZGlhZ29uYWwgc2Nyb2xsaW5nLlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHByZXZlbnREaWFnb25hbFNjcm9sbGluZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIElmIGByaWdodEVsZW1lbnRQcm9wcy5zdGlja3lgIGlzIHNldCB0byB0cnVlIHRoZSByaWdodCBlbGVtZW50IHdpbGwgYmUgdmlzaWJsZSBhdCBhbGwgdGltZXMsIG90aGVyd2lzZSB0aGUgdXNlclxuICAgICAqIHdpbGwgbmVlZCB0byBzY3JvbGwgdG8gdGhlIGVuZCB0byByZXZlYWwgaXQuXG4gICAgICpcbiAgICAgKiBJZiBgcmlnaHRFbGVtZW50UHJvcHMuZmlsbGAgaXMgc2V0LCB0aGUgcmlnaHQgZWxlbWVudHMgY29udGFpbmVyIHdpbGwgZmlsbCB0byBjb25zdW1lIGFsbCByZW1haW5pbmcgc3BhY2UgKGlmXG4gICAgICogYW55KSBhdCB0aGUgZW5kIG9mIHRoZSBncmlkLiBUaGlzIGRvZXMgbm90IHBsYXkgbmljZSB3aXRoIGdyb3dpbmcgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEBncm91cCBBZHZhbmNlZFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJpZ2h0RWxlbWVudFByb3BzOlxuICAgICAgICB8IHtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgc3RpY2t5PzogYm9vbGVhbjtcbiAgICAgICAgICAgICAgcmVhZG9ubHkgZmlsbD86IGJvb2xlYW47XG4gICAgICAgICAgfVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmlnaHQgZWxlbWVudCBpcyBhIERPTSBub2RlIHdoaWNoIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCByZWdpb24uIFRoaXMgY2FuIGJlXG4gICAgICogdXNlZCB0byBjcmVhdGUgYSByaWdodCBoYW5kbGUgcGFuZWwsIG1ha2UgYSBiaWcgYWRkIGJ1dHRvbiwgb3IgZGlzcGxheSBtZXNzYWdlcy5cbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSByaWdodEVsZW1lbnQ6IFJlYWN0LlJlYWN0Tm9kZSB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHRoZSBpbnRlcmFjdGl2ZSBtaW5pbWFwLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgZmFsc2VcbiAgICAgKiBAZ3JvdXAgQWR2YW5jZWRcbiAgICAgKi9cbiAgICByZWFkb25seSBzaG93TWluaW1hcDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBjbGllbnRTaXplOiByZWFkb25seSBbbnVtYmVyLCBudW1iZXJdO1xufVxuXG5jb25zdCBNaW5pbWFwU3R5bGUgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogNDRweDtcbiAgICBib3R0b206IDQ0cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZ2RnLWJnLWNlbGwpO1xuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh2YXIoLS1nZGctYmctY2VsbCksIHZhcigtLWdkZy1iZy1jZWxsLW1lZGl1bSkpO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB6LWluZGV4OiAxO1xuICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1nZGctYm9yZGVyLWNvbG9yKSwgMCAycHggNXB4IHJnYmEoMCwgMCwgMCwgMC4wOCk7XG5cbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgLmhlYWRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiA0cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWdkZy1iZy1oZWFkZXIpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggdmFyKC0tZ2RnLWJvcmRlci1jb2xvcik7XG4gICAgfVxuXG4gICAgLmxvY2F0aW9uTWFya2VyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWdkZy1hY2NlbnQtY29sb3IpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1nZGctYWNjZW50LWxpZ2h0KTtcbiAgICB9XG5gO1xuXG5jb25zdCBHcmlkU2Nyb2xsZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFNjcm9sbGluZ0RhdGFHcmlkUHJvcHM+ID0gcCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBjb2x1bW5zLFxuICAgICAgICByb3dzLFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgICAgZ3JvdXBIZWFkZXJIZWlnaHQsXG4gICAgICAgIGVuYWJsZUdyb3VwcyxcbiAgICAgICAgZnJlZXplQ29sdW1ucyxcbiAgICAgICAgZXhwZXJpbWVudGFsLFxuICAgICAgICBjbGllbnRTaXplLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQsXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBzY3JvbGxSZWYsXG4gICAgICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZyxcbiAgICAgICAgcmlnaHRFbGVtZW50LFxuICAgICAgICByaWdodEVsZW1lbnRQcm9wcyxcbiAgICAgICAgb3ZlcnNjcm9sbFgsXG4gICAgICAgIG92ZXJzY3JvbGxZLFxuICAgICAgICBzaG93TWluaW1hcCA9IGZhbHNlLFxuICAgICAgICBpbml0aWFsU2l6ZSxcbiAgICAgICAgc21vb3RoU2Nyb2xsWCA9IGZhbHNlLFxuICAgICAgICBzbW9vdGhTY3JvbGxZID0gZmFsc2UsXG4gICAgICAgIGlzRHJhZ2dhYmxlLFxuICAgIH0gPSBwO1xuICAgIGNvbnN0IHsgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tIH0gPSBleHBlcmltZW50YWwgPz8ge307XG5cbiAgICBjb25zdCBbY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodF0gPSBjbGllbnRTaXplO1xuICAgIGNvbnN0IGxhc3QgPSBSZWFjdC51c2VSZWY8UmVjdGFuZ2xlIHwgdW5kZWZpbmVkPigpO1xuICAgIGNvbnN0IGxhc3RYID0gUmVhY3QudXNlUmVmPG51bWJlciB8IHVuZGVmaW5lZD4oKTtcbiAgICBjb25zdCBsYXN0WSA9IFJlYWN0LnVzZVJlZjxudW1iZXIgfCB1bmRlZmluZWQ+KCk7XG4gICAgY29uc3QgbGFzdFNpemUgPSBSZWFjdC51c2VSZWY8cmVhZG9ubHkgW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZD4oKTtcblxuICAgIGNvbnN0IHdpZHRoID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCByID0gTWF0aC5tYXgoMCwgb3ZlcnNjcm9sbFggPz8gMCk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgICByICs9IGMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSwgW2NvbHVtbnMsIG92ZXJzY3JvbGxYXSk7XG5cbiAgICBsZXQgaGVpZ2h0ID0gZW5hYmxlR3JvdXBzID8gaGVhZGVySGVpZ2h0ICsgZ3JvdXBIZWFkZXJIZWlnaHQgOiBoZWFkZXJIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHJvd3MgKiByb3dIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICAgIGhlaWdodCArPSByb3dIZWlnaHQocik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJzY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ICs9IG92ZXJzY3JvbGxZO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RBcmdzID0gUmVhY3QudXNlUmVmPFJlY3RhbmdsZSAmIHsgcGFkZGluZ1JpZ2h0OiBudW1iZXIgfT4oKTtcblxuICAgIGNvbnN0IHByb2Nlc3NBcmdzID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAobGFzdEFyZ3MuY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7IC4uLmxhc3RBcmdzLmN1cnJlbnQgfTtcblxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB0eCA9IGFyZ3MueCA8IDAgPyAtYXJncy54IDogMDtcbiAgICAgICAgbGV0IGNlbGxSaWdodCA9IDA7XG4gICAgICAgIGxldCBjZWxsWCA9IDA7XG5cbiAgICAgICAgYXJncy54ID0gYXJncy54IDwgMCA/IDAgOiBhcmdzLng7XG5cbiAgICAgICAgbGV0IHN0aWNreUNvbFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmVlemVDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgIHN0aWNreUNvbFdpZHRoICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sdW1ucykge1xuICAgICAgICAgICAgY29uc3QgY3ggPSB4IC0gc3RpY2t5Q29sV2lkdGg7XG4gICAgICAgICAgICBpZiAoYXJncy54ID49IGN4ICsgYy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnggPiBjeCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSBjeCAtIGFyZ3MueDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjZWxsWCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsUmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncy54ICsgYXJncy53aWR0aCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0eSA9IDA7XG4gICAgICAgIGxldCBjZWxsWSA9IDA7XG4gICAgICAgIGxldCBjZWxsQm90dG9tID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChzbW9vdGhTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmZsb29yKGFyZ3MueSAvIHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgdHkgPSBjZWxsWSAqIHJvd0hlaWdodCAtIGFyZ3MueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmNlaWwoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxCb3R0b20gPSBNYXRoLmNlaWwoYXJncy5oZWlnaHQgLyByb3dIZWlnaHQpICsgY2VsbFk7XG4gICAgICAgICAgICBpZiAodHkgPCAwKSBjZWxsQm90dG9tKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJoID0gcm93SGVpZ2h0KHJvdyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3kgPSB5ICsgKHNtb290aFNjcm9sbFkgPyAwIDogcmggLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy55ID49IHkgKyByaCkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdzLnkgPiBjeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHkgKz0gY3kgLSBhcmdzLnk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsWSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MueSArIGFyZ3MuaGVpZ2h0ID4gcmggLyAyICsgeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVjdDogUmVjdGFuZ2xlID0ge1xuICAgICAgICAgICAgeDogY2VsbFgsXG4gICAgICAgICAgICB5OiBjZWxsWSxcbiAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgIGhlaWdodDogY2VsbEJvdHRvbSAtIGNlbGxZLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9sZFJlY3QgPSBsYXN0LmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2xkUmVjdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBvbGRSZWN0LnkgIT09IHJlY3QueSB8fFxuICAgICAgICAgICAgb2xkUmVjdC54ICE9PSByZWN0LnggfHxcbiAgICAgICAgICAgIG9sZFJlY3QuaGVpZ2h0ICE9PSByZWN0LmhlaWdodCB8fFxuICAgICAgICAgICAgb2xkUmVjdC53aWR0aCAhPT0gcmVjdC53aWR0aCB8fFxuICAgICAgICAgICAgbGFzdFguY3VycmVudCAhPT0gdHggfHxcbiAgICAgICAgICAgIGxhc3RZLmN1cnJlbnQgIT09IHR5IHx8XG4gICAgICAgICAgICBhcmdzLndpZHRoICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMF0gfHxcbiAgICAgICAgICAgIGFyZ3MuaGVpZ2h0ICE9PSBsYXN0U2l6ZS5jdXJyZW50Py5bMV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPy4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4OiBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjZWxsQm90dG9tIC0gY2VsbFksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcmdzLndpZHRoLFxuICAgICAgICAgICAgICAgIGFyZ3MuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFyZ3MucGFkZGluZ1JpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgdHgsXG4gICAgICAgICAgICAgICAgdHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsYXN0LmN1cnJlbnQgPSByZWN0O1xuICAgICAgICAgICAgbGFzdFguY3VycmVudCA9IHR4O1xuICAgICAgICAgICAgbGFzdFkuY3VycmVudCA9IHR5O1xuICAgICAgICAgICAgbGFzdFNpemUuY3VycmVudCA9IFthcmdzLndpZHRoLCBhcmdzLmhlaWdodF07XG4gICAgICAgIH1cbiAgICB9LCBbY29sdW1ucywgcm93SGVpZ2h0LCByb3dzLCBvblZpc2libGVSZWdpb25DaGFuZ2VkLCBmcmVlemVDb2x1bW5zLCBzbW9vdGhTY3JvbGxYLCBzbW9vdGhTY3JvbGxZXSk7XG5cbiAgICBjb25zdCBvblNjcm9sbFVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgICAoYXJnczogUmVjdGFuZ2xlICYgeyBwYWRkaW5nUmlnaHQ6IG51bWJlciB9KSA9PiB7XG4gICAgICAgICAgICBsYXN0QXJncy5jdXJyZW50ID0gYXJncztcbiAgICAgICAgICAgIHByb2Nlc3NBcmdzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFtwcm9jZXNzQXJnc11cbiAgICApO1xuXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvY2Vzc0FyZ3MoKTtcbiAgICB9LCBbcHJvY2Vzc0FyZ3NdKTtcblxuICAgIGNvbnN0IHNjcm9sbGVyID0gc2Nyb2xsUmVmPy5jdXJyZW50ID8/IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhc3BlY3QgPSBjbGFtcCh3aWR0aCAvIGhlaWdodCwgMiAvIDMsIDEuNSk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IDIwMDtcbiAgICBjb25zdCB3ID0gYXNwZWN0ID4gMSA/IG1heFNpemUgOiBNYXRoLmNlaWwobWF4U2l6ZSAqIGFzcGVjdCk7XG4gICAgY29uc3QgaCA9IGFzcGVjdCA+IDEgPyBNYXRoLmNlaWwobWF4U2l6ZSAvIGFzcGVjdCkgOiBtYXhTaXplO1xuICAgIGNvbnN0IGhSYXRpbyA9IHcgLyB3aWR0aDtcbiAgICBjb25zdCB2UmF0aW8gPSBoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHZXaWR0aCA9IE1hdGgubWluKGNsaWVudFdpZHRoICogTWF0aC5tYXgoaFJhdGlvLCAwLjAxKSwgdyk7XG4gICAgY29uc3QgdkhlaWdodCA9IE1hdGgubWluKGNsaWVudEhlaWdodCAqIE1hdGgubWF4KHZSYXRpbywgMC4wMSksIGgpO1xuICAgIGNvbnN0IGxlZnQgPSAoKHNjcm9sbGVyPy5zY3JvbGxMZWZ0ID8/IDApIC8gKHdpZHRoIC0gY2xpZW50V2lkdGgpKSAqICh3IC0gdldpZHRoKTtcbiAgICBjb25zdCB0b3AgPSAoKHNjcm9sbGVyPy5zY3JvbGxUb3AgPz8gMCkgLyAoaGVpZ2h0IC0gY2xpZW50SGVpZ2h0KSkgKiAoaCAtIHZIZWlnaHQpO1xuXG4gICAgY29uc3QgbWluaW1hcDogUmVhY3QuUmVhY3ROb2RlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvd01pbmltYXAgfHwgdldpZHRoID09PSAwIHx8IHZIZWlnaHQgPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlTW91c2UgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSBib3VuZHMueCAtIHZXaWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gYm91bmRzLnkgLSB2SGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsTGVmdCA9ICh3aWR0aCAtIHNjcm9sbGVyLmNsaWVudFdpZHRoKSAqICh4IC8gKHcgLSB2V2lkdGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbFRvcCA9IChoZWlnaHQgLSBzY3JvbGxlci5jbGllbnRIZWlnaHQpICogKHkgLyAoaCAtIHZIZWlnaHQpKTtcblxuICAgICAgICAgICAgc2Nyb2xsZXIuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG5ld1Njcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBuZXdTY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IGUudHlwZSA9PT0gXCJtb3VzZW1vdmVcIiA/IFwiYXV0b1wiIDogXCJzbW9vdGhcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8TWluaW1hcFN0eWxlXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IHcsIGhlaWdodDogaCB9fVxuICAgICAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwibWluaW1hcC1jb250YWluZXJcIlxuICAgICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9ucyAhPT0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZShlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1vdXNlfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiIC8+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsb2NhdGlvbk1hcmtlclwiXG4gICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtlID0+IGUucHJldmVudERlZmF1bHQoKX1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBNYXRoLm1pbih2V2lkdGgsIHZIZWlnaHQgKiAwLjIsIDkpLFxuICAgICAgICAgICAgICAgICAgICB9fT48L2Rpdj5cbiAgICAgICAgICAgIDwvTWluaW1hcFN0eWxlPlxuICAgICAgICApO1xuICAgIH0sIFtoLCBoZWlnaHQsIGxlZnQsIHNjcm9sbGVyLCBzaG93TWluaW1hcCwgdG9wLCB2SGVpZ2h0LCB2V2lkdGgsIHcsIHdpZHRoXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8SW5maW5pdGVTY3JvbGxlclxuICAgICAgICAgICAgc2Nyb2xsUmVmPXtzY3JvbGxSZWZ9XG4gICAgICAgICAgICBtaW5pbWFwPXttaW5pbWFwfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgICAgICBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc9e3ByZXZlbnREaWFnb25hbFNjcm9sbGluZ31cbiAgICAgICAgICAgIGRyYWdnYWJsZT17aXNEcmFnZ2FibGUgPT09IHRydWUgfHwgdHlwZW9mIGlzRHJhZ2dhYmxlID09PSBcInN0cmluZ1wifVxuICAgICAgICAgICAgc2Nyb2xsV2lkdGg9e3dpZHRoICsgKHBhZGRpbmdSaWdodCA/PyAwKX1cbiAgICAgICAgICAgIHNjcm9sbEhlaWdodD17aGVpZ2h0ICsgKHBhZGRpbmdCb3R0b20gPz8gMCl9XG4gICAgICAgICAgICBjbGllbnRIZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgIHJpZ2h0RWxlbWVudD17cmlnaHRFbGVtZW50fVxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbT17cGFkZGluZ0JvdHRvbX1cbiAgICAgICAgICAgIHBhZGRpbmdSaWdodD17cGFkZGluZ1JpZ2h0fVxuICAgICAgICAgICAgcmlnaHRFbGVtZW50UHJvcHM9e3JpZ2h0RWxlbWVudFByb3BzfVxuICAgICAgICAgICAgdXBkYXRlPXtvblNjcm9sbFVwZGF0ZX1cbiAgICAgICAgICAgIGluaXRpYWxTaXplPXtpbml0aWFsU2l6ZX1cbiAgICAgICAgICAgIHNjcm9sbFRvRW5kPXtzY3JvbGxUb0VuZH0+XG4gICAgICAgICAgICA8RGF0YUdyaWREbmRcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldFJlZj17c2Nyb2xsUmVmfVxuICAgICAgICAgICAgICAgIHdpZHRoPXtjbGllbnRXaWR0aH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e2NsaWVudEhlaWdodH1cbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5SGVpZ2h0PXtwLmFjY2Vzc2liaWxpdHlIZWlnaHR9XG4gICAgICAgICAgICAgICAgY2FudmFzUmVmPXtwLmNhbnZhc1JlZn1cbiAgICAgICAgICAgICAgICBjZWxsWE9mZnNldD17cC5jZWxsWE9mZnNldH1cbiAgICAgICAgICAgICAgICBjZWxsWU9mZnNldD17cC5jZWxsWU9mZnNldH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zPXtwLmNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRSb3dzPXtwLmRpc2FibGVkUm93c31cbiAgICAgICAgICAgICAgICBlbmFibGVHcm91cHM9e3AuZW5hYmxlR3JvdXBzfVxuICAgICAgICAgICAgICAgIGZpbGxIYW5kbGU9e3AuZmlsbEhhbmRsZX1cbiAgICAgICAgICAgICAgICBmaXJzdENvbEFjY2Vzc2libGU9e3AuZmlyc3RDb2xBY2Nlc3NpYmxlfVxuICAgICAgICAgICAgICAgIGZpeGVkU2hhZG93WD17cC5maXhlZFNoYWRvd1h9XG4gICAgICAgICAgICAgICAgZml4ZWRTaGFkb3dZPXtwLmZpeGVkU2hhZG93WX1cbiAgICAgICAgICAgICAgICBmcmVlemVDb2x1bW5zPXtwLmZyZWV6ZUNvbHVtbnN9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbENvbnRlbnQ9e3AuZ2V0Q2VsbENvbnRlbnR9XG4gICAgICAgICAgICAgICAgZ2V0Q2VsbFJlbmRlcmVyPXtwLmdldENlbGxSZW5kZXJlcn1cbiAgICAgICAgICAgICAgICBnZXRHcm91cERldGFpbHM9e3AuZ2V0R3JvdXBEZXRhaWxzfVxuICAgICAgICAgICAgICAgIGdldFJvd1RoZW1lT3ZlcnJpZGU9e3AuZ2V0Um93VGhlbWVPdmVycmlkZX1cbiAgICAgICAgICAgICAgICBncm91cEhlYWRlckhlaWdodD17cC5ncm91cEhlYWRlckhlaWdodH1cbiAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQ9e3AuaGVhZGVySGVpZ2h0fVxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnM9e3AuaGlnaGxpZ2h0UmVnaW9uc31cbiAgICAgICAgICAgICAgICBpbWFnZVdpbmRvd0xvYWRlcj17cC5pbWFnZVdpbmRvd0xvYWRlcn1cbiAgICAgICAgICAgICAgICBpc0ZpbGxpbmc9e3AuaXNGaWxsaW5nfVxuICAgICAgICAgICAgICAgIGlzRm9jdXNlZD17cC5pc0ZvY3VzZWR9XG4gICAgICAgICAgICAgICAgbG9ja0NvbHVtbnM9e3AubG9ja0NvbHVtbnN9XG4gICAgICAgICAgICAgICAgbWF4Q29sdW1uV2lkdGg9e3AubWF4Q29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgbWluQ29sdW1uV2lkdGg9e3AubWluQ29sdW1uV2lkdGh9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s9e3Aub25IZWFkZXJNZW51Q2xpY2t9XG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e3Aub25Nb3VzZU1vdmV9XG4gICAgICAgICAgICAgICAgcHJlbGlnaHRDZWxscz17cC5wcmVsaWdodENlbGxzfVxuICAgICAgICAgICAgICAgIHJvd0hlaWdodD17cC5yb3dIZWlnaHR9XG4gICAgICAgICAgICAgICAgcm93cz17cC5yb3dzfVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbj17cC5zZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgdGhlbWU9e3AudGhlbWV9XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdSb3dUeXBlPXtwLnRyYWlsaW5nUm93VHlwZX1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYPXtwLnRyYW5zbGF0ZVh9XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWT17cC50cmFuc2xhdGVZfVxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyPXtwLnZlcnRpY2FsQm9yZGVyfVxuICAgICAgICAgICAgICAgIGRyYXdDdXN0b21DZWxsPXtwLmRyYXdDdXN0b21DZWxsfVxuICAgICAgICAgICAgICAgIGRyYXdGb2N1c1Jpbmc9e3AuZHJhd0ZvY3VzUmluZ31cbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyPXtwLmRyYXdIZWFkZXJ9XG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsPXtwLmV4cGVyaW1lbnRhbH1cbiAgICAgICAgICAgICAgICBncmlkUmVmPXtwLmdyaWRSZWZ9XG4gICAgICAgICAgICAgICAgaGVhZGVySWNvbnM9e3AuaGVhZGVySWNvbnN9XG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU9e3AuaXNEcmFnZ2FibGV9XG4gICAgICAgICAgICAgICAgb25DYW52YXNCbHVyPXtwLm9uQ2FudmFzQmx1cn1cbiAgICAgICAgICAgICAgICBvbkNhbnZhc0ZvY3VzZWQ9e3Aub25DYW52YXNGb2N1c2VkfVxuICAgICAgICAgICAgICAgIG9uQ2VsbEZvY3VzZWQ9e3Aub25DZWxsRm9jdXNlZH1cbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPXtwLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemU9e3Aub25Db2x1bW5SZXNpemV9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVFbmQ9e3Aub25Db2x1bW5SZXNpemVFbmR9XG4gICAgICAgICAgICAgICAgb25Db2x1bW5SZXNpemVTdGFydD17cC5vbkNvbHVtblJlc2l6ZVN0YXJ0fVxuICAgICAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9e3Aub25Db250ZXh0TWVudX1cbiAgICAgICAgICAgICAgICBvbkRyYWdFbmQ9e3Aub25EcmFnRW5kfVxuICAgICAgICAgICAgICAgIG9uRHJhZ0xlYXZlPXtwLm9uRHJhZ0xlYXZlfVxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsPXtwLm9uRHJhZ092ZXJDZWxsfVxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXtwLm9uRHJhZ1N0YXJ0fVxuICAgICAgICAgICAgICAgIG9uRHJvcD17cC5vbkRyb3B9XG4gICAgICAgICAgICAgICAgb25JdGVtSG92ZXJlZD17cC5vbkl0ZW1Ib3ZlcmVkfVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bj17cC5vbktleURvd259XG4gICAgICAgICAgICAgICAgb25LZXlVcD17cC5vbktleVVwfVxuICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXtwLm9uTW91c2VEb3dufVxuICAgICAgICAgICAgICAgIG9uTW91c2VVcD17cC5vbk1vdXNlVXB9XG4gICAgICAgICAgICAgICAgb25Sb3dNb3ZlZD17cC5vblJvd01vdmVkfVxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbFg9e3Auc21vb3RoU2Nyb2xsWH1cbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGxZPXtwLnNtb290aFNjcm9sbFl9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0luZmluaXRlU2Nyb2xsZXI+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdyaWRTY3JvbGxlcjtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".bheiboo{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100vh;width:100vw;position:relative;}.bheiboo > .content{display:block;width:var(--bheiboo-0);height:var(--bheiboo-1);-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;position:relative;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:border-box;}.bheiboo > .content *,.bheiboo > .content *::before,.bheiboo > .content *::after{box-sizing:inherit;}\n.s15ez7jv{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s15ez7jv *,.s15ez7jv *::before,.s15ez7jv *::after{box-sizing:inherit;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5iaGVpYm9vIiwiLnMxNWV6N2p2Il0sIm1hcHBpbmdzIjoiQUFhTUE7QUFnQ0FDIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgU3RvcnlDb250ZXh0IH0gZnJvbSBcIkBzdG9yeWJvb2svYWRkb25zXCI7XG5pbXBvcnQgXCJyZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9zdHlsZXMvY2Fyb3VzZWwubWluLmNzc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgdXNlTW9yZVRvcFBhZGRpbmc/OiBib29sZWFuO1xuICAgIGZpZ21hRG9jPzogc3RyaW5nO1xuICAgIGNvbnRleHQ/OiBTdG9yeUNvbnRleHQ7XG59XG5cbmNvbnN0IEJ1aWxkZXJXcmFwcGVyID0gc3R5bGVkLmRpdjxQaWNrPFByb3BzLCBcIndpZHRoXCIgfCBcImhlaWdodFwiPj5gXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmID4gLmNvbnRlbnQge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcblxuICAgICAgICB3aWR0aDogJHtwID0+IHAud2lkdGh9cHg7XG4gICAgICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG5cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblxuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcblxuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgICAgICosXG4gICAgICAgICo6OmJlZm9yZSxcbiAgICAgICAgKjo6YWZ0ZXIge1xuICAgICAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgKixcbiAgICAqOjpiZWZvcmUsXG4gICAgKjo6YWZ0ZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjbGFzcyBCdWlsZGVyVGhlbWVXcmFwcGVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4+IHtcbiAgICBwdWJsaWMgcmVuZGVyKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxCdWlsZGVyV3JhcHBlciB7Li4ucmVzdH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudFwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L0J1aWxkZXJXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJwb3J0YWxcIiAvPlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e3AuY2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/core/src/stories/packages/core/src/stories/story-utils.tsx","webpack://./packages/core/src/stories/story-utils.tsx"],"names":[".bheiboo",".s15ez7jv"],"mappings":"AAaMA,SAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,YAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,oBAAAA,aAAAA,CAAAA,sBAAAA,CAAAA,uBAAAA,CAAAA,yBAAAA,CAAAA,0BAAAA,CAAAA,iBAAAA,CAAAA,iBAAAA,CAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,yCAAAA,CAAAA,wBAAAA,CAAAA,qBAAAA,CAAAA,oBAAAA,CAAAA,gBAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,iFAAAA,kBAAAA,CAAAA;AAgCAC,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AC3CN,uyFAAuyF","sourcesContent":["import * as React from \"react\";\nimport { styled } from \"@linaria/react\";\nimport type { StoryContext } from \"@storybook/addons\";\nimport \"react-responsive-carousel/lib/styles/carousel.min.css\";\n\ninterface Props {\n    width: number;\n    height: number;\n    useMoreTopPadding?: boolean;\n    figmaDoc?: string;\n    context?: StoryContext;\n}\n\nconst BuilderWrapper = styled.div<Pick<Props, \"width\" | \"height\">>`\n    display: flex;\n    height: 100vh;\n    width: 100vw;\n    position: relative;\n\n    & > .content {\n        display: block;\n\n        width: ${p => p.width}px;\n        height: ${p => p.height}px;\n        align-self: center;\n\n        position: relative;\n\n        text-rendering: optimizeLegibility;\n        -webkit-font-smoothing: antialiased;\n\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n\n        user-select: none;\n\n        box-sizing: border-box;\n\n        *,\n        *::before,\n        *::after {\n            box-sizing: inherit;\n        }\n    }\n`;\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nexport class BuilderThemeWrapper extends React.PureComponent<React.PropsWithChildren<Props>> {\n    public render(): React.ReactNode {\n        const { context, children, ...rest } = this.props;\n        return (\n            <>\n                <BuilderWrapper {...rest}>\n                    <div className=\"content\">{children}</div>\n                </BuilderWrapper>\n                <div id=\"portal\" />\n            </>\n        );\n    }\n}\n\nexport const SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n",".bheiboo{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:100vh;width:100vw;position:relative;}.bheiboo > .content{display:block;width:var(--bheiboo-0);height:var(--bheiboo-1);-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;position:relative;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:border-box;}.bheiboo > .content *,.bheiboo > .content *::before,.bheiboo > .content *::after{box-sizing:inherit;}\n.s15ez7jv{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s15ez7jv *,.s15ez7jv *::before,.s15ez7jv *::after{box-sizing:inherit;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Il0sIm5hbWVzIjpbIi5iaGVpYm9vIiwiLnMxNWV6N2p2Il0sIm1hcHBpbmdzIjoiQUFhTUE7QUFnQ0FDIiwiZmlsZSI6InBhY2thZ2VzL2NvcmUvc3JjL3N0b3JpZXMvc3RvcnktdXRpbHMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgU3RvcnlDb250ZXh0IH0gZnJvbSBcIkBzdG9yeWJvb2svYWRkb25zXCI7XG5pbXBvcnQgXCJyZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9zdHlsZXMvY2Fyb3VzZWwubWluLmNzc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgdXNlTW9yZVRvcFBhZGRpbmc/OiBib29sZWFuO1xuICAgIGZpZ21hRG9jPzogc3RyaW5nO1xuICAgIGNvbnRleHQ/OiBTdG9yeUNvbnRleHQ7XG59XG5cbmNvbnN0IEJ1aWxkZXJXcmFwcGVyID0gc3R5bGVkLmRpdjxQaWNrPFByb3BzLCBcIndpZHRoXCIgfCBcImhlaWdodFwiPj5gXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmID4gLmNvbnRlbnQge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcblxuICAgICAgICB3aWR0aDogJHtwID0+IHAud2lkdGh9cHg7XG4gICAgICAgIGhlaWdodDogJHtwID0+IHAuaGVpZ2h0fXB4O1xuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG5cbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblxuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcblxuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgICAgICosXG4gICAgICAgICo6OmJlZm9yZSxcbiAgICAgICAgKjo6YWZ0ZXIge1xuICAgICAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5cbmNvbnN0IFNpbXBsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG5cbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgKixcbiAgICAqOjpiZWZvcmUsXG4gICAgKjo6YWZ0ZXIge1xuICAgICAgICBib3gtc2l6aW5nOiBpbmhlcml0O1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjbGFzcyBCdWlsZGVyVGhlbWVXcmFwcGVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxQcm9wcz4+IHtcbiAgICBwdWJsaWMgcmVuZGVyKCk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgY2hpbGRyZW4sIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxCdWlsZGVyV3JhcHBlciB7Li4ucmVzdH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGVudFwiPntjaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgICAgICAgICA8L0J1aWxkZXJXcmFwcGVyPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJwb3J0YWxcIiAvPlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2ltcGxlVGhlbWVXcmFwcGVyOiBSZWFjdC5GQyA9IHAgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxTaW1wbGVXcmFwcGVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e3AuY2hpbGRyZW59PC9kaXY+XG4gICAgICAgIDwvU2ltcGxlV3JhcHBlcj5cbiAgICApO1xufTtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/use-data-source.stories.tsx":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".s1qcunhi{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1qcunhi *,.s1qcunhi *::before,.s1qcunhi *::after{box-sizing:inherit;}\n.bd6h1gz{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.bd6h1gz > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.bd6h1gz .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.bd6h1gz .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d8qm2x5{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXFjdW5oaSIsIi5iZDZoMWd6IiwiLmQ4cW0yeDUiXSwibWFwcGluZ3MiOiJBQVNNQTtBQWlDQUM7QUFvRUFDIiwiZmlsZSI6InBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQsIEdyaWRDb2x1bW4sIFRoZW1lIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyB1c2VDb2xsYXBzaW5nR3JvdXBzLCB1c2VDb2x1bW5Tb3J0LCB1c2VNb3ZlYWJsZUNvbHVtbnMgfSBmcm9tIFwiLlwiO1xuXG5mYWtlci5zZWVkKDEzMzcpO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvU291cmNlXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxuICAgICAgICAgICAge2Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXItY2xpcFwiIHJlZj17cmVmfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XG4gICAgKTtcbn07XG5cbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcbmA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcbiAgICBhY2NlbnRDb2xvcjogXCIjNEY1REZGXCIsXG4gICAgYWNjZW50Rmc6IFwiI0ZGRkZGRlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoNjIsIDExNiwgMjUzLCAwLjEpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjMzEzMTM5XCIsXG4gICAgdGV4dE1lZGl1bTogXCIjNzM3MzgzXCIsXG4gICAgdGV4dExpZ2h0OiBcIiNCMkIyQzBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiMzMTMxMzlcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjNzM3MzgzXCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiNGRkZGRkZcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0R3JvdXBIZWFkZXI6IFwiIzMxMzEzOUJCXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnQ2VsbDogXCIjRkZGRkZGXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNGQUZBRkJcIixcbiAgICBiZ0hlYWRlcjogXCIjRjdGN0Y4XCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjRTlFOUVCXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNFRkVGRjFcIixcblxuICAgIGJnQnViYmxlOiBcIiNFREVERjNcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiNmZmY5ZTNcIixcblxuICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMTE1LCAxMTYsIDEzMSwgMC4xNilcIixcbiAgICBob3Jpem9udGFsQm9yZGVyQ29sb3I6IFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVwiLFxuICAgIGRyaWxsZG93bkJvcmRlcjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cbiAgICBsaW5rQ29sb3I6IFwiIzRGNURGRlwiLFxuXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxuICAgIGNlbGxWZXJ0aWNhbFBhZGRpbmc6IDMsXG5cbiAgICBoZWFkZXJGb250U3R5bGU6IFwiNjAwIDEzcHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBlZGl0b3JGb250U2l6ZTogXCIxM3B4XCIsXG4gICAgbGluZUhlaWdodDogMS40LFxuICAgIGZvbnRGYW1pbHk6XG4gICAgICAgIFwiSW50ZXIsIFJvYm90bywgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBhdmVuaXIgbmV4dCwgYXZlbmlyLCBzZWdvZSB1aSwgaGVsdmV0aWNhIG5ldWUsIGhlbHZldGljYSwgVWJ1bnR1LCBub3RvLCBhcmlhbCwgc2Fucy1zZXJpZlwiLFxufTtcblxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQVwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAxXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkJcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogXCJDXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiRFwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAyXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkVcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMlwiLFxuICAgIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgVXNlRGF0YVNvdXJjZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcblxuICAgIGNvbnN0IHJvd3MgPSAxMDBfMDAwO1xuXG4gICAgY29uc3QgbW92ZUFyZ3MgPSB1c2VNb3ZlYWJsZUNvbHVtbnMoe1xuICAgICAgICBjb2x1bW5zOiBjb2xzLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2wgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBgJHtyb3d9YCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2NvbH0sJHtyb3d9YDtcbiAgICAgICAgICAgIGlmIChjYWNoZS5jdXJyZW50W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcIiBcIiArIGZha2VyLm5hbWUubGFzdE5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbXSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBbc29ydCwgc2V0U29ydF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KCk7XG5cbiAgICBjb25zdCBzb3J0QXJncyA9IHVzZUNvbHVtblNvcnQoe1xuICAgICAgICBjb2x1bW5zOiBtb3ZlQXJncy5jb2x1bW5zLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHNvcnQ6XG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZGVzY1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic21hcnRcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb2xsYXBzZUFyZ3MgPSB1c2VDb2xsYXBzaW5nR3JvdXBzKHtcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcbiAgICAgICAgdGhlbWU6IHRlc3RUaGVtZSxcbiAgICAgICAgZnJlZXplQ29sdW1uczogMCxcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRTb3J0KGluZGV4KTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlciB0aXRsZT1cIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1wiIGRlc2NyaXB0aW9uPXs8RGVzY3JpcHRpb24+Rml4bWUuPC9EZXNjcmlwdGlvbj59PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5tb3ZlQXJnc31cbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XG4gICAgICAgICAgICAgICAgey4uLmNvbGxhcHNlQXJnc31cbiAgICAgICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJDbGlja2VkPXtvbkhlYWRlckNsaWNrfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcbiJdfQ==*/", "",{"version":3,"sources":["webpack://./packages/source/src/packages/source/src/use-data-source.stories.tsx","webpack://./packages/source/src/use-data-source.stories.tsx"],"names":[".s1qcunhi",".bd6h1gz",".d8qm2x5"],"mappings":"AASMA,UAAAA,iCAAAA,CAAAA,kCAAAA,CAAAA,qBAAAA,CAAAA,CAAAA,mDAAAA,kBAAAA,CAAAA;AAiCAC,SAAAA,wBAAAA,CAAAA,iDAAAA,CAAAA,WAAAA,CAAAA,iBAAAA,CAAAA,mBAAAA,CAAAA,oBAAAA,CAAAA,mBAAAA,CAAAA,YAAAA,CAAAA,6BAAAA,CAAAA,yBAAAA,CAAAA,qBAAAA,CAAAA,YAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,cAAAA,cAAAA,CAAAA,eAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,gBAAAA,kBAAAA,CAAAA,mBAAAA,CAAAA,mBAAAA,CAAAA,WAAAA,CAAAA,sBAAAA,CAAAA,kBAAAA,CAAAA,iFAAAA,CAAAA,CAAAA,4BAAAA,kBAAAA,CAAAA,eAAAA,CAAAA,+BAAAA,CAAAA,2BAAAA,CAAAA,uBAAAA,CAAAA,WAAAA,CAAAA;AAoEAC,SAAAA,cAAAA,CAAAA,qBAAAA,CAAAA,mBAAAA,CAAAA,aAAAA,CAAAA,iBAAAA,CAAAA;AC3GN,u5SAAu5S","sourcesContent":["import { styled } from \"@linaria/react\";\nimport * as React from \"react\";\nimport { useResizeDetector } from \"react-resize-detector\";\nimport { DataEditor, DataEditorProps, GridCellKind, GridColumn, Theme } from \"@glideapps/glide-data-grid\";\nimport faker from \"faker\";\nimport { useCollapsingGroups, useColumnSort, useMoveableColumns } from \".\";\n\nfaker.seed(1337);\n\nconst SimpleWrapper = styled.div`\n    text-rendering: optimizeLegibility;\n    -webkit-font-smoothing: antialiased;\n\n    box-sizing: border-box;\n\n    *,\n    *::before,\n    *::after {\n        box-sizing: inherit;\n    }\n`;\n\nconst SimpleThemeWrapper: React.FC = p => {\n    return (\n        <SimpleWrapper>\n            <div className=\"content\">{p.children}</div>\n        </SimpleWrapper>\n    );\n};\n\nexport default {\n    title: \"Extra Packages/Source\",\n\n    decorators: [\n        (Story: React.ComponentType) => (\n            <SimpleThemeWrapper>\n                <Story />\n            </SimpleThemeWrapper>\n        ),\n    ],\n};\n\nconst BeautifulStyle = styled.div`\n    background-color: #2790b9;\n    background: linear-gradient(90deg, #2790b9, #2070a9);\n    color: white;\n\n    padding: 32px 48px;\n\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n\n    font-family: sans-serif;\n\n    & > h1 {\n        font-size: 50px;\n        font-weight: 600;\n        flex-shrink: 0;\n        margin: 0 0 12px 0;\n    }\n\n    .sizer {\n        flex-grow: 1;\n\n        background-color: white;\n\n        border-radius: 12px;\n        box-shadow: rgba(9, 30, 66, 0.25) 0px 4px 8px -2px, rgba(9, 30, 66, 0.08) 0px 0px 0px 1px;\n\n        .sizer-clip {\n            border-radius: 12px;\n            overflow: hidden;\n            transform: translateZ(0);\n\n            height: 100%;\n        }\n    }\n`;\n\ninterface BeautifulProps {\n    title: string;\n    description?: React.ReactNode;\n}\n\nconst BeautifulWrapper: React.FC<BeautifulProps> = p => {\n    const { title, children, description } = p;\n\n    const { ref, width, height } = useResizeDetector();\n\n    return (\n        <BeautifulStyle>\n            <h1>{title}</h1>\n            {description}\n            <div className=\"sizer\">\n                <div className=\"sizer-clip\" ref={ref}>\n                    <div\n                        style={{\n                            position: \"relative\",\n                            width: width ?? 100,\n                            height: height ?? 100,\n                        }}>\n                        {children}\n                    </div>\n                </div>\n            </div>\n        </BeautifulStyle>\n    );\n};\n\nconst Description = styled.p`\n    font-size: 18px;\n    flex-shrink: 0;\n    margin: 0 0 20px 0;\n`;\n\nconst defaultProps: Partial<DataEditorProps> = {\n    smoothScrollX: true,\n    smoothScrollY: true,\n    isDraggable: false,\n    rowMarkers: \"none\",\n    width: \"100%\",\n};\n\nconst testTheme: Theme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n\n    bgSearchResult: \"#fff9e3\",\n\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    horizontalBorderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n\n    linkColor: \"#4F5DFF\",\n\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4,\n    fontFamily:\n        \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n};\n\nconst cols: GridColumn[] = [\n    {\n        title: \"A\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"B\",\n        width: 200,\n        group: \"Group 1\",\n    },\n    {\n        title: \"C\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"D\",\n        width: 200,\n        group: \"Group 2\",\n    },\n    {\n        title: \"E\",\n        width: 200,\n        group: \"Group 2\",\n    },\n];\n\nexport const UseDataSource: React.VFC = () => {\n    const cache = React.useRef<Record<string, string>>({});\n\n    const rows = 100_000;\n\n    const moveArgs = useMoveableColumns({\n        columns: cols,\n        getCellContent: React.useCallback(([col, row]) => {\n            if (col === 0) {\n                return {\n                    kind: GridCellKind.Text,\n                    allowOverlay: true,\n                    data: `${row}`,\n                    displayData: `${row}`,\n                };\n            }\n\n            const key = `${col},${row}`;\n            if (cache.current[key] === undefined) {\n                cache.current[key] = faker.name.firstName() + \" \" + faker.name.lastName();\n            }\n            const d = cache.current[key];\n\n            return {\n                kind: GridCellKind.Text,\n                allowOverlay: true,\n                data: d,\n                displayData: d,\n            };\n        }, []),\n    });\n\n    const [sort, setSort] = React.useState<number>();\n\n    const sortArgs = useColumnSort({\n        columns: moveArgs.columns,\n        getCellContent: moveArgs.getCellContent,\n        rows,\n        sort:\n            sort === undefined\n                ? undefined\n                : {\n                      column: moveArgs.columns[sort],\n                      direction: \"desc\",\n                      mode: \"smart\",\n                  },\n    });\n\n    const collapseArgs = useCollapsingGroups({\n        columns: moveArgs.columns,\n        theme: testTheme,\n        freezeColumns: 0,\n    });\n\n    const onHeaderClick = React.useCallback((index: number) => {\n        setSort(index);\n    }, []);\n\n    return (\n        <BeautifulWrapper title=\"Custom source extensions\" description={<Description>Fixme.</Description>}>\n            <DataEditor\n                {...defaultProps}\n                {...moveArgs}\n                {...sortArgs}\n                {...collapseArgs}\n                rows={rows}\n                onColumnMoved={moveArgs.onColumnMoved}\n                onHeaderClicked={onHeaderClick}\n            />\n        </BeautifulWrapper>\n    );\n};\n(UseDataSource as any).parameters = {\n    options: {\n        showPanel: false,\n    },\n};\n",".s1qcunhi{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;box-sizing:border-box;}.s1qcunhi *,.s1qcunhi *::before,.s1qcunhi *::after{box-sizing:inherit;}\n.bd6h1gz{background-color:#2790b9;background:linear-gradient(90deg,#2790b9,#2070a9);color:white;padding:32px 48px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;height:100vh;font-family:sans-serif;}.bd6h1gz > h1{font-size:50px;font-weight:600;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 12px 0;}.bd6h1gz .sizer{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:white;border-radius:12px;box-shadow:rgba(9,30,66,0.25) 0px 4px 8px -2px,rgba(9,30,66,0.08) 0px 0px 0px 1px;}.bd6h1gz .sizer .sizer-clip{border-radius:12px;overflow:hidden;-webkit-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0);height:100%;}\n.d8qm2x5{font-size:18px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;margin:0 0 20px 0;}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Il0sIm5hbWVzIjpbIi5zMXFjdW5oaSIsIi5iZDZoMWd6IiwiLmQ4cW0yeDUiXSwibWFwcGluZ3MiOiJBQVNNQTtBQWlDQUM7QUFvRUFDIiwiZmlsZSI6InBhY2thZ2VzL3NvdXJjZS9zcmMvdXNlLWRhdGEtc291cmNlLnN0b3JpZXMudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlc2l6ZURldGVjdG9yIH0gZnJvbSBcInJlYWN0LXJlc2l6ZS1kZXRlY3RvclwiO1xuaW1wb3J0IHsgRGF0YUVkaXRvciwgRGF0YUVkaXRvclByb3BzLCBHcmlkQ2VsbEtpbmQsIEdyaWRDb2x1bW4sIFRoZW1lIH0gZnJvbSBcIkBnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkXCI7XG5pbXBvcnQgZmFrZXIgZnJvbSBcImZha2VyXCI7XG5pbXBvcnQgeyB1c2VDb2xsYXBzaW5nR3JvdXBzLCB1c2VDb2x1bW5Tb3J0LCB1c2VNb3ZlYWJsZUNvbHVtbnMgfSBmcm9tIFwiLlwiO1xuXG5mYWtlci5zZWVkKDEzMzcpO1xuXG5jb25zdCBTaW1wbGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICosXG4gICAgKjo6YmVmb3JlLFxuICAgICo6OmFmdGVyIHtcbiAgICAgICAgYm94LXNpemluZzogaW5oZXJpdDtcbiAgICB9XG5gO1xuXG5jb25zdCBTaW1wbGVUaGVtZVdyYXBwZXI6IFJlYWN0LkZDID0gcCA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNpbXBsZVdyYXBwZXI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj57cC5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgPC9TaW1wbGVXcmFwcGVyPlxuICAgICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgdGl0bGU6IFwiRXh0cmEgUGFja2FnZXMvU291cmNlXCIsXG5cbiAgICBkZWNvcmF0b3JzOiBbXG4gICAgICAgIChTdG9yeTogUmVhY3QuQ29tcG9uZW50VHlwZSkgPT4gKFxuICAgICAgICAgICAgPFNpbXBsZVRoZW1lV3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8U3RvcnkgLz5cbiAgICAgICAgICAgIDwvU2ltcGxlVGhlbWVXcmFwcGVyPlxuICAgICAgICApLFxuICAgIF0sXG59O1xuXG5jb25zdCBCZWF1dGlmdWxTdHlsZSA9IHN0eWxlZC5kaXZgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI3OTBiOTtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICMyNzkwYjksICMyMDcwYTkpO1xuICAgIGNvbG9yOiB3aGl0ZTtcblxuICAgIHBhZGRpbmc6IDMycHggNDhweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XG5cbiAgICAmID4gaDEge1xuICAgICAgICBmb250LXNpemU6IDUwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgICAgICBtYXJnaW46IDAgMCAxMnB4IDA7XG4gICAgfVxuXG4gICAgLnNpemVyIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHJnYmEoOSwgMzAsIDY2LCAwLjI1KSAwcHggNHB4IDhweCAtMnB4LCByZ2JhKDksIDMwLCA2NiwgMC4wOCkgMHB4IDBweCAwcHggMXB4O1xuXG4gICAgICAgIC5zaXplci1jbGlwIHtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuXG5pbnRlcmZhY2UgQmVhdXRpZnVsUHJvcHMge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb24/OiBSZWFjdC5SZWFjdE5vZGU7XG59XG5cbmNvbnN0IEJlYXV0aWZ1bFdyYXBwZXI6IFJlYWN0LkZDPEJlYXV0aWZ1bFByb3BzPiA9IHAgPT4ge1xuICAgIGNvbnN0IHsgdGl0bGUsIGNoaWxkcmVuLCBkZXNjcmlwdGlvbiB9ID0gcDtcblxuICAgIGNvbnN0IHsgcmVmLCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VSZXNpemVEZXRlY3RvcigpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEJlYXV0aWZ1bFN0eWxlPlxuICAgICAgICAgICAgPGgxPnt0aXRsZX08L2gxPlxuICAgICAgICAgICAge2Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzaXplclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2l6ZXItY2xpcFwiIHJlZj17cmVmfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/PyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPz8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvQmVhdXRpZnVsU3R5bGU+XG4gICAgKTtcbn07XG5cbmNvbnN0IERlc2NyaXB0aW9uID0gc3R5bGVkLnBgXG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIG1hcmdpbjogMCAwIDIwcHggMDtcbmA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wczogUGFydGlhbDxEYXRhRWRpdG9yUHJvcHM+ID0ge1xuICAgIHNtb290aFNjcm9sbFg6IHRydWUsXG4gICAgc21vb3RoU2Nyb2xsWTogdHJ1ZSxcbiAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgcm93TWFya2VyczogXCJub25lXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxufTtcblxuY29uc3QgdGVzdFRoZW1lOiBUaGVtZSA9IHtcbiAgICBhY2NlbnRDb2xvcjogXCIjNEY1REZGXCIsXG4gICAgYWNjZW50Rmc6IFwiI0ZGRkZGRlwiLFxuICAgIGFjY2VudExpZ2h0OiBcInJnYmEoNjIsIDExNiwgMjUzLCAwLjEpXCIsXG5cbiAgICB0ZXh0RGFyazogXCIjMzEzMTM5XCIsXG4gICAgdGV4dE1lZGl1bTogXCIjNzM3MzgzXCIsXG4gICAgdGV4dExpZ2h0OiBcIiNCMkIyQzBcIixcbiAgICB0ZXh0QnViYmxlOiBcIiMzMTMxMzlcIixcblxuICAgIGJnSWNvbkhlYWRlcjogXCIjNzM3MzgzXCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiNGRkZGRkZcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0R3JvdXBIZWFkZXI6IFwiIzMxMzEzOUJCXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnQ2VsbDogXCIjRkZGRkZGXCIsXG4gICAgYmdDZWxsTWVkaXVtOiBcIiNGQUZBRkJcIixcbiAgICBiZ0hlYWRlcjogXCIjRjdGN0Y4XCIsXG4gICAgYmdIZWFkZXJIYXNGb2N1czogXCIjRTlFOUVCXCIsXG4gICAgYmdIZWFkZXJIb3ZlcmVkOiBcIiNFRkVGRjFcIixcblxuICAgIGJnQnViYmxlOiBcIiNFREVERjNcIixcbiAgICBiZ0J1YmJsZVNlbGVjdGVkOiBcIiNGRkZGRkZcIixcblxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiNmZmY5ZTNcIixcblxuICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMTE1LCAxMTYsIDEzMSwgMC4xNilcIixcbiAgICBob3Jpem9udGFsQm9yZGVyQ29sb3I6IFwicmdiYSgxMTUsIDExNiwgMTMxLCAwLjE2KVwiLFxuICAgIGRyaWxsZG93bkJvcmRlcjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG5cbiAgICBsaW5rQ29sb3I6IFwiIzRGNURGRlwiLFxuXG4gICAgY2VsbEhvcml6b250YWxQYWRkaW5nOiA4LFxuICAgIGNlbGxWZXJ0aWNhbFBhZGRpbmc6IDMsXG5cbiAgICBoZWFkZXJGb250U3R5bGU6IFwiNjAwIDEzcHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBlZGl0b3JGb250U2l6ZTogXCIxM3B4XCIsXG4gICAgbGluZUhlaWdodDogMS40LFxuICAgIGZvbnRGYW1pbHk6XG4gICAgICAgIFwiSW50ZXIsIFJvYm90bywgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBhdmVuaXIgbmV4dCwgYXZlbmlyLCBzZWdvZSB1aSwgaGVsdmV0aWNhIG5ldWUsIGhlbHZldGljYSwgVWJ1bnR1LCBub3RvLCBhcmlhbCwgc2Fucy1zZXJpZlwiLFxufTtcblxuY29uc3QgY29sczogR3JpZENvbHVtbltdID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiQVwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAxXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkJcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogXCJDXCIsXG4gICAgICAgIHdpZHRoOiAyMDAsXG4gICAgICAgIGdyb3VwOiBcIkdyb3VwIDJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6IFwiRFwiLFxuICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICBncm91cDogXCJHcm91cCAyXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiBcIkVcIixcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgZ3JvdXA6IFwiR3JvdXAgMlwiLFxuICAgIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgVXNlRGF0YVNvdXJjZTogUmVhY3QuVkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gUmVhY3QudXNlUmVmPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KTtcblxuICAgIGNvbnN0IHJvd3MgPSAxMDBfMDAwO1xuXG4gICAgY29uc3QgbW92ZUFyZ3MgPSB1c2VNb3ZlYWJsZUNvbHVtbnMoe1xuICAgICAgICBjb2x1bW5zOiBjb2xzLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogUmVhY3QudXNlQ2FsbGJhY2soKFtjb2wsIHJvd10pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2wgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBgJHtyb3d9YCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGAke3Jvd31gLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2NvbH0sJHtyb3d9YDtcbiAgICAgICAgICAgIGlmIChjYWNoZS5jdXJyZW50W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlLmN1cnJlbnRba2V5XSA9IGZha2VyLm5hbWUuZmlyc3ROYW1lKCkgKyBcIiBcIiArIGZha2VyLm5hbWUubGFzdE5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGQgPSBjYWNoZS5jdXJyZW50W2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbXSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBbc29ydCwgc2V0U29ydF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KCk7XG5cbiAgICBjb25zdCBzb3J0QXJncyA9IHVzZUNvbHVtblNvcnQoe1xuICAgICAgICBjb2x1bW5zOiBtb3ZlQXJncy5jb2x1bW5zLFxuICAgICAgICBnZXRDZWxsQ29udGVudDogbW92ZUFyZ3MuZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHNvcnQ6XG4gICAgICAgICAgICBzb3J0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbW92ZUFyZ3MuY29sdW1uc1tzb3J0XSxcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZGVzY1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwic21hcnRcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBjb2xsYXBzZUFyZ3MgPSB1c2VDb2xsYXBzaW5nR3JvdXBzKHtcbiAgICAgICAgY29sdW1uczogbW92ZUFyZ3MuY29sdW1ucyxcbiAgICAgICAgdGhlbWU6IHRlc3RUaGVtZSxcbiAgICAgICAgZnJlZXplQ29sdW1uczogMCxcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uSGVhZGVyQ2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRTb3J0KGluZGV4KTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8QmVhdXRpZnVsV3JhcHBlciB0aXRsZT1cIkN1c3RvbSBzb3VyY2UgZXh0ZW5zaW9uc1wiIGRlc2NyaXB0aW9uPXs8RGVzY3JpcHRpb24+Rml4bWUuPC9EZXNjcmlwdGlvbj59PlxuICAgICAgICAgICAgPERhdGFFZGl0b3JcbiAgICAgICAgICAgICAgICB7Li4uZGVmYXVsdFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5tb3ZlQXJnc31cbiAgICAgICAgICAgICAgICB7Li4uc29ydEFyZ3N9XG4gICAgICAgICAgICAgICAgey4uLmNvbGxhcHNlQXJnc31cbiAgICAgICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgICAgIG9uQ29sdW1uTW92ZWQ9e21vdmVBcmdzLm9uQ29sdW1uTW92ZWR9XG4gICAgICAgICAgICAgICAgb25IZWFkZXJDbGlja2VkPXtvbkhlYWRlckNsaWNrfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9CZWF1dGlmdWxXcmFwcGVyPlxuICAgICk7XG59O1xuKFVzZURhdGFTb3VyY2UgYXMgYW55KS5wYXJhbWV0ZXJzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2hvd1BhbmVsOiBmYWxzZSxcbiAgICB9LFxufTtcbiJdfQ==*/"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./packages/core/dist/index.css":
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\n.d1t1th9s {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow: hidden;\n  box-sizing: border-box;\n  --overlay-top:var(--d1t1th9s-0);\n  left: var(--d1t1th9s-1);\n  top: var(--d1t1th9s-2);\n  min-width: var(--d1t1th9s-3);\n  min-height: var(--d1t1th9s-4);\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 400px;\n  max-height: calc(100vh - var(--d1t1th9s-5));\n  font-family: var(--gdg-font-family);\n  font-size: var(--gdg-editor-font-size);\n  text-align: start;\n}\n@-webkit-keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n@keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n.d1t1th9s.gdg-style {\n  border-radius: 2px;\n  background-color: var(--gdg-bg-cell);\n  box-shadow:\n    0 0 0 1px var(--gdg-accent-color),\n    0px 0px 1px rgba(62, 65, 86, 0.4),\n    0px 6px 12px rgba(62, 65, 86, 0.15);\n  -webkit-animation: glide_fade_in-d1t1th9s 60ms 1;\n  animation: glide_fade_in-d1t1th9s 60ms 1;\n}\n.d1t1th9s.pad {\n  padding: var(--d1t1th9s-6) 8.5px 3px;\n}\n.d1t1th9s .clip-region {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow-y: auto;\n  overflow-x: hidden;\n  border-radius: 2px;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.d1t1th9s .clip-region .gdg-growing-entry {\n  height: 100%;\n}\n.d1t1th9s .clip-region input.gdg-input {\n  width: 100%;\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.d1t1th9s .clip-region textarea.gdg-input {\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\n.m15w2ly5 {\n  position: absolute;\n  right: 44px;\n  bottom: 44px;\n  background-color: var(--gdg-bg-cell);\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n  border-radius: 4px;\n  z-index: 1;\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n}\n.m15w2ly5 .header {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 4px;\n  background-color: var(--gdg-bg-header);\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n}\n.m15w2ly5 .locationMarker {\n  position: absolute;\n  border: 1px solid var(--gdg-accent-color);\n  background-color: var(--gdg-accent-light);\n}\n\n/* linaria:infinite-scroller_1qseojb.linaria.css */\n.s1jz82f8 .dvn-scroller {\n  overflow: var(--s1jz82f8-0);\n  -webkit-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n}\n.s1jz82f8 .hidden {\n  visibility: hidden;\n}\n.s1jz82f8 .dvn-scroll-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  pointer-events: none;\n}\n.s1jz82f8 .dvn-scroll-inner > * {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n.s1jz82f8 .dvn-underlay > * {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.s1jz82f8 canvas {\n  outline: none;\n}\n.s1jz82f8 canvas * {\n  height: 0;\n}\n\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\n.sxep88s {\n  position: absolute;\n  top: 4px;\n  right: 20px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  padding: 8px;\n  border: 1px solid var(--gdg-border-color);\n  border-radius: 6px;\n  font-size: var(--gdg-editor-font-size);\n  -webkit-transform: translateX(var(--sxep88s-0));\n  -ms-transform: translateX(var(--sxep88s-0));\n  transform: translateX(var(--sxep88s-0));\n  -webkit-transition: -webkit-transform 0.15s;\n  -webkit-transition: transform 0.15s;\n  transition: transform 0.15s;\n}\n.sxep88s .search-bar-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.sxep88s .search-status {\n  padding-top: 4px;\n  font-size: 11px;\n}\n.sxep88s .search-progress {\n  position: absolute;\n  height: 4px;\n  left: 0;\n  bottom: 0;\n  background-color: var(--gdg-text-light);\n}\n.sxep88s input {\n  width: 220px;\n  color: var(--gdg-textDark);\n  background-color: var(--gdg-bg-cell);\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.sxep88s button {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  outline: none;\n  background: none;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  cursor: pointer;\n  color: var(--gdg-text-medium);\n}\n.sxep88s button:hover {\n  color: var(--gdg-text-dark);\n}\n.sxep88s button .button-icon {\n  width: 16px;\n  height: 16px;\n}\n.sxep88s button:disabled {\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n/* linaria:group-rename_yc2zuw.linaria.css */\n.r1kzy40b {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  border: none;\n  outline: none;\n  background-color: var(--gdg-bg-header-has-focus);\n  border-radius: 9px;\n  padding: 0 8px;\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n  color: var(--gdg-text-group-header);\n  min-height: var(--r1kzy40b-0);\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\n}\n.c1sqdbw3 {\n  padding: 0 8px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  background-color: var(--gdg-bg-header);\n}\n\n/* linaria:data-grid-container_gfrgfn.linaria.css */\n.wzg2m5k {\n  position: relative;\n  min-width: 10px;\n  min-height: 10px;\n  max-width: 100%;\n  max-height: 100%;\n  width: var(--wzg2m5k-0);\n  height: var(--wzg2m5k-1);\n  overflow: hidden;\n  overflow: clip;\n  contain: strict;\n}\n.wzg2m5k > :first-child {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\n.b1bqsp5z {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.b1bqsp5z .boe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 20px;\n  background-color: var(--gdg-bg-bubble);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n}\n.b1bqsp5z textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\n.df2kt4a {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.df2kt4a .doe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 24px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n  border-radius: 6px;\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n}\n.df2kt4a .doe-bubble img {\n  height: 16px;\n  object-fit: contain;\n  margin-right: 4px;\n}\n.df2kt4a textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\n.i1eozt10 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  height: 100%;\n}\n.i1eozt10 .centering-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  height: 100%;\n}\n.i1eozt10 .centering-container img,\n.i1eozt10 .centering-container canvas {\n  max-height: calc(100vh - var(--overlay-top) - 20px);\n  object-fit: contain;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.i1eozt10 .centering-container canvas {\n  max-width: 380px;\n}\n.i1eozt10 .edit-icon {\n  position: absolute;\n  top: 12px;\n  right: 0;\n  width: 48px;\n  height: 48px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.i1eozt10 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.i1eozt10 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:markdown-container_kvmc63.linaria.css */\n.mlbeo71 {\n  word-break: break-word;\n  -webkit-touch-callout: default;\n  padding-top: 6px;\n}\n.mlbeo71 > * {\n  margin: 0;\n}\n.mlbeo71 *:last-child {\n  margin-bottom: 0;\n}\n.mlbeo71 p img {\n  width: 100%;\n}\n\n/* linaria:growing-entry-style_ycxqui.linaria.css */\n.ijuk0po {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 0px;\n  resize: none;\n  white-space: pre-wrap;\n  min-width: 100%;\n  overflow: hidden;\n  border: 0;\n  background-color: transparent;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n}\n.ijuk0po::-webkit-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::-moz-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po:-ms-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::placeholder {\n  color: var(--gdg-text-light);\n}\n.invalid .ijuk0po {\n  -webkit-text-decoration: underline;\n  text-decoration: underline;\n  -webkit-text-decoration-color: #d60606;\n  text-decoration-color: #d60606;\n}\n.saq3p5l {\n  visibility: hidden;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 100%;\n  min-width: 100%;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n  padding-bottom: 2px;\n}\n.gf8vzix {\n  position: relative;\n  margin-top: 6px;\n}\n\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\n.mdwzdl1 {\n  min-width: var(--mdwzdl1-0);\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: flex-start;\n  -webkit-box-align: flex-start;\n  -ms-flex-align: flex-start;\n  align-items: flex-start;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  position: relative;\n  color: var(--gdg-text-dark);\n}\n.mdwzdl1 .gf8vzix {\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  min-width: 0;\n}\n.mdwzdl1 .spacer {\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n}\n.mdwzdl1 .edit-icon {\n  position: relative;\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  color: var(--gdg-accent-color);\n  padding: 0;\n  height: 24px;\n  width: 24px;\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  -webkit-transition: all \"0.125s ease\";\n  transition: all \"0.125s ease\";\n  border-radius: 6px;\n}\n.mdwzdl1 .edit-icon > * {\n  width: 16px;\n  height: 16px;\n}\n.mdwzdl1 .edit-hover:hover {\n  background-color: var(--gdg-accent-light);\n  -webkit-transition: background-color 150ms;\n  transition: background-color 150ms;\n}\n.mdwzdl1 .checkmark-hover:hover {\n  color: #ffffff;\n  background-color: var(--gdg-accent-color);\n}\n.mdwzdl1 .md-edit-textarea {\n  position: relative;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  margin-top: 25px;\n  opacity: 0;\n  padding: 0;\n}\n.mdwzdl1 .ml-6 {\n  margin-left: 6px;\n}\n\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\n.n1czszh3 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  margin: 6px 0 3px;\n  color: var(--gdg-text-dark);\n}\n.n1czszh3 > input {\n  font-size: var(--gdg-editor-font-size);\n  padding: 0;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  background-color: var(--gdg-bg-cell);\n}\n\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\n.uf0sjo8 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  min-height: 21px;\n}\n.uf0sjo8 .link-area {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  cursor: pointer;\n  margin-right: 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: var(--gdg-link-color);\n  -webkit-text-decoration: underline !important;\n  text-decoration: underline !important;\n}\n.uf0sjo8 .edit-icon {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  width: 32px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.uf0sjo8 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.uf0sjo8 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n/*# sourceMappingURL=index.css.map */\n", "",{"version":3,"sources":["webpack://./packages/core/dist/index.css"],"names":[],"mappings":"AAAA,+DAA+D;AAC/D;EACE,kBAAkB;EAClB,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,8BAA8B;EAC9B,0BAA0B;EAC1B,sBAAsB;EACtB,gBAAgB;EAChB,sBAAsB;EACtB,+BAA+B;EAC/B,uBAAuB;EACvB,sBAAsB;EACtB,4BAA4B;EAC5B,6BAA6B;EAC7B,0BAA0B;EAC1B,uBAAuB;EACvB,kBAAkB;EAClB,gBAAgB;EAChB,2CAA2C;EAC3C,mCAAmC;EACnC,sCAAsC;EACtC,iBAAiB;AACnB;AACA;EACE;IACE,WAAW;EACb;EACA;IACE,aAAa;EACf;AACF;AACA;EACE;IACE,WAAW;EACb;EACA;IACE,aAAa;EACf;AACF;AACA;EACE,kBAAkB;EAClB,oCAAoC;EACpC;;;uCAGqC;EACrC,gDAAgD;EAChD,wCAAwC;AAC1C;AACA;EACE,oCAAoC;AACtC;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,8BAA8B;EAC9B,0BAA0B;EAC1B,sBAAsB;EACtB,gBAAgB;EAChB,kBAAkB;EAClB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;AACd;AACA;EACE,YAAY;AACd;AACA;EACE,WAAW;EACX,YAAY;EACZ,eAAe;EACf,aAAa;AACf;AACA;EACE,YAAY;EACZ,eAAe;EACf,aAAa;AACf;;AAEA,mDAAmD;AACnD;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,oCAAoC;EACpC,0EAA0E;EAC1E,kBAAkB;EAClB,UAAU;EACV,4EAA4E;EAC5E,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,WAAW;EACX,WAAW;EACX,sCAAsC;EACtC,6CAA6C;AAC/C;AACA;EACE,kBAAkB;EAClB,yCAAyC;EACzC,yCAAyC;AAC3C;;AAEA,kDAAkD;AAClD;EACE,2BAA2B;EAC3B,uCAAuC;EACvC,mCAAmC;EACnC,+BAA+B;AACjC;AACA;EACE,kBAAkB;AACpB;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,oBAAoB;AACtB;AACA;EACE,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;AAChB;AACA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;AACd;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,8BAA8B;EAC9B,0BAA0B;EAC1B,sBAAsB;AACxB;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;AACR;AACA;EACE,aAAa;AACf;AACA;EACE,SAAS;AACX;;AAEA,sDAAsD;AACtD;EACE,kBAAkB;EAClB,QAAQ;EACR,WAAW;EACX,oCAAoC;EACpC,2BAA2B;EAC3B,YAAY;EACZ,yCAAyC;EACzC,kBAAkB;EAClB,sCAAsC;EACtC,+CAA+C;EAC/C,2CAA2C;EAC3C,uCAAuC;EACvC,2CAA2C;EAC3C,mCAAmC;EACnC,2BAA2B;AAC7B;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;AACf;AACA;EACE,gBAAgB;EAChB,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,OAAO;EACP,SAAS;EACT,uCAAuC;AACzC;AACA;EACE,YAAY;EACZ,0BAA0B;EAC1B,oCAAoC;EACpC,YAAY;EACZ,eAAe;EACf,aAAa;AACf;AACA;EACE,WAAW;EACX,YAAY;EACZ,UAAU;EACV,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,eAAe;EACf,6BAA6B;AAC/B;AACA;EACE,2BAA2B;AAC7B;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,YAAY;EACZ,oBAAoB;AACtB;;AAEA,4CAA4C;AAC5C;EACE,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;EACZ,YAAY;EACZ,aAAa;EACb,gDAAgD;EAChD,kBAAkB;EAClB,cAAc;EACd,6CAA6C;EAC7C,mCAAmC;EACnC,6BAA6B;EAC7B,yDAAyD;AAC3D;AACA;EACE,cAAc;EACd,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,sCAAsC;AACxC;;AAEA,mDAAmD;AACnD;EACE,kBAAkB;EAClB,eAAe;EACf,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,uBAAuB;EACvB,wBAAwB;EACxB,gBAAgB;EAChB,cAAc;EACd,eAAe;AACjB;AACA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,WAAW;EACX,YAAY;AACd;;AAEA,6DAA6D;AAC7D;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,eAAe;AACjB;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,oBAAoB;EACpB,cAAc;EACd,YAAY;EACZ,sCAAsC;EACtC,2BAA2B;EAC3B,WAAW;AACb;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;;AAEA,yDAAyD;AACzD;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,eAAe;AACjB;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,oBAAoB;EACpB,cAAc;EACd,YAAY;EACZ,oCAAoC;EACpC,2BAA2B;EAC3B,WAAW;EACX,kBAAkB;EAClB,0EAA0E;AAC5E;AACA;EACE,YAAY;EACZ,mBAAmB;EACnB,iBAAiB;AACnB;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;;AAEA,0DAA0D;AAC1D;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,YAAY;AACd;AACA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,YAAY;AACd;AACA;;EAEE,mDAAmD;EACnD,mBAAmB;EACnB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;AACnB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,WAAW;EACX,YAAY;EACZ,8BAA8B;EAC9B,eAAe;EACf,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;AACrB;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;;AAEA,kDAAkD;AAClD;EACE,sBAAsB;EACtB,8BAA8B;EAC9B,gBAAgB;AAClB;AACA;EACE,SAAS;AACX;AACA;EACE,gBAAgB;AAClB;AACA;EACE,WAAW;AACb;;AAEA,mDAAmD;AACnD;EACE,kBAAkB;EAClB,OAAO;EACP,QAAQ;EACR,MAAM;EACN,SAAS;EACT,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ,qBAAqB;EACrB,eAAe;EACf,gBAAgB;EAChB,SAAS;EACT,6BAA6B;EAC7B,sCAAsC;EACtC,iBAAiB;EACjB,mCAAmC;EACnC,2BAA2B;EAC3B,UAAU;EACV,SAAS;AACX;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,4BAA4B;AAC9B;AACA;EACE,kCAAkC;EAClC,0BAA0B;EAC1B,sCAAsC;EACtC,8BAA8B;AAChC;AACA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,qBAAqB;EACrB,0BAA0B;EAC1B,uBAAuB;EACvB,kBAAkB;EAClB,eAAe;EACf,eAAe;EACf,sCAAsC;EACtC,iBAAiB;EACjB,mCAAmC;EACnC,2BAA2B;EAC3B,UAAU;EACV,SAAS;EACT,mBAAmB;AACrB;AACA;EACE,kBAAkB;EAClB,eAAe;AACjB;;AAEA,6DAA6D;AAC7D;EACE,2BAA2B;EAC3B,WAAW;EACX,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,+BAA+B;EAC/B,6BAA6B;EAC7B,0BAA0B;EAC1B,uBAAuB;EACvB,yBAAyB;EACzB,sCAAsC;EACtC,sBAAsB;EACtB,8BAA8B;EAC9B,kBAAkB;EAClB,2BAA2B;AAC7B;AACA;EACE,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,YAAY;AACd;AACA;EACE,eAAe;EACf,WAAW;EACX,OAAO;AACT;AACA;EACE,kBAAkB;EAClB,eAAe;EACf,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,8BAA8B;EAC9B,UAAU;EACV,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,qCAAqC;EACrC,6BAA6B;EAC7B,kBAAkB;AACpB;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,yCAAyC;EACzC,0CAA0C;EAC1C,kCAAkC;AACpC;AACA;EACE,cAAc;EACd,yCAAyC;AAC3C;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,gBAAgB;EAChB,UAAU;EACV,UAAU;AACZ;AACA;EACE,gBAAgB;AAClB;;AAEA,2DAA2D;AAC3D;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,iBAAiB;EACjB,2BAA2B;AAC7B;AACA;EACE,sCAAsC;EACtC,UAAU;EACV,mCAAmC;EACnC,2BAA2B;EAC3B,oCAAoC;AACtC;;AAEA,wDAAwD;AACxD;EACE,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;EACZ,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,YAAY;EACZ,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,eAAe;EACf,iBAAiB;EACjB,gBAAgB;EAChB,uBAAuB;EACvB,mBAAmB;EACnB,4BAA4B;EAC5B,6CAA6C;EAC7C,qCAAqC;AACvC;AACA;EACE,sBAAsB;EACtB,oBAAoB;EACpB,cAAc;EACd,WAAW;EACX,8BAA8B;EAC9B,eAAe;EACf,oBAAoB;EACpB,qBAAqB;EACrB,oBAAoB;EACpB,aAAa;EACb,wBAAwB;EACxB,+BAA+B;EAC/B,qBAAqB;EACrB,uBAAuB;EACvB,2BAA2B;EAC3B,yBAAyB;EACzB,sBAAsB;EACtB,mBAAmB;AACrB;AACA;EACE,WAAW;EACX,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,QAAQ;EACR,SAAS;EACT,UAAU;EACV,WAAW;EACX,UAAU;AACZ;AACA,oCAAoC","sourcesContent":["/* linaria:data-grid-overlay-editor-style_115vs9w.linaria.css */\n.d1t1th9s {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow: hidden;\n  box-sizing: border-box;\n  --overlay-top:var(--d1t1th9s-0);\n  left: var(--d1t1th9s-1);\n  top: var(--d1t1th9s-2);\n  min-width: var(--d1t1th9s-3);\n  min-height: var(--d1t1th9s-4);\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 400px;\n  max-height: calc(100vh - var(--d1t1th9s-5));\n  font-family: var(--gdg-font-family);\n  font-size: var(--gdg-editor-font-size);\n  text-align: start;\n}\n@-webkit-keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n@keyframes glide_fade_in-d1t1th9s {\n  from {\n    opacity: 0%;\n  }\n  to {\n    opacity: 100%;\n  }\n}\n.d1t1th9s.gdg-style {\n  border-radius: 2px;\n  background-color: var(--gdg-bg-cell);\n  box-shadow:\n    0 0 0 1px var(--gdg-accent-color),\n    0px 0px 1px rgba(62, 65, 86, 0.4),\n    0px 6px 12px rgba(62, 65, 86, 0.15);\n  -webkit-animation: glide_fade_in-d1t1th9s 60ms 1;\n  animation: glide_fade_in-d1t1th9s 60ms 1;\n}\n.d1t1th9s.pad {\n  padding: var(--d1t1th9s-6) 8.5px 3px;\n}\n.d1t1th9s .clip-region {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n  overflow-y: auto;\n  overflow-x: hidden;\n  border-radius: 2px;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.d1t1th9s .clip-region .gdg-growing-entry {\n  height: 100%;\n}\n.d1t1th9s .clip-region input.gdg-input {\n  width: 100%;\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.d1t1th9s .clip-region textarea.gdg-input {\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n\n/* linaria:scrolling-data-grid_zcytub.linaria.css */\n.m15w2ly5 {\n  position: absolute;\n  right: 44px;\n  bottom: 44px;\n  background-color: var(--gdg-bg-cell);\n  background: linear-gradient(var(--gdg-bg-cell), var(--gdg-bg-cell-medium));\n  border-radius: 4px;\n  z-index: 1;\n  box-shadow: 0 0 0 1px var(--gdg-border-color), 0 2px 5px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n}\n.m15w2ly5 .header {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 4px;\n  background-color: var(--gdg-bg-header);\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n}\n.m15w2ly5 .locationMarker {\n  position: absolute;\n  border: 1px solid var(--gdg-accent-color);\n  background-color: var(--gdg-accent-light);\n}\n\n/* linaria:infinite-scroller_1qseojb.linaria.css */\n.s1jz82f8 .dvn-scroller {\n  overflow: var(--s1jz82f8-0);\n  -webkit-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n}\n.s1jz82f8 .hidden {\n  visibility: hidden;\n}\n.s1jz82f8 .dvn-scroll-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  pointer-events: none;\n}\n.s1jz82f8 .dvn-scroll-inner > * {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-spacer {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n}\n.s1jz82f8 .dvn-scroll-inner .dvn-stack {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-direction: column;\n  -ms-flex-direction: column;\n  flex-direction: column;\n}\n.s1jz82f8 .dvn-underlay > * {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.s1jz82f8 canvas {\n  outline: none;\n}\n.s1jz82f8 canvas * {\n  height: 0;\n}\n\n/* linaria:data-grid-search-style_jgiiup.linaria.css */\n.sxep88s {\n  position: absolute;\n  top: 4px;\n  right: 20px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  padding: 8px;\n  border: 1px solid var(--gdg-border-color);\n  border-radius: 6px;\n  font-size: var(--gdg-editor-font-size);\n  -webkit-transform: translateX(var(--sxep88s-0));\n  -ms-transform: translateX(var(--sxep88s-0));\n  transform: translateX(var(--sxep88s-0));\n  -webkit-transition: -webkit-transform 0.15s;\n  -webkit-transition: transform 0.15s;\n  transition: transform 0.15s;\n}\n.sxep88s .search-bar-inner {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.sxep88s .search-status {\n  padding-top: 4px;\n  font-size: 11px;\n}\n.sxep88s .search-progress {\n  position: absolute;\n  height: 4px;\n  left: 0;\n  bottom: 0;\n  background-color: var(--gdg-text-light);\n}\n.sxep88s input {\n  width: 220px;\n  color: var(--gdg-textDark);\n  background-color: var(--gdg-bg-cell);\n  border: none;\n  border-width: 0;\n  outline: none;\n}\n.sxep88s button {\n  width: 24px;\n  height: 24px;\n  padding: 0;\n  border: none;\n  outline: none;\n  background: none;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  cursor: pointer;\n  color: var(--gdg-text-medium);\n}\n.sxep88s button:hover {\n  color: var(--gdg-text-dark);\n}\n.sxep88s button .button-icon {\n  width: 16px;\n  height: 16px;\n}\n.sxep88s button:disabled {\n  opacity: 0.4;\n  pointer-events: none;\n}\n\n/* linaria:group-rename_yc2zuw.linaria.css */\n.r1kzy40b {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  border: none;\n  outline: none;\n  background-color: var(--gdg-bg-header-has-focus);\n  border-radius: 9px;\n  padding: 0 8px;\n  box-shadow: 0 0 0 1px var(--gdg-border-color);\n  color: var(--gdg-text-group-header);\n  min-height: var(--r1kzy40b-0);\n  font: var(--gdg-header-font-style) var(--gdg-font-family);\n}\n.c1sqdbw3 {\n  padding: 0 8px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  background-color: var(--gdg-bg-header);\n}\n\n/* linaria:data-grid-container_gfrgfn.linaria.css */\n.wzg2m5k {\n  position: relative;\n  min-width: 10px;\n  min-height: 10px;\n  max-width: 100%;\n  max-height: 100%;\n  width: var(--wzg2m5k-0);\n  height: var(--wzg2m5k-1);\n  overflow: hidden;\n  overflow: clip;\n  contain: strict;\n}\n.wzg2m5k > :first-child {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n\n/* linaria:bubbles-overlay-editor-style_1022dut.linaria.css */\n.b1bqsp5z {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.b1bqsp5z .boe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 20px;\n  background-color: var(--gdg-bg-bubble);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n}\n.b1bqsp5z textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:drilldown-overlay-editor_1gv6dry.linaria.css */\n.df2kt4a {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.df2kt4a .doe-bubble {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  border-radius: 100px;\n  padding: 0 8px;\n  height: 24px;\n  background-color: var(--gdg-bg-cell);\n  color: var(--gdg-text-dark);\n  margin: 2px;\n  border-radius: 6px;\n  box-shadow: 0 0 1px rgba(62, 65, 86, 0.4), 0 1px 3px rgba(62, 65, 86, 0.4);\n}\n.df2kt4a .doe-bubble img {\n  height: 16px;\n  object-fit: contain;\n  margin-right: 4px;\n}\n.df2kt4a textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:image-overlay-editor-style_sojiwi.linaria.css */\n.i1eozt10 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  height: 100%;\n}\n.i1eozt10 .centering-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  height: 100%;\n}\n.i1eozt10 .centering-container img,\n.i1eozt10 .centering-container canvas {\n  max-height: calc(100vh - var(--overlay-top) - 20px);\n  object-fit: contain;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.i1eozt10 .centering-container canvas {\n  max-width: 380px;\n}\n.i1eozt10 .edit-icon {\n  position: absolute;\n  top: 12px;\n  right: 0;\n  width: 48px;\n  height: 48px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.i1eozt10 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.i1eozt10 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n\n/* linaria:markdown-container_kvmc63.linaria.css */\n.mlbeo71 {\n  word-break: break-word;\n  -webkit-touch-callout: default;\n  padding-top: 6px;\n}\n.mlbeo71 > * {\n  margin: 0;\n}\n.mlbeo71 *:last-child {\n  margin-bottom: 0;\n}\n.mlbeo71 p img {\n  width: 100%;\n}\n\n/* linaria:growing-entry-style_ycxqui.linaria.css */\n.ijuk0po {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  border-radius: 0px;\n  resize: none;\n  white-space: pre-wrap;\n  min-width: 100%;\n  overflow: hidden;\n  border: 0;\n  background-color: transparent;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n}\n.ijuk0po::-webkit-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::-moz-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po:-ms-input-placeholder {\n  color: var(--gdg-text-light);\n}\n.ijuk0po::placeholder {\n  color: var(--gdg-text-light);\n}\n.invalid .ijuk0po {\n  -webkit-text-decoration: underline;\n  text-decoration: underline;\n  -webkit-text-decoration-color: #d60606;\n  text-decoration-color: #d60606;\n}\n.saq3p5l {\n  visibility: hidden;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  width: -webkit-max-content;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 100%;\n  min-width: 100%;\n  font-size: var(--gdg-editor-font-size);\n  line-height: 16px;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  padding: 0;\n  margin: 0;\n  padding-bottom: 2px;\n}\n.gf8vzix {\n  position: relative;\n  margin-top: 6px;\n}\n\n/* linaria:markdown-overlay-editor-style_nbv04l.linaria.css */\n.mdwzdl1 {\n  min-width: var(--mdwzdl1-0);\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: flex-start;\n  -webkit-box-align: flex-start;\n  -ms-flex-align: flex-start;\n  align-items: flex-start;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n  -ms-flex-pack: justify;\n  justify-content: space-between;\n  position: relative;\n  color: var(--gdg-text-dark);\n}\n.mdwzdl1 .gf8vzix {\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  min-width: 0;\n}\n.mdwzdl1 .spacer {\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n}\n.mdwzdl1 .edit-icon {\n  position: relative;\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  color: var(--gdg-accent-color);\n  padding: 0;\n  height: 24px;\n  width: 24px;\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  -webkit-transition: all \"0.125s ease\";\n  transition: all \"0.125s ease\";\n  border-radius: 6px;\n}\n.mdwzdl1 .edit-icon > * {\n  width: 16px;\n  height: 16px;\n}\n.mdwzdl1 .edit-hover:hover {\n  background-color: var(--gdg-accent-light);\n  -webkit-transition: background-color 150ms;\n  transition: background-color 150ms;\n}\n.mdwzdl1 .checkmark-hover:hover {\n  color: #ffffff;\n  background-color: var(--gdg-accent-color);\n}\n.mdwzdl1 .md-edit-textarea {\n  position: relative;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  margin-top: 25px;\n  opacity: 0;\n  padding: 0;\n}\n.mdwzdl1 .ml-6 {\n  margin-left: 6px;\n}\n\n/* linaria:number-overlay-editor-style_1i1z3n.linaria.css */\n.n1czszh3 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  margin: 6px 0 3px;\n  color: var(--gdg-text-dark);\n}\n.n1czszh3 > input {\n  font-size: var(--gdg-editor-font-size);\n  padding: 0;\n  font-family: var(--gdg-font-family);\n  color: var(--gdg-text-dark);\n  background-color: var(--gdg-bg-cell);\n}\n\n/* linaria:uri-overlay-editor-style_nguq6d.linaria.css */\n.uf0sjo8 {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  min-height: 21px;\n}\n.uf0sjo8 .link-area {\n  -webkit-box-flex: 1;\n  -webkit-flex-grow: 1;\n  -ms-flex-positive: 1;\n  flex-grow: 1;\n  -webkit-flex-shrink: 1;\n  -ms-flex-negative: 1;\n  flex-shrink: 1;\n  cursor: pointer;\n  margin-right: 8px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: var(--gdg-link-color);\n  -webkit-text-decoration: underline !important;\n  text-decoration: underline !important;\n}\n.uf0sjo8 .edit-icon {\n  -webkit-flex-shrink: 0;\n  -ms-flex-negative: 0;\n  flex-shrink: 0;\n  width: 32px;\n  color: var(--gdg-accent-color);\n  cursor: pointer;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  -webkit-align-items: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n}\n.uf0sjo8 .edit-icon > * {\n  width: 24px;\n  height: 24px;\n}\n.uf0sjo8 textarea {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 0px;\n  height: 0px;\n  opacity: 0;\n}\n/*# sourceMappingURL=index.css.map */\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./packages/cells/src/cell.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_cell_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_cell_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_cell_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/dropdown-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_dropdown_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_dropdown_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_dropdown_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/links-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_links_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_links_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_links_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/star-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_star_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_star_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_star_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/cells/src/cells/tags-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_tags_cell_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_tags_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_tags_cell_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor-container/data-grid-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_container_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor/group-rename.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_group_rename_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_group_rename_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_group_rename_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-beautiful.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_beautiful_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_beautiful_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_beautiful_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-repros.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_repros_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_repros_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_editor_repros_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-editor/stories/utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_utils_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_bubbles_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_bubbles_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_bubbles_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_drilldown_overlay_editor_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_drilldown_overlay_editor_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_drilldown_overlay_editor_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_image_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_image_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_image_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_uri_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_uri_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_uri_overlay_editor_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/data-grid-search/data-grid-search-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_search_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_search_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_data_grid_search_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/docs/doc-wrapper.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_doc_wrapper_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_doc_wrapper_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_doc_wrapper_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/growing-entry/growing-entry-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_growing_entry_style_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_growing_entry_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_growing_entry_style_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/markdown-div/private/markdown-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_container_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_markdown_container_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/infinite-scroller.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_infinite_scroller_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_infinite_scroller_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_infinite_scroller_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_scrolling_data_grid_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/core/src/stories/story-utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_story_utils_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_story_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_story_utils_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./packages/source/src/use-data-source.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/use-data-source.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_use_data_source_stories_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/use-data-source.stories.tsx");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_storybook_builder_webpack5_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_use_data_source_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_storybook_builder_webpack5_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_4_use_1_node_modules_linaria_webpack5_loader_lib_outputCssLoader_js_cacheProvider_use_data_source_stories_tsx__WEBPACK_IMPORTED_MODULE_1__/* ["default"].locals */ .Z.locals || {});

/***/ }),

/***/ "./.storybook/preview.js-generated-config-entry.js":
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// NAMESPACE OBJECT: ./.storybook/preview.js
var preview_namespaceObject = {};
__webpack_require__.r(preview_namespaceObject);
__webpack_require__.d(preview_namespaceObject, {
  "__namedExportsOrder": () => (__namedExportsOrder),
  "parameters": () => (parameters)
});

// EXTERNAL MODULE: ./node_modules/@storybook/client-api/dist/esm/ClientApi.js + 4 modules
var ClientApi = __webpack_require__("./node_modules/@storybook/client-api/dist/esm/ClientApi.js");
// EXTERNAL MODULE: ./node_modules/@storybook/react/dist/esm/client/index.js + 33 modules
var client = __webpack_require__("./node_modules/@storybook/react/dist/esm/client/index.js");
;// CONCATENATED MODULE: ./.storybook/preview.js

(0,client.addParameters)({
  options: {
    showRoots: true,
    storySort: (a, b) => {
      return a[1].name.localeCompare(b[1].name, undefined, {
        numeric: true
      });
    }
  }
});
const parameters = {
  layout: "fullscreen"
};
const __namedExportsOrder = ["parameters"];
;// CONCATENATED MODULE: ./.storybook/preview.js-generated-config-entry.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}



Object.keys(preview_namespaceObject).forEach(function (key) {
  var value = preview_namespaceObject[key];

  switch (key) {
    case 'args':
      {
        return (0,ClientApi/* addArgs */.uc)(value);
      }

    case 'argTypes':
      {
        return (0,ClientApi/* addArgTypes */.v9)(value);
      }

    case 'decorators':
      {
        return value.forEach(function (decorator) {
          return (0,ClientApi/* addDecorator */.$9)(decorator, false);
        });
      }

    case 'loaders':
      {
        return value.forEach(function (loader) {
          return (0,ClientApi/* addLoader */.HZ)(loader, false);
        });
      }

    case 'parameters':
      {
        return (0,ClientApi/* addParameters */.h1)(_objectSpread({}, value), false);
      }

    case 'argTypesEnhancers':
      {
        return value.forEach(function (enhancer) {
          return (0,ClientApi/* addArgTypesEnhancer */.My)(enhancer);
        });
      }

    case 'argsEnhancers':
      {
        return value.forEach(function (enhancer) {
          return (0,ClientApi/* addArgsEnhancer */._C)(enhancer);
        });
      }

    case 'render':
      {
        return (0,ClientApi/* setGlobalRender */.$P)(value);
      }

    case 'globals':
    case 'globalTypes':
      {
        var v = {};
        v[key] = value;
        return (0,ClientApi/* addParameters */.h1)(v, false);
      }

    case '__namedExportsOrder':
    case 'decorateStory':
    case 'renderToDOM':
      {
        return null;
      }

    default:
      {
        return console.log(key + ' was not supported :( !');
      }
  }
});

/***/ }),

/***/ "./packages/cells/src/cell.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "CustomCellEditing": () => (/* binding */ CustomCellEditing),
  "CustomCells": () => (/* binding */ CustomCells),
  "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
  "default": () => (/* binding */ cell_stories)
});

// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./packages/core/dist/js/index.js
var js = __webpack_require__("./packages/core/dist/js/index.js");
;// CONCATENATED MODULE: ./packages/cells/src/cells/star-cell.tsx



const starPoints = [[50, 5], [61.23, 39.55], [97.55, 39.55], [68.16, 60.9], [79.39, 95.45], [50, 74.1], [20.61, 95.45], [31.84, 60.9], [2.45, 39.55], [38.77, 39.55]];

function pathStar(ctx, center, size) {
  let moved = false;

  for (const p of starPoints) {
    const x = (p[0] - 50) * (size / 100) + center[0];
    const y = (p[1] - 50) * (size / 100) + center[1];

    if (moved) {
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
      moved = true;
    }
  }

  ctx.closePath();
}

const StarSVG = () => react.createElement("svg", {
  width: "100",
  height: "100",
  viewBox: "0 0 100 100",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, react.createElement("path", {
  d: "M47.1468 13.7811C48.0449 11.0172 51.9551 11.0172 52.8532 13.7812L60.5522 37.4762C60.9538 38.7123 62.1056 39.5491 63.4053 39.5491H88.3198C91.226 39.5491 92.4343 43.268 90.0831 44.9762L69.9269 59.6205C68.8755 60.3845 68.4355 61.7386 68.8371 62.9746L76.5361 86.6697C77.4342 89.4336 74.2707 91.732 71.9196 90.0238L51.7634 75.3794C50.7119 74.6155 49.2881 74.6155 48.2366 75.3795L28.0804 90.0238C25.7293 91.732 22.5659 89.4336 23.4639 86.6697L31.1629 62.9746C31.5645 61.7386 31.1245 60.3845 30.0731 59.6205L9.91686 44.9762C7.56572 43.268 8.77405 39.5491 11.6802 39.5491H36.5947C37.8944 39.5491 39.0462 38.7123 39.4478 37.4762L47.1468 13.7811Z",
  fill: "currentColor"
}));

const EditorWrap = (0,styled/* default */.Z)('div')({
  name: "EditorWrap",
  class: "e8nv6xj"
});
const renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "star-cell",
  needsHover: true,
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount
    } = args;
    const {
      rating
    } = cell.data;
    const padX = theme.cellHorizontalPadding;
    let drawX = rect.x + padX;
    const stars = Math.min(5, Math.ceil(rating));
    drawX += 8;
    ctx.beginPath();

    for (let i = 0; i < stars; i++) {
      pathStar(ctx, [drawX, rect.y + rect.height / 2], 16);
      drawX += 18;
    }

    ctx.fillStyle = theme.textDark;
    ctx.globalAlpha = 0.6 + 0.4 * hoverAmount;
    ctx.fill();
    ctx.globalAlpha = 1;
    return true;
  },
  provideEditor: () => {
    return p => react.createElement(EditorWrap, null, [0, 1, 2, 3, 4].map(index => react.createElement("div", {
      key: index,
      className: p.value.data.rating < index + 1 ? "inactive" : "active",
      onClick: () => {
        p.onChange({ ...p.value,
          data: { ...p.value.data,
            rating: index + 1
          }
        });
      }
    }, react.createElement(StarSVG, null))));
  },
  onPaste: (val, d) => {
    const num = Number.parseInt(val);
    return { ...d,
      rating: Number.isNaN(num) ? 0 : num
    };
  }
};
/* harmony default export */ const star_cell = (renderer);

__webpack_require__("./packages/cells/src/cells/star-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/star-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/sparkline-cell.tsx

const sparkline_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "sparkline-cell",
  needsHover: true,
  needsHoverPosition: true,
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount,
      hoverX
    } = args;
    let {
      values,
      yAxis,
      color,
      graphKind = "line",
      displayValues
    } = cell.data;
    const [minY, maxY] = yAxis;
    if (values.length === 0) return true;
    values = values.map(x => Math.min(1, Math.max(0, (x - minY) / (maxY - minY))));
    const padX = theme.cellHorizontalPadding;
    const drawX = padX + rect.x;
    const y = rect.y + 3;
    const height = rect.height - 6;
    const width = rect.width - padX * 2;
    const delta = maxY - minY;
    const zeroY = maxY <= 0 ? y : minY >= 0 ? y + height : y + height * (maxY / delta);

    if (minY <= 0 && maxY >= 0) {
      ctx.beginPath();
      ctx.moveTo(drawX, zeroY);
      ctx.lineTo(drawX + width, zeroY);
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 1;
      ctx.strokeStyle = theme.textLight;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (graphKind === "bar") {
      var _cell$data$color;

      ctx.beginPath();
      const margin = 2;
      const spacing = (values.length - 1) * margin;
      const barWidth = (width - spacing) / values.length;
      let x = drawX;

      for (const val of values) {
        const barY = y + height - val * height;
        ctx.moveTo(x, zeroY);
        ctx.lineTo(x + barWidth, zeroY);
        ctx.lineTo(x + barWidth, barY);
        ctx.lineTo(x, barY);
        x += barWidth + margin;
      }

      ctx.fillStyle = (_cell$data$color = cell.data.color) !== null && _cell$data$color !== void 0 ? _cell$data$color : theme.accentColor;
      ctx.fill();
    } else {
      if (values.length === 1) values = [values[0], values[0]];
      ctx.beginPath();
      const xStep = (rect.width - 16) / (values.length - 1);
      const points = values.map((val, ind) => {
        return {
          x: drawX + xStep * ind,
          y: y + height - val * height
        };
      });
      ctx.moveTo(points[0].x, points[0].y);
      let i;

      for (i = 1; i < points.length - 2; i++) {
        const xControl = (points[i].x + points[i + 1].x) / 2;
        const yControl = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(points[i].x, points[i].y, xControl, yControl);
      }

      ctx.quadraticCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y);
      ctx.strokeStyle = color !== null && color !== void 0 ? color : theme.accentColor;
      ctx.lineWidth = 1 + hoverAmount * 0.5;
      ctx.stroke();
      ctx.lineTo(rect.x + rect.width - padX, zeroY);
      ctx.lineTo(rect.x + padX, zeroY);
      ctx.closePath();
      ctx.globalAlpha = 0.2 + 0.2 * hoverAmount;
      const grad = ctx.createLinearGradient(0, y, 0, y + height * 1.4);
      grad.addColorStop(0, color !== null && color !== void 0 ? color : theme.accentColor);
      const [r, g, b] = (0,js/* parseToRgba */.dF)(color !== null && color !== void 0 ? color : theme.accentColor);
      grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.globalAlpha = 1;

      if (hoverX !== undefined && graphKind === "line" && displayValues !== undefined) {
        ctx.beginPath();
        const closest = Math.min(values.length - 1, Math.max(0, Math.round((hoverX - padX) / xStep)));
        ctx.moveTo(drawX + closest * xStep, rect.y);
        ctx.lineTo(drawX + closest * xStep, rect.y + rect.height);
        ctx.lineWidth = 1;
        ctx.strokeStyle = theme.textLight;
        ctx.stroke();
        ctx.save();
        ctx.font = `8px ${theme.fontFamily}`;
        ctx.fillStyle = theme.textMedium;
        ctx.textBaseline = "top";
        ctx.fillText(displayValues[closest], drawX, rect.y + theme.cellVerticalPadding);
        ctx.restore();
      }
    }

    return true;
  },
  provideEditor: () => undefined,
  onPaste: (_v, d) => d
};
/* harmony default export */ const sparkline_cell = (sparkline_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/draw-fns.ts
function roundedRect(ctx, x, y, width, height, radius) {
  if (radius === 0) {
    ctx.rect(x, y, width, height);
    return;
  }

  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }

  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}
;// CONCATENATED MODULE: ./packages/cells/src/cells/tags-cell.tsx




const tagHeight = 20;
const innerPad = 6;
const tags_cell_EditorWrap = (0,styled/* default */.Z)('div')({
  name: "EditorWrap",
  class: "e14vzbfa",
  vars: {
    "e14vzbfa-0": [p => p.tagHeight / 2, "px"],
    "e14vzbfa-1": [p => p.tagHeight, "px"],
    "e14vzbfa-2": [p => p.innerPad, "px"]
  }
});
const tags_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "tags-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      possibleTags,
      tags
    } = cell.data;
    const drawArea = {
      x: rect.x + theme.cellHorizontalPadding,
      y: rect.y + theme.cellVerticalPadding,
      width: rect.width - 2 * theme.cellHorizontalPadding,
      height: rect.height - 2 * theme.cellVerticalPadding
    };
    const rows = Math.max(1, Math.floor(drawArea.height / (tagHeight + innerPad)));
    let x = drawArea.x;
    let row = 1;
    let y = drawArea.y + (drawArea.height - rows * tagHeight - (rows - 1) * innerPad) / 2;

    for (const tag of tags) {
      var _possibleTags$find$co, _possibleTags$find;

      const color = (_possibleTags$find$co = (_possibleTags$find = possibleTags.find(t => t.tag === tag)) === null || _possibleTags$find === void 0 ? void 0 : _possibleTags$find.color) !== null && _possibleTags$find$co !== void 0 ? _possibleTags$find$co : theme.bgBubble;
      ctx.font = `12px ${theme.fontFamily}`;
      const metrics = (0,js/* measureTextCached */.P7)(tag, ctx);
      const width = metrics.width + innerPad * 2;
      const textY = tagHeight / 2;

      if (x !== drawArea.x && x + width > drawArea.x + drawArea.width && row < rows) {
        row++;
        y += tagHeight + innerPad;
        x = drawArea.x;
      }

      ctx.fillStyle = color;
      ctx.beginPath();
      roundedRect(ctx, x, y, width, tagHeight, tagHeight / 2);
      ctx.fill();
      ctx.fillStyle = theme.textDark;
      ctx.fillText(tag, x + innerPad, y + textY + (0,js/* getMiddleCenterBias */.aX)(ctx, `12px ${theme.fontFamily}`));
      x += width + 8;
      if (x > drawArea.x + drawArea.width && row >= rows) break;
    }

    return true;
  },
  provideEditor: () => {
    return p => {
      const {
        onChange,
        value
      } = p;
      const {
        possibleTags,
        tags,
        readonly = false
      } = value.data;
      return react.createElement(tags_cell_EditorWrap, {
        tagHeight: tagHeight,
        innerPad: innerPad,
        className: readonly ? "readonly" : ""
      }, possibleTags.map(t => {
        const selected = tags.indexOf(t.tag) !== -1;
        return react.createElement("label", {
          key: t.tag
        }, !readonly && react.createElement("input", {
          className: "gdg-input",
          type: "checkbox",
          checked: selected,
          onChange: () => {
            const newTags = selected ? tags.filter(x => x !== t.tag) : [...tags, t.tag];
            onChange({ ...p.value,
              data: { ...value.data,
                tags: newTags
              }
            });
          }
        }), react.createElement("div", {
          className: "pill " + (selected ? "selected" : "unselected"),
          style: {
            backgroundColor: selected ? t.color : undefined
          }
        }, t.tag));
      }));
    };
  },
  onPaste: (v, d) => ({ ...d,
    tags: d.possibleTags.map(x => x.tag).filter(x => v.split(",").map(s => s.trim()).includes(x))
  })
};
/* harmony default export */ const tags_cell = (tags_cell_renderer);

__webpack_require__("./packages/cells/src/cells/tags-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/tags-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/user-profile-cell.tsx


const user_profile_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "user-profile-cell",
  draw: (args, cell) => {
    const {
      ctx,
      rect,
      theme,
      imageLoader,
      col,
      row
    } = args;
    const {
      image,
      name,
      initial,
      tint
    } = cell.data;
    const xPad = theme.cellHorizontalPadding;
    const radius = Math.min(12, rect.height / 2 - theme.cellVerticalPadding);
    const drawX = rect.x + xPad;
    const imageResult = imageLoader.loadOrGetImage(image, col, row);
    ctx.save();
    ctx.beginPath();
    ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = tint;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.font = `600 16px ${theme.fontFamily}`;
    const metrics = (0,js/* measureTextCached */.P7)(initial[0], ctx);
    ctx.fillText(initial[0], drawX + radius - metrics.width / 2, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, `600 16px ${theme.fontFamily}`));

    if (imageResult !== undefined) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(drawX + radius, rect.y + rect.height / 2, radius, 0, Math.PI * 2);
      ctx.clip();
      ctx.drawImage(imageResult, drawX, rect.y + rect.height / 2 - radius, radius * 2, radius * 2);
      ctx.restore();
    }

    if (name !== undefined) {
      ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
      ctx.fillStyle = theme.textDark;
      ctx.fillText(name, drawX + radius * 2 + xPad, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, theme));
    }

    ctx.restore();
    return true;
  },
  provideEditor: () => p => {
    var _value$data$name;

    const {
      isHighlighted,
      onChange,
      value
    } = p;
    return react.createElement(js/* TextCellEntry */.t5, {
      highlight: isHighlighted,
      autoFocus: true,
      value: (_value$data$name = value.data.name) !== null && _value$data$name !== void 0 ? _value$data$name : "",
      onChange: e => onChange({ ...value,
        data: { ...value.data,
          name: e.target.value
        }
      })
    });
  },
  onPaste: (v, d) => ({ ...d,
    name: v
  })
};
/* harmony default export */ const user_profile_cell = (user_profile_cell_renderer);
// EXTERNAL MODULE: ./node_modules/react-select/dist/react-select.esm.js + 12 modules
var react_select_esm = __webpack_require__("./node_modules/react-select/dist/react-select.esm.js");
// EXTERNAL MODULE: ./node_modules/react-select/dist/index-a7690a33.esm.js + 2 modules
var index_a7690a33_esm = __webpack_require__("./node_modules/react-select/dist/index-a7690a33.esm.js");
;// CONCATENATED MODULE: ./packages/cells/src/cells/dropdown-cell.tsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }






const CustomMenu = p => {
  const {
    Menu
  } = index_a7690a33_esm.c;
  const {
    children,
    ...rest
  } = p;
  return react.createElement(Menu, rest, children);
};

const Wrap = (0,styled/* default */.Z)('div')({
  name: "Wrap",
  class: "wg6ppx4"
});
const PortalWrap = (0,styled/* default */.Z)('div')({
  name: "PortalWrap",
  class: "p7jnwoo"
});

const Editor = p => {
  const {
    value: cell,
    onFinishedEditing,
    initialValue
  } = p;
  const {
    allowedValues,
    value: valueIn
  } = cell.data;
  const [value, setValue] = react.useState(valueIn);
  const [inputValue, setInputValue] = react.useState(initialValue !== null && initialValue !== void 0 ? initialValue : "");
  const theme = (0,js/* useTheme */.Fg)();
  const values = react.useMemo(() => allowedValues.map(x => ({
    value: x,
    label: x
  })), [allowedValues]);
  return react.createElement(Wrap, null, react.createElement(react_select_esm/* default */.ZP, {
    className: "glide-select",
    inputValue: inputValue,
    onInputChange: setInputValue,
    menuPlacement: "auto",
    value: values.find(x => x.value === value),
    styles: {
      control: base => ({ ...base,
        border: 0,
        boxShadow: "none"
      })
    },
    theme: t => {
      return { ...t,
        colors: { ...t.colors,
          neutral0: theme.bgCell,
          neutral5: theme.bgCell,
          neutral10: theme.bgCell,
          neutral20: theme.bgCellMedium,
          neutral30: theme.bgCellMedium,
          neutral40: theme.bgCellMedium,
          neutral50: theme.textLight,
          neutral60: theme.textMedium,
          neutral70: theme.textMedium,
          neutral80: theme.textDark,
          neutral90: theme.textDark,
          neutral100: theme.textDark,
          primary: theme.accentColor,
          primary75: theme.accentColor,
          primary50: theme.accentColor,
          primary25: theme.accentLight
        }
      };
    },
    menuPortalTarget: document.getElementById("portal"),
    autoFocus: true,
    openMenuOnFocus: true,
    components: {
      DropdownIndicator: () => null,
      IndicatorSeparator: () => null,
      Menu: props => react.createElement(PortalWrap, null, react.createElement(CustomMenu, _extends({
        className: "click-outside-ignore"
      }, props)))
    },
    options: values,
    onChange: async e => {
      if (e === null) return;
      setValue(e.value);
      await new Promise(r => window.requestAnimationFrame(r));
      onFinishedEditing({ ...cell,
        data: { ...cell.data,
          value: e.value
        }
      });
    }
  }));
};

const dropdown_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "dropdown-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      value
    } = cell.data;
    ctx.fillStyle = theme.textDark;
    ctx.fillText(value, rect.x + theme.cellHorizontalPadding, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, theme));
    return true;
  },
  provideEditor: () => ({
    editor: Editor,
    disablePadding: true,
    deletedValue: v => ({ ...v,
      copyData: "",
      data: { ...v.data,
        value: ""
      }
    })
  }),
  onPaste: (v, d) => ({ ...d,
    value: d.allowedValues.includes(v) ? v : d.value
  })
};
/* harmony default export */ const dropdown_cell = (dropdown_cell_renderer);

__webpack_require__("./packages/cells/src/cells/dropdown-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/dropdown-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/article-cell.tsx


const ArticleCellEditor = react.lazy(async () => await Promise.all(/* import() */[__webpack_require__.e(296), __webpack_require__.e(858)]).then(__webpack_require__.bind(__webpack_require__, "./packages/cells/src/cells/article-cell-editor.tsx")));
const article_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "article-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      markdown
    } = cell.data;
    let data = markdown;

    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }

    const max = rect.width / 4;

    if (data.length > max) {
      data = data.slice(0, max);
    }

    ctx.fillStyle = theme.textDark;
    ctx.fillText(data, rect.x + theme.cellHorizontalPadding, rect.y + rect.height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, theme));
    return true;
  },
  provideEditor: () => ({
    editor: p => {
      return react.createElement(react.Suspense, {
        fallback: null
      }, react.createElement(ArticleCellEditor, p));
    },
    styleOverride: {
      position: "fixed",
      left: "12.5vw",
      top: "12.5vh",
      width: "75vw",
      borderRadius: "9px",
      maxWidth: "unset",
      maxHeight: "unset"
    },
    disablePadding: true
  }),
  onPaste: (val, d) => ({ ...d,
    markdown: val
  })
};
/* harmony default export */ const article_cell = (article_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/range-cell.tsx



const RANGE_HEIGHT = 6;
const inputStyle = {
  marginRight: 8
};
const wrapperStyle = {
  display: "flex",
  alignItems: "center",
  flexGrow: 1
};
const range_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "range-cell",
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect
    } = args;
    const {
      min,
      max,
      value,
      label,
      measureLabel
    } = cell.data;
    const x = rect.x + theme.cellHorizontalPadding;
    const yMid = rect.y + rect.height / 2;
    const rangeSize = max - min;
    const fillRatio = (value - min) / rangeSize;
    ctx.save();
    let labelWidth = 0;

    if (label !== undefined) {
      ctx.font = `12px ${theme.fontFamily}`;
      labelWidth = (0,js/* measureTextCached */.P7)(measureLabel !== null && measureLabel !== void 0 ? measureLabel : label, ctx, `12px ${theme.fontFamily}`).width + theme.cellHorizontalPadding;
    }

    const rangeWidth = rect.width - theme.cellHorizontalPadding * 2 - labelWidth;
    const gradient = ctx.createLinearGradient(x, yMid, x + rangeWidth, yMid);
    gradient.addColorStop(0, theme.accentColor);
    gradient.addColorStop(fillRatio, theme.accentColor);
    gradient.addColorStop(fillRatio, theme.bgBubble);
    gradient.addColorStop(1, theme.bgBubble);
    ctx.beginPath();
    ctx.fillStyle = gradient;
    roundedRect(ctx, x, yMid - RANGE_HEIGHT / 2, rangeWidth, RANGE_HEIGHT, RANGE_HEIGHT / 2);
    ctx.fill();
    ctx.beginPath();
    roundedRect(ctx, x + 0.5, yMid - RANGE_HEIGHT / 2 + 0.5, rangeWidth - 1, RANGE_HEIGHT - 1, (RANGE_HEIGHT - 1) / 2);
    ctx.strokeStyle = theme.accentLight;
    ctx.lineWidth = 1;
    ctx.stroke();

    if (label !== undefined) {
      ctx.textAlign = "right";
      ctx.fillStyle = theme.textDark;
      ctx.fillText(label, rect.x + rect.width - theme.cellHorizontalPadding, yMid + (0,js/* getMiddleCenterBias */.aX)(ctx, `12px ${theme.fontFamily}`));
    }

    ctx.restore();
    return true;
  },
  provideEditor: () => {
    return p => {
      const {
        data
      } = p.value;
      const strValue = data.value.toString();
      const strMin = data.min.toString();
      const strMax = data.max.toString();
      const strStep = data.step.toString();

      const onChange = e => {
        p.onChange({ ...p.value,
          data: { ...data,
            value: Number(e.target.value)
          }
        });
      };

      return react.createElement("label", {
        style: wrapperStyle
      }, react.createElement("input", {
        style: inputStyle,
        type: "range",
        value: strValue,
        min: strMin,
        max: strMax,
        step: strStep,
        onChange: onChange
      }), strValue);
    };
  },
  onPaste: (v, d) => {
    let num = Number.parseFloat(v);
    num = Number.isNaN(num) ? d.value : Math.max(d.min, Math.min(d.max, num));
    return { ...d,
      value: num
    };
  }
};
/* harmony default export */ const range_cell = (range_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/spinner-cell.tsx

const spinner_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "spinner-cell",
  draw: args => {
    const {
      ctx,
      theme,
      rect,
      requestAnimationFrame
    } = args;
    const progress = window.performance.now() % 1000 / 1000;
    const x = rect.x + rect.width / 2;
    const y = rect.y + rect.height / 2;
    ctx.arc(x, y, Math.min(12, rect.height / 2 - 2), Math.PI * 2 * progress, Math.PI * 2 * progress + Math.PI * 1.5);
    ctx.strokeStyle = theme.textMedium;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.lineWidth = 1;
    requestAnimationFrame();
    return true;
  },
  provideEditor: () => undefined
};
/* harmony default export */ const spinner_cell = (spinner_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/date-picker-cell.tsx


const date_picker_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: cell => cell.data.kind === "date-picker-cell",
  draw: (args, cell) => {
    const {
      displayDate
    } = cell.data;
    (0,js/* drawTextCell */.uN)(args, displayDate, cell.contentAlign);
    return true;
  },
  provideEditor: () => p => {
    const cellData = p.value.data;
    const {
      format,
      date
    } = cellData;
    let val = "";

    if (date !== undefined) {
      val = date.toISOString();

      if (format === "date") {
        val = val.split("T")[0];
      }
    }

    return react.createElement("input", {
      style: {
        minHeight: 26,
        border: "none",
        outline: "none"
      },
      type: format,
      autoFocus: true,
      value: val,
      onChange: e => {
        var _e$target$valueAsDate;

        p.onChange({ ...p.value,
          data: { ...p.value.data,
            date: (_e$target$valueAsDate = e.target.valueAsDate) !== null && _e$target$valueAsDate !== void 0 ? _e$target$valueAsDate : undefined
          }
        });
      }
    });
  },
  onPaste: (v, d) => {
    let newDate;

    try {
      newDate = new Date(v);
    } catch {}

    return { ...d,
      date: Number.isNaN(newDate) ? undefined : newDate
    };
  }
};
/* harmony default export */ const date_picker_cell = (date_picker_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/cells/links-cell.tsx




function onClickSelect(e) {
  const useCtrl = e.cell.data.navigateOn !== "click";
  if (useCtrl !== e.ctrlKey) return undefined;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d", {
    alpha: false
  });
  if (ctx === null) return;
  const {
    posX: hoverX,
    bounds: rect,
    cell,
    theme
  } = e;
  const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
  ctx.font = font;
  const {
    links
  } = cell.data;
  const xPad = theme.cellHorizontalPadding;
  let drawX = rect.x + xPad;
  const rectHoverX = rect.x + hoverX;

  for (const [index, l] of links.entries()) {
    const needsComma = index < links.length - 1;
    const metrics = (0,js/* measureTextCached */.P7)(l.title, ctx);
    const commaMetrics = needsComma ? (0,js/* measureTextCached */.P7)(l.title + ",", ctx, font) : metrics;
    const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;

    if (isHovered) {
      return l;
    }

    drawX += commaMetrics.width + 4;
  }

  return undefined;
}

const links_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  needsHover: true,
  needsHoverPosition: true,
  isMatch: c => c.data.kind === "links-cell",
  onSelect: e => {
    if (onClickSelect(e) !== undefined) {
      e.preventDefault();
    }
  },
  onClick: e => {
    const hovered = onClickSelect(e);

    if (hovered !== undefined) {
      var _hovered$onClick;

      (_hovered$onClick = hovered.onClick) === null || _hovered$onClick === void 0 ? void 0 : _hovered$onClick.call(hovered);
      e.preventDefault();
    }

    return undefined;
  },
  draw: (args, cell) => {
    const {
      ctx,
      rect,
      theme,
      hoverX = -100,
      highlighted
    } = args;
    const {
      links,
      underlineOffset = 5
    } = cell.data;
    const xPad = theme.cellHorizontalPadding;
    let drawX = rect.x + xPad;
    const rectHoverX = rect.x + hoverX;
    const font = `${theme.baseFontStyle} ${theme.fontFamily}`;
    const middleCenterBias = (0,js/* getMiddleCenterBias */.aX)(ctx, font);
    const drawY = rect.y + rect.height / 2 + middleCenterBias;

    for (const [index, l] of links.entries()) {
      const needsComma = index < links.length - 1;
      const metrics = (0,js/* measureTextCached */.P7)(l.title, ctx);
      const commaMetrics = needsComma ? (0,js/* measureTextCached */.P7)(l.title + ",", ctx, font) : metrics;
      const isHovered = rectHoverX > drawX && rectHoverX < drawX + metrics.width;

      if (isHovered) {
        ctx.moveTo(drawX, Math.floor(drawY + underlineOffset) + 0.5);
        ctx.lineTo(drawX + metrics.width, Math.floor(drawY + underlineOffset) + 0.5);
        ctx.strokeStyle = theme.textDark;
        ctx.stroke();
        ctx.fillStyle = highlighted ? (0,js/* blend */.NH)(theme.accentLight, theme.bgCell) : theme.bgCell;
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX - 1, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX + 1, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX - 2, drawY);
        ctx.fillText(needsComma ? l.title + "," : l.title, drawX + 2, drawY);
      }

      ctx.fillStyle = theme.textDark;
      ctx.fillText(needsComma ? l.title + "," : l.title, drawX, drawY);
      drawX += commaMetrics.width + 4;
    }

    return true;
  },
  provideEditor: () => p => {
    const {
      value,
      onChange
    } = p;
    const {
      links,
      maxLinks = Number.MAX_SAFE_INTEGER
    } = value.data;
    return react.createElement(LinksCellEditorStyle, {
      onKeyDown: ignoreTab
    }, links.map((l, i) => {
      var _l$href;

      return react.createElement(LinkTitleEditor, {
        key: i,
        link: (_l$href = l.href) !== null && _l$href !== void 0 ? _l$href : "",
        title: l.title,
        focus: i === 0,
        onDelete: links.length > 1 ? () => {
          const newLinks = [...links];
          newLinks.splice(i, 1);
          onChange({ ...value,
            data: { ...value.data,
              links: newLinks
            }
          });
        } : undefined,
        onChange: (link, title) => {
          const newLinks = [...links];
          newLinks[i] = {
            href: link,
            title
          };
          onChange({ ...value,
            data: { ...value.data,
              links: newLinks
            }
          });
        }
      });
    }), react.createElement("button", {
      disabled: links.length >= maxLinks,
      className: "add-link",
      onClick: () => {
        const newLinks = [...links, {
          title: ""
        }];
        onChange({ ...value,
          data: { ...value.data,
            links: newLinks
          }
        });
      }
    }, "Add link"));
  },
  onPaste: (v, d) => {
    const split = v.split(",");
    if (d.links.some((l, i) => split[i] !== l.title)) return undefined;
    return { ...d,
      links: split.map(l => ({
        title: l
      }))
    };
  }
};
const LinksCellEditorStyle = (0,styled/* default */.Z)('div')({
  name: "LinksCellEditorStyle",
  class: "lld219p"
});

function ignoreTab(e) {
  if (e.key === "Tab") {
    e.stopPropagation();
  }
}

const LinkTitleEditor = p => {
  const {
    link,
    onChange,
    title,
    onDelete,
    focus
  } = p;
  return react.createElement("div", {
    className: "gdg-link-title-editor"
  }, react.createElement("input", {
    className: "gdg-title-input",
    value: title,
    placeholder: "Title",
    autoFocus: focus,
    onChange: e => {
      onChange(link, e.target.value);
    }
  }), react.createElement("input", {
    className: "gdg-link-input",
    value: link,
    placeholder: "URL",
    onChange: e => {
      onChange(e.target.value, title);
    }
  }), onDelete !== undefined && react.createElement("button", {
    onClick: onDelete
  }, react.createElement("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 24 24",
    fill: "none",
    id: "icon-import",
    xmlns: "http://www.w3.org/2000/svg"
  }, react.createElement("path", {
    d: "M3 6L5 6L21 6",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M17.9019 6C18.491 6 18.9525 6.50676 18.8975 7.09334L17.67 20.1867C17.5736 21.2144 16.711 22 15.6787 22H8.32127C7.28902 22 6.42635 21.2144 6.33 20.1867L5.1025 7.09334C5.04751 6.50676 5.50898 6 6.09813 6H17.9019Z",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M14.4499 10.211L13.9949 17",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M9.55499 10.211L10.0049 17",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), react.createElement("path", {
    d: "M7.5 2.25H16.5",
    stroke: "currentColor",
    strokeWidth: "1px",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }))));
};

/* harmony default export */ const links_cell = (links_cell_renderer);

__webpack_require__("./packages/cells/src/cells/links-cell.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cells/links-cell.tsx");
;// CONCATENATED MODULE: ./packages/cells/src/cells/button-cell.tsx



function unpackColor(color, theme, hoverAmount) {
  if (typeof color === "string") {
    if (theme[color] !== undefined) return theme[color];
    return color;
  }

  let [normal, hover] = color;
  if (theme[normal] !== undefined) normal = theme[normal];
  if (theme[hover] !== undefined) hover = theme[hover];
  return (0,js/* interpolateColors */.Nz)(normal, hover, hoverAmount);
}

const button_cell_renderer = {
  kind: js/* GridCellKind.Custom */.p6.Custom,
  isMatch: c => c.data.kind === "button-cell",
  needsHover: true,
  onSelect: a => a.preventDefault(),
  onClick: a => {
    var _a$cell$data$onClick, _a$cell$data;

    (_a$cell$data$onClick = (_a$cell$data = a.cell.data).onClick) === null || _a$cell$data$onClick === void 0 ? void 0 : _a$cell$data$onClick.call(_a$cell$data);
    return undefined;
  },
  drawPrep: args => {
    const {
      ctx
    } = args;
    ctx.textAlign = "center";
    return {
      deprep: a => {
        a.ctx.textAlign = "start";
      }
    };
  },
  draw: (args, cell) => {
    const {
      ctx,
      theme,
      rect,
      hoverAmount
    } = args;
    const {
      title,
      backgroundColor,
      color,
      borderColor,
      borderRadius
    } = cell.data;
    const x = Math.floor(rect.x + theme.cellHorizontalPadding + 1);
    const y = Math.floor(rect.y + theme.cellVerticalPadding + 1);
    const width = Math.ceil(rect.width - theme.cellHorizontalPadding * 2 - 1);
    const height = Math.ceil(rect.height - theme.cellVerticalPadding * 2 - 1);

    if (backgroundColor !== undefined) {
      ctx.beginPath();
      roundedRect(ctx, x, y, width, height, borderRadius !== null && borderRadius !== void 0 ? borderRadius : 0);
      ctx.fillStyle = unpackColor(backgroundColor, theme, hoverAmount);
      ctx.fill();
    }

    if (borderColor !== undefined) {
      ctx.beginPath();
      roundedRect(ctx, x + 0.5, y + 0.5, width - 1, height - 1, borderRadius !== null && borderRadius !== void 0 ? borderRadius : 0);
      ctx.strokeStyle = unpackColor(borderColor, theme, hoverAmount);
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.fillStyle = unpackColor(color !== null && color !== void 0 ? color : theme.accentColor, theme, hoverAmount);
    ctx.fillText(title, x + width / 2, y + height / 2 + (0,js/* getMiddleCenterBias */.aX)(ctx, `${theme.baseFontStyle} ${theme.fontFamily}`));
    return true;
  },
  provideEditor: undefined
};
/* harmony default export */ const button_cell = (button_cell_renderer);
;// CONCATENATED MODULE: ./packages/cells/src/index.ts












const cells = [star_cell, sparkline_cell, tags_cell, user_profile_cell, dropdown_cell, article_cell, spinner_cell, range_cell, date_picker_cell, links_cell, button_cell];
function useExtraCells() {
  return (0,js/* useCustomCells */.R$)(cells);
}

// EXTERNAL MODULE: ./node_modules/lodash/range.js
var range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(range);
// EXTERNAL MODULE: ./node_modules/lodash/uniq.js
var uniq = __webpack_require__("./node_modules/lodash/uniq.js");
var uniq_default = /*#__PURE__*/__webpack_require__.n(uniq);
// EXTERNAL MODULE: ./node_modules/react-resize-detector/build/index.esm.js
var index_esm = __webpack_require__("./node_modules/react-resize-detector/build/index.esm.js");
// EXTERNAL MODULE: ./node_modules/@toast-ui/editor/dist/toastui-editor.css
var toastui_editor = __webpack_require__("./node_modules/@toast-ui/editor/dist/toastui-editor.css");
// EXTERNAL MODULE: ./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./packages/core/dist/index.css
var dist = __webpack_require__("./node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[4].use[1]!./packages/core/dist/index.css");
;// CONCATENATED MODULE: ./packages/core/dist/index.css

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = injectStylesIntoStyleTag_default()(dist/* default */.Z, options);



/* harmony default export */ const core_dist = (dist/* default.locals */.Z.locals || {});
;// CONCATENATED MODULE: ./packages/cells/src/cell.stories.tsx
function cell_stories_extends() { cell_stories_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return cell_stories_extends.apply(this, arguments); }










const SimpleWrapper = (0,styled/* default */.Z)('div')({
  name: "SimpleWrapper",
  class: "s1wvhs74"
});

const SimpleThemeWrapper = p => {
  return react.createElement(SimpleWrapper, null, react.createElement("div", {
    className: "content"
  }, p.children));
};

/* harmony default export */ const cell_stories = ({
  title: "Extra Packages/Cells",
  decorators: [Story => react.createElement(SimpleThemeWrapper, null, react.createElement(Story, null))]
});
const BeautifulStyle = (0,styled/* default */.Z)('div')({
  name: "BeautifulStyle",
  class: "b16aqpip"
});

const BeautifulWrapper = p => {
  const {
    title,
    children,
    description
  } = p;
  const {
    ref,
    width,
    height
  } = (0,index_esm/* useResizeDetector */.NB)();
  return react.createElement(BeautifulStyle, null, react.createElement("h1", null, title), description, react.createElement("div", {
    className: "sizer"
  }, react.createElement("div", {
    className: "sizer-clip",
    ref: ref
  }, react.createElement("div", {
    style: {
      position: "relative",
      width: width !== null && width !== void 0 ? width : 100,
      height: height !== null && height !== void 0 ? height : 100
    }
  }, children))));
};

const Description = (0,styled/* default */.Z)('p')({
  name: "Description",
  class: "d1npx1y"
});
const defaultProps = {
  smoothScrollX: true,
  smoothScrollY: true,
  isDraggable: false,
  rowMarkers: "none",
  width: "100%"
};
let num = 1;

function rand() {
  return (num = num * 16807 % 2147483647) / 2147483647;
}

const possibleTags = [{
  tag: "Bug",
  color: "#ff4d4d35"
}, {
  tag: "Feature",
  color: "#35f8ff35"
}, {
  tag: "Enhancement",
  color: "#48ff5735"
}, {
  tag: "First Issue",
  color: "#436fff35"
}, {
  tag: "PR",
  color: "#e0ff3235"
}, {
  tag: "Assigned",
  color: "#ff1eec35"
}];
const CustomCells = () => {
  const cellProps = useExtraCells();
  return react.createElement(BeautifulWrapper, {
    title: "Custom cells",
    description: react.createElement(Description, null, "Some of our extension cells.")
  }, react.createElement(js/* DataEditor */.Nd, cell_stories_extends({}, defaultProps, cellProps, {
    onPaste: true,
    onCellEdited: function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return console.log("Edit Cell", ...args);
    },
    getCellContent: cell => {
      const [col, row] = cell;

      if (col === 0) {
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "star-cell",
            label: "Test",
            rating: 4
          }
        };
      } else if (col === 1) {
        num = row + 1;
        const values = range_default()(0, 15).map(() => rand() * 100 - 50);
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: false,
          copyData: "4",
          data: {
            kind: "sparkline-cell",
            values,
            displayValues: values.map(x => Math.round(x).toString()),
            color: row % 2 === 0 ? "#77c4c4" : "#D98466",
            yAxis: [-50, 50]
          }
        };
      } else if (col === 2) {
        num = row + 1;
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: false,
          copyData: "4",
          data: {
            kind: "sparkline-cell",
            values: range_default()(0, 15).map(() => rand() * 100 - 50),
            color: row % 2 === 0 ? "#77c4c4" : "#D98466",
            graphKind: "bar",
            yAxis: [-50, 50]
          }
        };
      } else if (col === 3) {
        num = row + 1;
        rand();
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "tags-cell",
            possibleTags: possibleTags,
            readonly: row % 2 === 0,
            tags: uniq_default()([possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag, possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag, possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag, possibleTags[Math.round(rand() * 1000) % possibleTags.length].tag])
          }
        };
      } else if (col === 4) {
        num = row + 1;
        rand();
        return {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "user-profile-cell",
            image: row % 2 ? undefined : "https://i.redd.it/aqc1hwhalsz71.jpg",
            initial: "B",
            tint: "#F1D86E",
            name: row % 5 ? undefined : "Bee bb"
          }
        };
      } else if (col === 5) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "dropdown-cell",
            allowedValues: ["Good", "Better", "Best"],
            value: "Good"
          }
        };
        return d;
      } else if (col === 6) {
        num = row + 1;
        rand();
        const v = rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "range-cell",
            min: 10,
            max: 30,
            value: 10 + Math.round(v * 20),
            step: 1,
            label: `${Math.round(v * 100)}%`,
            measureLabel: "100%"
          }
        };
        return d;
      } else if (col === 7) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "article-cell",
            markdown: "## This is a test"
          }
        };
        return d;
      } else if (col === 8) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "spinner-cell"
          }
        };
        return d;
      } else if (col === 9) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "date-picker-cell",
            date: new Date(),
            displayDate: new Date().toISOString(),
            format: "date"
          }
        };
        return d;
      } else if (col === 10) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          allowOverlay: true,
          copyData: "4",
          data: {
            kind: "links-cell",
            underlineOffset: 6,
            links: [{
              title: "Linky phone",
              onClick: () => alert("Click 1")
            }, {
              title: "Click the linky dinky",
              onClick: () => alert("Click 2")
            }]
          }
        };
        return d;
      } else if (col === 11) {
        num = row + 1;
        rand();
        const d = {
          kind: js/* GridCellKind.Custom */.p6.Custom,
          cursor: "pointer",
          allowOverlay: true,
          copyData: "4",
          readonly: true,
          data: {
            kind: "button-cell",
            backgroundColor: ["transparent", "#6572ffee"],
            color: ["accentColor", "accentFg"],
            borderColor: "#6572ffa0",
            borderRadius: 9,
            title: "View Details",
            onClick: () => window.alert("Button clicked")
          },
          themeOverride: {
            baseFontStyle: "700 12px"
          }
        };
        return d;
      }

      throw new Error("Fail");
    },
    columns: [{
      title: "Stars",
      width: 200
    }, {
      title: "Sparkline",
      width: 150
    }, {
      title: "Sparkline (bars)",
      width: 150
    }, {
      title: "Tags",
      width: 250
    }, {
      title: "Profile",
      width: 150
    }, {
      title: "Dropdown",
      width: 150
    }, {
      title: "Range",
      width: 150
    }, {
      title: "Article",
      width: 150
    }, {
      title: "Spinner",
      width: 150
    }, {
      title: "Date Picker",
      width: 150
    }, {
      title: "Links",
      width: 150
    }, {
      title: "Button",
      width: 120
    }],
    rows: 500
  })));
};
CustomCells.parameters = {
  options: {
    showPanel: false
  }
};
const CustomCellEditing = () => {
  const cellProps = useExtraCells();
  const data = react.useRef([]);
  return react.createElement(BeautifulWrapper, {
    title: "Custom cell editing",
    description: react.createElement(Description, null, "Cells can be edited and responding to copy/paste using the copyData attribute.")
  }, react.createElement(js/* DataEditor */.Nd, cell_stories_extends({}, defaultProps, cellProps, {
    onPaste: true,
    onCellEdited: (cell, newVal) => {
      if (newVal.kind !== js/* GridCellKind.Custom */.p6.Custom) return;

      if (dropdown_cell.isMatch(newVal)) {
        data.current[cell[1]] = newVal.data.value;
      }
    },
    getCellsForSelection: true,
    getCellContent: cell => {
      var _data$current$row;

      const [, row] = cell;
      const val = (_data$current$row = data.current[row]) !== null && _data$current$row !== void 0 ? _data$current$row : "A";
      return {
        kind: js/* GridCellKind.Custom */.p6.Custom,
        allowOverlay: true,
        copyData: val,
        data: {
          kind: "dropdown-cell",
          allowedValues: ["A", "B", "C"],
          value: val
        }
      };
    },
    columns: [{
      title: "Dropdown",
      width: 200
    }],
    rows: 500
  })));
};
CustomCellEditing.parameters = {
  options: {
    showPanel: false
  }
};

__webpack_require__("./packages/cells/src/cell.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/cells/src/cell.stories.tsx");

const __namedExportsOrder = ["CustomCells", "CustomCellEditing"];

/***/ }),

/***/ "./packages/core/src/common/browser-detect.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FR": () => (/* binding */ browserIsOSX),
/* harmony export */   "Pq": () => (/* binding */ browserIsSafari),
/* harmony export */   "uC": () => (/* binding */ browserIsFirefox)
/* harmony export */ });
class Lazy {
  constructor(fn) {
    this.fn = void 0;
    this.val = void 0;
    this.fn = fn;
  }

  get value() {
    var _this$val;

    return (_this$val = this.val) !== null && _this$val !== void 0 ? _this$val : this.val = this.fn();
  }

}

function lazy(fn) {
  return new Lazy(fn);
}

const browserIsFirefox = lazy(() => window.navigator.userAgent.includes("Firefox"));
const browserIsSafari = lazy(() => window.navigator.userAgent.includes("Mac OS") && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome"));
const browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith("mac"));

/***/ }),

/***/ "./packages/core/src/common/styles.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ni": () => (/* binding */ ThemeContext),
/* harmony export */   "Zu": () => (/* binding */ getDataEditorTheme),
/* harmony export */   "be": () => (/* binding */ makeCSSStyle)
/* harmony export */ });
/* unused harmony export useTheme */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");

function makeCSSStyle(theme) {
  var _theme$textGroupHeade, _theme$horizontalBord;

  return {
    "--gdg-accent-color": theme.accentColor,
    "--gdg-accent-fg": theme.accentFg,
    "--gdg-accent-light": theme.accentLight,
    "--gdg-text-dark": theme.textDark,
    "--gdg-text-medium": theme.textMedium,
    "--gdg-text-light": theme.textLight,
    "--gdg-text-bubble": theme.textBubble,
    "--gdg-bg-icon-header": theme.bgIconHeader,
    "--gdg-fg-icon-header": theme.fgIconHeader,
    "--gdg-text-header": theme.textHeader,
    "--gdg-text-group-header": (_theme$textGroupHeade = theme.textGroupHeader) !== null && _theme$textGroupHeade !== void 0 ? _theme$textGroupHeade : theme.textHeader,
    "--gdg-text-header-selected": theme.textHeaderSelected,
    "--gdg-bg-cell": theme.bgCell,
    "--gdg-bg-cell-medium": theme.bgCellMedium,
    "--gdg-bg-header": theme.bgHeader,
    "--gdg-bg-header-has-focus": theme.bgHeaderHasFocus,
    "--gdg-bg-header-hovered": theme.bgHeaderHovered,
    "--gdg-bg-bubble": theme.bgBubble,
    "--gdg-bg-bubble-selected": theme.bgBubbleSelected,
    "--gdg-bg-search-result": theme.bgSearchResult,
    "--gdg-border-color": theme.borderColor,
    "--gdg-horizontal-border-color": (_theme$horizontalBord = theme.horizontalBorderColor) !== null && _theme$horizontalBord !== void 0 ? _theme$horizontalBord : theme.borderColor,
    "--gdg-drilldown-border": theme.drilldownBorder,
    "--gdg-link-color": theme.linkColor,
    "--gdg-cell-horizontal-padding": `${theme.cellHorizontalPadding}px`,
    "--gdg-cell-vertical-padding": `${theme.cellVerticalPadding}px`,
    "--gdg-header-font-style": theme.headerFontStyle,
    "--gdg-base-font-style": theme.baseFontStyle,
    "--gdg-font-family": theme.fontFamily,
    "--gdg-editor-font-size": theme.editorFontSize
  };
}
const dataEditorBaseTheme = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#4F5DFF",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif",
  editorFontSize: "13px",
  lineHeight: 1.4
};
function getDataEditorTheme() {
  return dataEditorBaseTheme;
}
const ThemeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(dataEditorBaseTheme);
function useTheme() {
  return React.useContext(ThemeContext);
}

/***/ }),

/***/ "./packages/core/src/common/support.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NG": () => (/* binding */ proveType),
/* harmony export */   "hu": () => (/* binding */ assert),
/* harmony export */   "vE": () => (/* binding */ assertNever),
/* harmony export */   "vZ": () => (/* binding */ deepEqual),
/* harmony export */   "wY": () => (/* binding */ maybe)
/* harmony export */ });
function proveType(_val) {}

function panic() {
  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "This should not happen";
  throw new Error(message);
}

function assert(fact) {
  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";
  if (fact) return;
  return panic(message);
}
function assertNever(_never) {
  return panic("Hell froze over");
}
function maybe(fn, defaultValue) {
  try {
    return fn();
  } catch {
    return defaultValue;
  }
}
const has = Object.prototype.hasOwnProperty;
function deepEqual(foo, bar) {
  let ctor, len;
  if (foo === bar) return true;

  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();

    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && deepEqual(foo[len], bar[len]));
      }

      return len === -1;
    }

    if (!ctor || typeof foo === "object") {
      len = 0;

      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor])) return false;
      }

      return Object.keys(bar).length === len;
    }
  }

  return foo !== foo && bar !== bar;
}

/***/ }),

/***/ "./packages/core/src/common/utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ht": () => (/* binding */ degreesToRadians),
/* harmony export */   "Iz": () => (/* binding */ getScrollBarWidth),
/* harmony export */   "MC": () => (/* binding */ Checkmark),
/* harmony export */   "OR": () => (/* binding */ useEventListener),
/* harmony export */   "Qy": () => (/* binding */ useDebouncedMemo),
/* harmony export */   "Wy": () => (/* binding */ EditPencil),
/* harmony export */   "ig": () => (/* binding */ useStateWithReactiveInput),
/* harmony export */   "o7": () => (/* binding */ direction),
/* harmony export */   "qJ": () => (/* binding */ whenDefined)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1__);


function useEventListener(eventName, handler, element, passive) {
  let capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const savedHandler = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  savedHandler.current = handler;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (element === null || element.addEventListener === undefined) return;
    const el = element;

    const eventListener = event => {
      var _savedHandler$current;

      (_savedHandler$current = savedHandler.current) === null || _savedHandler$current === void 0 ? void 0 : _savedHandler$current.call(el, event);
    };

    el.addEventListener(eventName, eventListener, {
      passive,
      capture
    });
    return () => {
      el.removeEventListener(eventName, eventListener, {
        capture
      });
    };
  }, [eventName, element, passive, capture]);
}
function whenDefined(obj, result) {
  return obj === undefined ? undefined : result;
}
const PI = Math.PI;
function degreesToRadians(degrees) {
  return degrees * PI / 180;
}
const EditPencil = props => {
  var _props$fgColor;

  const fg = (_props$fgColor = props.fgColor) !== null && _props$fgColor !== void 0 ? _props$fgColor : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }));
};
const Checkmark = props => {
  var _props$fgColor2;

  const fg = (_props$fgColor2 = props.fgColor) !== null && _props$fgColor2 !== void 0 ? _props$fgColor2 : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M19 6L10.3802 17L5.34071 11.8758",
    vectorEffect: "non-scaling-stroke",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
function useDebouncedMemo(factory, deps, time) {
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(factory);
  const mountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => {
    mountedRef.current = false;
  }, []);
  const debouncedSetState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1___default()(x => {
    if (mountedRef.current) {
      setState(x);
    }
  }, time));
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (mountedRef.current) {
      debouncedSetState.current(() => factory());
    }
  }, deps);
  return state;
}
const rtlRange = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
const ltrRange = "A-Za-z\u00C0-\u00D6\u00D8-\u00F6" + "\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C" + "\uFE00-\uFE6F\uFEFD-\uFFFF";
const rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
const ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");
function direction(value) {
  return rtl.test(value) ? "rtl" : ltr.test(value) ? "ltr" : "neutral";
}
let scrollbarWidthCache = undefined;
function getScrollBarWidth() {
  if (scrollbarWidthCache !== undefined) return scrollbarWidthCache;
  const inner = document.createElement("p");
  inner.style.width = "100%";
  inner.style.height = "200px";
  const outer = document.createElement("div");
  outer.id = "testScrollbar";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.append(inner);
  document.body.append(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;

  if (w1 === w2) {
    w2 = outer.clientWidth;
  }

  outer.remove();
  scrollbarWidthCache = w1 - w2;
  return scrollbarWidthCache;
}
const empty = Symbol();
function useStateWithReactiveInput(inputState) {
  const inputStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([empty, inputState]);

  if (inputStateRef.current[1] !== inputState) {
    inputStateRef.current[0] = inputState;
  }

  inputStateRef.current[1] = inputState;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(inputState);
  const [, forceRender] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const setStateOuter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(nv => {
    const s = inputStateRef.current[0];

    if (s !== empty) {
      nv = typeof nv === "function" ? nv(s) : nv;
      if (nv === s) return;
    }

    if (s !== empty) forceRender({});
    setState(pv => {
      if (typeof nv === "function") {
        return nv(s === empty ? pv : s);
      }

      return nv;
    });
    inputStateRef.current[0] = empty;
  }, []);
  const onEmpty = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    inputStateRef.current[0] = empty;
    forceRender({});
  }, []);
  return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];
}

/***/ }),

/***/ "./packages/core/src/data-editor/data-editor.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "N": () => (/* binding */ DataEditor)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./packages/core/src/common/support.ts
var support = __webpack_require__("./packages/core/src/common/support.ts");
// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__("./node_modules/lodash/clamp.js");
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);
// EXTERNAL MODULE: ./node_modules/lodash/uniq.js
var uniq = __webpack_require__("./node_modules/lodash/uniq.js");
var uniq_default = /*#__PURE__*/__webpack_require__.n(uniq);
// EXTERNAL MODULE: ./node_modules/lodash/flatten.js
var flatten = __webpack_require__("./node_modules/lodash/flatten.js");
var flatten_default = /*#__PURE__*/__webpack_require__.n(flatten);
// EXTERNAL MODULE: ./node_modules/lodash/range.js
var range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(range);
// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__("./node_modules/lodash/debounce.js");
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__("./node_modules/react-dom/index.js");
;// CONCATENATED MODULE: ./packages/core/src/click-outside-container/click-outside-container.tsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }


class ClickOutsideContainer extends react.PureComponent {
  constructor() {
    super(...arguments);
    this.wrapperRef = react.createRef();

    this.clickOutside = event => {
      if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target)) {
        let node = event.target;

        while (node !== null) {
          if (node.classList.contains("click-outside-ignore")) {
            return;
          }

          node = node.parentElement;
        }

        this.props.onClickOutside();
      }
    };
  }

  componentDidMount() {
    document.addEventListener("mousedown", this.clickOutside, true);
    document.addEventListener("contextmenu", this.clickOutside, true);
  }

  componentWillUnmount() {
    document.removeEventListener("mousedown", this.clickOutside);
    document.removeEventListener("contextmenu", this.clickOutside);
  }

  render() {
    const {
      onClickOutside,
      ...rest
    } = this.props;
    return react.createElement("div", _extends({}, rest, {
      ref: this.wrapperRef
    }), this.props.children);
  }

}
// EXTERNAL MODULE: ./packages/core/src/common/styles.ts
var styles = __webpack_require__("./packages/core/src/common/styles.ts");
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-types.ts
var data_grid_types = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx

const DataGridOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "DataGridOverlayEditorStyle",
  class: "dpsd959",
  vars: {
    "dpsd959-0": [p => p.targetY, "px"],
    "dpsd959-1": [p => p.targetX - 1, "px"],
    "dpsd959-2": [p => p.targetY - 1, "px"],
    "dpsd959-3": [p => p.targetWidth + 2, "px"],
    "dpsd959-4": [p => p.targetHeight + 2, "px"],
    "dpsd959-5": [p => p.targetY + 10, "px"],
    "dpsd959-6": [p => Math.max(0, (p.targetHeight - 28) / 2), "px"]
  }
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/use-stay-on-screen.ts


function useRefState() {
  const [refState, setRefState] = react.useState();
  return [refState !== null && refState !== void 0 ? refState : undefined, setRefState];
}

function useStayOnScreen() {
  const [ref, setRef] = useRefState();
  const [xOffset, setXOffset] = react.useState(0);
  const [isIntersecting, setIsIntersecting] = react.useState(true);
  react.useLayoutEffect(() => {
    if (ref === undefined) return;
    if (!("IntersectionObserver" in window)) return;
    const observer = new IntersectionObserver(ents => {
      if (ents.length === 0) return;
      setIsIntersecting(ents[0].isIntersecting);
    }, {
      threshold: 1
    });
    observer.observe(ref);
    return () => observer.disconnect();
  }, [ref]);
  react.useEffect(() => {
    if (isIntersecting || ref === undefined) return;
    let rafHandle;

    const fn = () => {
      const {
        right: refRight
      } = ref.getBoundingClientRect();
      setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));
      rafHandle = requestAnimationFrame(fn);
    };

    rafHandle = requestAnimationFrame(fn);
    return () => {
      if (rafHandle !== undefined) {
        cancelAnimationFrame(rafHandle);
      }
    };
  }, [ref, isIntersecting]);
  const style = react.useMemo(() => {
    return {
      transform: `translateX(${xOffset}px)`
    };
  }, [xOffset]);
  return {
    ref: setRef,
    style
  };
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/data-grid-overlay-editor.tsx








const DataGridOverlayEditor = p => {
  const {
    target,
    content,
    onFinishEditing: onFinishEditingIn,
    forceEditMode,
    initialValue,
    imageEditorOverride,
    markdownDivCreateNode,
    highlight,
    className,
    theme,
    id,
    cell,
    validateCell,
    getCellRenderer,
    provideEditor
  } = p;
  const [tempValue, setTempValueRaw] = react.useState(forceEditMode ? content : undefined);
  const lastValueRef = react.useRef(tempValue !== null && tempValue !== void 0 ? tempValue : content);
  lastValueRef.current = tempValue !== null && tempValue !== void 0 ? tempValue : content;
  const [isValid, setIsValid] = react.useState(() => {
    if (validateCell === undefined) return true;
    return !((0,data_grid_types/* isEditableGridCell */.T9)(content) && (validateCell === null || validateCell === void 0 ? void 0 : validateCell(cell, content, lastValueRef.current)) === false);
  });
  const onFinishEditing = react.useCallback((newCell, movement) => {
    onFinishEditingIn(isValid ? newCell : undefined, movement);
  }, [isValid, onFinishEditingIn]);
  const setTempValue = react.useCallback(newVal => {
    if (validateCell !== undefined && newVal !== undefined && (0,data_grid_types/* isEditableGridCell */.T9)(newVal)) {
      const validResult = validateCell(cell, newVal, lastValueRef.current);

      if (validResult === false) {
        setIsValid(false);
      } else if (typeof validResult === "object") {
        newVal = validResult;
        setIsValid(true);
      } else {
        setIsValid(true);
      }
    }

    setTempValueRaw(newVal);
  }, [cell, validateCell]);
  const finished = react.useRef(false);
  const customMotion = react.useRef(undefined);
  const onClickOutside = react.useCallback(() => {
    onFinishEditing(tempValue, [0, 0]);
    finished.current = true;
  }, [tempValue, onFinishEditing]);
  const onEditorFinished = react.useCallback(newValue => {
    var _customMotion$current;

    onFinishEditing(newValue, (_customMotion$current = customMotion.current) !== null && _customMotion$current !== void 0 ? _customMotion$current : [0, 0]);
    finished.current = true;
  }, [onFinishEditing]);
  const onKeyDown = react.useCallback(async event => {
    let save = false;

    if (event.key === "Escape") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 0];
    } else if (event.key === "Enter" && !event.shiftKey) {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 1];
      save = true;
    } else if (event.key === "Tab") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [event.shiftKey ? -1 : 1, 0];
      save = true;
    }

    window.setTimeout(() => {
      if (!finished.current && customMotion.current !== undefined) {
        onFinishEditing(save ? tempValue : undefined, customMotion.current);
        finished.current = true;
      }
    }, 0);
  }, [onFinishEditing, tempValue]);
  const targetValue = tempValue !== null && tempValue !== void 0 ? tempValue : content;
  const [editorProvider, useLabel] = react.useMemo(() => {
    var _getCellRenderer, _getCellRenderer$prov;

    if ((0,data_grid_types/* isInnerOnlyCell */.rs)(content)) return [];
    const external = provideEditor === null || provideEditor === void 0 ? void 0 : provideEditor(content);
    if (external !== undefined) return [external, false];
    return [(_getCellRenderer = getCellRenderer(content)) === null || _getCellRenderer === void 0 ? void 0 : (_getCellRenderer$prov = _getCellRenderer.provideEditor) === null || _getCellRenderer$prov === void 0 ? void 0 : _getCellRenderer$prov.call(_getCellRenderer, content), false];
  }, [content, getCellRenderer, provideEditor]);
  const {
    ref,
    style: stayOnScreenStyle
  } = useStayOnScreen();
  let pad = true;
  let editor;
  let style = true;
  let styleOverride;

  if (editorProvider !== undefined) {
    pad = editorProvider.disablePadding !== true;
    style = editorProvider.disableStyling !== true;
    const isObjectEditor = (0,data_grid_types/* isObjectEditorCallbackResult */.DP)(editorProvider);

    if (isObjectEditor) {
      styleOverride = editorProvider.styleOverride;
    }

    const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;
    editor = react.createElement(CustomEditor, {
      isHighlighted: highlight,
      onChange: setTempValue,
      value: targetValue,
      initialValue: initialValue,
      onFinishedEditing: onEditorFinished,
      validatedSelection: (0,data_grid_types/* isEditableGridCell */.T9)(targetValue) ? targetValue.selectionRange : undefined,
      forceEditMode: forceEditMode,
      target: target,
      imageEditorOverride: imageEditorOverride,
      markdownDivCreateNode: markdownDivCreateNode,
      isValid: isValid
    });
  }

  styleOverride = { ...styleOverride,
    ...stayOnScreenStyle
  };
  const portalElement = document.getElementById("portal");

  if (portalElement === null) {
    console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id="portal" />` as the last child of your `<body>`.');
    return null;
  }

  let classWrap = style ? "gdg-style" : "gdg-unstyle";

  if (!isValid) {
    classWrap += " invalid";
  }

  if (pad) {
    classWrap += " pad";
  }

  return (0,react_dom.createPortal)(react.createElement(styles/* ThemeContext.Provider */.Ni.Provider, {
    value: theme
  }, react.createElement(ClickOutsideContainer, {
    style: (0,styles/* makeCSSStyle */.be)(theme),
    className: className,
    onClickOutside: onClickOutside
  }, react.createElement(DataGridOverlayEditorStyle, {
    ref: ref,
    id: id,
    className: classWrap,
    style: styleOverride,
    as: useLabel === true ? "label" : undefined,
    targetX: target.x,
    targetY: target.y,
    targetWidth: target.width,
    targetHeight: target.height
  }, react.createElement("div", {
    className: "clip-region",
    onKeyDown: onKeyDown
  }, editor)))), portalElement);
};

/* harmony default export */ const data_grid_overlay_editor = (DataGridOverlayEditor);
// EXTERNAL MODULE: ./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx + 3 modules
var scrolling_data_grid = __webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-search/data-grid-search-style.tsx

const SearchWrapper = (0,styled/* default */.Z)('div')({
  name: "SearchWrapper",
  class: "s11k75lr",
  vars: {
    "s11k75lr-0": [p => p.showSearch ? 0 : 400, "px"]
  }
});

__webpack_require__("./packages/core/src/data-grid-search/data-grid-search-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-search/data-grid-search-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-search/data-grid-search.tsx





const upArrow = react.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 244l144-144 144 144M256 120v292"
}));
const downArrow = react.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 268l144 144 144-144M256 392V100"
}));
const closeX = react.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "32",
  d: "M368 368L144 144M368 144L144 368"
}));
const targetSearchTimeMS = 10;

const DataGridSearch = p => {
  const {
    canvasRef,
    cellYOffset,
    rows,
    columns,
    searchInputRef,
    getCellsForSelection,
    onSearchResultsChanged,
    showSearch = false,
    onSearchClose
  } = p;
  const [searchID] = react.useState(() => "search-box-" + Math.round(Math.random() * 1000));
  const [searchString, setSearchString] = react.useState("");
  const [searchStatus, setSearchStatus] = react.useState();
  const searchStatusRef = react.useRef(searchStatus);
  searchStatusRef.current = searchStatus;
  const abortControllerRef = react.useRef(new AbortController());
  const searchHandle = react.useRef();
  const [searchResults, setSearchResults] = react.useState([]);
  const cancelSearch = react.useCallback(() => {
    if (searchHandle.current !== undefined) {
      window.cancelAnimationFrame(searchHandle.current);
      searchHandle.current = undefined;
      abortControllerRef.current.abort();
    }
  }, []);
  const cellYOffsetRef = react.useRef(cellYOffset);
  cellYOffsetRef.current = cellYOffset;
  const beginSearch = react.useCallback(str => {
    const regex = new RegExp(str.replace(/([$()*+.?[\\\]^{|}-])/g, "\\$1"), "i");
    let startY = cellYOffsetRef.current;
    let searchStride = Math.min(10, rows);
    let rowsSearched = 0;
    setSearchStatus(undefined);
    setSearchResults([]);
    const runningResult = [];

    const tick = async () => {
      var _searchStatusRef$curr, _searchStatusRef$curr2;

      if (getCellsForSelection === undefined) return;
      const tStart = performance.now();
      const rowsLeft = rows - rowsSearched;
      let data = getCellsForSelection({
        x: 0,
        y: startY,
        width: columns.length,
        height: Math.min(searchStride, rowsLeft, rows - startY)
      }, abortControllerRef.current.signal);

      if (typeof data === "function") {
        data = await data();
      }

      let added = false;

      for (const [row, d] of data.entries()) {
        for (const [col, cell] of d.entries()) {
          let testString;

          switch (cell.kind) {
            case data_grid_types/* GridCellKind.Text */.p6.Text:
            case data_grid_types/* GridCellKind.Number */.p6.Number:
              testString = cell.displayData;
              break;

            case data_grid_types/* GridCellKind.Uri */.p6.Uri:
            case data_grid_types/* GridCellKind.Markdown */.p6.Markdown:
              testString = cell.data;
              break;

            case data_grid_types/* GridCellKind.Boolean */.p6.Boolean:
              testString = typeof cell.data === "boolean" ? cell.data.toString() : undefined;
              break;

            case data_grid_types/* GridCellKind.Image */.p6.Image:
            case data_grid_types/* GridCellKind.Bubble */.p6.Bubble:
              testString = cell.data.join("");
              break;

            case data_grid_types/* GridCellKind.Custom */.p6.Custom:
              testString = cell.copyData;
              break;
          }

          if (testString !== undefined && regex.test(testString)) {
            runningResult.push([col, row + startY]);
            added = true;
          }
        }
      }

      const tEnd = performance.now();

      if (added) {
        setSearchResults([...runningResult]);
      }

      rowsSearched += data.length;
      (0,support/* assert */.hu)(rowsSearched <= rows);
      const selectedIndex = (_searchStatusRef$curr = (_searchStatusRef$curr2 = searchStatusRef.current) === null || _searchStatusRef$curr2 === void 0 ? void 0 : _searchStatusRef$curr2.selectedIndex) !== null && _searchStatusRef$curr !== void 0 ? _searchStatusRef$curr : -1;
      setSearchStatus({
        results: runningResult.length,
        rowsSearched,
        selectedIndex
      });
      onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged(runningResult, selectedIndex);

      if (startY + searchStride >= rows) {
        startY = 0;
      } else {
        startY += searchStride;
      }

      const tElapsed = tEnd - tStart;
      const rounded = Math.max(tElapsed, 1);
      const scalar = targetSearchTimeMS / rounded;
      searchStride = Math.ceil(searchStride * scalar);

      if (rowsSearched < rows && runningResult.length < 1000) {
        searchHandle.current = window.requestAnimationFrame(tick);
      }
    };

    cancelSearch();
    searchHandle.current = window.requestAnimationFrame(tick);
  }, [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]);
  const onClose = react.useCallback(() => {
    var _canvasRef$current;

    onSearchClose === null || onSearchClose === void 0 ? void 0 : onSearchClose();
    setSearchStatus(undefined);
    setSearchResults([]);
    onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged([], -1);
    cancelSearch();
    canvasRef === null || canvasRef === void 0 ? void 0 : (_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.focus();
  }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);
  const onSearchChange = react.useCallback(event => {
    setSearchString(event.target.value);

    if (event.target.value === "") {
      setSearchStatus(undefined);
      setSearchResults([]);
      cancelSearch();
    } else {
      beginSearch(event.target.value);
    }
  }, [beginSearch, cancelSearch]);
  react.useEffect(() => {
    if (showSearch && searchInputRef.current !== null) {
      setSearchString("");
      searchInputRef.current.focus({
        preventScroll: true
      });
    }
  }, [showSearch, searchInputRef]);
  const onNext = react.useCallback(ev => {
    var _ev$stopPropagation;

    ev === null || ev === void 0 ? void 0 : (_ev$stopPropagation = ev.stopPropagation) === null || _ev$stopPropagation === void 0 ? void 0 : _ev$stopPropagation.call(ev);
    if (searchStatus === undefined) return;
    const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [searchStatus, onSearchResultsChanged, searchResults]);
  const onPrev = react.useCallback(ev => {
    var _ev$stopPropagation2;

    ev === null || ev === void 0 ? void 0 : (_ev$stopPropagation2 = ev.stopPropagation) === null || _ev$stopPropagation2 === void 0 ? void 0 : _ev$stopPropagation2.call(ev);
    if (searchStatus === undefined) return;
    let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;
    if (newIndex < 0) newIndex += searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged === null || onSearchResultsChanged === void 0 ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [onSearchResultsChanged, searchResults, searchStatus]);
  const onSearchKeyDown = react.useCallback(event => {
    if ((event.ctrlKey || event.metaKey) && event.nativeEvent.code === "KeyF" || event.key === "Escape") {
      onClose();
      event.stopPropagation();
      event.preventDefault();
    } else if (event.key === "Enter") {
      if (event.shiftKey) {
        onPrev();
      } else {
        onNext();
      }
    }
  }, [onClose, onNext, onPrev]);
  react.useEffect(() => {
    return () => {
      cancelSearch();
    };
  }, [cancelSearch]);
  const searchbox = react.useMemo(() => {
    var _searchStatus$rowsSea, _searchStatus$results, _searchStatus$results2;

    let resultString;

    if (searchStatus !== undefined) {
      resultString = searchStatus.results >= 1000 ? `over 1000` : `${searchStatus.results} result${searchStatus.results !== 1 ? "s" : ""}`;

      if (searchStatus.selectedIndex >= 0) {
        resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;
      }
    }

    const cancelEvent = ev => {
      ev.stopPropagation();
    };

    const rowsSearchedProgress = Math.floor(((_searchStatus$rowsSea = searchStatus === null || searchStatus === void 0 ? void 0 : searchStatus.rowsSearched) !== null && _searchStatus$rowsSea !== void 0 ? _searchStatus$rowsSea : 0) / rows * 100);
    const progressStyle = {
      width: `${rowsSearchedProgress}%`
    };
    return react.createElement(SearchWrapper, {
      showSearch: showSearch,
      onMouseDown: cancelEvent,
      onMouseMove: cancelEvent,
      onMouseUp: cancelEvent,
      onClick: cancelEvent
    }, react.createElement("div", {
      className: "search-bar-inner"
    }, react.createElement("input", {
      id: searchID,
      "aria-hidden": !showSearch,
      "data-testid": "search-input",
      ref: searchInputRef,
      onChange: onSearchChange,
      value: searchString,
      tabIndex: showSearch ? undefined : -1,
      onKeyDownCapture: onSearchKeyDown
    }), react.createElement("button", {
      "aria-label": "Previous Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? undefined : -1,
      onClick: onPrev,
      disabled: ((_searchStatus$results = searchStatus === null || searchStatus === void 0 ? void 0 : searchStatus.results) !== null && _searchStatus$results !== void 0 ? _searchStatus$results : 0) === 0
    }, upArrow), react.createElement("button", {
      "aria-label": "Next Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? undefined : -1,
      onClick: onNext,
      disabled: ((_searchStatus$results2 = searchStatus === null || searchStatus === void 0 ? void 0 : searchStatus.results) !== null && _searchStatus$results2 !== void 0 ? _searchStatus$results2 : 0) === 0
    }, downArrow), onSearchClose !== undefined && react.createElement("button", {
      "aria-label": "Close Search",
      "aria-hidden": !showSearch,
      "data-testid": "search-close-button",
      tabIndex: showSearch ? undefined : -1,
      onClick: onClose
    }, closeX)), searchStatus !== undefined ? react.createElement(react.Fragment, null, react.createElement("div", {
      className: "search-status"
    }, react.createElement("div", {
      "data-testid": "search-result-area"
    }, resultString)), react.createElement("div", {
      className: "search-progress",
      style: progressStyle
    })) : react.createElement("div", {
      className: "search-status"
    }, react.createElement("label", {
      htmlFor: searchID
    }, "Type to search")));
  }, [onClose, onNext, onPrev, onSearchChange, onSearchClose, onSearchKeyDown, rows, searchStatus, searchString, showSearch, searchID, searchInputRef]);
  return react.createElement(react.Fragment, null, react.createElement(scrolling_data_grid/* default */.Z, {
    prelightCells: searchResults,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    className: p.className,
    clientSize: p.clientSize,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    initialSize: p.initialSize,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    onVisibleRegionChanged: p.onVisibleRegionChanged,
    overscrollX: p.overscrollX,
    overscrollY: p.overscrollY,
    preventDiagonalScrolling: p.preventDiagonalScrolling,
    rightElement: p.rightElement,
    rightElementProps: p.rightElementProps,
    rowHeight: p.rowHeight,
    rows: p.rows,
    scrollRef: p.scrollRef,
    selection: p.selection,
    showMinimap: p.showMinimap,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    scrollToEnd: p.scrollToEnd
  }), searchbox);
};

/* harmony default export */ const data_grid_search = (DataGridSearch);
// EXTERNAL MODULE: ./packages/core/src/common/browser-detect.ts
var browser_detect = __webpack_require__("./packages/core/src/common/browser-detect.ts");
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-lib.ts
var data_grid_lib = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/group-rename.tsx



const RenameInput = (0,styled/* default */.Z)('input')({
  name: "RenameInput",
  class: "r1fzhvm4",
  vars: {
    "r1fzhvm4-0": [p => Math.max(16, p.targetHeight - 10), "px"]
  }
});
const GroupRename = p => {
  const {
    bounds,
    group,
    onClose,
    canvasBounds,
    onFinish
  } = p;
  const [value, setValue] = react.useState(group);
  return react.createElement(ClickOutsideContainer, {
    style: {
      position: "absolute",
      left: bounds.x - canvasBounds.left + 1,
      top: bounds.y - canvasBounds.top,
      width: bounds.width - 2,
      height: bounds.height
    },
    className: "c181oggi",
    onClickOutside: onClose
  }, react.createElement(RenameInput, {
    targetHeight: bounds.height,
    "data-testid": "group-rename-input",
    value: value,
    onBlur: onClose,
    onFocus: e => e.target.setSelectionRange(0, value.length),
    onChange: e => setValue(e.target.value),
    onKeyDown: e => {
      if (e.key === "Enter") {
        onFinish(value);
      } else if (e.key === "Escape") {
        onClose();
      }
    },
    autoFocus: true
  }));
};

__webpack_require__("./packages/core/src/data-editor/group-rename.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/group-rename.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/use-column-sizer.ts


const defaultSize = 150;

function measureCell(ctx, cell, theme, getCellRenderer) {
  var _r$measure, _r$measure2;

  if (cell.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) return defaultSize;
  const r = getCellRenderer(cell);
  return (_r$measure = r === null || r === void 0 ? void 0 : (_r$measure2 = r.measure) === null || _r$measure2 === void 0 ? void 0 : _r$measure2.call(r, ctx, cell, theme)) !== null && _r$measure !== void 0 ? _r$measure : defaultSize;
}

function measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, removeOutliers, getCellRenderer) {
  let sizes = [];

  if (selectedData !== undefined) {
    sizes.push(...selectedData.map(row => row[colIndex]).map(cell => measureCell(ctx, cell, theme, getCellRenderer)));
  }

  if (sizes.length > 5 && removeOutliers) {
    const average = sizes.reduce((a, b) => a + b) / sizes.length;
    sizes = sizes.filter(a => a < average * 2);
  }

  sizes.push(ctx.measureText(c.title).width + 16 + (c.icon === undefined ? 0 : 28));
  const biggest = Math.max(...sizes);
  const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(biggest)));
  return { ...c,
    width: final
  };
}
function useColumnSizer(columns, rows, getCellsForSelection, clientWidth, minColumnWidth, maxColumnWidth, theme, getCellRenderer, abortController) {
  const rowsRef = react.useRef(rows);
  const getCellsForSelectionRef = react.useRef(getCellsForSelection);
  const themeRef = react.useRef(theme);
  rowsRef.current = rows;
  getCellsForSelectionRef.current = getCellsForSelection;
  themeRef.current = theme;
  const [ctx] = react.useState(() => {
    const offscreen = document.createElement("canvas");
    return offscreen.getContext("2d", {
      alpha: false
    });
  });
  const memoMap = react.useRef({});
  const lastColumns = react.useRef();
  const [selectedData, setSelectionData] = react.useState();
  react.useLayoutEffect(() => {
    const getCells = getCellsForSelectionRef.current;
    if (getCells === undefined || columns.every(data_grid_types/* isSizedGridColumn */.Sq)) return;
    let computeRows = Math.max(1, 10 - Math.floor(columns.length / 10000));
    let tailRows = 0;

    if (computeRows < rowsRef.current && computeRows > 1) {
      computeRows--;
      tailRows = 1;
    }

    const computeArea = {
      x: 0,
      y: 0,
      width: columns.length,
      height: Math.min(rowsRef.current, computeRows)
    };
    const tailComputeArea = {
      x: 0,
      y: rowsRef.current - 1,
      width: columns.length,
      height: 1
    };

    const fn = async () => {
      const getResult = getCells(computeArea, abortController.signal);
      const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : undefined;
      let toSet;

      if (typeof getResult === "object") {
        toSet = getResult;
      } else {
        toSet = await (0,data_grid_types/* resolveCellsThunk */.rL)(getResult);
      }

      if (tailGetResult !== undefined) {
        if (typeof tailGetResult === "object") {
          toSet = [...toSet, ...tailGetResult];
        } else {
          toSet = [...toSet, ...(await (0,data_grid_types/* resolveCellsThunk */.rL)(tailGetResult))];
        }
      }

      lastColumns.current = columns;
      setSelectionData(toSet);
    };

    void fn();
  }, [abortController.signal, columns]);
  return react.useMemo(() => {
    const getRaw = () => {
      if (columns.every(data_grid_types/* isSizedGridColumn */.Sq)) {
        return columns;
      }

      if (ctx === null) {
        return columns.map(c => {
          if ((0,data_grid_types/* isSizedGridColumn */.Sq)(c)) return c;
          return { ...c,
            width: defaultSize
          };
        });
      }

      ctx.font = `${themeRef.current.baseFontStyle} ${themeRef.current.fontFamily}`;
      return columns.map((c, colIndex) => {
        if ((0,data_grid_types/* isSizedGridColumn */.Sq)(c)) return c;

        if (memoMap.current[c.id] !== undefined) {
          return { ...c,
            width: memoMap.current[c.id]
          };
        }

        if (selectedData === undefined || lastColumns.current !== columns || c.id === undefined) {
          return { ...c,
            width: defaultSize
          };
        }

        const r = measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, true, getCellRenderer);
        memoMap.current[c.id] = r.width;
        return r;
      });
    };

    let result = getRaw();
    let totalWidth = 0;
    let totalGrow = 0;
    const distribute = [];

    for (const [i, c] of result.entries()) {
      totalWidth += c.width;

      if (c.grow !== undefined && c.grow > 0) {
        totalGrow += c.grow;
        distribute.push(i);
      }
    }

    if (totalWidth < clientWidth && distribute.length > 0) {
      const writeable = [...result];
      const extra = clientWidth - totalWidth;
      let remaining = extra;

      for (let di = 0; di < distribute.length; di++) {
        var _result$i$grow;

        const i = distribute[di];
        const weighted = ((_result$i$grow = result[i].grow) !== null && _result$i$grow !== void 0 ? _result$i$grow : 0) / totalGrow;
        const toAdd = di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));
        writeable[i] = { ...result[i],
          growOffset: toAdd,
          width: result[i].width + toAdd
        };
        remaining -= toAdd;
      }

      result = writeable;
    }

    return result;
  }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);
}
;// CONCATENATED MODULE: ./packages/core/src/common/is-hotkey.ts


function checkKey(key, args) {
  if (key === undefined) return false;

  if (key.length > 1 && key.startsWith("_")) {
    const keycode = Number.parseInt(key.slice(1));
    if (keycode !== args.keyCode) return false;
  } else {
    if (key !== args.key) return false;
  }

  return true;
}

function isHotkey(hotkey, args) {
  if (hotkey.length === 0) return false;
  let wantCtrl = false;
  let wantShift = false;
  let wantAlt = false;
  let wantMeta = false;
  const split = hotkey.split("+");
  const key = split.pop();
  if (!checkKey(key, args)) return false;

  for (const accel of split) {
    switch (accel) {
      case "ctrl":
        wantCtrl = true;
        break;

      case "shift":
        wantShift = true;
        break;

      case "alt":
        wantAlt = true;
        break;

      case "meta":
        wantMeta = true;
        break;

      case "primary":
        if (browser_detect/* browserIsOSX.value */.FR.value) {
          wantMeta = true;
        } else {
          wantCtrl = true;
        }

        break;
    }
  }

  return args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta;
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid/use-selection-behavior.ts


function useSelectionBehavior(gridSelection, setGridSelection, rangeBehavior, columnBehavior, rowBehavior, rangeSelect) {
  const setCurrent = react.useCallback((value, expand, append, trigger) => {
    var _gridSelection$curren, _gridSelection$curren2;

    if ((rangeSelect === "cell" || rangeSelect === "multi-cell") && value !== undefined) {
      value = { ...value,
        range: {
          x: value.cell[0],
          y: value.cell[1],
          width: 1,
          height: 1
        }
      };
    }

    const rangeMixable = rangeBehavior === "mixed" && (append || trigger === "drag");
    const allowColumnCoSelect = columnBehavior === "mixed" && rangeMixable;
    const allowRowCoSelect = rowBehavior === "mixed" && rangeMixable;
    let newVal = {
      current: value === undefined ? undefined : { ...value,
        rangeStack: trigger === "drag" ? (_gridSelection$curren = (_gridSelection$curren2 = gridSelection.current) === null || _gridSelection$curren2 === void 0 ? void 0 : _gridSelection$curren2.rangeStack) !== null && _gridSelection$curren !== void 0 ? _gridSelection$curren : [] : []
      },
      columns: allowColumnCoSelect ? gridSelection.columns : data_grid_types/* CompactSelection.empty */.EV.empty(),
      rows: allowRowCoSelect ? gridSelection.rows : data_grid_types/* CompactSelection.empty */.EV.empty()
    };
    const addLastRange = append && (rangeSelect === "multi-rect" || rangeSelect === "multi-cell");

    if (addLastRange && newVal.current !== undefined && gridSelection.current !== undefined) {
      newVal = { ...newVal,
        current: { ...newVal.current,
          rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range]
        }
      };
    }

    setGridSelection(newVal, expand);
  }, [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]);
  const setSelectedRows = react.useCallback((newRows, append, allowMixed) => {
    var _newRows;

    newRows = (_newRows = newRows) !== null && _newRows !== void 0 ? _newRows : gridSelection.rows;

    if (append !== undefined) {
      newRows = newRows.add(append);
    }

    let newVal;

    if (rowBehavior === "exclusive" && newRows.length > 0) {
      newVal = {
        current: undefined,
        columns: data_grid_types/* CompactSelection.empty */.EV.empty(),
        rows: newRows
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const columnMixed = allowMixed && columnBehavior === "mixed";
      const current = !rangeMixed ? undefined : gridSelection.current;
      newVal = {
        current,
        columns: columnMixed ? gridSelection.columns : data_grid_types/* CompactSelection.empty */.EV.empty(),
        rows: newRows
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  const setSelectedColumns = react.useCallback((newCols, append, allowMixed) => {
    var _newCols;

    newCols = (_newCols = newCols) !== null && _newCols !== void 0 ? _newCols : gridSelection.columns;

    if (append !== undefined) {
      newCols = newCols.add(append);
    }

    let newVal;

    if (columnBehavior === "exclusive" && newCols.length > 0) {
      newVal = {
        current: undefined,
        rows: data_grid_types/* CompactSelection.empty */.EV.empty(),
        columns: newCols
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const rowMixed = allowMixed && rowBehavior === "mixed";
      const current = !rangeMixed ? undefined : gridSelection.current;
      newVal = {
        current,
        rows: rowMixed ? gridSelection.rows : data_grid_types/* CompactSelection.empty */.EV.empty(),
        columns: newCols
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  return [setCurrent, setSelectedRows, setSelectedColumns];
}
;// CONCATENATED MODULE: ./packages/core/src/data-editor/use-cells-for-selection.ts


function useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortController) {
  const getCellsForSelectionDirectWhenValid = react.useCallback(rect => {
    var _getCellsForSelection;

    if (getCellsForSelectionIn === true) {
      const result = [];

      for (let y = rect.y; y < rect.y + rect.height; y++) {
        const row = [];

        for (let x = rect.x; x < rect.x + rect.width; x++) {
          if (x < 0) {
            row.push({
              kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
              allowOverlay: false
            });
          } else {
            row.push(getCellContent([x, y]));
          }
        }

        result.push(row);
      }

      return result;
    }

    return (_getCellsForSelection = getCellsForSelectionIn === null || getCellsForSelectionIn === void 0 ? void 0 : getCellsForSelectionIn(rect, abortController.signal)) !== null && _getCellsForSelection !== void 0 ? _getCellsForSelection : [];
  }, [abortController.signal, getCellContent, getCellsForSelectionIn]);
  const getCellsForSelectionDirect = getCellsForSelectionIn !== undefined ? getCellsForSelectionDirectWhenValid : undefined;
  const getCellsForSelectionMangled = react.useCallback(rect => {
    if (getCellsForSelectionDirect === undefined) return [];
    const newRect = { ...rect,
      x: rect.x - rowMarkerOffset
    };

    if (newRect.x < 0) {
      newRect.x = 0;
      newRect.width--;
      const r = getCellsForSelectionDirect(newRect, abortController.signal);

      if (typeof r === "function") {
        return async () => (await r()).map(row => [{
          kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
          allowOverlay: false
        }, ...row]);
      }

      return r.map(row => [{
        kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
        allowOverlay: false
      }, ...row]);
    }

    return getCellsForSelectionDirect(newRect, abortController.signal);
  }, [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]);
  const getCellsForSelection = getCellsForSelectionIn !== undefined ? getCellsForSelectionMangled : undefined;
  return [getCellsForSelection, getCellsForSelectionDirect];
}
;// CONCATENATED MODULE: ./packages/core/src/data-editor/data-editor-fns.ts


function expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortController) {
  const origVal = newVal;
  if (spanRangeBehavior === "allowPartial" || newVal.current === undefined) return newVal;

  if (getCellsForSelection !== undefined) {
    let isFilled = false;

    do {
      var _newVal, _newVal$current;

      if (((_newVal = newVal) === null || _newVal === void 0 ? void 0 : _newVal.current) === undefined) break;
      const r = (_newVal$current = newVal.current) === null || _newVal$current === void 0 ? void 0 : _newVal$current.range;
      const cells = [];

      if (r.width > 2) {
        const leftCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof leftCells === "function") {
          return origVal;
        }

        cells.push(...leftCells);
        const rightCells = getCellsForSelection({
          x: r.x + r.width - 1,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof rightCells === "function") {
          return origVal;
        }

        cells.push(...rightCells);
      } else {
        const rCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: r.width,
          height: r.height
        }, abortController.signal);

        if (typeof rCells === "function") {
          return origVal;
        }

        cells.push(...rCells);
      }

      let left = r.x - rowMarkerOffset;
      let right = r.x + r.width - 1 - rowMarkerOffset;

      for (const row of cells) {
        for (const cell of row) {
          if (cell.span === undefined) continue;
          left = Math.min(cell.span[0], left);
          right = Math.max(cell.span[1], right);
        }
      }

      if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {
        isFilled = true;
      } else {
        var _newVal$current$cell;

        newVal = {
          current: {
            cell: (_newVal$current$cell = newVal.current.cell) !== null && _newVal$current$cell !== void 0 ? _newVal$current$cell : [0, 0],
            range: {
              x: left + rowMarkerOffset,
              y: r.y,
              width: right - left + 1,
              height: r.height
            },
            rangeStack: newVal.current.rangeStack
          },
          columns: newVal.columns,
          rows: newVal.rows
        };
      }
    } while (!isFilled);
  }

  return newVal;
}

function descape(s) {
  if (s.startsWith('"') && s.endsWith('"')) {
    s = s.slice(1, -1).replace(/""/g, '"');
  }

  return s;
}

function unquote(str) {
  let State;

  (function (State) {
    State[State["None"] = 0] = "None";
    State[State["inString"] = 1] = "inString";
    State[State["inStringPostQuote"] = 2] = "inStringPostQuote";
  })(State || (State = {}));

  const result = [];
  let current = [];
  let start = 0;
  let state = State.None;
  str = str.replace(/\r\n/g, "\n");
  let index = 0;

  for (const char of str) {
    switch (state) {
      case State.None:
        if (char === "\t" || char === "\n") {
          current.push(str.slice(start, index));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }
        } else if (char === `"`) {
          state = State.inString;
        }

        break;

      case State.inString:
        if (char === `"`) {
          state = State.inStringPostQuote;
        }

        break;

      case State.inStringPostQuote:
        if (char === '"') {
          state = State.inString;
        } else if (char === "\t" || char === "\n") {
          current.push(descape(str.slice(start, index)));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }

          state = State.None;
        } else {
          state = State.None;
        }

        break;
    }

    index++;
  }

  if (start < str.length) {
    current.push(descape(str.slice(start, str.length)));
  }

  result.push(current);
  return result;
}
function decodeHTML(tableEl) {
  const walkEl = [tableEl];
  const result = [];
  let current;

  while (walkEl.length > 0) {
    const el = walkEl.pop();
    if (el === undefined) break;

    if (el instanceof HTMLTableElement || el.nodeName === "TBODY") {
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableRowElement) {
      if (current !== undefined) {
        result.push(current);
      }

      current = [];
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableCellElement) {
      var _current, _ref, _el$innerText;

      (_current = current) === null || _current === void 0 ? void 0 : _current.push((_ref = (_el$innerText = el.innerText) !== null && _el$innerText !== void 0 ? _el$innerText : el.textContent) !== null && _ref !== void 0 ? _ref : "");
    }
  }

  if (current !== undefined) {
    result.push(current);
  }

  return result;
}

function data_editor_fns_escape(str) {
  if (/[\t\n"]/.test(str)) {
    str = `"${str.replace(/"/g, '""')}"`;
  }

  return str;
}

const formatBoolean = val => {
  switch (val) {
    case true:
      return "TRUE";

    case false:
      return "FALSE";

    case data_grid_types/* BooleanIndeterminate */.sd:
      return "INDETERMINATE";

    case data_grid_types/* BooleanEmpty */.qF:
      return "";

    default:
      (0,support/* assertNever */.vE)(val);
  }
};

function copyToClipboard(cells, columnIndexes, e) {
  var _window$navigator$cli;

  const formatCell = (cell, index, raw) => {
    var _cell$data$toString, _cell$data;

    const colIndex = columnIndexes[index];
    if (cell.span !== undefined && cell.span[0] !== colIndex) return "";

    switch (cell.kind) {
      case data_grid_types/* GridCellKind.Text */.p6.Text:
      case data_grid_types/* GridCellKind.Number */.p6.Number:
        return data_editor_fns_escape(raw ? (_cell$data$toString = (_cell$data = cell.data) === null || _cell$data === void 0 ? void 0 : _cell$data.toString()) !== null && _cell$data$toString !== void 0 ? _cell$data$toString : "" : cell.displayData);

      case data_grid_types/* GridCellKind.Markdown */.p6.Markdown:
      case data_grid_types/* GridCellKind.RowID */.p6.RowID:
      case data_grid_types/* GridCellKind.Uri */.p6.Uri:
        return data_editor_fns_escape(cell.data);

      case data_grid_types/* GridCellKind.Image */.p6.Image:
      case data_grid_types/* GridCellKind.Bubble */.p6.Bubble:
        return cell.data.reduce((pv, cv) => `${data_editor_fns_escape(pv)},${data_editor_fns_escape(cv)}`);

      case data_grid_types/* GridCellKind.Boolean */.p6.Boolean:
        return formatBoolean(cell.data);

      case data_grid_types/* GridCellKind.Loading */.p6.Loading:
        return raw ? "" : "#LOADING";

      case data_grid_types/* GridCellKind.Protected */.p6.Protected:
        return raw ? "" : "************";

      case data_grid_types/* GridCellKind.Drilldown */.p6.Drilldown:
        return cell.data.map(i => i.text).reduce((pv, cv) => `${data_editor_fns_escape(pv)},${data_editor_fns_escape(cv)}`);

      case data_grid_types/* GridCellKind.Custom */.p6.Custom:
        return data_editor_fns_escape(cell.copyData);

      default:
        (0,support/* assertNever */.vE)(cell);
    }
  };

  const str = cells.map(row => row.map((a, b) => formatCell(a, b, false)).join("\t")).join("\n");

  if (((_window$navigator$cli = window.navigator.clipboard) === null || _window$navigator$cli === void 0 ? void 0 : _window$navigator$cli.write) !== undefined || e !== undefined) {
    var _window$navigator$cli2;

    const rootEl = document.createElement("tbody");

    for (const row of cells) {
      const rowEl = document.createElement("tr");

      for (const [i, cell] of row.entries()) {
        const cellEl = document.createElement("td");

        if (cell.kind === data_grid_types/* GridCellKind.Uri */.p6.Uri) {
          const link = document.createElement("a");
          link.href = cell.data;
          link.innerText = cell.data;
          cellEl.append(link);
        } else {
          cellEl.innerText = formatCell(cell, i, true);
        }

        rowEl.append(cellEl);
      }

      rootEl.append(rowEl);
    }

    if (((_window$navigator$cli2 = window.navigator.clipboard) === null || _window$navigator$cli2 === void 0 ? void 0 : _window$navigator$cli2.write) !== undefined) {
      void window.navigator.clipboard.write([new ClipboardItem({
        "text/plain": new Blob([str], {
          type: "text/plain"
        }),
        "text/html": new Blob([`<table>${rootEl.outerHTML}</table>`], {
          type: "text/html"
        })
      })]);
    } else if (e !== undefined && (e === null || e === void 0 ? void 0 : e.clipboardData) !== null) {
      try {
        e.clipboardData.setData("text/plain", str);
        e.clipboardData.setData("text/html", `<table>${rootEl.outerHTML}</table>`);
      } catch {
        var _window$navigator$cli3;

        void ((_window$navigator$cli3 = window.navigator.clipboard) === null || _window$navigator$cli3 === void 0 ? void 0 : _window$navigator$cli3.writeText(str));
      }
    }
  } else {
    var _window$navigator$cli4;

    void ((_window$navigator$cli4 = window.navigator.clipboard) === null || _window$navigator$cli4 === void 0 ? void 0 : _window$navigator$cli4.writeText(str));
  }

  e === null || e === void 0 ? void 0 : e.preventDefault();
}
;// CONCATENATED MODULE: ./packages/core/src/data-editor-container/data-grid-container.tsx
function data_grid_container_extends() { data_grid_container_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return data_grid_container_extends.apply(this, arguments); }




function toCss(x) {
  if (typeof x === "string") return x;
  return `${x}px`;
}

const Wrapper = (0,styled/* default */.Z)('div')({
  name: "Wrapper",
  class: "wo9gtxb",
  vars: {
    "wo9gtxb-0": [p => p.innerWidth],
    "wo9gtxb-1": [p => p.innerHeight]
  }
});
const DataEditorContainer = p => {
  const {
    inWidth,
    inHeight,
    children,
    ...rest
  } = p;
  return react.createElement(Wrapper, data_grid_container_extends({
    innerHeight: toCss(inHeight),
    innerWidth: toCss(inWidth)
  }, rest), children);
};

__webpack_require__("./packages/core/src/data-editor-container/data-grid-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor-container/data-grid-container.tsx");
// EXTERNAL MODULE: ./packages/core/src/data-grid/cells/boolean-cell.tsx
var boolean_cell = __webpack_require__("./packages/core/src/data-grid/cells/boolean-cell.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/use-autoscroll.ts

const maxPxPerMs = 2;
const msToFullSpeed = 1300;
function useAutoscroll(scrollDirection, scrollRef) {
  const speedScalar = react.useRef(0);
  const [xDir, yDir] = scrollDirection !== null && scrollDirection !== void 0 ? scrollDirection : [0, 0];
  react.useEffect(() => {
    if (xDir === 0 && yDir === 0) {
      speedScalar.current = 0;
      return;
    }

    let lastTime = 0;

    const scrollFn = curTime => {
      if (lastTime === 0) {
        lastTime = curTime;
      } else {
        var _scrollRef$current;

        const step = curTime - lastTime;
        speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);
        const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;
        (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.scrollBy(xDir * motion, yDir * motion);
        lastTime = curTime;
      }

      t = window.requestAnimationFrame(scrollFn);
    };

    let t = window.requestAnimationFrame(scrollFn);
    return () => window.cancelAnimationFrame(t);
  }, [scrollRef, xDir, yDir]);
}
// EXTERNAL MODULE: ./packages/core/src/data-grid/cells/index.ts + 25 modules
var cells = __webpack_require__("./packages/core/src/data-grid/cells/index.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-editor/data-editor.tsx
function data_editor_extends() { data_editor_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return data_editor_extends.apply(this, arguments); }

























let idCounter = 0;

function getSpanStops(cells) {
  return uniq_default()(flatten_default()(flatten_default()(cells).filter(c => c.span !== undefined).map(c => {
    var _c$span$, _c$span, _c$span$2, _c$span2;

    return range_default()(((_c$span$ = (_c$span = c.span) === null || _c$span === void 0 ? void 0 : _c$span[0]) !== null && _c$span$ !== void 0 ? _c$span$ : 0) + 1, ((_c$span$2 = (_c$span2 = c.span) === null || _c$span2 === void 0 ? void 0 : _c$span2[1]) !== null && _c$span$2 !== void 0 ? _c$span$2 : 0) + 1);
  })));
}

function shiftSelection(input, offset) {
  if (input === undefined || offset === 0 || input.columns.length === 0 && input.current === undefined) return input;
  return {
    current: input.current === undefined ? undefined : {
      cell: [input.current.cell[0] + offset, input.current.cell[1]],
      range: { ...input.current.range,
        x: input.current.range.x + offset
      },
      rangeStack: input.current.rangeStack.map(r => ({ ...r,
        x: r.x + offset
      }))
    },
    rows: input.rows,
    columns: input.columns.offset(offset)
  };
}

const keybindingDefaults = {
  selectAll: true,
  selectRow: true,
  selectColumn: true,
  downFill: false,
  rightFill: false,
  pageUp: false,
  pageDown: false,
  clear: true,
  copy: true,
  paste: true,
  search: false,
  first: true,
  last: true
};
const loadingCell = {
  kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
  allowOverlay: false
};
const emptyGridSelection = {
  columns: data_grid_types/* CompactSelection.empty */.EV.empty(),
  rows: data_grid_types/* CompactSelection.empty */.EV.empty(),
  current: undefined
};

const DataEditorImpl = (p, forwardedRef) => {
  var _visibleRegion$height, _visibleRegion$width, _gridSelection$curren6, _gridSelectionOuter$c, _gridSelectionOuter$c2;

  const [gridSelectionInner, setGridSelectionInner] = react.useState(emptyGridSelection);
  const [overlay, setOverlay] = react.useState();
  const searchInputRef = react.useRef(null);
  const canvasRef = react.useRef(null);
  const [mouseState, setMouseState] = react.useState();
  const scrollRef = react.useRef(null);
  const lastSent = react.useRef();
  const {
    rowMarkers = "none",
    rowHeight = 34,
    headerHeight = 36,
    rowMarkerWidth: rowMarkerWidthRaw,
    imageEditorOverride,
    getRowThemeOverride,
    markdownDivCreateNode
  } = p;
  const {
    width,
    height,
    columns: columnsIn,
    rows,
    getCellContent,
    onCellClicked,
    onCellActivated,
    onFinishedEditing,
    coercePasteValue,
    drawHeader: drawHeaderIn,
    onHeaderClicked,
    spanRangeBehavior = "default",
    onGroupHeaderClicked,
    onCellContextMenu,
    className,
    theme,
    onHeaderContextMenu,
    getCellsForSelection: getCellsForSelectionIn,
    onGroupHeaderContextMenu,
    onGroupHeaderRenamed,
    onCellEdited,
    onCellsEdited,
    onKeyDown: onKeyDownIn,
    onKeyUp: onKeyUpIn,
    keybindings: keybindingsIn,
    onRowAppended,
    onColumnMoved,
    validateCell: validateCellIn,
    highlightRegions: highlightRegionsIn,
    drawCell,
    rangeSelect = "rect",
    columnSelect = "multi",
    rowSelect = "multi",
    rangeSelectionBlending = "exclusive",
    columnSelectionBlending = "exclusive",
    rowSelectionBlending = "exclusive",
    onDelete: onDeleteIn,
    onDragStart,
    onMouseMove,
    onPaste,
    groupHeaderHeight = headerHeight,
    freezeColumns = 0,
    rowSelectionMode = "auto",
    rowMarkerStartIndex = 1,
    onHeaderMenuClick,
    getGroupDetails,
    onSearchClose: onSearchCloseIn,
    onItemHovered,
    onSelectionCleared,
    showSearch: showSearchIn,
    onVisibleRegionChanged,
    gridSelection: gridSelectionOuter,
    onGridSelectionChange,
    minColumnWidth: minColumnWidthIn = 50,
    maxColumnWidth: maxColumnWidthIn = 500,
    maxColumnAutoWidth: maxColumnAutoWidthIn,
    provideEditor,
    trailingRowOptions,
    scrollOffsetX,
    scrollOffsetY,
    verticalBorder,
    onDragOverCell,
    onDrop,
    onColumnResize: onColumnResizeIn,
    onColumnResizeEnd: onColumnResizeEndIn,
    onColumnResizeStart: onColumnResizeStartIn,
    customRenderers: additionalRenderers,
    fillHandle,
    drawFocusRing,
    experimental,
    fixedShadowX,
    fixedShadowY,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX,
    overscrollY,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    scrollToEnd
  } = p;
  const minColumnWidth = Math.max(minColumnWidthIn, 20);
  const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);
  const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn !== null && maxColumnAutoWidthIn !== void 0 ? maxColumnAutoWidthIn : maxColumnWidth, minColumnWidth);
  const keybindings = react.useMemo(() => {
    return keybindingsIn === undefined ? keybindingDefaults : { ...keybindingDefaults,
      ...keybindingsIn
    };
  }, [keybindingsIn]);
  const rowMarkerWidth = rowMarkerWidthRaw !== null && rowMarkerWidthRaw !== void 0 ? rowMarkerWidthRaw : rows > 10000 ? 48 : rows > 1000 ? 44 : rows > 100 ? 36 : 32;
  const hasRowMarkers = rowMarkers !== "none";
  const rowMarkerOffset = hasRowMarkers ? 1 : 0;
  const showTrailingBlankRow = onRowAppended !== undefined;
  const lastRowSticky = (trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.sticky) === true;
  const [showSearchInner, setShowSearchInner] = react.useState(false);
  const showSearch = showSearchIn !== null && showSearchIn !== void 0 ? showSearchIn : showSearchInner;
  const onSearchClose = react.useCallback(() => {
    if (onSearchCloseIn !== undefined) {
      onSearchCloseIn();
    } else {
      setShowSearchInner(false);
    }
  }, [onSearchCloseIn]);
  const gridSelectionOuterMangled = react.useMemo(() => {
    return gridSelectionOuter === undefined ? undefined : shiftSelection(gridSelectionOuter, rowMarkerOffset);
  }, [gridSelectionOuter, rowMarkerOffset]);
  const gridSelection = gridSelectionOuterMangled !== null && gridSelectionOuterMangled !== void 0 ? gridSelectionOuterMangled : gridSelectionInner;
  const abortControllerRef = react.useRef(new AbortController());
  react.useEffect(() => {
    return () => {
      abortControllerRef === null || abortControllerRef === void 0 ? void 0 : abortControllerRef.current.abort();
    };
  }, []);
  const [getCellsForSelection, getCellsForSeletionDirect] = useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortControllerRef.current);
  const validateCell = react.useCallback((cell, newValue, prevValue) => {
    if (validateCellIn === undefined) return true;
    const item = [cell[0] - rowMarkerOffset, cell[1]];
    return validateCellIn === null || validateCellIn === void 0 ? void 0 : validateCellIn(item, newValue, prevValue);
  }, [rowMarkerOffset, validateCellIn]);
  const expectedExternalGridSelection = react.useRef(gridSelectionOuter);
  const setGridSelection = react.useCallback((newVal, expand) => {
    if (expand) {
      newVal = expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortControllerRef.current);
    }

    if (onGridSelectionChange !== undefined) {
      expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);
      onGridSelectionChange(expectedExternalGridSelection.current);
    } else {
      setGridSelectionInner(newVal);
    }
  }, [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]);
  const onColumnResize = (0,utils/* whenDefined */.qJ)(onColumnResizeIn, react.useCallback((_, w, ind, wg) => {
    onColumnResizeIn === null || onColumnResizeIn === void 0 ? void 0 : onColumnResizeIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeEnd = (0,utils/* whenDefined */.qJ)(onColumnResizeEndIn, react.useCallback((_, w, ind, wg) => {
    onColumnResizeEndIn === null || onColumnResizeEndIn === void 0 ? void 0 : onColumnResizeEndIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeEndIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeStart = (0,utils/* whenDefined */.qJ)(onColumnResizeStartIn, react.useCallback((_, w, ind, wg) => {
    onColumnResizeStartIn === null || onColumnResizeStartIn === void 0 ? void 0 : onColumnResizeStartIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeStartIn, rowMarkerOffset, columnsIn]));
  const drawHeader = (0,utils/* whenDefined */.qJ)(drawHeaderIn, react.useCallback(args => {
    var _drawHeaderIn;

    return (_drawHeaderIn = drawHeaderIn === null || drawHeaderIn === void 0 ? void 0 : drawHeaderIn({ ...args,
      columnIndex: args.columnIndex - rowMarkerOffset
    })) !== null && _drawHeaderIn !== void 0 ? _drawHeaderIn : false;
  }, [drawHeaderIn, rowMarkerOffset]));
  const onDelete = react.useCallback(sel => {
    if (onDeleteIn !== undefined) {
      const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));

      if (typeof result === "boolean") {
        return result;
      }

      return shiftSelection(result, rowMarkerOffset);
    }

    return true;
  }, [onDeleteIn, rowMarkerOffset]);
  const [setCurrent, setSelectedRows, setSelectedColumns] = useSelectionBehavior(gridSelection, setGridSelection, rangeSelectionBlending, columnSelectionBlending, rowSelectionBlending, rangeSelect);
  const mergedTheme = react.useMemo(() => {
    return { ...(0,styles/* getDataEditorTheme */.Zu)(),
      ...theme
    };
  }, [theme]);
  const [clientSize, setClientSize] = react.useState([10, 10, 0]);
  const getCellRenderer = react.useCallback(cell => {
    if (cell.kind !== data_grid_types/* GridCellKind.Custom */.p6.Custom) {
      return cells/* CellRenderers */.L[cell.kind];
    }

    return additionalRenderers === null || additionalRenderers === void 0 ? void 0 : additionalRenderers.find(x => x.isMatch(cell));
  }, [additionalRenderers]);
  const columns = useColumnSizer(columnsIn, rows, getCellsForSeletionDirect, clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2], minColumnWidth, maxColumnAutoWidth, mergedTheme, getCellRenderer, abortControllerRef.current);
  const enableGroups = react.useMemo(() => {
    return columns.some(c => c.group !== undefined);
  }, [columns]);
  const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;
  const numSelectedRows = gridSelection.rows.length;
  const rowMarkerHeader = rowMarkers === "none" ? "" : numSelectedRows === 0 ? data_grid_types/* headerCellUnheckedMarker */.YK : numSelectedRows === rows ? data_grid_types/* headerCellCheckedMarker */.qT : data_grid_types/* headerCellIndeterminateMarker */.iJ;
  const mangledCols = react.useMemo(() => {
    if (rowMarkers === "none") return columns;
    return [{
      title: rowMarkerHeader,
      width: rowMarkerWidth,
      icon: undefined,
      hasMenu: false,
      style: "normal"
    }, ...columns];
  }, [columns, rowMarkerWidth, rowMarkers, rowMarkerHeader]);
  const [visibleRegionY, visibleRegionTy] = react.useMemo(() => {
    return [scrollOffsetY !== undefined && typeof rowHeight === "number" ? Math.floor(scrollOffsetY / rowHeight) : 0, scrollOffsetY !== undefined && typeof rowHeight === "number" ? -(scrollOffsetY % rowHeight) : 0];
  }, [scrollOffsetY, rowHeight]);
  const visibleRegionRef = react.useRef({
    height: 1,
    width: 1,
    x: 0,
    y: 0
  });
  const visibleRegionInput = react.useMemo(() => {
    var _visibleRegionRef$cur, _visibleRegionRef$cur2;

    return {
      x: visibleRegionRef.current.x,
      y: visibleRegionY,
      width: (_visibleRegionRef$cur = visibleRegionRef.current.width) !== null && _visibleRegionRef$cur !== void 0 ? _visibleRegionRef$cur : 1,
      height: (_visibleRegionRef$cur2 = visibleRegionRef.current.height) !== null && _visibleRegionRef$cur2 !== void 0 ? _visibleRegionRef$cur2 : 1,
      ty: visibleRegionTy
    };
  }, [visibleRegionTy, visibleRegionY]);
  const hasJustScrolled = react.useRef(false);
  const [visibleRegion, setVisibleRegion, empty] = (0,utils/* useStateWithReactiveInput */.ig)(visibleRegionInput);
  visibleRegionRef.current = visibleRegion;
  const vScrollReady = ((_visibleRegion$height = visibleRegion.height) !== null && _visibleRegion$height !== void 0 ? _visibleRegion$height : 1) > 1;
  react.useLayoutEffect(() => {
    if (scrollOffsetY !== undefined && scrollRef.current !== null && vScrollReady) {
      scrollRef.current.scrollTop = scrollOffsetY;

      if (scrollRef.current.scrollTop !== scrollOffsetY) {
        empty();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetY, vScrollReady, empty]);
  const hScrollReady = ((_visibleRegion$width = visibleRegion.width) !== null && _visibleRegion$width !== void 0 ? _visibleRegion$width : 1) > 1;
  react.useLayoutEffect(() => {
    if (scrollOffsetX !== undefined && scrollRef.current !== null && hScrollReady) {
      scrollRef.current.scrollLeft = scrollOffsetX;

      if (scrollRef.current.scrollLeft !== scrollOffsetX) {
        empty();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetX, hScrollReady, empty]);
  const cellXOffset = visibleRegion.x + rowMarkerOffset;
  const cellYOffset = visibleRegion.y;
  const gridRef = react.useRef(null);
  const focus = react.useCallback(immediate => {
    if (immediate === true) {
      var _gridRef$current;

      (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.focus();
    } else {
      window.requestAnimationFrame(() => {
        var _gridRef$current2;

        (_gridRef$current2 = gridRef.current) === null || _gridRef$current2 === void 0 ? void 0 : _gridRef$current2.focus();
      });
    }
  }, []);
  const mangledRows = showTrailingBlankRow ? rows + 1 : rows;
  const mangledOnCellsEdited = react.useCallback(items => {
    const mangledItems = rowMarkerOffset === 0 ? items : items.map(x => ({ ...x,
      location: [x.location[0] - rowMarkerOffset, x.location[1]]
    }));
    const r = onCellsEdited === null || onCellsEdited === void 0 ? void 0 : onCellsEdited(mangledItems);

    if (r !== true) {
      for (const i of mangledItems) onCellEdited === null || onCellEdited === void 0 ? void 0 : onCellEdited(i.location, i.value);
    }

    return r;
  }, [onCellEdited, onCellsEdited, rowMarkerOffset]);
  const highlightRegions = react.useMemo(() => {
    if (highlightRegionsIn === undefined) return undefined;
    if (rowMarkerOffset === 0) return highlightRegionsIn;
    return highlightRegionsIn.map(r => {
      const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;
      if (maxWidth <= 0) return undefined;
      return {
        color: r.color,
        range: { ...r.range,
          x: r.range.x + rowMarkerOffset,
          width: Math.min(maxWidth, r.range.width)
        },
        style: r.style
      };
    }).filter(x => x !== undefined);
  }, [highlightRegionsIn, mangledCols.length, rowMarkerOffset]);
  const mangledColsRef = react.useRef(mangledCols);
  mangledColsRef.current = mangledCols;
  const getMangledCellContent = react.useCallback(_ref => {
    let [col, row] = _ref;
    const isTrailing = showTrailingBlankRow && row === mangledRows - 1;
    const isRowMarkerCol = col === 0 && hasRowMarkers;

    if (isRowMarkerCol) {
      if (isTrailing) {
        return loadingCell;
      }

      return {
        kind: data_grid_types/* InnerGridCellKind.Marker */.$o.Marker,
        allowOverlay: false,
        checked: (gridSelection === null || gridSelection === void 0 ? void 0 : gridSelection.rows.hasIndex(row)) === true,
        markerKind: rowMarkers === "clickable-number" ? "number" : rowMarkers,
        row: rowMarkerStartIndex + row,
        drawHandle: onRowMoved !== undefined
      };
    } else if (isTrailing) {
      var _trailingRowOptions$h, _c$trailingRowOptions;

      const isFirst = col === rowMarkerOffset;
      const maybeFirstColumnHint = isFirst ? (_trailingRowOptions$h = trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.hint) !== null && _trailingRowOptions$h !== void 0 ? _trailingRowOptions$h : "" : "";
      const c = mangledColsRef.current[col];

      if ((c === null || c === void 0 ? void 0 : (_c$trailingRowOptions = c.trailingRowOptions) === null || _c$trailingRowOptions === void 0 ? void 0 : _c$trailingRowOptions.disabled) === true) {
        return loadingCell;
      } else {
        var _c$trailingRowOptions2, _c$trailingRowOptions3, _c$trailingRowOptions4, _c$trailingRowOptions5;

        const hint = (_c$trailingRowOptions2 = c === null || c === void 0 ? void 0 : (_c$trailingRowOptions3 = c.trailingRowOptions) === null || _c$trailingRowOptions3 === void 0 ? void 0 : _c$trailingRowOptions3.hint) !== null && _c$trailingRowOptions2 !== void 0 ? _c$trailingRowOptions2 : maybeFirstColumnHint;
        const icon = (_c$trailingRowOptions4 = c === null || c === void 0 ? void 0 : (_c$trailingRowOptions5 = c.trailingRowOptions) === null || _c$trailingRowOptions5 === void 0 ? void 0 : _c$trailingRowOptions5.addIcon) !== null && _c$trailingRowOptions4 !== void 0 ? _c$trailingRowOptions4 : trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.addIcon;
        return {
          kind: data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow,
          hint,
          allowOverlay: false,
          icon
        };
      }
    } else {
      const outerCol = col - rowMarkerOffset;

      if ((experimental === null || experimental === void 0 ? void 0 : experimental.strict) === true) {
        var _vr$extras, _vr$extras$selected, _vr$extras2, _vr$extras3;

        const vr = visibleRegionRef.current;
        const isOutsideMainArea = vr.x > outerCol || outerCol > vr.x + vr.width || vr.y > row || row > vr.y + vr.height;
        const isSelected = outerCol === ((_vr$extras = vr.extras) === null || _vr$extras === void 0 ? void 0 : (_vr$extras$selected = _vr$extras.selected) === null || _vr$extras$selected === void 0 ? void 0 : _vr$extras$selected[0]) && row === ((_vr$extras2 = vr.extras) === null || _vr$extras2 === void 0 ? void 0 : _vr$extras2.selected[1]);
        const isOutsideFreezeArea = ((_vr$extras3 = vr.extras) === null || _vr$extras3 === void 0 ? void 0 : _vr$extras3.freezeRegion) === undefined || vr.extras.freezeRegion.x > outerCol || outerCol > vr.extras.freezeRegion.x + vr.extras.freezeRegion.width || vr.extras.freezeRegion.y > row || row > vr.extras.freezeRegion.y + vr.extras.freezeRegion.height;

        if (isOutsideMainArea && !isSelected && isOutsideFreezeArea) {
          return {
            kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
            allowOverlay: false
          };
        }
      }

      let result = getCellContent([outerCol, row]);

      if (rowMarkerOffset !== 0 && result.span !== undefined) {
        result = { ...result,
          span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset]
        };
      }

      return result;
    }
  }, [showTrailingBlankRow, mangledRows, hasRowMarkers, gridSelection === null || gridSelection === void 0 ? void 0 : gridSelection.rows, onRowMoved, rowMarkers, rowMarkerOffset, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.hint, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.addIcon, experimental === null || experimental === void 0 ? void 0 : experimental.strict, getCellContent, rowMarkerStartIndex]);
  const mangledGetGroupDetails = react.useCallback(group => {
    var _getGroupDetails;

    let result = (_getGroupDetails = getGroupDetails === null || getGroupDetails === void 0 ? void 0 : getGroupDetails(group)) !== null && _getGroupDetails !== void 0 ? _getGroupDetails : {
      name: group
    };

    if (onGroupHeaderRenamed !== undefined && group !== "") {
      var _result$actions;

      result = {
        icon: result.icon,
        name: result.name,
        overrideTheme: result.overrideTheme,
        actions: [...((_result$actions = result.actions) !== null && _result$actions !== void 0 ? _result$actions : []), {
          title: "Rename",
          icon: "renameIcon",
          onClick: e => setRenameGroup({
            group: result.name,
            bounds: e.bounds
          })
        }]
      };
    }

    return result;
  }, [getGroupDetails, onGroupHeaderRenamed]);
  const setOverlaySimple = react.useCallback(val => {
    var _mangledGetGroupDetai;

    const [col, row] = val.cell;
    const column = mangledCols[col];
    const groupTheme = (column === null || column === void 0 ? void 0 : column.group) !== undefined ? (_mangledGetGroupDetai = mangledGetGroupDetails(column.group)) === null || _mangledGetGroupDetai === void 0 ? void 0 : _mangledGetGroupDetai.overrideTheme : undefined;
    const colTheme = column === null || column === void 0 ? void 0 : column.themeOverride;
    const rowTheme = getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row);
    setOverlay({ ...val,
      theme: { ...mergedTheme,
        ...groupTheme,
        ...colTheme,
        ...rowTheme,
        ...val.content.themeOverride
      }
    });
  }, [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]);
  const reselect = react.useCallback((bounds, fromKeyboard, initialValue) => {
    if (gridSelection.current === undefined) return;
    const [col, row] = gridSelection.current.cell;
    const c = getMangledCellContent([col, row]);

    if (c.kind !== data_grid_types/* GridCellKind.Boolean */.p6.Boolean && c.allowOverlay) {
      let content = c;

      if (initialValue !== undefined) {
        switch (content.kind) {
          case data_grid_types/* GridCellKind.Number */.p6.Number:
            {
              const d = (0,support/* maybe */.wY)(() => initialValue === "-" ? -0 : Number.parseFloat(initialValue), 0);
              content = { ...content,
                data: Number.isNaN(d) ? 0 : d
              };
              break;
            }

          case data_grid_types/* GridCellKind.Text */.p6.Text:
          case data_grid_types/* GridCellKind.Markdown */.p6.Markdown:
          case data_grid_types/* GridCellKind.Uri */.p6.Uri:
            content = { ...content,
              data: initialValue
            };
            break;
        }
      }

      setOverlaySimple({
        target: bounds,
        content,
        initialValue,
        cell: [col, row],
        highlight: initialValue === undefined,
        forceEditMode: initialValue !== undefined
      });
    } else if (c.kind === data_grid_types/* GridCellKind.Boolean */.p6.Boolean && fromKeyboard && c.readonly !== true) {
      var _gridRef$current3;

      mangledOnCellsEdited([{
        location: gridSelection.current.cell,
        value: { ...c,
          data: (0,boolean_cell/* toggleBoolean */.D)(c.data)
        }
      }]);
      (_gridRef$current3 = gridRef.current) === null || _gridRef$current3 === void 0 ? void 0 : _gridRef$current3.damage([{
        cell: gridSelection.current.cell
      }]);
    }
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]);
  const focusOnRowFromTrailingBlankRow = react.useCallback((col, row) => {
    var _gridRef$current4;

    const bounds = (_gridRef$current4 = gridRef.current) === null || _gridRef$current4 === void 0 ? void 0 : _gridRef$current4.getBounds(col, row);

    if (bounds === undefined || scrollRef.current === null) {
      return;
    }

    const content = getMangledCellContent([col, row]);

    if (!content.allowOverlay) {
      return;
    }

    setOverlaySimple({
      target: bounds,
      content,
      initialValue: undefined,
      highlight: true,
      cell: [col, row],
      forceEditMode: true
    });
  }, [getMangledCellContent, setOverlaySimple]);
  const scrollTo = react.useCallback(function (col, row) {
    let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "both";
    let paddingX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let paddingY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;

    if (scrollRef.current !== null) {
      const grid = gridRef.current;
      const canvas = canvasRef.current;
      const trueCol = typeof col !== "number" ? col.unit === "cell" ? col.amount : undefined : col;
      const trueRow = typeof row !== "number" ? row.unit === "cell" ? row.amount : undefined : row;
      const desiredX = typeof col !== "number" && col.unit === "px" ? col.amount : undefined;
      const desiredY = typeof row !== "number" && row.unit === "px" ? row.amount : undefined;

      if (grid !== null && canvas !== null) {
        let targetRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        let scrollX = 0;
        let scrollY = 0;

        if (trueCol !== undefined || trueRow !== undefined) {
          var _grid$getBounds;

          targetRect = (_grid$getBounds = grid.getBounds((trueCol !== null && trueCol !== void 0 ? trueCol : 0) + rowMarkerOffset, trueRow !== null && trueRow !== void 0 ? trueRow : 0)) !== null && _grid$getBounds !== void 0 ? _grid$getBounds : targetRect;
          if (targetRect.width === 0 || targetRect.height === 0) return;
        }

        const scrollBounds = canvas.getBoundingClientRect();

        if (desiredX !== undefined) {
          targetRect = { ...targetRect,
            x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,
            width: 1
          };
        }

        if (desiredY !== undefined) {
          targetRect = { ...targetRect,
            y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,
            height: 1
          };
        }

        if (targetRect !== undefined) {
          const bounds = {
            x: targetRect.x - paddingX,
            y: targetRect.y - paddingY,
            width: targetRect.width + 2 * paddingX,
            height: targetRect.height + 2 * paddingY
          };
          let frozenWidth = 0;

          for (let i = 0; i < freezeColumns; i++) {
            frozenWidth += columns[i].width;
          }

          let trailingRowHeight = 0;

          if (lastRowSticky) {
            trailingRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows);
          }

          let sLeft = frozenWidth + scrollBounds.left + rowMarkerOffset * rowMarkerWidth;
          let sRight = scrollBounds.right;
          let sTop = scrollBounds.top + totalHeaderHeight;
          let sBottom = scrollBounds.bottom - trailingRowHeight;
          const minx = targetRect.width + paddingX * 2;

          switch (options === null || options === void 0 ? void 0 : options.hAlign) {
            case "start":
              sRight = sLeft + minx;
              break;

            case "end":
              sLeft = sRight - minx;
              break;

            case "center":
              sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;
              sRight = sLeft + minx;
              break;
          }

          const miny = targetRect.height + paddingY * 2;

          switch (options === null || options === void 0 ? void 0 : options.vAlign) {
            case "start":
              sBottom = sTop + miny;
              break;

            case "end":
              sTop = sBottom - miny;
              break;

            case "center":
              sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;
              sBottom = sTop + miny;
              break;
          }

          if (sLeft > bounds.x) {
            scrollX = bounds.x - sLeft;
          } else if (sRight < bounds.x + bounds.width) {
            scrollX = bounds.x + bounds.width - sRight;
          }

          if (sTop > bounds.y) {
            scrollY = bounds.y - sTop;
          } else if (sBottom < bounds.y + bounds.height) {
            scrollY = bounds.y + bounds.height - sBottom;
          }

          if (dir === "vertical" || col < freezeColumns) {
            scrollX = 0;
          } else if (dir === "horizontal") {
            scrollY = 0;
          }

          if (scrollX !== 0 || scrollY !== 0) {
            scrollRef.current.scrollTo(scrollX + scrollRef.current.scrollLeft, scrollY + scrollRef.current.scrollTop);
          }
        }
      }
    }
  }, [rowMarkerOffset, rowMarkerWidth, totalHeaderHeight, lastRowSticky, freezeColumns, columns, rowHeight, rows]);
  const focusCallback = react.useRef(focusOnRowFromTrailingBlankRow);
  const getCellContentRef = react.useRef(getCellContent);
  const rowsRef = react.useRef(rows);
  focusCallback.current = focusOnRowFromTrailingBlankRow;
  getCellContentRef.current = getCellContent;
  rowsRef.current = rows;
  const appendRow = react.useCallback(async col => {
    var _c$trailingRowOptions6;

    const c = mangledCols[col];

    if ((c === null || c === void 0 ? void 0 : (_c$trailingRowOptions6 = c.trailingRowOptions) === null || _c$trailingRowOptions6 === void 0 ? void 0 : _c$trailingRowOptions6.disabled) === true) {
      return;
    }

    const appendResult = onRowAppended === null || onRowAppended === void 0 ? void 0 : onRowAppended();
    let r = undefined;
    let bottom = true;

    if (appendResult !== undefined) {
      r = await appendResult;
      if (r === "top") bottom = false;
      if (typeof r === "number") bottom = false;
    }

    let backoff = 0;

    const doFocus = () => {
      if (rowsRef.current <= rows) {
        if (backoff < 500) {
          window.setTimeout(doFocus, backoff);
        }

        backoff = 50 + backoff * 2;
        return;
      }

      const row = typeof r === "number" ? r : bottom ? rows : 0;
      scrollTo(col - rowMarkerOffset, row);
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, false, false, "edit");
      const cell = getCellContentRef.current([col - rowMarkerOffset, row]);

      if (cell.allowOverlay && (0,data_grid_types/* isReadWriteCell */.Qo)(cell) && cell.readonly !== true) {
        window.setTimeout(() => {
          focusCallback.current(col, row);
        }, 0);
      }
    };

    doFocus();
  }, [mangledCols, onRowAppended, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const getCustomNewRowTargetColumn = react.useCallback(col => {
    var _columns$col$trailing, _columns$col, _columns$col$trailing2;

    const customTargetColumn = (_columns$col$trailing = (_columns$col = columns[col]) === null || _columns$col === void 0 ? void 0 : (_columns$col$trailing2 = _columns$col.trailingRowOptions) === null || _columns$col$trailing2 === void 0 ? void 0 : _columns$col$trailing2.targetColumn) !== null && _columns$col$trailing !== void 0 ? _columns$col$trailing : trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.targetColumn;

    if (typeof customTargetColumn === "number") {
      const customTargetOffset = hasRowMarkers ? 1 : 0;
      return customTargetColumn + customTargetOffset;
    }

    if (typeof customTargetColumn === "object") {
      const maybeIndex = columnsIn.indexOf(customTargetColumn);

      if (maybeIndex >= 0) {
        const customTargetOffset = hasRowMarkers ? 1 : 0;
        return maybeIndex + customTargetOffset;
      }
    }

    return undefined;
  }, [columns, columnsIn, hasRowMarkers, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.targetColumn]);
  const lastSelectedRowRef = react.useRef();
  const lastSelectedColRef = react.useRef();
  const themeForCell = react.useCallback((cell, pos) => {
    var _mangledCols$col;

    const [col, row] = pos;
    return { ...mergedTheme,
      ...((_mangledCols$col = mangledCols[col]) === null || _mangledCols$col === void 0 ? void 0 : _mangledCols$col.themeOverride),
      ...(getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row)),
      ...cell.themeOverride
    };
  }, [getRowThemeOverride, mangledCols, mergedTheme]);
  const handleSelect = react.useCallback(args => {
    var _gridSelection$curren, _gridSelection$curren2;

    const isMultiKey = browser_detect/* browserIsOSX.value */.FR.value ? args.metaKey : args.ctrlKey;
    const isMultiRow = isMultiKey && rowSelect === "multi";
    const isMultiCol = isMultiKey && columnSelect === "multi";
    const [col, row] = args.location;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const [cellCol, cellRow] = (_gridSelection$curren = (_gridSelection$curren2 = gridSelection.current) === null || _gridSelection$curren2 === void 0 ? void 0 : _gridSelection$curren2.cell) !== null && _gridSelection$curren !== void 0 ? _gridSelection$curren : [];

    if (args.kind === "cell") {
      lastSelectedColRef.current = undefined;
      lastMouseSelectLocation.current = [col, row];

      if (col === 0 && hasRowMarkers) {
        if (showTrailingBlankRow === true && row === rows || rowMarkers === "number" || rowSelect === "none") return;
        const markerCell = getMangledCellContent(args.location);

        if (markerCell.kind !== data_grid_types/* InnerGridCellKind.Marker */.$o.Marker) {
          return;
        }

        if (onRowMoved !== undefined) {
          var _renderer$onClick;

          const renderer = getCellRenderer(markerCell);
          (0,support/* assert */.hu)((renderer === null || renderer === void 0 ? void 0 : renderer.kind) === data_grid_types/* InnerGridCellKind.Marker */.$o.Marker);
          const postClick = renderer === null || renderer === void 0 ? void 0 : (_renderer$onClick = renderer.onClick) === null || _renderer$onClick === void 0 ? void 0 : _renderer$onClick.call(renderer, { ...args,
            cell: markerCell,
            posX: args.localEventX,
            posY: args.localEventY,
            bounds: args.bounds,
            theme: themeForCell(markerCell, args.location),
            preventDefault: () => undefined
          });
          if (postClick === undefined || postClick.checked === markerCell.checked) return;
        }

        setOverlay(undefined);
        focus();
        const isSelected = selectedRows.hasIndex(row);
        const lastHighlighted = lastSelectedRowRef.current;

        if (rowSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastHighlighted !== undefined && selectedRows.hasIndex(lastHighlighted)) {
          const newSlice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];

          if (isMultiRow || rowSelectionMode === "multi") {
            setSelectedRows(undefined, newSlice, true);
          } else {
            setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(newSlice), undefined, isMultiRow);
          }
        } else if (isMultiRow || args.isTouch || rowSelectionMode === "multi") {
          if (isSelected) {
            setSelectedRows(selectedRows.remove(row), undefined, true);
          } else {
            setSelectedRows(undefined, row, true);
            lastSelectedRowRef.current = row;
          }
        } else if (isSelected && selectedRows.length === 1) {
          setSelectedRows(data_grid_types/* CompactSelection.empty */.EV.empty(), undefined, isMultiKey);
        } else {
          setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(row), undefined, isMultiKey);
          lastSelectedRowRef.current = row;
        }
      } else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {
        const customTargetColumn = getCustomNewRowTargetColumn(col);
        void appendRow(customTargetColumn !== null && customTargetColumn !== void 0 ? customTargetColumn : col);
      } else {
        if (cellCol !== col || cellRow !== row) {
          var _gridSelection$curren3;

          const cell = getMangledCellContent(args.location);
          const renderer = getCellRenderer(cell);

          if ((renderer === null || renderer === void 0 ? void 0 : renderer.onSelect) !== undefined) {
            let prevented = false;
            renderer.onSelect({ ...args,
              cell,
              posX: args.localEventX,
              posY: args.localEventY,
              bounds: args.bounds,
              preventDefault: () => prevented = true,
              theme: themeForCell(cell, args.location)
            });

            if (prevented) {
              return;
            }
          }

          const isLastStickyRow = lastRowSticky && row === rows;
          const startedFromLastSticky = lastRowSticky && gridSelection !== undefined && ((_gridSelection$curren3 = gridSelection.current) === null || _gridSelection$curren3 === void 0 ? void 0 : _gridSelection$curren3.cell[1]) === rows;

          if ((args.shiftKey || args.isLongTouch === true) && cellCol !== undefined && cellRow !== undefined && gridSelection.current !== undefined && !startedFromLastSticky) {
            if (isLastStickyRow) {
              return;
            }

            const left = Math.min(col, cellCol);
            const right = Math.max(col, cellCol);
            const top = Math.min(row, cellRow);
            const bottom = Math.max(row, cellRow);
            setCurrent({ ...gridSelection.current,
              range: {
                x: left,
                y: top,
                width: right - left + 1,
                height: bottom - top + 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = undefined;
            focus();
          } else {
            setCurrent({
              cell: [col, row],
              range: {
                x: col,
                y: row,
                width: 1,
                height: 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = undefined;
            setOverlay(undefined);
            focus();
          }
        }
      }
    } else if (args.kind === "header") {
      lastMouseSelectLocation.current = [col, row];
      setOverlay(undefined);

      if (hasRowMarkers && col === 0) {
        lastSelectedRowRef.current = undefined;
        lastSelectedColRef.current = undefined;

        if (rowSelect === "multi") {
          if (selectedRows.length !== rows) {
            setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection([0, rows]), undefined, isMultiKey);
          } else {
            setSelectedRows(data_grid_types/* CompactSelection.empty */.EV.empty(), undefined, isMultiKey);
          }

          focus();
        }
      } else {
        const lastCol = lastSelectedColRef.current;

        if (columnSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastCol !== undefined && selectedColumns.hasIndex(lastCol)) {
          const newSlice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];

          if (isMultiCol) {
            setSelectedColumns(undefined, newSlice, isMultiKey);
          } else {
            setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(newSlice), undefined, isMultiKey);
          }
        } else if (isMultiCol) {
          if (selectedColumns.hasIndex(col)) {
            setSelectedColumns(selectedColumns.remove(col), undefined, isMultiKey);
          } else {
            setSelectedColumns(undefined, col, isMultiKey);
          }

          lastSelectedColRef.current = col;
        } else if (columnSelect !== "none") {
          setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(col), undefined, isMultiKey);
          lastSelectedColRef.current = col;
        }

        lastSelectedRowRef.current = undefined;
        focus();
      }
    } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      lastMouseSelectLocation.current = [col, row];
    } else if (args.kind === data_grid_types/* outOfBoundsKind */.Xv) {
      setGridSelection(emptyGridSelection, false);
      setOverlay(undefined);
      focus();
      onSelectionCleared === null || onSelectionCleared === void 0 ? void 0 : onSelectionCleared();
      lastSelectedRowRef.current = undefined;
      lastSelectedColRef.current = undefined;
    }
  }, [appendRow, columnSelect, focus, getCellRenderer, getCustomNewRowTargetColumn, getMangledCellContent, gridSelection, hasRowMarkers, lastRowSticky, onSelectionCleared, onRowMoved, rowMarkerOffset, rowMarkers, rowSelect, rowSelectionMode, rows, setCurrent, setGridSelection, setSelectedColumns, setSelectedRows, showTrailingBlankRow, themeForCell]);
  const lastMouseSelectLocation = react.useRef();
  const touchDownArgs = react.useRef(visibleRegion);
  const mouseDownData = react.useRef();
  const onMouseDown = react.useCallback(args => {
    var _mouseDownData$curren, _mouseDownData$curren2;

    isPrevented.current = false;
    touchDownArgs.current = visibleRegionRef.current;

    if (args.button !== 0) {
      mouseDownData.current = undefined;
      return;
    }

    const time = performance.now();
    const wasDoubleClick = time - ((_mouseDownData$curren = (_mouseDownData$curren2 = mouseDownData.current) === null || _mouseDownData$curren2 === void 0 ? void 0 : _mouseDownData$curren2.time) !== null && _mouseDownData$curren !== void 0 ? _mouseDownData$curren : -1000) < 250;
    mouseDownData.current = {
      wasDoubleClick,
      time,
      location: args.location
    };
    const fh = args.kind === "cell" && args.isFillHandle;
    if (!fh && args.kind !== "cell" && args.isEdge) return;
    setMouseState({
      previousSelection: gridSelection,
      fillHandle: fh
    });
    lastMouseSelectLocation.current = undefined;

    if (!args.isTouch) {
      handleSelect(args);
    }
  }, [gridSelection, handleSelect]);
  const [renameGroup, setRenameGroup] = react.useState();
  const handleGroupHeaderSelection = react.useCallback(args => {
    if (args.kind !== data_grid_types/* groupHeaderKind */.mr || columnSelect !== "multi") {
      return;
    }

    const isMultiKey = browser_detect/* browserIsOSX.value */.FR.value ? args.metaKey : args.ctrlKey;
    const [col] = args.location;
    const selectedColumns = gridSelection.columns;
    if (col < rowMarkerOffset) return;
    const needle = mangledCols[col];
    let start = col;
    let end = col;

    for (let i = col - 1; i >= rowMarkerOffset; i--) {
      if (!(0,data_grid_lib/* isGroupEqual */.PU)(needle.group, mangledCols[i].group)) break;
      start--;
    }

    for (let i = col + 1; i < mangledCols.length; i++) {
      if (!(0,data_grid_lib/* isGroupEqual */.PU)(needle.group, mangledCols[i].group)) break;
      end++;
    }

    focus();

    if (isMultiKey) {
      if (selectedColumns.hasAll([start, end + 1])) {
        let newVal = selectedColumns;

        for (let index = start; index <= end; index++) {
          newVal = newVal.remove(index);
        }

        setSelectedColumns(newVal, undefined, isMultiKey);
      } else {
        setSelectedColumns(undefined, [start, end + 1], isMultiKey);
      }
    } else {
      setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection([start, end + 1]), undefined, isMultiKey);
    }
  }, [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]);
  const fillDown = react.useCallback(reverse => {
    var _gridRef$current5;

    if (gridSelection.current === undefined) return;
    const v = [];
    const r = gridSelection.current.range;

    for (let x = 0; x < r.width; x++) {
      const fillCol = x + r.x;
      const fillVal = getMangledCellContent([fillCol, reverse ? r.y + r.height - 1 : r.y]);
      if ((0,data_grid_types/* isInnerOnlyCell */.rs)(fillVal) || !(0,data_grid_types/* isReadWriteCell */.Qo)(fillVal)) continue;

      for (let y = 1; y < r.height; y++) {
        const fillRow = reverse ? r.y + r.height - (y + 1) : y + r.y;
        const target = [fillCol, fillRow];
        v.push({
          location: target,
          value: { ...fillVal
          }
        });
      }
    }

    mangledOnCellsEdited(v);
    (_gridRef$current5 = gridRef.current) === null || _gridRef$current5 === void 0 ? void 0 : _gridRef$current5.damage(v.map(c => ({
      cell: c.location
    })));
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited]);
  const isPrevented = react.useRef(false);
  const onContextMenu = react.useCallback((args, preventDefault) => {
    const clickLocation = args.location[0] - rowMarkerOffset;

    if (args.kind === "header") {
      onHeaderContextMenu === null || onHeaderContextMenu === void 0 ? void 0 : onHeaderContextMenu(clickLocation, { ...args,
        preventDefault
      });
    }

    if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      if (clickLocation < 0) {
        return;
      }

      onGroupHeaderContextMenu === null || onGroupHeaderContextMenu === void 0 ? void 0 : onGroupHeaderContextMenu(clickLocation, { ...args,
        preventDefault
      });
    }

    if (args.kind === "cell") {
      onCellContextMenu === null || onCellContextMenu === void 0 ? void 0 : onCellContextMenu([clickLocation, args.location[1]], { ...args,
        preventDefault
      });
    }
  }, [onCellContextMenu, onGroupHeaderContextMenu, onHeaderContextMenu, rowMarkerOffset]);
  const normalSizeColumn = react.useCallback(async col => {
    var _mouseDownData$curren3;

    if (((_mouseDownData$curren3 = mouseDownData.current) === null || _mouseDownData$curren3 === void 0 ? void 0 : _mouseDownData$curren3.wasDoubleClick) === true && getCellsForSelection !== undefined && onColumnResize !== undefined) {
      const start = visibleRegionRef.current.y;
      const end = visibleRegionRef.current.height;
      let cells = getCellsForSelection({
        x: col,
        y: start,
        width: 1,
        height: Math.min(end, rows - start)
      }, abortControllerRef.current.signal);

      if (typeof cells !== "object") {
        cells = await cells();
      }

      const inputCol = columns[col - rowMarkerOffset];
      const offscreen = document.createElement("canvas");
      const ctx = offscreen.getContext("2d", {
        alpha: false
      });

      if (ctx !== null) {
        ctx.font = `${mergedTheme.baseFontStyle} ${mergedTheme.fontFamily}`;
        const newCol = measureColumn(ctx, mergedTheme, inputCol, 0, cells, minColumnWidth, maxColumnWidth, false, getCellRenderer);
        onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(inputCol, newCol.width, col, newCol.width);
      }
    }
  }, [columns, getCellsForSelection, maxColumnWidth, mergedTheme, minColumnWidth, onColumnResize, rowMarkerOffset, rows, getCellRenderer]);
  const [scrollDir, setScrollDir] = react.useState();
  const onMouseUp = react.useCallback((args, isOutside) => {
    var _lastMouseSelectLocat;

    const mouse = mouseState;
    setMouseState(undefined);
    setScrollDir(undefined);
    if (isOutside) return;

    if ((mouse === null || mouse === void 0 ? void 0 : mouse.fillHandle) === true && gridSelection.current !== undefined) {
      fillDown(gridSelection.current.cell[1] !== gridSelection.current.range.y);
      return;
    }

    const [col, row] = args.location;
    const [lastMouseDownCol, lastMouseDownRow] = (_lastMouseSelectLocat = lastMouseSelectLocation.current) !== null && _lastMouseSelectLocat !== void 0 ? _lastMouseSelectLocat : [];

    const preventDefault = () => {
      isPrevented.current = true;
    };

    const handleMaybeClick = a => {
      if (a.isTouch || lastMouseDownCol === col && lastMouseDownRow === row) {
        onCellClicked === null || onCellClicked === void 0 ? void 0 : onCellClicked([col - rowMarkerOffset, row], { ...a,
          preventDefault
        });
      }

      if (!isPrevented.current) {
        var _mouse$previousSelect, _mouse$previousSelect2;

        const c = getMangledCellContent(args.location);
        const r = getCellRenderer(c);

        if (r !== undefined && r.onClick !== undefined) {
          const newVal = r.onClick({ ...a,
            cell: c,
            posX: a.localEventX,
            posY: a.localEventY,
            bounds: a.bounds,
            theme: themeForCell(c, args.location),
            preventDefault
          });

          if (newVal !== undefined && !(0,data_grid_types/* isInnerOnlyCell */.rs)(newVal) && (0,data_grid_types/* isEditableGridCell */.T9)(newVal)) {
            var _gridRef$current6;

            mangledOnCellsEdited([{
              location: a.location,
              value: newVal
            }]);
            (_gridRef$current6 = gridRef.current) === null || _gridRef$current6 === void 0 ? void 0 : _gridRef$current6.damage([{
              cell: a.location
            }]);
          }
        }

        if (!isPrevented.current && (mouse === null || mouse === void 0 ? void 0 : (_mouse$previousSelect = mouse.previousSelection) === null || _mouse$previousSelect === void 0 ? void 0 : (_mouse$previousSelect2 = _mouse$previousSelect.current) === null || _mouse$previousSelect2 === void 0 ? void 0 : _mouse$previousSelect2.cell) !== undefined && gridSelection.current !== undefined) {
          const [selectedCol, selectedRow] = gridSelection.current.cell;
          const [prevCol, prevRow] = mouse.previousSelection.current.cell;

          if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {
            onCellActivated === null || onCellActivated === void 0 ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
            reselect(a.bounds, false);
            return true;
          }
        }
      }

      return false;
    };

    const clickLocation = args.location[0] - rowMarkerOffset;

    if (args.isTouch) {
      const vr = visibleRegionRef.current;
      const touchVr = touchDownArgs.current;

      if (vr.x !== touchVr.x || vr.y !== touchVr.y) {
        return;
      }

      if (args.isLongTouch === true) {
        var _gridSelection$curren4, _gridSelection$curren5;

        if (args.kind === "cell" && (gridSelection === null || gridSelection === void 0 ? void 0 : (_gridSelection$curren4 = gridSelection.current) === null || _gridSelection$curren4 === void 0 ? void 0 : _gridSelection$curren4.cell[0]) === col && (gridSelection === null || gridSelection === void 0 ? void 0 : (_gridSelection$curren5 = gridSelection.current) === null || _gridSelection$curren5 === void 0 ? void 0 : _gridSelection$curren5.cell[1]) === row) {
          onCellContextMenu === null || onCellContextMenu === void 0 ? void 0 : onCellContextMenu([clickLocation, args.location[1]], { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === "header" && gridSelection.columns.hasIndex(col)) {
          onHeaderContextMenu === null || onHeaderContextMenu === void 0 ? void 0 : onHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
          if (clickLocation < 0) {
            return;
          }

          onGroupHeaderContextMenu === null || onGroupHeaderContextMenu === void 0 ? void 0 : onGroupHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        }
      }

      if (args.kind === "cell") {
        if (!handleMaybeClick(args)) {
          handleSelect(args);
        }
      } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
        onGroupHeaderClicked === null || onGroupHeaderClicked === void 0 ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      } else {
        if (args.kind === data_grid_types/* headerKind */.aZ) {
          onHeaderClicked === null || onHeaderClicked === void 0 ? void 0 : onHeaderClicked(clickLocation, { ...args,
            preventDefault
          });
        }

        handleSelect(args);
      }

      return;
    }

    if (args.kind === "header") {
      if (clickLocation < 0) {
        return;
      }

      if (args.isEdge) {
        void normalSizeColumn(col);
      } else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onHeaderClicked === null || onHeaderClicked === void 0 ? void 0 : onHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      }
    }

    if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      if (clickLocation < 0) {
        return;
      }

      if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onGroupHeaderClicked === null || onGroupHeaderClicked === void 0 ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });

        if (!isPrevented.current) {
          handleGroupHeaderSelection(args);
        }
      }
    }

    if (args.kind === "cell" && args.button === 0) {
      handleMaybeClick(args);
    }

    lastMouseSelectLocation.current = undefined;
  }, [mouseState, rowMarkerOffset, gridSelection, onCellClicked, fillDown, getMangledCellContent, getCellRenderer, themeForCell, mangledOnCellsEdited, onCellActivated, reselect, onCellContextMenu, onHeaderContextMenu, onGroupHeaderContextMenu, handleSelect, onGroupHeaderClicked, normalSizeColumn, onHeaderClicked, handleGroupHeaderSelection]);
  const onMouseMoveImpl = react.useCallback(args => {
    const a = { ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    };
    onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(a);
    setScrollDir(cv => {
      var _mouseDownData$curren4, _mouseDownData$curren5;

      if (args.scrollEdge[0] === (cv === null || cv === void 0 ? void 0 : cv[0]) && args.scrollEdge[1] === cv[1]) return cv;
      return mouseState === undefined || ((_mouseDownData$curren4 = (_mouseDownData$curren5 = mouseDownData.current) === null || _mouseDownData$curren5 === void 0 ? void 0 : _mouseDownData$curren5.location[0]) !== null && _mouseDownData$curren4 !== void 0 ? _mouseDownData$curren4 : 0) < rowMarkerOffset ? undefined : args.scrollEdge;
    });
  }, [mouseState, onMouseMove, rowMarkerOffset]);
  useAutoscroll(scrollDir, scrollRef);
  const onHeaderMenuClickInner = react.useCallback((col, screenPosition) => {
    onHeaderMenuClick === null || onHeaderMenuClick === void 0 ? void 0 : onHeaderMenuClick(col - rowMarkerOffset, screenPosition);
  }, [onHeaderMenuClick, rowMarkerOffset]);
  const currentCell = gridSelection === null || gridSelection === void 0 ? void 0 : (_gridSelection$curren6 = gridSelection.current) === null || _gridSelection$curren6 === void 0 ? void 0 : _gridSelection$curren6.cell;
  const onVisibleRegionChangedImpl = react.useCallback((region, clientWidth, clientHeight, rightElWidth, tx, ty) => {
    let selected = currentCell;

    if (selected !== undefined) {
      selected = [selected[0] - rowMarkerOffset, selected[1]];
    }

    const newRegion = {
      x: region.x - rowMarkerOffset,
      y: region.y,
      width: region.width,
      height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,
      tx,
      ty,
      extras: {
        selected,
        freezeRegion: freezeColumns === 0 ? undefined : {
          x: 0,
          y: region.y,
          width: freezeColumns,
          height: region.height
        }
      }
    };
    setClientSize([clientWidth, clientHeight, rightElWidth]);
    setVisibleRegion(newRegion);
    onVisibleRegionChanged === null || onVisibleRegionChanged === void 0 ? void 0 : onVisibleRegionChanged(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);
  }, [currentCell, rowMarkerOffset, showTrailingBlankRow, rows, freezeColumns, setVisibleRegion, onVisibleRegionChanged]);
  const onColumnMovedImpl = (0,utils/* whenDefined */.qJ)(onColumnMoved, react.useCallback((startIndex, endIndex) => {
    onColumnMoved === null || onColumnMoved === void 0 ? void 0 : onColumnMoved(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);

    if (columnSelect !== "none") {
      setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(endIndex), undefined, true);
    }
  }, [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]));
  const isActivelyDragging = react.useRef(false);
  const onDragStartImpl = react.useCallback(args => {
    if (args.location[0] === 0 && rowMarkerOffset > 0) {
      args.preventDefault();
      return;
    }

    onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });

    if (!args.defaultPrevented()) {
      isActivelyDragging.current = true;
    }

    setMouseState(undefined);
  }, [onDragStart, rowMarkerOffset]);
  const onDragEnd = react.useCallback(() => {
    isActivelyDragging.current = false;
  }, []);
  const onItemHoveredImpl = react.useCallback(args => {
    if (mouseState !== undefined && gridSelection.current !== undefined && !isActivelyDragging.current && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
      const [selectedCol, selectedRow] = gridSelection.current.cell;
      let [col, row] = args.location;

      if (row < 0) {
        row = visibleRegionRef.current.y;
      }

      const startedFromLastStickyRow = lastRowSticky && selectedRow === rows;
      if (startedFromLastStickyRow) return;
      const landedOnLastStickyRow = lastRowSticky && row === rows;

      if (landedOnLastStickyRow) {
        if (args.kind === data_grid_types/* outOfBoundsKind */.Xv) row--;else return;
      }

      col = Math.max(col, rowMarkerOffset);
      const deltaX = col - selectedCol;
      const deltaY = row - selectedRow;
      const newRange = {
        x: deltaX >= 0 ? selectedCol : col,
        y: deltaY >= 0 ? selectedRow : row,
        width: Math.abs(deltaX) + 1,
        height: Math.abs(deltaY) + 1
      };
      setCurrent({ ...gridSelection.current,
        range: newRange
      }, true, false, "drag");
    }

    onItemHovered === null || onItemHovered === void 0 ? void 0 : onItemHovered({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });
  }, [mouseState, gridSelection, rangeSelect, onItemHovered, rowMarkerOffset, lastRowSticky, rows, setCurrent]);
  const adjustSelection = react.useCallback(direction => {
    if (gridSelection.current === undefined) return;
    const [x, y] = direction;
    const [col, row] = gridSelection.current.cell;
    const old = gridSelection.current.range;
    let left = old.x;
    let right = old.x + old.width;
    let top = old.y;
    let bottom = old.y + old.height;

    if (y !== 0) {
      switch (y) {
        case 2:
          {
            bottom = rows;
            top = row;
            scrollTo(0, bottom, "vertical");
            break;
          }

        case -2:
          {
            top = 0;
            bottom = row + 1;
            scrollTo(0, top, "vertical");
            break;
          }

        case 1:
          {
            if (top < row) {
              top++;
              scrollTo(0, top, "vertical");
            } else {
              bottom = Math.min(rows, bottom + 1);
              scrollTo(0, bottom, "vertical");
            }

            break;
          }

        case -1:
          {
            if (bottom > row + 1) {
              bottom--;
              scrollTo(0, bottom, "vertical");
            } else {
              top = Math.max(0, top - 1);
              scrollTo(0, top, "vertical");
            }

            break;
          }

        default:
          {
            (0,support/* assertNever */.vE)(y);
          }
      }
    }

    if (x !== 0) {
      if (x === 2) {
        right = mangledCols.length;
        left = col;
        scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
      } else if (x === -2) {
        left = rowMarkerOffset;
        right = col + 1;
        scrollTo(left - rowMarkerOffset, 0, "horizontal");
      } else {
        let disallowed = [];

        if (getCellsForSelection !== undefined) {
          const cells = getCellsForSelection({
            x: left,
            y: top,
            width: right - left - rowMarkerOffset,
            height: bottom - top
          }, abortControllerRef.current.signal);

          if (typeof cells === "object") {
            disallowed = getSpanStops(cells);
          }
        }

        if (x === 1) {
          let done = false;

          if (left < col) {
            if (disallowed.length > 0) {
              const target = range_default()(left + 1, col + 1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== undefined) {
                left = target;
                done = true;
              }
            } else {
              left++;
              done = true;
            }

            if (done) scrollTo(left, 0, "horizontal");
          }

          if (!done) {
            right = Math.min(mangledCols.length, right + 1);
            scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
          }
        } else if (x === -1) {
          let done = false;

          if (right > col + 1) {
            if (disallowed.length > 0) {
              const target = range_default()(right - 1, col, -1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== undefined) {
                right = target;
                done = true;
              }
            } else {
              right--;
              done = true;
            }

            if (done) scrollTo(right - rowMarkerOffset, 0, "horizontal");
          }

          if (!done) {
            left = Math.max(rowMarkerOffset, left - 1);
            scrollTo(left - rowMarkerOffset, 0, "horizontal");
          }
        } else {
          (0,support/* assertNever */.vE)(x);
        }
      }
    }

    setCurrent({
      cell: gridSelection.current.cell,
      range: {
        x: left,
        y: top,
        width: right - left,
        height: bottom - top
      }
    }, true, false, "keyboard-select");
  }, [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const updateSelectedCell = react.useCallback((col, row, fromEditingTrailingRow, freeMove) => {
    const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);
    col = clamp_default()(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);
    row = clamp_default()(row, 0, rowMax);
    if (col === (currentCell === null || currentCell === void 0 ? void 0 : currentCell[0]) && row === (currentCell === null || currentCell === void 0 ? void 0 : currentCell[1])) return false;

    if (freeMove && gridSelection.current !== undefined) {
      const newStack = [...gridSelection.current.rangeStack];

      if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {
        newStack.push(gridSelection.current.range);
      }

      setGridSelection({ ...gridSelection,
        current: {
          cell: [col, row],
          range: {
            x: col,
            y: row,
            width: 1,
            height: 1
          },
          rangeStack: newStack
        }
      }, true);
    } else {
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-nav");
    }

    if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {
      lastSent.current = undefined;
    }

    scrollTo(col - rowMarkerOffset, row);
    return true;
  }, [mangledRows, rowMarkerOffset, columns.length, currentCell, gridSelection, scrollTo, setGridSelection, setCurrent]);
  const onFinishEditing = react.useCallback((newValue, movement) => {
    if ((overlay === null || overlay === void 0 ? void 0 : overlay.cell) !== undefined && newValue !== undefined && (0,data_grid_types/* isEditableGridCell */.T9)(newValue)) {
      mangledOnCellsEdited([{
        location: overlay.cell,
        value: newValue
      }]);
      window.requestAnimationFrame(() => {
        var _gridRef$current7;

        (_gridRef$current7 = gridRef.current) === null || _gridRef$current7 === void 0 ? void 0 : _gridRef$current7.damage([{
          cell: overlay.cell
        }]);
      });
    }

    focus(true);
    setOverlay(undefined);
    const [movX, movY] = movement;

    if (gridSelection.current !== undefined && (movX !== 0 || movY !== 0)) {
      const isEditingTrailingRow = gridSelection.current.cell[1] === mangledRows - 1 && newValue !== undefined;
      updateSelectedCell(clamp_default()(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1), clamp_default()(gridSelection.current.cell[1] + movY, 0, mangledRows - 1), isEditingTrailingRow, false);
    }

    onFinishedEditing === null || onFinishedEditing === void 0 ? void 0 : onFinishedEditing(newValue, movement);
  }, [overlay === null || overlay === void 0 ? void 0 : overlay.cell, focus, gridSelection, onFinishedEditing, mangledOnCellsEdited, mangledRows, updateSelectedCell, mangledCols.length]);
  const overlayID = react.useMemo(() => {
    return `gdg-overlay-${idCounter++}`;
  }, []);
  const onKeyDown = react.useCallback(event => {
    const fn = async () => {
      let cancelled = false;

      if (onKeyDownIn !== undefined) {
        onKeyDownIn({ ...event,
          cancel: () => {
            cancelled = true;
          }
        });
      }

      if (cancelled) return;

      const cancel = () => {
        event.stopPropagation();
        event.preventDefault();
      };

      const overlayOpen = overlay !== undefined;
      const {
        altKey,
        shiftKey,
        metaKey,
        ctrlKey,
        key,
        bounds
      } = event;
      const isOSX = browser_detect/* browserIsOSX.value */.FR.value;
      const isPrimaryKey = isOSX ? metaKey : ctrlKey;
      const isDeleteKey = key === "Delete" || isOSX && key === "Backspace";
      const vr = visibleRegionRef.current;
      const selectedColumns = gridSelection.columns;
      const selectedRows = gridSelection.rows;

      if (key === "Escape") {
        if (overlayOpen) {
          setOverlay(undefined);
        } else if (keybindings.clear) {
          setGridSelection(emptyGridSelection, false);
          onSelectionCleared === null || onSelectionCleared === void 0 ? void 0 : onSelectionCleared();
        }

        return;
      } else if (isHotkey("primary+a", event) && keybindings.selectAll) {
        if (!overlayOpen) {
          var _gridSelection$curren7, _gridSelection$curren8;

          setGridSelection({
            columns: data_grid_types/* CompactSelection.empty */.EV.empty(),
            rows: data_grid_types/* CompactSelection.empty */.EV.empty(),
            current: {
              cell: (_gridSelection$curren7 = (_gridSelection$curren8 = gridSelection.current) === null || _gridSelection$curren8 === void 0 ? void 0 : _gridSelection$curren8.cell) !== null && _gridSelection$curren7 !== void 0 ? _gridSelection$curren7 : [rowMarkerOffset, 0],
              range: {
                x: rowMarkerOffset,
                y: 0,
                width: columnsIn.length,
                height: rows
              },
              rangeStack: []
            }
          }, false);
        } else {
          const el = document.getElementById(overlayID);

          if (el !== null) {
            const s = window.getSelection();
            const r = document.createRange();
            r.selectNodeContents(el);
            s === null || s === void 0 ? void 0 : s.removeAllRanges();
            s === null || s === void 0 ? void 0 : s.addRange(r);
          }
        }

        cancel();
        return;
      } else if (isHotkey("primary+f", event) && keybindings.search) {
        var _searchInputRef$curre;

        cancel();
        searchInputRef === null || searchInputRef === void 0 ? void 0 : (_searchInputRef$curre = searchInputRef.current) === null || _searchInputRef$curre === void 0 ? void 0 : _searchInputRef$curre.focus({
          preventScroll: true
        });
        setShowSearchInner(true);
      }

      function deleteRange(r) {
        var _gridRef$current8;

        focus();
        const editList = [];

        for (let x = r.x; x < r.x + r.width; x++) {
          for (let y = r.y; y < r.y + r.height; y++) {
            const cellValue = getCellContent([x - rowMarkerOffset, y]);
            if (!cellValue.allowOverlay && cellValue.kind !== data_grid_types/* GridCellKind.Boolean */.p6.Boolean) continue;
            let newVal = undefined;

            if (cellValue.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) {
              const editor = provideEditor === null || provideEditor === void 0 ? void 0 : provideEditor(cellValue);

              if ((0,data_grid_types/* isObjectEditorCallbackResult */.DP)(editor)) {
                var _editor$deletedValue;

                newVal = editor === null || editor === void 0 ? void 0 : (_editor$deletedValue = editor.deletedValue) === null || _editor$deletedValue === void 0 ? void 0 : _editor$deletedValue.call(editor, cellValue);
              }
            } else if ((0,data_grid_types/* isEditableGridCell */.T9)(cellValue) && cellValue.allowOverlay || cellValue.kind === data_grid_types/* GridCellKind.Boolean */.p6.Boolean) {
              var _toDelete$onDelete;

              const toDelete = getCellRenderer(cellValue);
              newVal = toDelete === null || toDelete === void 0 ? void 0 : (_toDelete$onDelete = toDelete.onDelete) === null || _toDelete$onDelete === void 0 ? void 0 : _toDelete$onDelete.call(toDelete, cellValue);
            }

            if (newVal !== undefined && !(0,data_grid_types/* isInnerOnlyCell */.rs)(newVal) && (0,data_grid_types/* isEditableGridCell */.T9)(newVal)) {
              editList.push({
                location: [x, y],
                value: newVal
              });
            }
          }
        }

        mangledOnCellsEdited(editList);
        (_gridRef$current8 = gridRef.current) === null || _gridRef$current8 === void 0 ? void 0 : _gridRef$current8.damage(editList.map(x => ({
          cell: x.location
        })));
      }

      if (isDeleteKey) {
        var _onDelete;

        const callbackResult = (_onDelete = onDelete === null || onDelete === void 0 ? void 0 : onDelete(gridSelection)) !== null && _onDelete !== void 0 ? _onDelete : true;
        cancel();

        if (callbackResult !== false) {
          const toDelete = callbackResult === true ? gridSelection : callbackResult;

          if (toDelete.current !== undefined) {
            deleteRange(toDelete.current.range);

            for (const r of toDelete.current.rangeStack) {
              deleteRange(r);
            }
          }

          for (const r of toDelete.rows) {
            deleteRange({
              x: rowMarkerOffset,
              y: r,
              width: mangledCols.length - rowMarkerOffset,
              height: 1
            });
          }

          for (const col of toDelete.columns) {
            deleteRange({
              x: col,
              y: 0,
              width: 1,
              height: rows
            });
          }
        }

        return;
      }

      if (gridSelection.current === undefined) return;
      let [col, row] = gridSelection.current.cell;
      let freeMove = false;

      if (keybindings.selectColumn && isHotkey("ctrl+ ", event) && columnSelect !== "none") {
        if (selectedColumns.hasIndex(col)) {
          setSelectedColumns(selectedColumns.remove(col), undefined, true);
        } else {
          if (columnSelect === "single") {
            setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(col), undefined, true);
          } else {
            setSelectedColumns(undefined, col, true);
          }
        }
      } else if (keybindings.selectRow && isHotkey("shift+ ", event) && rowSelect !== "none") {
        if (selectedRows.hasIndex(row)) {
          setSelectedRows(selectedRows.remove(row), undefined, true);
        } else {
          if (rowSelect === "single") {
            setSelectedRows(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(row), undefined, true);
          } else {
            setSelectedRows(undefined, row, true);
          }
        }
      } else if ((isHotkey("Enter", event) || isHotkey(" ", event) || isHotkey("shift+Enter", event)) && bounds !== undefined) {
        if (overlayOpen) {
          setOverlay(undefined);

          if (isHotkey("Enter", event)) {
            row++;
          } else if (isHotkey("shift+Enter", event)) {
            row--;
          }
        } else if (row === rows && showTrailingBlankRow) {
          window.setTimeout(() => {
            const customTargetColumn = getCustomNewRowTargetColumn(col);
            void appendRow(customTargetColumn !== null && customTargetColumn !== void 0 ? customTargetColumn : col);
          }, 0);
        } else {
          onCellActivated === null || onCellActivated === void 0 ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
          reselect(bounds, true);
          cancel();
        }
      } else if (keybindings.downFill && isHotkey("primary+_68", event) && gridSelection.current.range.height > 1) {
        fillDown(false);
        cancel();
      } else if (keybindings.rightFill && isHotkey("primary+_82", event) && gridSelection.current.range.width > 1) {
        var _gridRef$current9;

        const editList = [];
        const r = gridSelection.current.range;

        for (let y = 0; y < r.height; y++) {
          const fillRow = y + r.y;
          const fillVal = getMangledCellContent([r.x, fillRow]);
          if ((0,data_grid_types/* isInnerOnlyCell */.rs)(fillVal) || !(0,data_grid_types/* isReadWriteCell */.Qo)(fillVal)) continue;

          for (let x = 1; x < r.width; x++) {
            const fillCol = x + r.x;
            const target = [fillCol, fillRow];
            editList.push({
              location: target,
              value: { ...fillVal
              }
            });
          }
        }

        mangledOnCellsEdited(editList);
        (_gridRef$current9 = gridRef.current) === null || _gridRef$current9 === void 0 ? void 0 : _gridRef$current9.damage(editList.map(c => ({
          cell: c.location
        })));
        cancel();
      } else if (keybindings.pageDown && isHotkey("PageDown", event)) {
        row += Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.pageUp && isHotkey("PageUp", event)) {
        row -= Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.first && isHotkey("primary+Home", event)) {
        setOverlay(undefined);
        row = 0;
        col = 0;
      } else if (keybindings.last && isHotkey("primary+End", event)) {
        setOverlay(undefined);
        row = Number.MAX_SAFE_INTEGER;
        col = Number.MAX_SAFE_INTEGER;
      } else if (keybindings.first && isHotkey("primary+shift+Home", event)) {
        setOverlay(undefined);
        adjustSelection([-2, -2]);
      } else if (keybindings.last && isHotkey("primary+shift+End", event)) {
        setOverlay(undefined);
        adjustSelection([2, 2]);
      } else if (key === "ArrowDown") {
        if (ctrlKey && altKey) {
          return;
        }

        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, isPrimaryKey && !altKey ? 2 : 1]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          if (isPrimaryKey && !altKey) {
            row = rows - 1;
          } else {
            row += 1;
          }
        }
      } else if (key === "ArrowUp" || key === "Home") {
        const asPrimary = key === "Home" || isPrimaryKey;
        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, asPrimary && !altKey ? -2 : -1]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          row += asPrimary && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "ArrowRight" || key === "End") {
        const asPrimary = key === "End" || isPrimaryKey;
        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([asPrimary && !altKey ? 2 : 1, 0]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          col += asPrimary && !altKey ? Number.MAX_SAFE_INTEGER : 1;
        }
      } else if (key === "ArrowLeft") {
        setOverlay(undefined);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([isPrimaryKey && !altKey ? -2 : -1, 0]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          col += isPrimaryKey && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "Tab") {
        setOverlay(undefined);

        if (shiftKey) {
          col--;
        } else {
          col++;
        }
      } else if (!metaKey && !ctrlKey && gridSelection.current !== undefined && key.length === 1 && /[ -~]/g.test(key) && bounds !== undefined && (0,data_grid_types/* isReadWriteCell */.Qo)(getCellContent([col - rowMarkerOffset, Math.max(0, row - 1)]))) {
        if ((!lastRowSticky || row !== rows) && (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)) {
          return;
        }

        reselect(bounds, true, key);
        cancel();
      }

      const moved = updateSelectedCell(col, row, false, freeMove);

      if (moved) {
        cancel();
      }
    };

    void fn();
  }, [onKeyDownIn, overlay, gridSelection, keybindings.selectAll, keybindings.search, keybindings.selectColumn, keybindings.selectRow, keybindings.downFill, keybindings.rightFill, keybindings.pageDown, keybindings.pageUp, keybindings.first, keybindings.last, keybindings.clear, columnSelect, rowSelect, getCellContent, rowMarkerOffset, updateSelectedCell, setGridSelection, onSelectionCleared, columnsIn.length, rows, overlayID, focus, mangledOnCellsEdited, provideEditor, getCellRenderer, onDelete, mangledCols.length, setSelectedColumns, setSelectedRows, showTrailingBlankRow, getCustomNewRowTargetColumn, appendRow, onCellActivated, reselect, fillDown, getMangledCellContent, adjustSelection, rangeSelect, lastRowSticky]);
  const onPasteInternal = react.useCallback(async e => {
    var _scrollRef$current, _canvasRef$current, _gridSelection$curren9;

    if (!keybindings.paste) return;

    function pasteToCell(inner, target, toPaste) {
      if (!(0,data_grid_types/* isInnerOnlyCell */.rs)(inner) && (0,data_grid_types/* isReadWriteCell */.Qo)(inner) && inner.readonly !== true) {
        const coerced = coercePasteValue === null || coercePasteValue === void 0 ? void 0 : coercePasteValue(toPaste, inner);

        if (coerced !== undefined && (0,data_grid_types/* isEditableGridCell */.T9)(coerced)) {
          if (false) {}

          return {
            location: target,
            value: coerced
          };
        }

        const r = getCellRenderer(inner);
        if (r === undefined) return undefined;

        if (r.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) {
          var _r$onPaste;

          (0,support/* assert */.hu)(inner.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom);
          const newVal = (_r$onPaste = r.onPaste) === null || _r$onPaste === void 0 ? void 0 : _r$onPaste.call(r, toPaste, inner);
          if (newVal === undefined) return undefined;
          return {
            location: target,
            value: { ...inner,
              data: newVal
            }
          };
        } else {
          var _r$onPaste2;

          const newVal = (_r$onPaste2 = r.onPaste) === null || _r$onPaste2 === void 0 ? void 0 : _r$onPaste2.call(r, toPaste, inner);
          if (newVal === undefined) return undefined;
          (0,support/* assert */.hu)(newVal.kind === inner.kind);
          return {
            location: target,
            value: newVal
          };
        }
      }

      return undefined;
    }

    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const focused = ((_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.contains(document.activeElement)) === true || ((_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.contains(document.activeElement)) === true;
    let target = (_gridSelection$curren9 = gridSelection.current) === null || _gridSelection$curren9 === void 0 ? void 0 : _gridSelection$curren9.cell;

    if (target === undefined && selectedColumns.length === 1) {
      var _selectedColumns$firs;

      target = [(_selectedColumns$firs = selectedColumns.first()) !== null && _selectedColumns$firs !== void 0 ? _selectedColumns$firs : 0, 0];
    }

    if (target === undefined && selectedRows.length === 1) {
      var _selectedRows$first;

      target = [rowMarkerOffset, (_selectedRows$first = selectedRows.first()) !== null && _selectedRows$first !== void 0 ? _selectedRows$first : 0];
    }

    if (focused && target !== undefined) {
      var _gridRef$current10;

      let data;
      let text;
      const textPlain = "text/plain";
      const textHtml = "text/html";

      if (navigator.clipboard.read !== undefined) {
        const clipboardContent = await navigator.clipboard.read();

        for (const item of clipboardContent) {
          if (item.types.includes(textHtml)) {
            const htmlBlob = await item.getType(textHtml);
            const html = await htmlBlob.text();
            const fragment = document.createElement("html");
            fragment.innerHTML = html;
            const el = fragment.querySelector("table");

            if (el !== null) {
              data = decodeHTML(el);
              break;
            }
          }

          if (item.types.includes(textPlain)) {
            text = await (await item.getType(textPlain)).text();
          }
        }
      } else if (navigator.clipboard.readText !== undefined) {
        text = await navigator.clipboard.readText();
      } else if (e !== undefined && (e === null || e === void 0 ? void 0 : e.clipboardData) !== null) {
        if (e.clipboardData.types.includes(textHtml)) {
          const html = e.clipboardData.getData(textHtml);
          const fragment = document.createElement("html");
          fragment.innerHTML = html;
          const el = fragment.querySelector("table");

          if (el !== null) {
            data = decodeHTML(el);
          }
        }

        if (data === undefined && e.clipboardData.types.includes(textPlain)) {
          text = e.clipboardData.getData(textPlain);
        }
      } else {
        return;
      }

      const [gridCol, gridRow] = target;
      const editList = [];

      do {
        if (onPaste === undefined) {
          var _ref2, _text, _data;

          const cellData = getMangledCellContent(target);
          const newVal = pasteToCell(cellData, target, (_ref2 = (_text = text) !== null && _text !== void 0 ? _text : (_data = data) === null || _data === void 0 ? void 0 : _data.map(r => r.join("\t")).join("\t")) !== null && _ref2 !== void 0 ? _ref2 : "");

          if (newVal !== undefined) {
            editList.push(newVal);
          }

          break;
        }

        if (data === undefined) {
          if (text === undefined) return;
          data = unquote(text);
        }

        if (onPaste === false || typeof onPaste === "function" && (onPaste === null || onPaste === void 0 ? void 0 : onPaste([target[0] - rowMarkerOffset, target[1]], data)) !== true) {
          return;
        }

        for (const [row, dataRow] of data.entries()) {
          if (row + gridRow >= rows) break;

          for (const [col, dataItem] of dataRow.entries()) {
            const index = [col + gridCol, row + gridRow];
            const cellData = getMangledCellContent(index);
            const newVal = pasteToCell(cellData, index, dataItem);

            if (newVal !== undefined) {
              editList.push(newVal);
            }
          }
        }
      } while (false);

      mangledOnCellsEdited(editList);
      (_gridRef$current10 = gridRef.current) === null || _gridRef$current10 === void 0 ? void 0 : _gridRef$current10.damage(editList.map(c => ({
        cell: c.location
      })));
    }
  }, [coercePasteValue, getCellRenderer, getMangledCellContent, gridSelection, keybindings.paste, mangledOnCellsEdited, onPaste, rowMarkerOffset, rows]);
  (0,utils/* useEventListener */.OR)("paste", onPasteInternal, window, false, true);
  const onCopy = react.useCallback(async (e, ignoreFocus) => {
    var _scrollRef$current2, _canvasRef$current2;

    if (!keybindings.copy) return;
    const focused = ignoreFocus === true || ((_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 ? void 0 : _scrollRef$current2.contains(document.activeElement)) === true || ((_canvasRef$current2 = canvasRef.current) === null || _canvasRef$current2 === void 0 ? void 0 : _canvasRef$current2.contains(document.activeElement)) === true;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;

    if (focused && getCellsForSelection !== undefined) {
      if (gridSelection.current !== undefined) {
        let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);

        if (typeof thunk !== "object") {
          thunk = await thunk();
        }

        copyToClipboard(thunk, range_default()(gridSelection.current.range.x - rowMarkerOffset, gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset), e);
      } else if (selectedRows !== undefined && selectedRows.length > 0) {
        const toCopy = [...selectedRows];
        const cells = toCopy.map(rowIndex => {
          const thunk = getCellsForSelection({
            x: rowMarkerOffset,
            y: rowIndex,
            width: columnsIn.length - rowMarkerOffset,
            height: 1
          }, abortControllerRef.current.signal);

          if (typeof thunk === "object") {
            return thunk[0];
          }

          return thunk().then(v => v[0]);
        });

        if (cells.some(x => x instanceof Promise)) {
          const settled = await Promise.all(cells);
          copyToClipboard(settled, range_default()(columnsIn.length), e);
        } else {
          copyToClipboard(cells, range_default()(columnsIn.length), e);
        }
      } else if (selectedColumns.length > 0) {
        const results = [];
        const cols = [];

        for (const col of selectedColumns) {
          let thunk = getCellsForSelection({
            x: col,
            y: 0,
            width: 1,
            height: rows
          }, abortControllerRef.current.signal);

          if (typeof thunk !== "object") {
            thunk = await thunk();
          }

          results.push(thunk);
          cols.push(col - rowMarkerOffset);
        }

        if (results.length === 1) {
          copyToClipboard(results[0], cols, e);
        } else {
          const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));
          copyToClipboard(toCopy, cols, e);
        }
      }
    }
  }, [columnsIn.length, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows]);
  (0,utils/* useEventListener */.OR)("copy", onCopy, window, false, false);
  const onSearchResultsChanged = react.useCallback((results, navIndex) => {
    if (results.length === 0 || navIndex === -1) return;
    const [col, row] = results[navIndex];

    if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {
      return;
    }

    lastSent.current = [col, row];
    updateSelectedCell(col, row, false, false);
  }, [updateSelectedCell]);
  const [outCol, outRow] = (_gridSelectionOuter$c = gridSelectionOuter === null || gridSelectionOuter === void 0 ? void 0 : (_gridSelectionOuter$c2 = gridSelectionOuter.current) === null || _gridSelectionOuter$c2 === void 0 ? void 0 : _gridSelectionOuter$c2.cell) !== null && _gridSelectionOuter$c !== void 0 ? _gridSelectionOuter$c : [];
  const scrollToRef = react.useRef(scrollTo);
  scrollToRef.current = scrollTo;
  react.useEffect(() => {
    var _expectedExternalGrid, _expectedExternalGrid2, _expectedExternalGrid3, _expectedExternalGrid4;

    if (outCol !== undefined && outRow !== undefined && (outCol !== ((_expectedExternalGrid = expectedExternalGridSelection.current) === null || _expectedExternalGrid === void 0 ? void 0 : (_expectedExternalGrid2 = _expectedExternalGrid.current) === null || _expectedExternalGrid2 === void 0 ? void 0 : _expectedExternalGrid2.cell[0]) || outRow !== ((_expectedExternalGrid3 = expectedExternalGridSelection.current) === null || _expectedExternalGrid3 === void 0 ? void 0 : (_expectedExternalGrid4 = _expectedExternalGrid3.current) === null || _expectedExternalGrid4 === void 0 ? void 0 : _expectedExternalGrid4.cell[1]))) {
      scrollToRef.current(outCol, outRow);
    }
  }, [outCol, outRow]);
  const disabledRows = react.useMemo(() => {
    if (showTrailingBlankRow === true && (trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.tint) === true) {
      return data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(mangledRows - 1);
    }

    return data_grid_types/* CompactSelection.empty */.EV.empty();
  }, [mangledRows, showTrailingBlankRow, trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.tint]);
  const mangledVerticalBorder = react.useCallback(col => {
    var _verticalBorder;

    return typeof verticalBorder === "boolean" ? verticalBorder : (_verticalBorder = verticalBorder === null || verticalBorder === void 0 ? void 0 : verticalBorder(col - rowMarkerOffset)) !== null && _verticalBorder !== void 0 ? _verticalBorder : true;
  }, [rowMarkerOffset, verticalBorder]);
  const renameGroupNode = react.useMemo(() => {
    if (renameGroup === undefined || canvasRef.current === null) return null;
    const {
      bounds,
      group
    } = renameGroup;
    const canvasBounds = canvasRef.current.getBoundingClientRect();
    return react.createElement(GroupRename, {
      bounds: bounds,
      group: group,
      canvasBounds: canvasBounds,
      onClose: () => setRenameGroup(undefined),
      onFinish: newVal => {
        setRenameGroup(undefined);
        onGroupHeaderRenamed === null || onGroupHeaderRenamed === void 0 ? void 0 : onGroupHeaderRenamed(group, newVal);
      }
    });
  }, [onGroupHeaderRenamed, renameGroup]);
  const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));
  react.useImperativeHandle(forwardedRef, () => ({
    appendRow: col => appendRow(col + rowMarkerOffset),
    updateCells: damageList => {
      var _gridRef$current11;

      if (rowMarkerOffset !== 0) {
        damageList = damageList.map(x => ({
          cell: [x.cell[0] + rowMarkerOffset, x.cell[1]]
        }));
      }

      return (_gridRef$current11 = gridRef.current) === null || _gridRef$current11 === void 0 ? void 0 : _gridRef$current11.damage(damageList);
    },
    getBounds: (col, row) => {
      var _gridRef$current12;

      return (_gridRef$current12 = gridRef.current) === null || _gridRef$current12 === void 0 ? void 0 : _gridRef$current12.getBounds(col + rowMarkerOffset, row);
    },
    focus: () => {
      var _gridRef$current13;

      return (_gridRef$current13 = gridRef.current) === null || _gridRef$current13 === void 0 ? void 0 : _gridRef$current13.focus();
    },
    emit: async e => {
      switch (e) {
        case "delete":
          onKeyDown({
            bounds: undefined,
            cancel: () => undefined,
            stopPropagation: () => undefined,
            preventDefault: () => undefined,
            ctrlKey: false,
            key: "Delete",
            keyCode: 46,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
          break;

        case "fill-right":
          onKeyDown({
            bounds: undefined,
            cancel: () => undefined,
            stopPropagation: () => undefined,
            preventDefault: () => undefined,
            ctrlKey: true,
            key: "r",
            keyCode: 82,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
          break;

        case "fill-down":
          onKeyDown({
            bounds: undefined,
            cancel: () => undefined,
            stopPropagation: () => undefined,
            preventDefault: () => undefined,
            ctrlKey: true,
            key: "d",
            keyCode: 68,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
          break;

        case "copy":
          await onCopy(undefined, true);
          break;

        case "paste":
          await onPasteInternal();
          break;
      }
    },
    scrollTo
  }), [appendRow, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]);
  const [selCol, selRow] = currentCell !== null && currentCell !== void 0 ? currentCell : [];
  const onCellFocused = react.useCallback(cell => {
    const [col, row] = cell;

    if (row === -1) {
      if (columnSelect !== "none") {
        setSelectedColumns(data_grid_types/* CompactSelection.fromSingleSelection */.EV.fromSingleSelection(col), undefined, false);
        focus();
      }

      return;
    }

    if (selCol === col && selRow === row) return;
    setCurrent({
      cell,
      range: {
        x: col,
        y: row,
        width: 1,
        height: 1
      }
    }, true, false, "keyboard-nav");
    scrollTo(col, row);
  }, [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]);
  const [isFocused, setIsFocused] = react.useState(false);
  const setIsFocusedDebounced = react.useRef(debounce_default()(val => {
    setIsFocused(val);
  }, 5));
  const onCanvasFocused = react.useCallback(() => {
    setIsFocusedDebounced.current(true);

    if (gridSelection.current === undefined && gridSelection.columns.length === 0 && gridSelection.rows.length === 0 && mouseState === undefined) {
      setCurrent({
        cell: [rowMarkerOffset, cellYOffset],
        range: {
          x: rowMarkerOffset,
          y: cellYOffset,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-select");
    }
  }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);
  const onFocusOut = react.useCallback(() => {
    setIsFocusedDebounced.current(false);
  }, []);
  const [idealWidth, idealHeight] = react.useMemo(() => {
    var _experimental$scrollb;

    let h;
    const scrollbarWidth = (_experimental$scrollb = experimental === null || experimental === void 0 ? void 0 : experimental.scrollbarWidthOverride) !== null && _experimental$scrollb !== void 0 ? _experimental$scrollb : (0,utils/* getScrollBarWidth */.Iz)();
    const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);

    if (typeof rowHeight === "number") {
      h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;
    } else {
      let avg = 0;
      const toAverage = Math.min(rowsCountWithTrailingRow, 10);

      for (let i = 0; i < toAverage; i++) {
        avg += rowHeight(i);
      }

      avg = Math.floor(avg / toAverage);
      h = totalHeaderHeight + rowsCountWithTrailingRow * avg;
    }

    h += scrollbarWidth;
    const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;
    return [`${Math.min(100000, w)}px`, `${Math.min(100000, h)}px`];
  }, [mangledCols, experimental === null || experimental === void 0 ? void 0 : experimental.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);
  return react.createElement(styles/* ThemeContext.Provider */.Ni.Provider, {
    value: mergedTheme
  }, react.createElement(DataEditorContainer, {
    style: (0,styles/* makeCSSStyle */.be)(mergedTheme),
    className: className,
    inWidth: width !== null && width !== void 0 ? width : idealWidth,
    inHeight: height !== null && height !== void 0 ? height : idealHeight
  }, react.createElement(data_grid_search, {
    fillHandle: fillHandle,
    drawFocusRing: drawFocusRing,
    experimental: experimental,
    fixedShadowX: fixedShadowX,
    fixedShadowY: fixedShadowY,
    getRowThemeOverride: p.getRowThemeOverride,
    headerIcons: headerIcons,
    imageWindowLoader: imageWindowLoader,
    initialSize: initialSize,
    isDraggable: isDraggable,
    onDragLeave: onDragLeave,
    onRowMoved: onRowMoved,
    overscrollX: overscrollX,
    overscrollY: overscrollY,
    preventDiagonalScrolling: preventDiagonalScrolling,
    rightElement: rightElement,
    rightElementProps: rightElementProps,
    showMinimap: showMinimap,
    smoothScrollX: smoothScrollX,
    smoothScrollY: smoothScrollY,
    className: className,
    enableGroups: enableGroups,
    onCanvasFocused: onCanvasFocused,
    onCanvasBlur: onFocusOut,
    canvasRef: canvasRef,
    onContextMenu: onContextMenu,
    theme: mergedTheme,
    cellXOffset: cellXOffset,
    cellYOffset: cellYOffset,
    accessibilityHeight: visibleRegion.height,
    onDragEnd: onDragEnd,
    columns: mangledCols,
    drawCustomCell: drawCell,
    drawHeader: drawHeader,
    disabledRows: disabledRows,
    freezeColumns: mangledFreezeColumns,
    lockColumns: rowMarkerOffset,
    firstColAccessible: rowMarkerOffset === 0,
    getCellContent: getMangledCellContent,
    minColumnWidth: minColumnWidth,
    maxColumnWidth: maxColumnWidth,
    searchInputRef: searchInputRef,
    showSearch: showSearch,
    onSearchClose: onSearchClose,
    highlightRegions: highlightRegions,
    getCellsForSelection: getCellsForSelection,
    getGroupDetails: mangledGetGroupDetails,
    headerHeight: headerHeight,
    isFocused: isFocused,
    groupHeaderHeight: enableGroups ? groupHeaderHeight : 0,
    trailingRowType: !showTrailingBlankRow ? "none" : (trailingRowOptions === null || trailingRowOptions === void 0 ? void 0 : trailingRowOptions.sticky) === true ? "sticky" : "appended",
    onColumnResize: onColumnResize,
    onColumnResizeEnd: onColumnResizeEnd,
    onColumnResizeStart: onColumnResizeStart,
    onCellFocused: onCellFocused,
    onColumnMoved: onColumnMovedImpl,
    onDragStart: onDragStartImpl,
    onHeaderMenuClick: onHeaderMenuClickInner,
    onItemHovered: onItemHoveredImpl,
    isFilling: (mouseState === null || mouseState === void 0 ? void 0 : mouseState.fillHandle) === true,
    onMouseMove: onMouseMoveImpl,
    onKeyDown: onKeyDown,
    onKeyUp: onKeyUpIn,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    onDragOverCell: onDragOverCell,
    onDrop: onDrop,
    onSearchResultsChanged: onSearchResultsChanged,
    onVisibleRegionChanged: onVisibleRegionChangedImpl,
    clientSize: [clientSize[0], clientSize[1]],
    rowHeight: rowHeight,
    rows: mangledRows,
    scrollRef: scrollRef,
    selection: gridSelection,
    translateX: visibleRegion.tx,
    translateY: visibleRegion.ty,
    verticalBorder: mangledVerticalBorder,
    gridRef: gridRef,
    getCellRenderer: getCellRenderer,
    scrollToEnd: scrollToEnd
  }), renameGroupNode, overlay !== undefined && react.createElement(data_grid_overlay_editor, data_editor_extends({}, overlay, {
    validateCell: validateCell,
    id: overlayID,
    getCellRenderer: getCellRenderer,
    className: (experimental === null || experimental === void 0 ? void 0 : experimental.isSubGrid) === true ? "click-outside-ignore" : undefined,
    provideEditor: provideEditor,
    imageEditorOverride: imageEditorOverride,
    onFinishEditing: onFinishEditing,
    markdownDivCreateNode: markdownDivCreateNode
  }))));
};

const DataEditor = react.forwardRef(DataEditorImpl);

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-async.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServerSideData": () => (/* binding */ ServerSideData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/range.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_range_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/lodash/chunk.js");
/* harmony import */ var lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }








/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_3__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});

function useAsyncData(pageSize, maxConcurrency, getRowData, toCell, onEdited, gridRef) {
  pageSize = Math.max(pageSize, 1);
  const loadingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .CompactSelection.empty */ .EV.empty());
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const [visiblePages, setVisiblePages] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  const visiblePagesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(visiblePages);
  visiblePagesRef.current = visiblePages;
  const onVisibleRegionChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(r => {
    setVisiblePages(cv => {
      if (r.x === cv.x && r.y === cv.y && r.width === cv.width && r.height === cv.height) return cv;
      return r;
    });
  }, []);
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const rowData = dataRef.current[row];

    if (rowData !== undefined) {
      return toCell(rowData, col);
    }

    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Loading */ .p6.Loading,
      allowOverlay: false
    };
  }, [toCell]);
  const loadPage = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async page => {
    var _gridRef$current;

    loadingRef.current = loadingRef.current.add(page);
    const startIndex = page * pageSize;
    const d = await getRowData([startIndex, (page + 1) * pageSize]);
    const vr = visiblePagesRef.current;
    const damageList = [];
    const data = dataRef.current;

    for (const [i, element] of d.entries()) {
      data[i + startIndex] = element;

      for (let col = vr.x; col <= vr.x + vr.width; col++) {
        damageList.push({
          cell: [col, i + startIndex]
        });
      }
    }

    (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.updateCells(damageList);
  }, [getRowData, gridRef, pageSize]);
  const getCellsForSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(r => {
    return async () => {
      const firstPage = Math.max(0, Math.floor(r.y / pageSize));
      const lastPage = Math.floor((r.y + r.height) / pageSize);

      for (const pageChunk of lodash_chunk_js__WEBPACK_IMPORTED_MODULE_2___default()(lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default()(firstPage, lastPage + 1).filter(i => !loadingRef.current.hasIndex(i)), maxConcurrency)) {
        await Promise.allSettled(pageChunk.map(loadPage));
      }

      const result = [];

      for (let y = r.y; y < r.y + r.height; y++) {
        const row = [];

        for (let x = r.x; x < r.x + r.width; x++) {
          row.push(getCellContent([x, y]));
        }

        result.push(row);
      }

      return result;
    };
  }, [getCellContent, loadPage, maxConcurrency, pageSize]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const r = visiblePages;
    const firstPage = Math.max(0, Math.floor((r.y - pageSize / 2) / pageSize));
    const lastPage = Math.floor((r.y + r.height + pageSize / 2) / pageSize);

    for (const page of lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default()(firstPage, lastPage + 1)) {
      if (loadingRef.current.hasIndex(page)) continue;
      void loadPage(page);
    }
  }, [loadPage, pageSize, visiblePages]);
  const onCellEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newVal) => {
    const [, row] = cell;
    const current = dataRef.current[row];
    if (current === undefined) return;
    const result = onEdited(cell, newVal, current);

    if (result !== undefined) {
      dataRef.current[row] = result;
    }
  }, [onEdited]);
  return {
    getCellContent,
    onVisibleRegionChanged,
    onCellEdited,
    getCellsForSelection
  };
}

const ServerSideData = () => {
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const getRowData = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async r => {
    await new Promise(res => setTimeout(res, 300));
    return lodash_range_js__WEBPACK_IMPORTED_MODULE_1___default()(r[0], r[1]).map(rowIndex => [`1, ${rowIndex}`, `2, ${rowIndex}`]);
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "A",
      width: 150
    }, {
      title: "B",
      width: 200
    }];
  }, []);
  const args = useAsyncData(50, 5, getRowData, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rowData, col) => ({
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text,
    data: rowData[col],
    allowOverlay: true,
    displayData: rowData[col]
  }), []), react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newVal, rowData) => {
    const [col] = cell;
    if (newVal.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_4__/* .GridCellKind.Text */ .p6.Text) return undefined;
    const newRow = [...rowData];
    newRow[col] = newVal.data;
    return newRow;
  }, []), ref);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Server Side Data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Glide data grid is fully ready to handle your server side data needs. This example condenses the implementation into a single custom hook and loads in pages of 50. We are using 300ms sleeps, but network transactions should work the same.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({
    ref: ref
  }, args, {
    width: "100%",
    columns: columns,
    rows: 3000,
    rowMarkers: "both"
  })));
};
ServerSideData.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["ServerSideData"];

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddColumns": () => (/* binding */ AddColumns),
/* harmony export */   "AddData": () => (/* binding */ AddData),
/* harmony export */   "AddDataToMiddle": () => (/* binding */ AddDataToMiddle),
/* harmony export */   "AddDataToTop": () => (/* binding */ AddDataToTop),
/* harmony export */   "AllCellKinds": () => (/* binding */ AllCellKinds),
/* harmony export */   "AppendRowHandle": () => (/* binding */ AppendRowHandle),
/* harmony export */   "AutomaticRowMarkers": () => (/* binding */ AutomaticRowMarkers),
/* harmony export */   "BuiltInSearch": () => (/* binding */ BuiltInSearch),
/* harmony export */   "CellActivatedEvent": () => (/* binding */ CellActivatedEvent),
/* harmony export */   "ColumnGroupCollapse": () => (/* binding */ ColumnGroupCollapse),
/* harmony export */   "ColumnGroups": () => (/* binding */ ColumnGroups),
/* harmony export */   "ContentAlignment": () => (/* binding */ ContentAlignment),
/* harmony export */   "ControlledSelection": () => (/* binding */ ControlledSelection),
/* harmony export */   "CopySupport": () => (/* binding */ CopySupport),
/* harmony export */   "CustomHeader": () => (/* binding */ CustomHeader),
/* harmony export */   "CustomHeaderIcons": () => (/* binding */ CustomHeaderIcons),
/* harmony export */   "DragSource": () => (/* binding */ DragSource),
/* harmony export */   "DrawCustomCells": () => (/* binding */ DrawCustomCells),
/* harmony export */   "DropEvents": () => (/* binding */ DropEvents),
/* harmony export */   "FillHandle": () => (/* binding */ FillHandle),
/* harmony export */   "FreezeColumns": () => (/* binding */ FreezeColumns),
/* harmony export */   "HeaderMenus": () => (/* binding */ HeaderMenus),
/* harmony export */   "HighlightCells": () => (/* binding */ HighlightCells),
/* harmony export */   "ImperativeScroll": () => (/* binding */ ImperativeScroll),
/* harmony export */   "InputBlending": () => (/* binding */ InputBlending),
/* harmony export */   "LayoutIntegration": () => (/* binding */ LayoutIntegration),
/* harmony export */   "Minimap": () => (/* binding */ Minimap),
/* harmony export */   "MultiSelectColumns": () => (/* binding */ MultiSelectColumns),
/* harmony export */   "NewColumnButton": () => (/* binding */ NewColumnButton),
/* harmony export */   "ObserveVisibleRegion": () => (/* binding */ ObserveVisibleRegion),
/* harmony export */   "OneHundredThousandCols": () => (/* binding */ OneHundredThousandCols),
/* harmony export */   "OneMillionRows": () => (/* binding */ OneMillionRows),
/* harmony export */   "Overscroll": () => (/* binding */ Overscroll),
/* harmony export */   "Padding": () => (/* binding */ Padding),
/* harmony export */   "PasteSupport": () => (/* binding */ PasteSupport),
/* harmony export */   "PreventDiagonalScroll": () => (/* binding */ PreventDiagonalScroll),
/* harmony export */   "RapidUpdates": () => (/* binding */ RapidUpdates),
/* harmony export */   "RearrangeColumns": () => (/* binding */ RearrangeColumns),
/* harmony export */   "ReorderRows": () => (/* binding */ ReorderRows),
/* harmony export */   "ResizableColumns": () => (/* binding */ ResizableColumns),
/* harmony export */   "RightElement": () => (/* binding */ RightElement),
/* harmony export */   "RightToLeft": () => (/* binding */ RightToLeft),
/* harmony export */   "RowAndHeaderSizes": () => (/* binding */ RowAndHeaderSizes),
/* harmony export */   "RowHover": () => (/* binding */ RowHover),
/* harmony export */   "ScrollShadows": () => (/* binding */ ScrollShadows),
/* harmony export */   "SillyNumbers": () => (/* binding */ SillyNumbers),
/* harmony export */   "SmallEditableGrid": () => (/* binding */ SmallEditableGrid),
/* harmony export */   "SmoothScrollingGrid": () => (/* binding */ SmoothScrollingGrid),
/* harmony export */   "SpanCell": () => (/* binding */ SpanCell),
/* harmony export */   "StretchColumnSize": () => (/* binding */ StretchColumnSize),
/* harmony export */   "TenMillionCells": () => (/* binding */ TenMillionCells),
/* harmony export */   "ThemePerColumn": () => (/* binding */ ThemePerColumn),
/* harmony export */   "ThemePerRow": () => (/* binding */ ThemePerRow),
/* harmony export */   "ThemeSupport": () => (/* binding */ ThemeSupport),
/* harmony export */   "Tooltips": () => (/* binding */ Tooltips),
/* harmony export */   "TrailingRowOptions": () => (/* binding */ TrailingRowOptions),
/* harmony export */   "UnevenRows": () => (/* binding */ UnevenRows),
/* harmony export */   "ValidateData": () => (/* binding */ ValidateData),
/* harmony export */   "WrappingText": () => (/* binding */ WrappingText),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/faker/index.js");
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(faker__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./packages/core/src/common/utils.tsx");
/* harmony import */ var react_laag__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/react-laag/dist/react-laag.esm.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/lodash/range.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_range_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/stories/utils.tsx");
/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/lodash/noop.js");
/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__);
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }












/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/DataEditor Demos",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_4__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const defaultProps = {
  smoothScrollX: true,
  smoothScrollY: true,
  isDraggable: false,
  getCellsForSelection: true,
  rowMarkers: "none",
  width: "100%"
};
const ResizableColumns = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Resizable columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can resize columns by dragging their edges, as long as you respond to the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onColumnResize"), " prop."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "By setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "overscrollX"), " property extra space can be allocated at the end of the grid to allow for easier resizing of the final column. You can highlight multiple columns to resize them all at once."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    overscrollX: 200,
    overscrollY: 200,
    maxColumnAutoWidth: 500,
    maxColumnWidth: 2000,
    rows: 50,
    onColumnResize: onColumnResize,
    getCellsForSelection: getCellsForSelection
  })));
};
ResizableColumns.parameters = {
  options: {
    showPanel: false
  }
};
const Overscroll = p => {
  const {
    overscrollX,
    overscrollY
  } = p;
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(20);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Overscroll",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can allocate extra space at the ends of the grid by setting the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "overscrollX"), " and ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "overscrollY"), " props"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    overscrollX: overscrollX,
    overscrollY: overscrollY,
    rows: 50
  })));
};
Overscroll.argTypes = {
  overscrollX: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  },
  overscrollY: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  }
};
Overscroll.args = {
  overscrollX: 200,
  overscrollY: 200
};
Overscroll.parameters = {
  options: {
    showPanel: true
  }
};

function clearCell(cell) {
  switch (cell.kind) {
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Boolean */ .p6.Boolean:
      {
        return { ...cell,
          data: false
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Image */ .p6.Image:
      {
        return { ...cell,
          data: [],
          displayData: []
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Drilldown */ .p6.Drilldown:
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Bubble */ .p6.Bubble:
      {
        return { ...cell,
          data: []
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Uri */ .p6.Uri:
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Markdown */ .p6.Markdown:
      {
        return { ...cell,
          data: ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text:
      {
        return { ...cell,
          data: "",
          displayData: ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Number */ .p6.Number:
      {
        return { ...cell,
          data: 0,
          displayData: ""
        };
      }
  }

  return cell;
}

const AddData = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], clearCell(cell));
    }

    setNumRows(cv => cv + 1);
  }, [getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Add data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data can be added by clicking on the trailing row."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Keyboard is also supported, just navigate past the last row and press ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "Enter")))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    getCellsForSelection: getCellsForSelection,
    rowMarkers: "both",
    onPaste: true,
    onCellEdited: setCellValue,
    trailingRowOptions: {
      sticky: true,
      tint: true,
      hint: "New row..."
    },
    rows: numRows,
    onRowAppended: onRowAppended
  })));
};
AddData.parameters = {
  options: {
    showPanel: false
  }
};
const RightToLeft = () => {
  const {
    cols,
    getCellContent,
    setCellValue,
    onColumnResize
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  const getCellContentMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(item => {
    const [col, _row] = item;
    if (col !== 0) return getCellContent(item);
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      data: " ,   .",
      displayData: " ,   .",
      allowWrapping: true
    };
  }, [getCellContent]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Right ",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "The data editor automatically detects RTL in text cells and respects it."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContentMangled,
    columns: cols,
    onColumnResize: onColumnResize,
    getCellsForSelection: true,
    rowMarkers: "both",
    onPaste: true,
    onCellEdited: setCellValue,
    rows: 1000
  })));
};
RightToLeft.parameters = {
  options: {
    showPanel: false
  }
};
const ValidateData = () => {
  const {
    cols,
    getCellContent,
    setCellValue,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Validate data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data can be validated using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "validateCell"), " callback"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "This example only allows the word \"Valid\" inside text cells."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    getCellsForSelection: getCellsForSelection,
    rowMarkers: "both",
    onPaste: true,
    onCellEdited: setCellValue,
    rows: 100,
    validateCell: (_cell, newValue) => {
      if (newValue.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text) return true;
      if (newValue.data === "Valid") return true;

      if (newValue.data.toLowerCase() === "valid") {
        return { ...newValue,
          data: "Valid",
          selectionRange: [0, 3]
        };
      }

      return false;
    }
  })));
};
ValidateData.parameters = {
  options: {
    showPanel: false
  }
};
const FillHandle = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const getCellContentMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(i => {
    let val = getCellContent(i);

    if (i[0] === 1 && val.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text) {
      val = { ...val,
        readonly: true
      };
    }

    return val;
  }, [getCellContent]);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], clearCell(cell));
    }

    setNumRows(cv => cv + 1);
  }, [getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Fill handle",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Fill handles can be used to downfill data with the mouse."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Just click and drag, the top row will be copied down. Enable using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "fillHandle"), " prop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContentMangled,
    columns: cols,
    getCellsForSelection: getCellsForSelection,
    rowMarkers: "both",
    onPaste: true,
    fillHandle: true,
    onCellEdited: setCellValue,
    trailingRowOptions: {
      sticky: true,
      tint: true,
      hint: "New row..."
    },
    rows: numRows,
    onRowAppended: onRowAppended
  })));
};
FillHandle.parameters = {
  options: {
    showPanel: false
  }
};
const trailingRowOptionsColumnIndexesHint = {
  2: "Smol text",
  3: "Add",
  5: "New"
};
const trailingRowOptionsColumnIndexesIcon = {
  2: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderArray */ .PE.HeaderArray,
  3: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderEmoji */ .PE.HeaderEmoji,
  5: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber
};
const trailingRowOptionsColumnIndexesTarget = {
  2: 0,
  3: 0,
  5: 0
};
const trailingRowOptionsColumnIndexesDisabled = {
  3: true
};
const trailingRowOptionsColumnIndexesTheme = {
  2: {
    baseFontStyle: "10px"
  }
};
const TrailingRowOptions = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], clearCell(cell));
    }

    setNumRows(cv => cv + 1);
  }, [getCellContent, numRows, setCellValueRaw]);
  const columnsWithRowOptions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map((c, idx) => ({ ...c,
      trailingRowOptions: {
        hint: trailingRowOptionsColumnIndexesHint[idx],
        addIcon: trailingRowOptionsColumnIndexesIcon[idx],
        targetColumn: trailingRowOptionsColumnIndexesTarget[idx],
        disabled: trailingRowOptionsColumnIndexesDisabled[idx],
        themeOverride: trailingRowOptionsColumnIndexesTheme[idx]
      }
    }));
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Trailing row options",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can customize the trailing row in each column by setting a", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "trailingRowOptions"), " in your columns.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: columnsWithRowOptions,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      tint: true,
      sticky: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  })));
};
TrailingRowOptions.parameters = {
  options: {
    showPanel: false
  }
};
const AddDataToTop = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {
    for (let y = numRows; y > 0; y--) {
      for (let x = 0; x < 6; x++) {
        setCellValueRaw([x, y], getCellContent([x, y - 1]));
      }
    }

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, 0]);
      setCellValueRaw([c, 0], clearCell(cell));
    }

    setNumRows(cv => cv + 1);
    return "top";
  }, [getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Add data",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can return a different location to have the new row append take place."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  })));
};
AddDataToTop.parameters = {
  options: {
    showPanel: false
  }
};
const AddDataToMiddle = p => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const index = p.insertIndex;
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {
    for (let y = numRows; y > index; y--) {
      for (let x = 0; x < 6; x++) {
        setCellValueRaw([x, y], getCellContent([x, y - 1]));
      }
    }

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, index]);
      setCellValueRaw([c, index], clearCell(cell));
    }

    setNumRows(cv => cv + 1);
    return index;
  }, [getCellContent, numRows, setCellValueRaw, index]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Add data to middle",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can return a different location to have the new row append take place."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Note that ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "insertIndex"), " is zero-based while the number column on the left side of the grid is one-based, so inserting at index \"4\" creates a new row at \"5\""))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  })));
};
AddDataToMiddle.args = {
  insertIndex: 10
};
AddDataToMiddle.argTypes = {
  insertIndex: {
    control: {
      type: "range",
      min: 1,
      max: 48
    }
  }
};
AddDataToMiddle.parameters = {
  options: {
    showPanel: true
  }
};
const AppendRowHandle = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    setCellValue
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60, false);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(50);
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const onClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _ref$current;

    void ((_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.appendRow(3));
  }, [ref]);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;

    for (let c = 0; c < 6; c++) {
      const cell = getCellContent([c, newRow]);
      setCellValueRaw([c, newRow], clearCell(cell));
    }

    setNumRows(cv => cv + 1);
  }, [getCellContent, numRows, setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "appendRow Ref",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Adding data can also be triggered from outside of ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "DataEditor")), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "By calling ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "appendRow"), " on a ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "ref"), " to your grid, you can trigger the append elsewhere, like this ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, {
      onClick: onClick
    }, "Append"), " button"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    ref: ref,
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended
  })));
};
AppendRowHandle.parameters = {
  options: {
    showPanel: false
  }
};
const SmallEditableGrid = () => {
  const {
    cols,
    getCellContent,
    setCellValue
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Editable Grid",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data grid supports overlay editors for changing values. There are bespoke editors for numbers, strings, images, booleans, markdown, and uri.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    rowMarkers: "both",
    columns: cols,
    rows: 20,
    onCellEdited: setCellValue
  })));
};
SmallEditableGrid.parameters = {
  options: {
    showPanel: false
  }
};
const OneMillionRows = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "One Million Rows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data grid supports over 1 million rows. Your limit is mostly RAM.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    rowHeight: 31,
    rows: 1000000,
    rowMarkers: "number"
  })));
};
OneMillionRows.parameters = {
  options: {
    showPanel: false
  }
};
const SillyNumbers = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "100 Million Rows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "100 million rows is silly. Once we cross about 33 million pixels in height we can no longer trust the browser to scroll accurately.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    rowHeight: 31,
    rows: 100000000,
    rowMarkers: "number"
  })));
};
SillyNumbers.parameters = {
  options: {
    showPanel: false
  }
};
const ObserveVisibleRegion = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100);
  const [visibleRegion, setVisibleRegion] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Observe Visible Region",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "The visible region can be observed using ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onVisibleRegionChanged")), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Then current visible region is x:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, visibleRegion.x), " y:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, visibleRegion.y), " width:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, visibleRegion.width), " height:", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, visibleRegion.height)))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000,
    onVisibleRegionChanged: setVisibleRegion
  })));
};
OneMillionRows.parameters = {
  options: {
    showPanel: false
  }
};
const OneHundredThousandCols = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100000);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "One Hundred Thousand Columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data grid supports way more columns than you will ever need. Also this is rendering 10 million cells but that's not important.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellsForSelection: getCellsForSelection,
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  })));
};
OneHundredThousandCols.parameters = {
  options: {
    showPanel: false
  }
};
const TenMillionCells = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Ten Million Cells",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data grid supports over 10 million cells. Go nuts with it.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "number",
    getCellContent: getCellContent,
    columns: cols,
    rows: 100000
  })));
};
TenMillionCells.parameters = {
  options: {
    showPanel: false
  }
};
const SmoothScrollingGrid = p => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(30);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Smooth scrolling",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can enable smooth scrolling with the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "smoothScrollX"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "smoothScrollY"), " props. Disabling smooth scrolling can dramatically increase performance and improve visual stability during rapid scrolling.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    getCellContent: getCellContent,
    columns: cols,
    rows: 10000
  })));
};
SmoothScrollingGrid.args = {
  smoothScrollX: false,
  smoothScrollY: false
};
SmoothScrollingGrid.parameters = {
  options: {
    showPanel: true
  }
};
const InputBlending = p => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(30);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Input blending",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Input blending can be enabled or disable between row, column, and range selections. Multi-selections can also be enabled or disabled with the same level of granularity.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: p.rowMultiSelect === "none" ? "number" : "both",
    keybindings: {
      clear: true,
      copy: true,
      downFill: true,
      rightFill: true,
      pageDown: true,
      pageUp: true,
      paste: true,
      search: true,
      selectAll: true,
      selectColumn: true,
      selectRow: true
    },
    getCellsForSelection: true,
    rangeSelect: p.rangeMultiSelect,
    columnSelect: p.columnMultiSelect,
    rowSelect: p.rowMultiSelect,
    rangeSelectionBlending: p.rangeBlending,
    columnSelectionBlending: p.columnBlending,
    rowSelectionBlending: p.rowBlending,
    getCellContent: getCellContent,
    columns: cols,
    rows: 10000
  })));
};
InputBlending.args = {
  rangeBlending: "mixed",
  columnBlending: "mixed",
  rowBlending: "mixed",
  rangeMultiSelect: "rect",
  columnMultiSelect: "multi",
  rowMultiSelect: "multi"
};
InputBlending.argTypes = {
  rangeBlending: {
    control: {
      type: "select",
      options: ["mixed", "exclusive"]
    }
  },
  columnBlending: {
    control: {
      type: "select",
      options: ["mixed", "exclusive"]
    }
  },
  rowBlending: {
    control: {
      type: "select",
      options: ["mixed", "exclusive"]
    }
  },
  rangeMultiSelect: {
    control: {
      type: "select",
      options: ["none", "cell", "rect", "multi-cell", "multi-rect"]
    }
  },
  columnMultiSelect: {
    control: {
      type: "select",
      options: ["none", "single", "multi"]
    }
  },
  rowMultiSelect: {
    control: {
      type: "select",
      options: ["none", "single", "multi"]
    }
  }
};
InputBlending.parameters = {
  options: {
    showPanel: true
  }
};
const AddColumns = p => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(p.columnsCount);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Add and remove columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can add and remove columns at your disposal"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Use the story's controls to change the number of columns"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "number",
    getCellsForSelection: getCellsForSelection,
    getCellContent: getCellContent,
    columns: cols,
    rows: 10000
  })));
};
AddColumns.args = {
  columnsCount: 10
};
AddColumns.argTypes = {
  columnsCount: {
    control: {
      type: "range",
      min: 2,
      max: 200
    }
  }
};
AddColumns.parameters = {
  options: {
    showPanel: true
  }
};
const ScrollShadows = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  const [selection, setSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty(),
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty()
  });
  const onSelectionChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newSel => {
    let newRows = _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty();

    if (newSel.current !== undefined) {
      newRows = newRows.add([newSel.current.range.y, newSel.current.range.y + newSel.current.range.height]);
    }

    for (const b of (_newSel$current$range = (_newSel$current = newSel.current) === null || _newSel$current === void 0 ? void 0 : _newSel$current.rangeStack) !== null && _newSel$current$range !== void 0 ? _newSel$current$range : []) {
      var _newSel$current$range, _newSel$current;

      newRows = newRows.add([b.y, b.y + b.height]);
    }

    setSelection({ ...newSel,
      rows: newRows
    });
  }, []);
  const theme = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    accentLight: "#b1f6ff",
    horizontalBorderColor: "transparent",
    headerBottomBorderColor: "rgba(115, 116, 131, 0.16)"
  }), []);
  const getRowThemeOverride = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(row => row % 2 === 0 ? undefined : {
    bgCell: "#f5f5f6"
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Automatic Row Markers",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can enable and disable the horizontal/vertical scroll shadows."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "number",
    gridSelection: selection,
    onGridSelectionChange: onSelectionChange,
    fixedShadowX: false,
    headerHeight: 26,
    drawFocusRing: false,
    rowHeight: 22,
    fixedShadowY: false,
    getRowThemeOverride: getRowThemeOverride,
    verticalBorder: false,
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000,
    theme: theme
  })));
};
ScrollShadows.parameters = {
  options: {
    showPanel: false
  }
};
const AutomaticRowMarkers = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Automatic Row Markers",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can enable row markers with rich selection behavior using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "rowMarkers"), " prop."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Use ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "\u21E7"), " + click to make range selections, and ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "Ctrl"), " (", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "\u2318"), " on Mac) + click to add/remove individual rows."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "both",
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  })));
};
AutomaticRowMarkers.parameters = {
  options: {
    showPanel: false
  }
};
const WrappingText = p => {
  const {
    cols,
    getCellContent,
    onColumnResize
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  const suffix = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return lodash_range_js__WEBPACK_IMPORTED_MODULE_2___default()(0, 100).map(() => faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.sentence(p.length));
  }, [p.length]);
  const mangledGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(i => {
    const [col, row] = i;

    if (col === 0) {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: true,
        displayData: `${row},\n${suffix[row % suffix.length]}`,
        data: `${row}, ${suffix}`,
        allowWrapping: true,
        contentAlign: p.alignment
      };
    }

    return getCellContent(i);
  }, [getCellContent, p.alignment, suffix]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Wrapping Text",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Text cells can have wrapping text by setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "allowWrapping"), " prop to true.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowHeight: 80,
    getCellContent: mangledGetCellContent,
    columns: cols,
    rows: 1000,
    onColumnResize: onColumnResize,
    experimental: {
      hyperWrapping: p.hyperWrapping
    }
  })));
};
WrappingText.args = {
  alignment: "left",
  length: 20,
  hyperWrapping: false
};
WrappingText.argTypes = {
  alignment: {
    control: {
      type: "select",
      options: ["left", "center", "right"]
    }
  },
  length: {
    control: {
      type: "range",
      min: 2,
      max: 200
    }
  }
};
WrappingText.parameters = {
  options: {
    showPanel: true
  }
};
const UnevenRows = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Uneven Rows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Rows can be made uneven by passing a callback to the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "rowHeight"), " prop")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowHeight: r => r % 3 === 0 ? 30 : r % 2 ? 50 : 60,
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  })));
};
UnevenRows.parameters = {
  options: {
    showPanel: false
  }
};
const DrawCustomCells = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Draw custom cells",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can draw custom cell contents however you want using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "drawCustomCell"), " ", "prop")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    drawCell: args => {
      const {
        cell,
        rect,
        ctx
      } = args;
      if (cell.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text) return false;
      const hasX = cell.displayData.toLowerCase().includes("x");
      ctx.save();
      const {
        x,
        y,
        width,
        height
      } = rect;
      const data = cell.displayData;
      ctx.fillStyle = hasX ? "#bfffcd" : "#ffe6e6";
      ctx.fillRect(x + 1, y + 1, width - 1, height - 1);
      ctx.fillStyle = hasX ? "#0fc035" : "#e01e1e";
      ctx.font = "bold 14px sans-serif";
      ctx.fillText(data, x + 8 + 0.5, y + height / 2 + 4.5);
      ctx.restore();
      return true;
    },
    rows: 1000
  })));
};
DrawCustomCells.parameters = {
  options: {
    showPanel: false
  }
};
const RearrangeColumns = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(60);
  const [sortableCols, setSortableCols] = react__WEBPACK_IMPORTED_MODULE_0__.useState(cols);
  const onColMoved = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((startIndex, endIndex) => {
    setSortableCols(old => {
      const newCols = [...old];
      const [toMove] = newCols.splice(startIndex, 1);
      newCols.splice(endIndex, 0, toMove);
      return newCols;
    });
  }, []);
  const getCellContentMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;
    const remappedCol = cols.findIndex(c => c.title === sortableCols[col].title);
    return getCellContent([remappedCol, row]);
  }, [cols, getCellContent, sortableCols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Rearrange Columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Columns can be rearranged by drag and dropping, as long as you respond to the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onColumnMoved"), " callback.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    freezeColumns: 1,
    rowMarkers: "both",
    getCellContent: getCellContentMangled,
    getCellsForSelection: getCellsForSelection,
    columns: sortableCols,
    onColumnMoved: onColMoved,
    rows: 1000
  })));
};
RearrangeColumns.parameters = {
  options: {
    showPanel: false
  }
};
const RowAndHeaderSizes = p => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Row and Header sizes",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "The row size can be controlled with ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "rowHeight"), " and the header size with", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "headerHeight"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Use the story's controls to resize them"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowHeight: p.rowHeight,
    headerHeight: p.headerHeight,
    getCellsForSelection: getCellsForSelection,
    rowMarkers: "number",
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  })));
};
RowAndHeaderSizes.args = {
  rowHeight: 34,
  headerHeight: 34
};
RowAndHeaderSizes.argTypes = {
  rowHeight: {
    control: {
      type: "range",
      min: 20,
      max: 200
    }
  },
  headerHeight: {
    control: {
      type: "range",
      min: 20,
      max: 200
    }
  }
};
RowAndHeaderSizes.parameters = {
  options: {
    showPanel: true
  }
};
const KeyName = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)('kbd')({
  name: "KeyName",
  class: "k1txkgwh"
});
const MultiSelectColumns = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Multi select columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can select multiple columns by using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "selectedColumns"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onSelectedColumnsChange"), " props"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Here you can multi select columns by using ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "Ctrl"), " (on Windows) or", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "\u2318"), " (on Mac)"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    getCellsForSelection: getCellsForSelection,
    rowMarkers: "both",
    columns: cols,
    rows: 100000
  })));
};
MultiSelectColumns.parameters = {
  options: {
    showPanel: false
  }
};

function getColumnsForCellTypes() {
  return [{
    title: "Row ID",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderRowID */ .PE.HeaderRowID,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.RowID */ .p6.RowID,
        data: faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.uuid(),
        allowOverlay: true
      };
    }
  }, {
    title: "Protected",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderCode */ .PE.HeaderCode,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Protected */ .p6.Protected,
        data: faker__WEBPACK_IMPORTED_MODULE_1___default().finance.bitcoinAddress(),
        allowOverlay: false
      };
    }
  }, {
    title: "Loading",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Loading */ .p6.Loading,
        allowOverlay: false
      };
    }
  }, {
    title: "Text",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderCode */ .PE.HeaderCode,
    hasMenu: false,
    getContent: () => {
      const name = faker__WEBPACK_IMPORTED_MODULE_1___default().name.firstName();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text,
        data: name,
        displayData: name,
        allowOverlay: true
      };
    }
  }, {
    title: "Number",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber,
    hasMenu: false,
    getContent: () => {
      const age = faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100);
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Number */ .p6.Number,
        data: age,
        displayData: `${age}`,
        allowOverlay: true
      };
    }
  }, {
    title: "Boolean",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderBoolean */ .PE.HeaderBoolean,
    hasMenu: false,
    getContent: () => {
      const roll = Math.random();
      const checked = roll < 0.1 ? undefined : roll < 0.2 ? null : roll < 0.6;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Boolean */ .p6.Boolean,
        data: checked,
        allowOverlay: false,
        readonly: false
      };
    }
  }, {
    title: "Image",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Image */ .p6.Image,
        data: [`${faker__WEBPACK_IMPORTED_MODULE_1___default().image.animals(40, 40)}?random=${faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100000)}`],
        allowOverlay: true,
        allowAdd: false,
        readonly: true
      };
    }
  }, {
    title: "Uri",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderUri */ .PE.HeaderUri,
    hasMenu: false,
    getContent: () => {
      const url = faker__WEBPACK_IMPORTED_MODULE_1___default().internet.url();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Uri */ .p6.Uri,
        data: url,
        allowOverlay: true
      };
    }
  }, {
    title: "Markdown",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderMarkdown */ .PE.HeaderMarkdown,
    hasMenu: false,
    getContent: () => {
      const markdown = `# Title
Hello my name is *${faker__WEBPACK_IMPORTED_MODULE_1___default().name.firstName()}*

## TODO:
Try out [Glide](https://www.glideapps.com/)
`;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Markdown */ .p6.Markdown,
        data: markdown,
        allowOverlay: true
      };
    }
  }, {
    title: "Bubble",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderArray */ .PE.HeaderArray,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Bubble */ .p6.Bubble,
        data: [faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word(), faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word(), faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word()],
        allowOverlay: true
      };
    }
  }, {
    title: "Drilldown",
    width: 120,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderArray */ .PE.HeaderArray,
    hasMenu: false,
    getContent: () => {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Drilldown */ .p6.Drilldown,
        data: [{
          text: faker__WEBPACK_IMPORTED_MODULE_1___default().address.cityName(),
          img: `${faker__WEBPACK_IMPORTED_MODULE_1___default().image.nature(40, 40)}?random=${faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100000)}`
        }, {
          text: faker__WEBPACK_IMPORTED_MODULE_1___default().address.cityName(),
          img: `${faker__WEBPACK_IMPORTED_MODULE_1___default().image.nature(40, 40)}?random=${faker__WEBPACK_IMPORTED_MODULE_1___default().datatype.number(100000)}`
        }],
        allowOverlay: true
      };
    }
  }];
}

function useAllMockedKinds() {
  const cache = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new _utils__WEBPACK_IMPORTED_MODULE_5__/* .ContentCache */ .c6());
  const [colsMap, setColsMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(getColumnsForCellTypes);
  const onColumnResize = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((column, newSize) => {
    setColsMap(prevColsMap => {
      const index = prevColsMap.findIndex(ci => ci.title === column.title);
      const newArray = [...prevColsMap];
      newArray.splice(index, 1, { ...prevColsMap[index],
        width: newSize
      });
      return newArray;
    });
  }, []);
  const cols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return colsMap.map(_utils__WEBPACK_IMPORTED_MODULE_5__/* .getGridColumn */ .Cj);
  }, [colsMap]);
  const [updateVersion, setUpdateVersion] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref2 => {
    let [col, row] = _ref2;
    lodash_noop_js__WEBPACK_IMPORTED_MODULE_3___default()(updateVersion);
    let val = cache.current.get(col, row);

    if (val === undefined) {
      val = colsMap[col].getContent();
      cache.current.set(col, row, val);
    }

    return val;
  }, [colsMap, updateVersion]);
  const setCellValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref3, val, noDisplay, forceUpdate) => {
    let [col, row] = _ref3;
    let current = cache.current.get(col, row);

    if (current === undefined) {
      current = colsMap[col].getContent();
    }

    if ((0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .isEditableGridCell */ .T9)(val) && (0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .isEditableGridCell */ .T9)(current)) {
      var _copied$data$toString, _copied$data;

      const copied = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .lossyCopyData */ .kZ)(val, current);
      cache.current.set(col, row, { ...copied,
        displayData: noDisplay === true ? undefined : (_copied$data$toString = (_copied$data = copied.data) === null || _copied$data === void 0 ? void 0 : _copied$data.toString()) !== null && _copied$data$toString !== void 0 ? _copied$data$toString : ""
      });

      if (forceUpdate === true) {
        setUpdateVersion(v => v + 1);
      }
    }
  }, [colsMap]);
  return {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  };
}

const AllCellKinds = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Lotsa cell kinds",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data grid supports plenty cell kinds. Anything under ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "GridCellKind"), ".")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    highlightRegions: [{
      color: "#ff00ff33",
      range: {
        x: 1,
        y: 1,
        width: 3,
        height: 3
      }
    }],
    rows: 1000
  })));
};
AllCellKinds.parameters = {
  options: {
    showPanel: false
  }
};
const darkTheme = {
  accentColor: "#8c96ff",
  accentLight: "rgba(202, 206, 255, 0.253)",
  textDark: "#ffffff",
  textMedium: "#b8b8b8",
  textLight: "#a0a0a0",
  textBubble: "#ffffff",
  bgIconHeader: "#b8b8b8",
  fgIconHeader: "#000000",
  textHeader: "#a1a1a1",
  textHeaderSelected: "#000000",
  bgCell: "#16161b",
  bgCellMedium: "#202027",
  bgHeader: "#212121",
  bgHeaderHasFocus: "#474747",
  bgHeaderHovered: "#404040",
  bgBubble: "#212121",
  bgBubbleSelected: "#000000",
  bgSearchResult: "#423c24",
  borderColor: "rgba(225,225,225,0.2)",
  drilldownBorder: "rgba(225,225,225,0.4)",
  linkColor: "#4F5DFF",
  headerFontStyle: "bold 14px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif"
};
const hotdogStand = {
  accentColor: "#8c96ff",
  accentLight: "rgba(202, 206, 255, 0.253)",
  textDark: "#ffffff",
  textMedium: "rgba(255, 255, 255, 0.9)",
  textLight: "rgba(255, 255, 255, 0.7)",
  textBubble: "#000000",
  bgIconHeader: "#880000",
  fgIconHeader: "#ff5555",
  textHeader: "rgba(0, 0, 0, 0.9)",
  textHeaderSelected: "#000000",
  bgCell: "#ff0000",
  bgCellMedium: "#ff4d4d",
  bgHeader: "#f3f300",
  bgHeaderHasFocus: "#eeee00",
  bgHeaderHovered: "#e0e000",
  bgBubble: "#ffff00",
  bgBubbleSelected: "#ffff00",
  bgSearchResult: "#423c24",
  borderColor: "#ffff00",
  drilldownBorder: "#ffff00",
  linkColor: "#4F5DFF",
  headerFontStyle: "bold 14px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif"
};
const ThemeSupport = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const [theme, setTheme] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(1000);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;
    setNumRows(cv => cv + 1);

    for (let c = 0; c < 6; c++) {
      setCellValue([c, newRow], {
        displayData: "",
        data: ""
      });
    }
  }, [numRows, setCellValue]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Theme support",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "DataGrid respects the theme provided by the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "theme"), " prop."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => setTheme({})
    }, "Light"), " or", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => setTheme(darkTheme)
    }, "Dark"), " even", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => setTheme(hotdogStand)
    }, "Hotdog Stand")))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    theme: theme,
    getCellContent: getCellContent,
    columns: cols,
    onRowAppended: onRowAppended,
    trailingRowOptions: {
      tint: true,
      sticky: true
    },
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: numRows
  })));
};
ThemeSupport.parameters = {
  options: {
    showPanel: false
  }
};
const ThemePerColumn = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const realCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const c = [...cols];
    c[3] = { ...c[3],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF",
        baseFontStyle: "600 13px"
      }
    };
    c[4] = { ...c[4],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF",
        baseFontStyle: "600 13px"
      }
    };
    c[9] = { ...c[9],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF"
      }
    };
    c[10] = { ...c[10],
      themeOverride: {
        textDark: "#009CA6",
        bgIconHeader: "#009CA6",
        accentColor: "#009CA6",
        accentLight: "#009CA620",
        fgIconHeader: "#FFFFFF"
      }
    };
    return c;
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Theme per column",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Each column can provide theme overrides for rendering that column."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: realCols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000
  })));
};
ThemePerColumn.parameters = {
  options: {
    showPanel: false
  }
};
const ThemePerRow = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(5);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Theme per row",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Each row can provide theme overrides for rendering that row using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "getRowThemeOverride"), " callback."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    trailingRowOptions: {
      sticky: true,
      tint: true
    },
    onRowAppended: () => undefined,
    getCellsForSelection: getCellsForSelection,
    getRowThemeOverride: i => i % 2 === 0 ? undefined : {
      bgCell: "#f0f8ff",
      borderColor: "#3f90e0"
    },
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000000
  })));
};
ThemePerRow.parameters = {
  options: {
    showPanel: false
  }
};
const CellActivatedEvent = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const [lastActivated, setLastActivated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);
  const onCellActivated = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    setLastActivated(cell);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Cell Activated event",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "When you tap ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "Enter"), ", ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "Space"), " or double click a cell, that cell is activated. You can track this with ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onCellActivated"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Last activated cell:", " ", lastActivated === undefined ? "none" : `(${lastActivated[0]}, ${lastActivated[1]})`))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    getCellsForSelection: true,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    onCellActivated: onCellActivated,
    rows: 10000
  })));
};
CellActivatedEvent.parameters = {
  options: {
    showPanel: false
  }
};
const BuiltInSearch = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const [showSearch, setShowSearch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [selection, setSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty(),
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty()
  });
  (0,_common_utils__WEBPACK_IMPORTED_MODULE_9__/* .useEventListener */ .OR)("keydown", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if ((event.ctrlKey || event.metaKey) && event.code === "KeyF") {
      setShowSearch(cv => !cv);
      event.stopPropagation();
      event.preventDefault();
    }
  }, []), window, false, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Search is easy",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Search for any data in your grid by setting ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "showSearch"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "In this story, ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "Ctrl"), " (", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "\u2318"), " on Mac) + ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, null, "f"), " ", "toggles the search bar. Make sure you're focused on the Data Grid!"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    getCellsForSelection: true,
    gridSelection: selection,
    onGridSelectionChange: setSelection,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    showSearch: showSearch,
    onSearchClose: () => setShowSearch(false),
    rows: 10000
  })));
};
BuiltInSearch.parameters = {
  options: {
    showPanel: false
  }
};
const ImperativeScroll = p => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);

  const onClick = () => {
    var _ref$current2;

    (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.scrollTo(4, 99, "both", p.paddingX, p.paddingY, {
      vAlign: p.vAlign,
      hAlign: p.hAlign
    });
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Imperative scrolling",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can imperatively scroll to a cell by calling ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "scrollTo"), " on a DataEditor ref."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Click ", react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: onClick
    }, "Here"), " to scroll to column 4 row 100"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    ref: ref,
    rowMarkers: "clickable-number",
    getCellContent: getCellContent,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 10000
  })));
};
ImperativeScroll.args = {
  paddingY: 0,
  paddingX: 0,
  vAlign: "start",
  hAlign: "start"
};
ImperativeScroll.argTypes = {
  paddingY: 0,
  paddingX: 0,
  vAlign: {
    control: {
      type: "select",
      options: ["start", "center", "end", undefined]
    }
  },
  hAlign: {
    control: {
      type: "select",
      options: ["start", "center", "end", undefined]
    }
  }
};
ImperativeScroll.parameters = {
  options: {
    showPanel: true
  }
};
const SimpleMenu = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)('div')({
  name: "SimpleMenu",
  class: "s11gjm00"
});
const HeaderMenus = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const realCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map(c => ({ ...c,
      hasMenu: true
    }));
  }, [cols]);
  const [menu, setMenu] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const isOpen = menu !== undefined;
  const {
    layerProps,
    renderLayer
  } = (0,react_laag__WEBPACK_IMPORTED_MODULE_10__/* .useLayer */ .sJ)({
    isOpen,
    auto: true,
    placement: "bottom-end",
    triggerOffset: 2,
    onOutsideClick: () => setMenu(undefined),
    trigger: {
      getBounds: () => {
        var _menu$bounds$x, _menu$bounds$y, _menu$bounds$width, _menu$bounds$height, _menu$bounds$x2, _menu$bounds$width2, _menu$bounds$y2, _menu$bounds$height2;

        return {
          left: (_menu$bounds$x = menu === null || menu === void 0 ? void 0 : menu.bounds.x) !== null && _menu$bounds$x !== void 0 ? _menu$bounds$x : 0,
          top: (_menu$bounds$y = menu === null || menu === void 0 ? void 0 : menu.bounds.y) !== null && _menu$bounds$y !== void 0 ? _menu$bounds$y : 0,
          width: (_menu$bounds$width = menu === null || menu === void 0 ? void 0 : menu.bounds.width) !== null && _menu$bounds$width !== void 0 ? _menu$bounds$width : 0,
          height: (_menu$bounds$height = menu === null || menu === void 0 ? void 0 : menu.bounds.height) !== null && _menu$bounds$height !== void 0 ? _menu$bounds$height : 0,
          right: ((_menu$bounds$x2 = menu === null || menu === void 0 ? void 0 : menu.bounds.x) !== null && _menu$bounds$x2 !== void 0 ? _menu$bounds$x2 : 0) + ((_menu$bounds$width2 = menu === null || menu === void 0 ? void 0 : menu.bounds.width) !== null && _menu$bounds$width2 !== void 0 ? _menu$bounds$width2 : 0),
          bottom: ((_menu$bounds$y2 = menu === null || menu === void 0 ? void 0 : menu.bounds.y) !== null && _menu$bounds$y2 !== void 0 ? _menu$bounds$y2 : 0) + ((_menu$bounds$height2 = menu === null || menu === void 0 ? void 0 : menu.bounds.height) !== null && _menu$bounds$height2 !== void 0 ? _menu$bounds$height2 : 0)
        };
      }
    }
  });
  const onHeaderMenuClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, bounds) => {
    setMenu({
      col,
      bounds
    });
  }, []);
  const onHeaderClicked = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    console.log("Header clicked");
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Header menus",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Headers on the data grid can be configured to support menus. We provide the events and the triangle, you provide the menu."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    onHeaderMenuClick: onHeaderMenuClick,
    onHeaderClicked: onHeaderClicked,
    columns: realCols,
    onCellContextMenu: (_, e) => e.preventDefault(),
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000
  })), isOpen && renderLayer(react__WEBPACK_IMPORTED_MODULE_0__.createElement(SimpleMenu, layerProps, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    onClick: () => setMenu(undefined)
  }, "These do nothing"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    onClick: () => setMenu(undefined)
  }, "Add column right"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    onClick: () => setMenu(undefined)
  }, "Add column left"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "danger",
    onClick: () => setMenu(undefined)
  }, "Delete"))));
};
HeaderMenus.parameters = {
  options: {
    showPanel: false
  }
};
const CustomHeaderIcons = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const realCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    const c = [...cols];
    c[3] = { ...c[3],
      title: "CUSTOM ICON",
      icon: "custom",
      width: 200
    };
    return c;
  }, [cols]);
  const headerIcons = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      custom: p => `<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="2.00015" y="2" width="16" height="16" rx="4" fill="${p.bgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M4.69759 6.00977C4.23735 6.00977 3.86426 6.38286 3.86426 6.8431C3.86426 7.30334 4.23735 7.67643 4.69759 7.67643H8.86426C9.3245 7.67643 9.69759 7.30334 9.69759 6.8431C9.69759 6.38286 9.32449 6.00977 8.86426 6.00977H4.69759Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M7.61426 4.76009C7.61426 4.29985 7.24116 3.92676 6.78092 3.92676C6.32069 3.92676 5.94759 4.29985 5.94759 4.76009L5.94759 8.92676C5.94759 9.387 6.32069 9.76009 6.78092 9.76009C7.24116 9.76009 7.61426 9.38699 7.61426 8.92676L7.61426 4.76009Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M11.0336 6.00977C10.5734 6.00977 10.2003 6.38286 10.2003 6.8431C10.2003 7.30334 10.5734 7.67643 11.0336 7.67643H15.2003C15.6605 7.67643 16.0336 7.30334 16.0336 6.8431C16.0336 6.38286 15.6605 6.00977 15.2003 6.00977H11.0336Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M5.89704 10.9916C5.5716 10.6662 5.04397 10.6662 4.71853 10.9916C4.39309 11.317 4.39309 11.8447 4.71853 12.1701L7.66481 15.1164C7.99024 15.4418 8.51788 15.4418 8.84332 15.1164C9.16876 14.791 9.16876 14.2633 8.84332 13.9379L5.89704 10.9916Z" fill="${p.fgColor}"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M8.84332 12.1703C9.16875 11.8449 9.16875 11.3172 8.84332 10.9918C8.51788 10.6664 7.99024 10.6664 7.6648 10.9918L4.71853 13.9381C4.39309 14.2635 4.39309 14.7912 4.71853 15.1166C5.04396 15.442 5.5716 15.442 5.89704 15.1166L8.84332 12.1703Z" fill="${p.fgColor}"/>
                <path d="M10.2003 11.804C10.2003 11.3438 10.5734 10.9707 11.0336 10.9707H15.2003C15.6605 10.9707 16.0336 11.3438 16.0336 11.804C16.0336 12.2643 15.6605 12.6374 15.2003 12.6374H11.0336C10.5734 12.6374 10.2003 12.2643 10.2003 11.804Z" fill="${p.fgColor}"/>
                <path d="M10.2003 14.304C10.2003 13.8438 10.5734 13.4707 11.0336 13.4707H15.2003C15.6605 13.4707 16.0336 13.8438 16.0336 14.304C16.0336 14.7643 15.6605 15.1374 15.2003 15.1374H11.0336C10.5734 15.1374 10.2003 14.7643 10.2003 14.304Z" fill="${p.fgColor}"/>
            </svg>`
    };
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Custom header icons",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can provide overrides for the default icons by passing the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "headerIcons"), " ", "prop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: realCols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    headerIcons: headerIcons,
    rows: 1000
  })));
};
CustomHeaderIcons.parameters = {
  options: {
    showPanel: false
  }
};
const RightElement = () => {
  const {
    cols,
    getCellContent,
    setCellValue,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(8, false);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => cols.map(c => ({ ...c,
    grow: 1
  })), [cols]);
  const [numRows, setNumRows] = react__WEBPACK_IMPORTED_MODULE_0__.useState(300);
  const onRowAppended = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const newRow = numRows;
    setNumRows(cv => cv + 1);

    for (let c = 0; c < 6; c++) {
      setCellValue([c, newRow], {
        displayData: "",
        data: ""
      });
    }
  }, [numRows, setCellValue]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Right Element",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "A DOM element may be added as a trailer to the grid by using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "rightElement"), " ", "prop.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: columns,
    getCellsForSelection: getCellsForSelection,
    rowMarkers: "both",
    onCellEdited: setCellValue,
    trailingRowOptions: {
      hint: "New row...",
      sticky: true,
      tint: true
    },
    rows: numRows,
    onRowAppended: onRowAppended,
    rightElementProps: {
      sticky: true
    },
    rightElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      style: {
        height: "100%",
        padding: "20px 20px 40px 20px",
        width: 200,
        color: "black",
        whiteSpace: "pre-wrap",
        backgroundColor: "rgba(240, 240, 250, 0.2)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        boxShadow: "0 0 10px rgba(0, 0, 0, 0.15)",
        backdropFilter: "blur(12px)"
      }
    }, "This is a real DOM element. You can put whatever you want here. You can also size it as big as you want. ", "\n\n", "It also does not have to be sticky.")
  })));
};
RightElement.parameters = {
  options: {
    showPanel: false
  }
};
let num = 1;

function rand() {
  return num = num * 16807 % 2147483647;
}

const RapidUpdates = () => {
  const {
    cols,
    getCellContent,
    setCellValueRaw,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100);
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const countRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const displayCountRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let rafID = 0;

    const sendUpdate = () => {
      var _ref$current3;

      const cells = [];
      const now = performance.now();

      for (let x = 0; x < 5000; x++) {
        const col = Math.max(10, rand() % 100);
        const row = rand() % 10000;
        setCellValueRaw([col, row], {
          kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text,
          data: x.toString(),
          displayData: `${x}k`,
          themeOverride: x % 5 !== 0 ? {
            bgCell: "#f2fff4",
            textDark: "#00d41c"
          } : {
            bgCell: "#fff6f6",
            textDark: "#d40000"
          },
          allowOverlay: true,
          lastUpdated: now
        });
        cells.push({
          cell: [col, row]
        });
      }

      countRef.current += 5000;

      if (displayCountRef.current !== null) {
        displayCountRef.current.textContent = `${countRef.current}`;
      }

      (_ref$current3 = ref.current) === null || _ref$current3 === void 0 ? void 0 : _ref$current3.updateCells(cells);
      rafID = window.requestAnimationFrame(sendUpdate);
    };

    sendUpdate();
    return () => {
      cancelAnimationFrame(rafID);
    };
  }, [setCellValueRaw]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Rapid updating",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Data grid can support many thousands of updates per seconds. The data grid can easily update data faster than a human can read it, more importantly the faster the data grid can update, the more time your code can spend doing more valuable work."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Updates processed: ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(KeyName, {
      ref: displayCountRef
    }), " We could do this faster but we wrote a really crappy data store for this demo which is actually slowing down the data grid."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    ref: ref,
    getCellContent: getCellContent,
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    rows: 10000
  })));
};
RapidUpdates.parameters = {
  options: {
    showPanel: false
  }
};
const CopySupport = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(10, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Copy support",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Large amounts of data can be copied and customized using", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "getCellsForSelection"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "The data is copied into a format ready to be pasted into Excel or Google Sheets"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
      placeholder: "Copy something below and paste it here...",
      style: {
        width: "100%",
        marginBottom: 20,
        borderRadius: 9,
        minHeight: 200,
        padding: 10
      }
    }))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    rowMarkers: "both",
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 400
  })));
};
CopySupport.parameters = {
  options: {
    showPanel: false
  }
};
const PasteSupport = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(50, false);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Paste support",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "The data grid can handle paste automatically by returning true from ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onPaste"), ". You can also return false and handle paste yourself. If paste is undefined the DataEditor will do its best to paste to the current cell."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Paste supports the copy format of Google Sheets and Excel. Below is an example of data copied from excel with some escaped text."), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
      value: `Sunday	Dogs	https://google.com
Monday	Cats	https://google.com
Tuesday	Turtles	https://google.com
Wednesday	Bears	https://google.com
Thursday	"L  ions"	https://google.com
Friday	Pigs	https://google.com
Saturday	"Turkeys and some ""quotes"" and
a new line char ""more quotes"" plus a tab  ."	https://google.com`,
      style: {
        width: "100%",
        marginBottom: 20,
        borderRadius: 9,
        minHeight: 200,
        padding: 10
      }
    }))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    rowMarkers: "both",
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    onPaste: true,
    rows: 400
  })));
};
PasteSupport.parameters = {
  options: {
    showPanel: false
  }
};
const FreezeColumns = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Freeze columns",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Columns at the start of your grid can be frozen in place by settings", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "freezeColumns"), " to a number greater than 0.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "both",
    freezeColumns: 1,
    getCellContent: getCellContent,
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    verticalBorder: c => c > 0,
    rows: 1000
  })));
};
FreezeColumns.parameters = {
  options: {
    showPanel: false
  }
};
const ReorderRows = () => {
  const cols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => [{
    title: "Col A",
    width: 150
  }, {
    title: "Col B",
    width: 150
  }], []);
  const [rowData, setRowData] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    return lodash_range_js__WEBPACK_IMPORTED_MODULE_2___default()(0, 50).map(x => [`A: ${x}`, `B: ${x}`]);
  });
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref4 => {
    let [col, row] = _ref4;
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: false,
      data: rowData[row][col],
      displayData: rowData[row][col]
    };
  }, [rowData]);
  const reorderRows = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((from, to) => {
    setRowData(cv => {
      const d = [...cv];
      const removed = d.splice(from, 1);
      d.splice(to, 0, ...removed);
      return d;
    });
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Reorder Rows",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Rows can be re-arranged by using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onRowMoved"), " callback. When set the first row can be used to drag and drop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "both",
    onRowMoved: reorderRows,
    getCellContent: getCellContent,
    columns: cols,
    rows: 50
  })));
};
ReorderRows.parameters = {
  options: {
    showPanel: false
  }
};
const ColumnGroups = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(20, true, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Column Grouping",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Columns in the data grid may be grouped by setting their ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "group"), " property.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    onGroupHeaderRenamed: (x, y) => window.alert(`Please rename group ${x} to ${y}`),
    columns: cols,
    getCellsForSelection: getCellsForSelection,
    rows: 1000,
    getGroupDetails: g => ({
      name: g,
      icon: g === "" ? undefined : _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridColumnIcon.HeaderCode */ .PE.HeaderCode
    }),
    rowMarkers: "both"
  })));
};
ColumnGroups.parameters = {
  options: {
    showPanel: false
  }
};
const StretchColumnSize = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection,
    onColumnResize
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(5, true, true);
  const hasResized = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Set());
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map((x, i) => ({ ...x,
      grow: hasResized.current.has(i) ? undefined : (5 + i) / 5
    }));
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Column Grow",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Columns in the data grid may be set to grow to fill space by setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "grow"), " ", "prop.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: columns,
    getCellsForSelection: getCellsForSelection,
    rows: 1000,
    onColumnResize: (col, _newSize, colIndex, newSizeWithGrow) => {
      hasResized.current.add(colIndex);
      onColumnResize(col, newSizeWithGrow);
    },
    rowMarkers: "both"
  })));
};
StretchColumnSize.parameters = {
  options: {
    showPanel: false
  }
};

function useCollapsableColumnGroups(cols) {
  const [collapsed, setCollapsed] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  const onGroupHeaderClicked = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((colIndex, args) => {
    var _cols$colIndex$group;

    const group = (_cols$colIndex$group = cols[colIndex].group) !== null && _cols$colIndex$group !== void 0 ? _cols$colIndex$group : "";
    setCollapsed(cv => cv.includes(group) ? cv.filter(g => g !== group) : [...cv, group]);
    args.preventDefault();
  }, [cols]);
  const [selectedColumns, setSelectedColumns] = react__WEBPACK_IMPORTED_MODULE_0__.useState(_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty());
  const setCols = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal, trigger) => {
    if (trigger === "group") return;
    setSelectedColumns(newVal);
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return cols.map(c => {
      var _c$group;

      if (!collapsed.includes((_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : "")) return { ...c,
        hasMenu: true
      };
      return { ...c,
        width: 8,
        hasMenu: true
      };
    });
  }, [collapsed, cols]);
  return {
    columns,
    onGroupHeaderClicked,
    selectedColumns,
    onSelectedColumnsChange: setCols
  };
}

const ColumnGroupCollapse = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100, true, true);
  const groupHeaderArgs = useCollapsableColumnGroups(cols);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Group collapse",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Through clever usage of ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onGroupHeaderClicked"), " you can implement group collapsing. This is a very basic version however it is possible to go much further."), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Cells under a certain size will not attempt to render to save some frames."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, groupHeaderArgs, {
    getCellContent: getCellContent,
    groupHeaderHeight: 24,
    rows: 1000,
    rowMarkers: "both"
  })));
};
ColumnGroupCollapse.parameters = {
  options: {
    showPanel: false
  }
};
const Minimap = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(1000, true, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Minimap",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "A minimap can be enabled by setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "showMinimap"), " property.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    showMinimap: true,
    rows: 3000,
    rowMarkers: "both"
  })));
};
Minimap.parameters = {
  options: {
    showPanel: false
  }
};
const ContentAlignment = () => {
  const {
    cols,
    getCellContent
  } = useAllMockedKinds();
  const mangledGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, _row] = cell;

    if (col === 3) {
      return { ...getCellContent(cell),
        contentAlign: "center"
      };
    }

    if (col === 4) {
      return { ...getCellContent(cell),
        contentAlign: "right"
      };
    }

    return getCellContent(cell);
  }, [getCellContent]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Content Alignment",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can customize the content alignment by setting ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "contentAlign"), " of a cell to", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "left"), ", ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "right"), " or ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "center"), ".")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: mangledGetCellContent,
    columns: cols,
    rows: 300
  })));
};
const RowHover = () => {
  const {
    cols,
    getCellContent
  } = useAllMockedKinds();
  const [hoverRow, setHoverRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);
  const onItemHovered = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const [_, row] = args.location;
    setHoverRow(args.kind !== "cell" ? undefined : row);
  }, []);
  const getRowThemeOverride = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(row => {
    if (row !== hoverRow) return undefined;
    return {
      bgCell: "#f7f7f7",
      bgCellMedium: "#f0f0f0"
    };
  }, [hoverRow]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Row Hover Effect",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Through careful usage of the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onItemHovered"), " callback it is possible to easily create a row hover effect.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "both",
    onItemHovered: onItemHovered,
    getCellContent: getCellContent,
    getRowThemeOverride: getRowThemeOverride,
    columns: cols,
    rows: 300
  })));
};
const SpanCell = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100, true, true);
  const mangledGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;

    if (row === 6 && col >= 3 && col <= 4) {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: false,
        data: "Span Cell that is very long and will go past the cell limits",
        span: [3, 4],
        displayData: "Span Cell that is very long and will go past the cell limits"
      };
    }

    if (row === 5) {
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: false,
        data: "Span Cell that is very long and will go past the cell limits",
        span: [0, 99],
        displayData: "Span Cell that is very long and will go past the cell limits"
      };
    }

    return getCellContent(cell);
  }, [getCellContent]);
  const getCellsForSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(selection => {
    const result = [];

    for (let y = selection.y; y < selection.y + selection.height; y++) {
      const row = [];

      for (let x = selection.x; x < selection.x + selection.width; x++) {
        row.push(mangledGetCellContent([x, y]));
      }

      result.push(row);
    }

    return result;
  }, [mangledGetCellContent]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Spans",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "By setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "span"), " of a cell you can create spans in your grid. All cells within a span must return consistent data for defined behavior.", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Spans will always be split if they span frozen and non-frozen columns. By default selections are always expanded to include a span. This can be disabled using the", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "spanRangeBehavior"), " prop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: mangledGetCellContent,
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    freezeColumns: 2,
    rows: 300,
    rowMarkers: "both"
  })));
};
SpanCell.parameters = {
  options: {
    showPanel: false
  }
};
const zeroBounds = {
  left: 0,
  top: 0,
  width: 0,
  height: 0,
  bottom: 0,
  right: 0
};
const Tooltips = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(6);
  const [tooltip, setTooltip] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const onItemHovered = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.kind === "cell") {
      window.clearTimeout(timeoutRef.current);
      setTooltip(undefined);
      timeoutRef.current = window.setTimeout(() => {
        setTooltip({
          val: `Tooltip for ${args.location[0]}, ${args.location[1]}`,
          bounds: {
            left: args.bounds.x,
            top: args.bounds.y,
            width: args.bounds.width,
            height: args.bounds.height,
            right: args.bounds.x + args.bounds.width,
            bottom: args.bounds.y + args.bounds.height
          }
        });
      }, 1000);
    } else {
      window.clearTimeout(timeoutRef.current);
      timeoutRef.current = 0;
      setTooltip(undefined);
    }
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => window.clearTimeout(timeoutRef.current), []);
  const isOpen = tooltip !== undefined;
  const {
    renderLayer,
    layerProps
  } = (0,react_laag__WEBPACK_IMPORTED_MODULE_10__/* .useLayer */ .sJ)({
    isOpen,
    triggerOffset: 4,
    auto: true,
    container: "portal",
    trigger: {
      getBounds: () => {
        var _tooltip$bounds;

        return (_tooltip$bounds = tooltip === null || tooltip === void 0 ? void 0 : tooltip.bounds) !== null && _tooltip$bounds !== void 0 ? _tooltip$bounds : zeroBounds;
      }
    }
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Tooltips",
    className: "double",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onItemHovered"), " event makes it easy to create tooltips. This story is intentionally forced to scroll vertically so layout in scrolling documents can be confirmed.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    onItemHovered: onItemHovered,
    getCellContent: getCellContent,
    columns: cols,
    rows: 1000
  }))), isOpen && renderLayer(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", _extends({}, layerProps, {
    style: { ...layerProps.style,
      padding: "8px 12px",
      color: "white",
      font: "500 13px Inter",
      backgroundColor: "rgba(0, 0, 0, 0.85)",
      borderRadius: 9
    }
  }), tooltip.val)));
};
Tooltips.parameters = {
  options: {
    showPanel: false
  }
};
const ControlledSelection = () => {
  var _selection$current$ce, _selection$current, _selection$current$ce2, _selection$current2;

  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(30, true, true);
  const [selection, setSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty()
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Controlled Selection",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "The selection of the grid can be controlled via ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "GridSelection"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onGridSelectionChange"), ".", react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      type: "range",
      min: 0,
      max: 29,
      value: (_selection$current$ce = (_selection$current = selection.current) === null || _selection$current === void 0 ? void 0 : _selection$current.cell[0]) !== null && _selection$current$ce !== void 0 ? _selection$current$ce : 0,
      onChange: e => {
        const newCol = e.target.valueAsNumber;
        setSelection(cv => {
          var _cv$current$cell$, _cv$current, _cv$current$cell$2, _cv$current2;

          return { ...cv,
            current: {
              cell: [newCol, (_cv$current$cell$ = (_cv$current = cv.current) === null || _cv$current === void 0 ? void 0 : _cv$current.cell[1]) !== null && _cv$current$cell$ !== void 0 ? _cv$current$cell$ : 0],
              range: {
                x: newCol,
                y: (_cv$current$cell$2 = (_cv$current2 = cv.current) === null || _cv$current2 === void 0 ? void 0 : _cv$current2.cell[1]) !== null && _cv$current$cell$2 !== void 0 ? _cv$current$cell$2 : 0,
                width: 1,
                height: 1
              },
              rangeStack: []
            }
          };
        });
      }
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      type: "range",
      min: 0,
      max: 99,
      value: (_selection$current$ce2 = (_selection$current2 = selection.current) === null || _selection$current2 === void 0 ? void 0 : _selection$current2.cell[1]) !== null && _selection$current$ce2 !== void 0 ? _selection$current$ce2 : 0,
      onChange: e => {
        const newRow = e.target.valueAsNumber;
        setSelection(cv => {
          var _cv$current$cell$3, _cv$current3, _cv$current$cell$4, _cv$current4;

          return { ...cv,
            current: {
              cell: [(_cv$current$cell$3 = (_cv$current3 = cv.current) === null || _cv$current3 === void 0 ? void 0 : _cv$current3.cell[0]) !== null && _cv$current$cell$3 !== void 0 ? _cv$current$cell$3 : 0, newRow],
              range: {
                x: (_cv$current$cell$4 = (_cv$current4 = cv.current) === null || _cv$current4 === void 0 ? void 0 : _cv$current4.cell[0]) !== null && _cv$current$cell$4 !== void 0 ? _cv$current$cell$4 : 0,
                y: newRow,
                width: 1,
                height: 1
              },
              rangeStack: []
            }
          };
        });
      }
    }))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    gridSelection: selection,
    onGridSelectionChange: setSelection,
    columns: cols,
    rows: 100,
    rowMarkers: "both"
  })));
};
const NewColumnButton = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(10, true);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => cols.map(c => ({ ...c,
    grow: 1
  })), [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "New column button",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "A new column button can be created using the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "rightElement"), ".")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: columns,
    rightElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .ColumnAddButton */ .YE, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      onClick: () => window.alert("Add a column!")
    }, "+")),
    rightElementProps: {
      fill: false,
      sticky: false
    },
    rows: 3000,
    rowMarkers: "both"
  })));
};
const CustomHeader = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(1000, true, true);
  const drawHeader = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const {
      ctx,
      rect
    } = args;
    ctx.rect(rect.x, rect.y, rect.width, rect.height);
    const lg = ctx.createLinearGradient(0, rect.y, 0, rect.y + rect.height);
    lg.addColorStop(0, "#ff00d934");
    lg.addColorStop(1, "#00a2ff34");
    ctx.fillStyle = lg;
    ctx.fill();
    return false;
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Custom Header",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Make it as fancy as you like.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    drawHeader: drawHeader,
    rows: 3000,
    rowMarkers: "both"
  })));
};
CustomHeader.parameters = {
  options: {
    showPanel: false
  }
};
const Padding = p => {
  const {
    paddingRight,
    paddingBottom
  } = p;
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(20);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Padding",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can add padding at the ends of the grid by setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "paddingRight"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "paddingBottom"), " props"))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    experimental: {
      paddingRight,
      paddingBottom
    },
    rows: 50
  })));
};
Padding.argTypes = {
  paddingRight: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  },
  paddingBottom: {
    control: {
      type: "range",
      min: 0,
      max: 600
    }
  }
};
Padding.args = {
  paddingRight: 200,
  paddingBottom: 200
};
Padding.parameters = {
  options: {
    showPanel: true
  }
};
const HighlightCells = () => {
  const {
    cols,
    getCellContent,
    getCellsForSelection
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(100);
  const [gridSelection, setGridSelection] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .CompactSelection.empty */ .EV.empty()
  });
  const highlights = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (gridSelection.current === undefined) return undefined;
    const [col, row] = gridSelection.current.cell;
    return [{
      color: "#44BB0022",
      range: {
        x: col + 2,
        y: row,
        width: 10,
        height: 10
      },
      style: "solid"
    }, {
      color: "#b000b021",
      range: {
        x: col,
        y: row + 2,
        width: 1,
        height: 1
      }
    }];
  }, [gridSelection]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "HighlightCells",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "The ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "highlightRegions"), " prop can be set to provide additional hinting or context for the current selection.")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    rowMarkers: "both",
    freezeColumns: 1,
    highlightRegions: highlights,
    gridSelection: gridSelection,
    onGridSelectionChange: setGridSelection,
    getCellContent: getCellContent,
    getCellsForSelection: getCellsForSelection,
    columns: cols,
    verticalBorder: c => c > 0,
    rows: 1000
  })));
};
HighlightCells.parameters = {
  options: {
    showPanel: false
  }
};
const LayoutIntegration = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(1000, true, true);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulStyle */ .xl, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", null, "Layout Integration"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Trying the grid in different situations"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 10,
    rowMarkers: "both",
    height: 200
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 10,
    rowMarkers: "both"
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      display: "flex",
      height: "300px"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rows: 10,
    rowMarkers: "both"
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      flexShrink: 0
    }
  }, "This is some text what happens here?")));
};
LayoutIntegration.parameters = {
  options: {
    showPanel: false
  }
};
const DragSource = p => {
  const {
    cols,
    getCellContent,
    onColumnResize
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(200);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Drag source",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Setting the ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "isDraggable"), " prop can allow for more granular control over what is draggable in the grid via HTML drag and drop."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    rowMarkers: "both",
    rows: 5000,
    onRowMoved: (s, e) => window.alert(`Moved row ${s} to ${e}`),
    onColumnMoved: (s, e) => window.alert(`Moved col ${s} to ${e}`),
    onColumnResize: onColumnResize,
    isDraggable: p.isDraggable,
    onDragStart: e => {
      e.setData("text/plain", "Drag data here!");
    }
  })));
};
DragSource.argTypes = {
  isDraggable: {
    control: {
      type: "select",
      options: [true, false, "cell", "header"]
    }
  }
};
DragSource.args = {
  isDraggable: false
};
DragSource.parameters = {
  options: {
    showPanel: true
  }
};
const PreventDiagonalScroll = () => {
  const {
    cols,
    getCellContent
  } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__/* .useMockDataGenerator */ .F9)(200);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Prevent Diagonal Scroll",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "Diagonal scrolling can be prevented by setting ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "preventDiagonalScrolling"), "."))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    preventDiagonalScrolling: true,
    rows: 5000
  })));
};
PreventDiagonalScroll.parameters = {
  options: {
    showPanel: false
  }
};
const SUPPORTED_IMAGE_TYPES = new Set(["image/png", "image/gif", "image/bmp", "image/jpeg"]);
const DropEvents = () => {
  const {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue
  } = useAllMockedKinds();
  const [highlights, setHighlights] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  const [lastDropCell, setLastDropCell] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const onDrop = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, dataTransfer) => {
    setHighlights([]);

    if (dataTransfer === null) {
      return;
    }

    const {
      files
    } = dataTransfer;

    if (files.length !== 1) {
      return;
    }

    const [file] = files;

    if (!SUPPORTED_IMAGE_TYPES.has(file.type)) {
      return;
    }

    const imgUrl = URL.createObjectURL(file);
    setCellValue(cell, {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Image */ .p6.Image,
      data: [imgUrl],
      allowOverlay: true,
      allowAdd: false
    }, true, true);
    setLastDropCell(cell);
  }, [setCellValue]);
  const onDragOverCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, dataTransfer) => {
    if (dataTransfer === null) {
      return;
    }

    const {
      items
    } = dataTransfer;

    if (items.length !== 1) {
      return;
    }

    const [item] = items;

    if (!SUPPORTED_IMAGE_TYPES.has(item.type)) {
      return;
    }

    const [col, row] = cell;

    if (getCellContent(cell).kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_7__/* .GridCellKind.Image */ .p6.Image) {
      setHighlights([{
        color: "#44BB0022",
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }]);
    } else {
      setHighlights([]);
    }
  }, [getCellContent]);
  const onDragLeave = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setHighlights([]);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .BeautifulWrapper */ .m, {
    title: "Drop events",
    description: react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .Description */ .dk, null, "You can drag and drop into cells by using ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onDragOverCell"), " and", " ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, "onDrop"), "."), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, lastDropCell === undefined ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "Nothing dropped, yet") : react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .MoreInfo */ .OX, null, "You last dropped in cell ", react__WEBPACK_IMPORTED_MODULE_0__.createElement(_utils__WEBPACK_IMPORTED_MODULE_5__/* .PropName */ .Gi, null, JSON.stringify(lastDropCell))))))
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_6__/* .DataEditor */ .N, _extends({}, defaultProps, {
    getCellContent: getCellContent,
    columns: cols,
    onCellEdited: setCellValue,
    onColumnResize: onColumnResize,
    rows: 1000,
    onDrop: onDrop,
    onDragOverCell: onDragOverCell,
    onDragLeave: onDragLeave,
    highlightRegions: highlights,
    rowMarkers: "none"
  })));
};
DropEvents.parameters = {
  options: {
    showPanel: false
  }
};

__webpack_require__("./packages/core/src/data-editor/stories/data-editor-beautiful.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx");

const __namedExportsOrder = ["ResizableColumns", "Overscroll", "AddData", "RightToLeft", "ValidateData", "FillHandle", "TrailingRowOptions", "AddDataToTop", "AddDataToMiddle", "AppendRowHandle", "SmallEditableGrid", "OneMillionRows", "SillyNumbers", "ObserveVisibleRegion", "OneHundredThousandCols", "TenMillionCells", "SmoothScrollingGrid", "InputBlending", "AddColumns", "ScrollShadows", "AutomaticRowMarkers", "WrappingText", "UnevenRows", "DrawCustomCells", "RearrangeColumns", "RowAndHeaderSizes", "MultiSelectColumns", "AllCellKinds", "ThemeSupport", "ThemePerColumn", "ThemePerRow", "CellActivatedEvent", "BuiltInSearch", "ImperativeScroll", "HeaderMenus", "CustomHeaderIcons", "RightElement", "RapidUpdates", "CopySupport", "PasteSupport", "FreezeColumns", "ReorderRows", "ColumnGroups", "StretchColumnSize", "ColumnGroupCollapse", "Minimap", "ContentAlignment", "RowHover", "SpanCell", "Tooltips", "ControlledSelection", "NewColumnButton", "CustomHeader", "Padding", "HighlightCells", "LayoutIntegration", "DragSource", "PreventDiagonalScroll", "DropEvents"];

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bug70": () => (/* binding */ Bug70),
/* harmony export */   "FilterColumns": () => (/* binding */ FilterColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _storybook_addons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@storybook/addons/dist/esm/hooks.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Tests/TestCases/Bugs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .BuilderThemeWrapper */ .j, {
    width: 1000,
    height: 800
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});

const bug70Gen = _ref => {
  let [, row] = _ref;
  return {
    allowOverlay: true,
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Number */ .p6.Number,
    data: row,
    displayData: row.toString()
  };
};

const ignore = () => undefined;

const Bug70Style = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)('div')({
  name: "Bug70Style",
  class: "b1nvh7n2"
});
function Bug70() {
  const cols = [{
    title: "Col1",
    width: 100
  }, {
    title: "Col2",
    width: 100
  }];
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Bug70Style, {
    className: "App"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "To cause error: scroll down at least one row, edit a cell in Col2, and hit Tab"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    href: "https://github.com/glideapps/glide-data-grid/issues/70",
    target: "_blank",
    rel: "noreferrer"
  }, "Original report"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: 500,
    height: 500,
    rows: 100,
    columns: cols,
    getCellContent: bug70Gen,
    onCellEdited: ignore
  }));
}

const filterColumnsGen = _ref2 => {
  let [col, row] = _ref2;
  return {
    allowOverlay: true,
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
    data: `${col} - ${row}`,
    displayData: `${col} - ${row}`
  };
};

const filteringColumns = [{
  title: "Col AAAA",
  width: 120
}, {
  title: "Col AAA",
  width: 120
}, {
  title: "Col AA",
  width: 120
}, {
  title: "Col A",
  width: 120
}, {
  title: "Col",
  width: 120
}];
function FilterColumns() {
  const [searchText, setSearchText] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_5__/* .useState */ .eJ)("");
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_5__/* .useMemo */ .Ye)(() => {
    if (searchText === "") {
      return filteringColumns;
    }

    return filteringColumns.filter(c => c.title.toLowerCase().includes(searchText.toLowerCase()));
  }, [searchText]);

  const onInputChange = e => {
    setSearchText(e.target.value);
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    value: searchText,
    onChange: onInputChange
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: 1000,
    height: 500,
    rows: 100,
    columns: cols,
    getCellContent: filterColumnsGen,
    smoothScrollX: true,
    smoothScrollY: true
  }));
}

__webpack_require__("./packages/core/src/data-editor/stories/data-editor-repros.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx");

const __namedExportsOrder = ["Bug70", "FilterColumns"];

/***/ }),

/***/ "./packages/core/src/data-editor/stories/data-editor.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanEditBoolean": () => (/* binding */ CanEditBoolean),
/* harmony export */   "Draggable": () => (/* binding */ Draggable),
/* harmony export */   "DynamicAddRemoveColumns": () => (/* binding */ DynamicAddRemoveColumns),
/* harmony export */   "GridAddNewRows": () => (/* binding */ GridAddNewRows),
/* harmony export */   "GridNoTrailingBlankRow": () => (/* binding */ GridNoTrailingBlankRow),
/* harmony export */   "GridSelectionOutOfRangeLessColumnsThanSelection": () => (/* binding */ GridSelectionOutOfRangeLessColumnsThanSelection),
/* harmony export */   "GridSelectionOutOfRangeNoColumns": () => (/* binding */ GridSelectionOutOfRangeNoColumns),
/* harmony export */   "IdealSize": () => (/* binding */ IdealSize),
/* harmony export */   "ManualControl": () => (/* binding */ ManualControl),
/* harmony export */   "MarkdownEdits": () => (/* binding */ MarkdownEdits),
/* harmony export */   "Minimal": () => (/* binding */ Minimal),
/* harmony export */   "RelationColumn": () => (/* binding */ RelationColumn),
/* harmony export */   "ResizableColumns": () => (/* binding */ ResizableColumns),
/* harmony export */   "SimpleEditable": () => (/* binding */ SimpleEditable),
/* harmony export */   "Simplenotest": () => (/* binding */ Simplenotest),
/* harmony export */   "Smooth": () => (/* binding */ Smooth),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _storybook_addons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/@storybook/addons/dist/esm/hooks.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Tests/TestCases",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .BuilderThemeWrapper */ .j, {
    width: 1000,
    height: 800
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});

function getDummyData(_ref) {
  let [col, row] = _ref;

  if (col === 0) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.RowID */ .p6.RowID,
      data: `RowID ${col}, ${row}`,
      allowOverlay: false
    };
  }

  if (col === 1) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Bubble */ .p6.Bubble,
      data: [`Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`, `Bub ${col}`, `Bub ${row}`],
      allowOverlay: true
    };
  }

  if (col === 2) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Image */ .p6.Image,
      data: ["https://i.imgur.com/5J0BftG.jpg", "https://preview.redd.it/7jlqkp2cyap51.jpg?width=575&auto=webp&s=26fa9ed15b16fb450ee08ed1f2f0ccb5e0223581"],
      allowOverlay: true,
      allowAdd: true
    };
  }

  if (col === 3) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown,
      data: `## Markdown has titles

And supports newline chars and automatic wrapping text that just needs to be long enough to trigger it.


[Google](https://google.com)

- with
- lists
- that
- can
- be
- pretty
- long
                    `,
      allowOverlay: true
    };
  }

  if (col === 4) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Number */ .p6.Number,
      displayData: "$10,352",
      allowOverlay: true,
      data: 10352,
      readonly: true
    };
  }

  if (col === 5) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Uri */ .p6.Uri,
      data: "https://www.google.com",
      allowOverlay: true
    };
  }

  if (col === 6) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Boolean */ .p6.Boolean,
      data: row % 3 === 0 || row % 5 === 0,
      readonly: true,
      allowOverlay: false
    };
  }

  if (col === 7) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      displayData: ` `,
      data: ` `,
      allowOverlay: true,
      readonly: true
    };
  }

  if (col === 8) {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Drilldown */ .p6.Drilldown,
      data: [{
        text: "Test",
        img: "https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg"
      }, {
        text: "No Image"
      }],
      allowOverlay: true
    };
  }

  return {
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
    displayData: `${col}, ${row} `,
    data: `${col}, ${row} `,
    allowOverlay: true
  };
}

function getDummyCols() {
  return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20].map(i => ({
    title: i.toString() + " is the longest header in the world",
    width: 120 + i % 4 * 10,
    icon: "headerString",
    hasMenu: true
  }));
}

function Simplenotest() {
  const [cols, setColumns] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getDummyCols);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((col, newSize) => {
    const index = cols.indexOf(col);
    const newCols = [...cols];
    newCols[index] = { ...newCols[index],
      width: newSize
    };
    setColumns(newCols);
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    getCellsForSelection: true,
    columns: cols,
    rows: 1000,
    onColumnResize: onColumnResize
  });
}

function getDummyRelationColumn() {
  return [{
    title: "Relation",
    width: 360,
    icon: "headerString",
    hasMenu: true
  }];
}

function getDummyRelationData(_ref2) {
  let [col, row] = _ref2;
  return {
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Drilldown */ .p6.Drilldown,
    data: [{
      text: `Image ${col}-${row}`,
      img: "https://allthatsinteresting.com/wordpress/wp-content/uploads/2012/06/iconic-photos-1950-einstein.jpg"
    }, {
      text: `Text ${col}-${row}`
    }, {
      text: `More text ${col}-${row}`
    }],
    allowOverlay: true
  };
}

function RelationColumn() {
  const [cols, setColumns] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getDummyRelationColumn);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((col, newSize) => {
    const index = cols.indexOf(col);
    const newCols = [...cols];
    newCols[index] = { ...newCols[index],
      width: newSize
    };
    setColumns(newCols);
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyRelationData,
    columns: cols,
    rows: 1000,
    onColumnResize: onColumnResize,
    smoothScrollX: true,
    smoothScrollY: true
  });
}
const columns = [{
  title: "Number",
  width: 100,
  icon: "headerArray",
  overlayIcon: "rowOwnerOverlay"
}, {
  title: "Square",
  width: 100
}];

function getData(_ref3) {
  let [col, row] = _ref3;
  const n = Math.pow(row, col + 1);
  return {
    kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Number */ .p6.Number,
    data: n,
    displayData: n.toString(),
    allowOverlay: false
  };
}

function Minimal() {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getData,
    columns: columns,
    rows: 1000
  });
}
function Smooth() {
  const [cols, setCols] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getDummyCols);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((column, newSize) => {
    const index = cols.indexOf(column);

    if (index !== -1) {
      const newCol = { ...column,
        width: newSize
      };
      const newCols = [...cols];
      newCols.splice(index, 1, newCol);
      setCols(newCols);
    }
  }, [cols]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    onColumnResize: onColumnResize,
    columns: cols,
    rows: 1000,
    smoothScrollY: true,
    smoothScrollX: true
  });
}
function ManualControl() {
  const [gridSelection, setGridSelection] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(undefined);

  const cb = newVal => {
    var _newVal$current$cell$, _newVal$current;

    if (((_newVal$current$cell$ = (_newVal$current = newVal.current) === null || _newVal$current === void 0 ? void 0 : _newVal$current.cell[0]) !== null && _newVal$current$cell$ !== void 0 ? _newVal$current$cell$ : 0) % 2 === 0) {
      setGridSelection(newVal);
    }
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    gridSelection: gridSelection,
    onGridSelectionChange: cb,
    getCellContent: getData,
    columns: columns,
    rows: 1000
  });
}
function Draggable() {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    isDraggable: true,
    onDragStart: args => {
      args.setData("text", "testing");
    },
    getCellContent: getData,
    columns: columns,
    rows: 1000
  });
}
function IdealSize() {
  const cols = [{
    title: "Number",
    width: 250
  }, {
    title: "Square",
    width: 250
  }];
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      width: 500,
      height: 500,
      position: "relative"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: 500,
    height: 500,
    isDraggable: true,
    onDragStart: args => {
      args.setData("text", "testing");
    },
    getCellContent: getData,
    columns: cols,
    smoothScrollX: true,
    smoothScrollY: true,
    rowHeight: 50,
    headerHeight: 50,
    rows: 9
  }));
}
function DynamicAddRemoveColumns(_ref4) {
  let {
    columnCount
  } = _ref4;
  const cols = [{
    title: "Number",
    width: 250
  }, {
    title: "Square",
    width: 250
  }];

  for (let i = 2; i < columnCount; i++) {
    cols.push({
      title: "Foo",
      width: 250
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    isDraggable: true,
    getCellContent: getData,
    columns: cols,
    smoothScrollX: true,
    smoothScrollY: true,
    rowHeight: 50,
    headerHeight: 50,
    rows: 9
  });
}
DynamicAddRemoveColumns.args = {
  columnCount: 2
};
function GridSelectionOutOfRangeNoColumns() {
  const dummyCols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => getDummyCols().map(v => ({ ...v,
    width: 300,
    title: "Making column smaller used to crash!"
  })), []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)({
    current: {
      cell: [2, 8],
      range: {
        width: 1,
        height: 1,
        x: 2,
        y: 8
      },
      rangeStack: []
    },
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
  });
  const [cols, setCols] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(dummyCols);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 1000,
    onGridSelectionChange: onSelected,
    gridSelection: selected,
    onColumnResize: (_col, newSize) => {
      if (newSize > 300) {
        setCols(dummyCols);
      } else {
        setCols([]);
      }
    }
  });
}

function getResizableColumnsInitSize() {
  return {
    "resize me 0": 120,
    "resize me 1": 120,
    "resize me 2": 120,
    "resize me 3": 120,
    "resize me 4": 120,
    "resize me 5": 120,
    "resize me 6": 120,
    "resize me 7": 120
  };
}

function getResizableColumns(sizeMap) {
  return Object.entries(sizeMap).map(_ref5 => {
    let [title, width] = _ref5;
    return {
      title,
      width,
      icon: "headerString",
      hasMenu: true
    };
  });
}

function ResizableColumns() {
  const [colSizes, setColSizes] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(getResizableColumnsInitSize);
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => {
    return getResizableColumns(colSizes);
  }, [colSizes]);
  const onColumnResize = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)((column, newSize) => {
    setColSizes(prevColSizes => {
      return { ...prevColSizes,
        [column.title]: newSize
      };
    });
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 20,
    isDraggable: false,
    smoothScrollX: true,
    smoothScrollY: true,
    onColumnResize: onColumnResize
  });
}
function GridSelectionOutOfRangeLessColumnsThanSelection() {
  const dummyCols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => getDummyCols().map(v => ({ ...v,
    width: 300,
    title: "Making column smaller used to crash!"
  })), []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)({
    current: {
      cell: [2, 8],
      range: {
        width: 1,
        height: 1,
        x: 2,
        y: 8
      },
      rangeStack: []
    },
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
  });
  const [cols, setCols] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(dummyCols);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 1000,
    onGridSelectionChange: onSelected,
    gridSelection: selected,
    onColumnResize: (_col, newSize) => {
      if (newSize > 300) {
        setCols(dummyCols);
      } else {
        setCols([dummyCols[0]]);
      }
    }
  });
}
function GridAddNewRows() {
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(getDummyCols, []);
  const [rowsCount, setRowsCount] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(10);
  const onRowAppended = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(() => {
    setRowsCount(r => r + 1);
  }, []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(undefined);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: rowsCount,
    onRowAppended: onRowAppended,
    onGridSelectionChange: onSelected,
    gridSelection: selected
  });
}
function GridNoTrailingBlankRow() {
  const cols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(getDummyCols, []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(undefined);
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: getDummyData,
    columns: cols,
    rows: 100,
    onGridSelectionChange: onSelected,
    gridSelection: selected
  });
}
function MarkdownEdits() {
  const dummyCols = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useMemo */ .Ye)(() => {
    return [{
      title: "MD short",
      width: 50
    }, {
      title: "MD long",
      width: 50
    }];
  }, []);
  const dummyCells = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(_ref6 => {
    let [col, _row] = _ref6;

    if (col === 0) {
      const editable = {
        data: "text",
        allowOverlay: true,
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown
      };
      return editable;
    } else if (col === 1) {
      const editable = {
        data: `text really really really long
## H1

- this
- is
- a
- longer
- example
- to
- test
- scroll
- of
- preview
                `,
        allowOverlay: true,
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown
      };
      return editable;
    }

    const editable = {
      data: "text",
      allowOverlay: true,
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Markdown */ .p6.Markdown
    };
    return editable;
  }, []);
  const [selected, setSelected] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)({
    current: {
      cell: [2, 8],
      range: {
        width: 1,
        height: 1,
        x: 2,
        y: 8
      },
      rangeStack: []
    },
    columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
    rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
  });
  const onSelected = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useCallback */ .I4)(newSel => {
    setSelected(newSel);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    getCellContent: dummyCells,
    columns: dummyCols,
    rows: 1000,
    onGridSelectionChange: onSelected,
    gridSelection: selected
  });
}
const CanEditBoolean = () => {
  const [vals, setVals] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)([false, false]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    columns: [{
      title: "Editable",
      width: 100
    }, {
      title: "Readonly",
      width: 100
    }],
    rows: 1,
    getCellContent: _ref7 => {
      let [col] = _ref7;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Boolean */ .p6.Boolean,
        readonly: col !== 0,
        allowOverlay: false,
        data: vals[col]
      };
    },
    onCellEdited: (_ref8, newVal) => {
      let [col] = _ref8;

      if (newVal.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Boolean */ .p6.Boolean) {
        setVals(cv => {
          const f = [...cv];
          f.splice(col, 1, newVal.data);
          return f;
        });
      }
    }
  });
};
const SimpleEditable = () => {
  const [vals, setVals] = (0,_storybook_addons__WEBPACK_IMPORTED_MODULE_3__/* .useState */ .eJ)(() => {
    const result = [];

    for (let i = 0; i < 2000; i++) {
      result.push(["Edit", "Me"]);
    }

    return result;
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    width: "100%",
    columns: [{
      title: "Column A",
      width: 250
    }, {
      title: "Column B",
      width: 250
    }],
    rows: vals.length,
    getCellContent: _ref9 => {
      let [col, row] = _ref9;
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        allowOverlay: true,
        data: vals[row][col],
        displayData: vals[row][col]
      };
    },
    onCellEdited: (_ref10, newVal) => {
      let [col, row] = _ref10;
      const newVals = [...vals];
      const newRow = [...newVals[row]];

      if (typeof newVal.data === "string") {
        newRow[col] = newVal.data;
      }

      newVals[row] = newRow;
      setVals(newVals);
    }
  });
};
const __namedExportsOrder = ["Simplenotest", "RelationColumn", "Minimal", "Smooth", "ManualControl", "Draggable", "IdealSize", "DynamicAddRemoveColumns", "GridSelectionOutOfRangeNoColumns", "ResizableColumns", "GridSelectionOutOfRangeLessColumnsThanSelection", "GridAddNewRows", "GridNoTrailingBlankRow", "MarkdownEdits", "CanEditBoolean", "SimpleEditable"];

/***/ }),

/***/ "./packages/core/src/data-editor/stories/utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cj": () => (/* binding */ getGridColumn),
/* harmony export */   "F9": () => (/* binding */ useMockDataGenerator),
/* harmony export */   "Gi": () => (/* binding */ PropName),
/* harmony export */   "OX": () => (/* binding */ MoreInfo),
/* harmony export */   "YE": () => (/* binding */ ColumnAddButton),
/* harmony export */   "c6": () => (/* binding */ ContentCache),
/* harmony export */   "dk": () => (/* binding */ Description),
/* harmony export */   "kZ": () => (/* binding */ lossyCopyData),
/* harmony export */   "m": () => (/* binding */ BeautifulWrapper),
/* harmony export */   "xl": () => (/* binding */ BeautifulStyle)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/faker/index.js");
/* harmony import */ var faker__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(faker__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/lodash/isArray.js");
/* harmony import */ var lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/common/support.ts");
/* harmony import */ var _common_browser_detect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./packages/core/src/common/browser-detect.ts");
/* harmony import */ var react_resize_detector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/react-resize-detector/build/index.esm.js");








faker__WEBPACK_IMPORTED_MODULE_1___default().seed(1337);

function isTruthy(x) {
  return x ? true : false;
}

function lossyCopyData(source, target) {
  const sourceData = source.data;

  if (typeof sourceData === typeof target.data) {
    return { ...target,
      data: sourceData
    };
  } else switch (target.kind) {
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Uri */ .p6.Uri:
      {
        var _sourceData$toString;

        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          return { ...target,
            data: sourceData[0]
          };
        }

        return { ...target,
          data: (_sourceData$toString = sourceData === null || sourceData === void 0 ? void 0 : sourceData.toString()) !== null && _sourceData$toString !== void 0 ? _sourceData$toString : ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Boolean */ .p6.Boolean:
      {
        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          return { ...target,
            data: sourceData[0] !== undefined
          };
        } else if (source.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Boolean */ .p6.Boolean) {
          return { ...target,
            data: source.data
          };
        }

        return { ...target,
          data: isTruthy(sourceData) ? true : false
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Image */ .p6.Image:
      {
        var _sourceData$toString2;

        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          return { ...target,
            data: [sourceData[0]]
          };
        }

        return { ...target,
          data: [(_sourceData$toString2 = sourceData === null || sourceData === void 0 ? void 0 : sourceData.toString()) !== null && _sourceData$toString2 !== void 0 ? _sourceData$toString2 : ""]
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Number */ .p6.Number:
      {
        return { ...target,
          data: 0
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text:
    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Markdown */ .p6.Markdown:
      {
        var _source$data$toString, _source$data;

        if (lodash_isArray_js__WEBPACK_IMPORTED_MODULE_2___default()(sourceData)) {
          var _sourceData$0$toStrin;

          return { ...target,
            data: (_sourceData$0$toStrin = sourceData[0].toString()) !== null && _sourceData$0$toStrin !== void 0 ? _sourceData$0$toStrin : ""
          };
        }

        return { ...target,
          data: (_source$data$toString = (_source$data = source.data) === null || _source$data === void 0 ? void 0 : _source$data.toString()) !== null && _source$data$toString !== void 0 ? _source$data$toString : ""
        };
      }

    case _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Custom */ .p6.Custom:
      {
        return target;
      }
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_4__/* .assertNever */ .vE)(target);
}
function getGridColumn(columnWithMock) {
  const {
    getContent,
    ...rest
  } = columnWithMock;
  return rest;
}
const ColumnAddButton = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)('div')({
  name: "ColumnAddButton",
  class: "c4uqbye"
});
const BeautifulStyle = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)('div')({
  name: "BeautifulStyle",
  class: "b1bsqg7n"
});
const PropName = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)('span')({
  name: "PropName",
  class: "piiq54i"
});
const Description = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)('p')({
  name: "Description",
  class: "d1k3yj19"
});
const MoreInfo = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)('p')({
  name: "MoreInfo",
  class: "m1j0dy02"
});
const BeautifulWrapper = p => {
  const {
    title,
    children,
    description,
    className
  } = p;
  const {
    ref,
    width,
    height
  } = (0,react_resize_detector__WEBPACK_IMPORTED_MODULE_6__/* .useResizeDetector */ .NB)();
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(BeautifulStyle, {
    className: className + (_common_browser_detect__WEBPACK_IMPORTED_MODULE_7__/* .browserIsFirefox.value */ .uC.value ? " firefox" : "")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", null, title), description, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "sizer"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "sizer-clip",
    ref: ref
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      position: "relative",
      width: width !== null && width !== void 0 ? width : 100,
      height: height !== null && height !== void 0 ? height : 100
    }
  }, children))));
};

function createTextColumnInfo(index, group) {
  return {
    title: `Column ${index}`,
    id: `Column ${index}`,
    group: group ? `Group ${Math.round(index / 3)}` : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const text = faker__WEBPACK_IMPORTED_MODULE_1___default().lorem.word();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
        data: text,
        displayData: text,
        allowOverlay: true,
        readonly: true
      };
    }
  };
}

function getResizableColumns(amount, group) {
  const defaultColumns = [{
    title: "First name",
    id: "First name",
    group: group ? "Name" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const firstName = faker__WEBPACK_IMPORTED_MODULE_1___default().name.firstName();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
        displayData: firstName,
        data: firstName,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Last name",
    id: "Last name",
    group: group ? "Name" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const lastName = faker__WEBPACK_IMPORTED_MODULE_1___default().name.lastName();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
        displayData: lastName,
        data: lastName,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Avatar",
    id: "Avatar",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage,
    hasMenu: false,
    getContent: () => {
      const n = Math.round(Math.random() * 100);
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Image */ .p6.Image,
        data: [`https://picsum.photos/id/${n}/900/900`],
        displayData: [`https://picsum.photos/id/${n}/40/40`],
        allowOverlay: true,
        allowAdd: false,
        readonly: true
      };
    }
  }, {
    title: "Email",
    id: "Email",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const email = faker__WEBPACK_IMPORTED_MODULE_1___default().internet.email();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
        displayData: email,
        data: email,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "Title",
    id: "Title",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
    hasMenu: false,
    getContent: () => {
      const company = faker__WEBPACK_IMPORTED_MODULE_1___default().name.jobTitle();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Text */ .p6.Text,
        displayData: company,
        data: company,
        allowOverlay: true,
        readonly: true
      };
    }
  }, {
    title: "More Info",
    id: "More Info",
    group: group ? "Info" : undefined,
    icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridColumnIcon.HeaderUri */ .PE.HeaderUri,
    hasMenu: false,
    getContent: () => {
      const url = faker__WEBPACK_IMPORTED_MODULE_1___default().internet.url();
      return {
        kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .GridCellKind.Uri */ .p6.Uri,
        displayData: url,
        data: url,
        allowOverlay: true,
        readonly: true
      };
    }
  }];

  if (amount < defaultColumns.length) {
    return defaultColumns.slice(0, amount);
  }

  const extraColumnsAmount = amount - defaultColumns.length;
  const extraColumns = [...new Array(extraColumnsAmount)].map((_, index) => createTextColumnInfo(index + defaultColumns.length, group));
  return [...defaultColumns, ...extraColumns];
}

class ContentCache {
  constructor() {
    this.cachedContent = new Map();
  }

  get(col, row) {
    const colCache = this.cachedContent.get(col);

    if (colCache === undefined) {
      return undefined;
    }

    return colCache.get(row);
  }

  set(col, row, value) {
    if (this.cachedContent.get(col) === undefined) {
      this.cachedContent.set(col, new Map());
    }

    const rowCache = this.cachedContent.get(col);
    rowCache.set(row, value);
  }

}
function useMockDataGenerator(numCols) {
  let readonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let group = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const cache = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new ContentCache());
  const [colsMap, setColsMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => getResizableColumns(numCols, group));
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    setColsMap(getResizableColumns(numCols, group));
  }, [group, numCols]);
  const onColumnResize = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((column, newSize) => {
    setColsMap(prevColsMap => {
      const index = prevColsMap.findIndex(ci => ci.title === column.title);
      const newArray = [...prevColsMap];
      newArray.splice(index, 1, { ...prevColsMap[index],
        width: newSize
      });
      return newArray;
    });
  }, []);
  const cols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return colsMap.map(getGridColumn);
  }, [colsMap]);
  const colsMapRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(colsMap);
  colsMapRef.current = colsMap;
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;
    let val = cache.current.get(col, row);

    if (val === undefined) {
      val = colsMapRef.current[col].getContent();

      if (!readonly && (0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .isTextEditableGridCell */ .f)(val)) {
        val = { ...val,
          readonly
        };
      }

      cache.current.set(col, row, val);
    }

    return val;
  }, [readonly]);
  const getCellsForSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(selection => {
    const result = [];

    for (let y = selection.y; y < selection.y + selection.height; y++) {
      const row = [];

      for (let x = selection.x; x < selection.x + selection.width; x++) {
        row.push(getCellContent([x, y]));
      }

      result.push(row);
    }

    return result;
  }, [getCellContent]);
  const setCellValueRaw = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref2, val) => {
    let [col, row] = _ref2;
    cache.current.set(col, row, val);
  }, []);
  const setCellValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref3, val) => {
    let [col, row] = _ref3;
    let current = cache.current.get(col, row);

    if (current === undefined) {
      current = colsMap[col].getContent();
    }

    if ((0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .isEditableGridCell */ .T9)(val) && (0,_data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .isEditableGridCell */ .T9)(current)) {
      const copied = lossyCopyData(val, current);
      cache.current.set(col, row, { ...copied,
        displayData: typeof copied.data === "string" ? copied.data : copied.displayData,
        lastUpdated: performance.now()
      });
    }
  }, [colsMap]);
  return {
    cols,
    getCellContent,
    onColumnResize,
    setCellValue,
    getCellsForSelection,
    setCellValueRaw
  };
}

__webpack_require__("./packages/core/src/data-editor/stories/utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-editor/stories/utils.tsx");

/***/ }),

/***/ "./packages/core/src/data-grid/cells/boolean-cell.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "D": () => (/* binding */ toggleBoolean),
/* harmony export */   "j": () => (/* binding */ booleanCellRenderer)
/* harmony export */ });
/* harmony import */ var _data_grid_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
/* harmony import */ var _data_grid_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");


function toggleBoolean(data) {
  return data !== true;
}
const booleanCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "false";
  },
  kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .GridCellKind.Boolean */ .p6.Boolean,
  needsHover: true,
  useLabel: false,
  needsHoverPosition: true,
  measure: () => 50,
  draw: a => (0,_data_grid_lib__WEBPACK_IMPORTED_MODULE_1__/* .drawBoolean */ .Df)(a, a.cell.data, (0,_data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .booleanCellIsEditable */ .kf)(a.cell)),
  onDelete: c => ({ ...c,
    data: false
  }),
  onClick: e => {
    const {
      cell,
      posX: x,
      posY: y,
      bounds
    } = e;

    if ((0,_data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .booleanCellIsEditable */ .kf)(cell) && Math.abs(x - bounds.width / 2) <= bounds.height / 3.4 && Math.abs(y - bounds.height / 2) <= bounds.height / 3.4) {
      return { ...cell,
        data: toggleBoolean(cell.data)
      };
    }

    return undefined;
  },
  onPaste: (toPaste, cell) => {
    let newVal = _data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .BooleanEmpty */ .qF;

    if (toPaste.toLowerCase() === "true") {
      newVal = true;
    } else if (toPaste.toLowerCase() === "false") {
      newVal = false;
    } else if (toPaste.toLowerCase() === "indeterminate") {
      newVal = _data_grid_types__WEBPACK_IMPORTED_MODULE_0__/* .BooleanIndeterminate */ .sd;
    }

    return newVal === cell.data ? undefined : { ...cell,
      data: newVal
    };
  }
};

/***/ }),

/***/ "./packages/core/src/data-grid/cells/index.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "L": () => (/* binding */ CellRenderers)
});

// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-types.ts
var data_grid_types = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
// EXTERNAL MODULE: ./packages/core/src/data-grid/cells/boolean-cell.tsx
var boolean_cell = __webpack_require__("./packages/core/src/data-grid/cells/boolean-cell.tsx");
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx

const BubblesOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "BubblesOverlayEditorStyle",
  class: "bvh4xn4"
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/bubbles-overlay-editor.tsx



const BubblesOverlayEditor = p => {
  const {
    bubbles
  } = p;
  return react.createElement(BubblesOverlayEditorStyle, null, bubbles.map((b, i) => react.createElement("div", {
    key: i,
    className: "boe-bubble"
  }, b)), react.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

/* harmony default export */ const bubbles_overlay_editor = (BubblesOverlayEditor);
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-lib.ts
var data_grid_lib = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/bubble-cell.tsx




const bubbleCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Bubble */.p6.Bubble,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => (0,data_grid_lib/* drawBubbles */.hp)(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react.createElement(bubbles_overlay_editor, {
      bubbles: value.data
    });
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx


const DrilldownOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "DrilldownOverlayEditorStyle",
  class: "d11gcyta"
});

const DrilldownOverlayEditor = p => {
  const {
    drilldowns
  } = p;
  return react.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => react.createElement("div", {
    key: i,
    className: "doe-bubble"
  }, d.img !== undefined && react.createElement("img", {
    src: d.img
  }), react.createElement("div", null, d.text))));
};

/* harmony default export */ const drilldown_overlay_editor = (DrilldownOverlayEditor);

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/drilldown-overlay-editor.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/drilldown-cell.tsx




const drilldownCellRenderer = {
  getAccessibilityString: c => c.data.map(d => d.text).join(", "),
  kind: data_grid_types/* GridCellKind.Drilldown */.p6.Drilldown,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== undefined ? 18 : 0), 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => (0,data_grid_lib/* drawDrilldownCell */.SP)(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react.createElement(drilldown_overlay_editor, {
      drilldowns: value.data
    });
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx

const ImageOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "ImageOverlayEditorStyle",
  class: "i1v3763o"
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor-style.tsx");
// EXTERNAL MODULE: ./node_modules/react-responsive-carousel/lib/js/index.js
var js = __webpack_require__("./node_modules/react-responsive-carousel/lib/js/index.js");
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/image-overlay-editor.tsx




const ImageOverlayEditor = p => {
  const {
    urls,
    canWrite,
    onEditClick,
    renderImage
  } = p;
  const filtered = urls.filter(u => u !== "");

  if (filtered.length === 0) {
    return null;
  }

  const allowMove = filtered.length > 1;
  return react.createElement(ImageOverlayEditorStyle, {
    "data-testid": "GDG-default-image-overlay-editor"
  }, react.createElement(js/* Carousel */.lr, {
    showArrows: allowMove,
    showThumbs: false,
    swipeable: allowMove,
    emulateTouch: allowMove,
    infiniteLoop: allowMove
  }, filtered.map(url => {
    var _renderImage;

    const innerContent = (_renderImage = renderImage === null || renderImage === void 0 ? void 0 : renderImage(url)) !== null && _renderImage !== void 0 ? _renderImage : react.createElement("img", {
      draggable: false,
      src: url
    });
    return react.createElement("div", {
      className: "centering-container",
      key: url
    }, innerContent);
  })), canWrite && onEditClick && react.createElement("button", {
    className: "edit-icon",
    onClick: onEditClick
  }, react.createElement(utils/* EditPencil */.Wy, null)));
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/image-cell.tsx




const imageCellRenderer = {
  getAccessibilityString: c => c.data.join(", "),
  kind: data_grid_types/* GridCellKind.Image */.p6.Image,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  draw: a => {
    var _a$cell$displayData;

    return (0,data_grid_lib/* drawImage */.AE)(a, (_a$cell$displayData = a.cell.displayData) !== null && _a$cell$displayData !== void 0 ? _a$cell$displayData : a.cell.data, a.cell.rounding);
  },
  measure: (_ctx, cell) => cell.data.length * 50,
  onDelete: c => ({ ...c,
    data: []
  }),
  provideEditor: () => p => {
    const {
      value,
      onFinishedEditing,
      imageEditorOverride
    } = p;
    const ImageEditor = imageEditorOverride !== null && imageEditorOverride !== void 0 ? imageEditorOverride : ImageOverlayEditor;
    return react.createElement(ImageEditor, {
      urls: value.data,
      canWrite: value.allowAdd,
      onCancel: onFinishedEditing,
      onChange: newImage => {
        onFinishedEditing({ ...value,
          data: [newImage]
        });
      }
    });
  },
  onPaste: (toPaste, cell) => {
    toPaste = toPaste.trim();
    const fragments = toPaste.split(",");
    const uris = fragments.map(f => {
      try {
        new URL(f);
        return f;
      } catch {
        return undefined;
      }
    }).filter(x => x !== undefined);
    if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i])) return undefined;
    return { ...cell,
      data: uris
    };
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/loading-cell.tsx

const loadingCellRenderer = {
  getAccessibilityString: () => "",
  kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: () => 120,
  draw: () => undefined,
  onPaste: () => undefined
};
// EXTERNAL MODULE: ./node_modules/marked/lib/marked.esm.js
var marked_esm = __webpack_require__("./node_modules/marked/lib/marked.esm.js");
;// CONCATENATED MODULE: ./packages/core/src/markdown-div/private/markdown-container.tsx

const MarkdownContainer = (0,styled/* default */.Z)('div')({
  name: "MarkdownContainer",
  class: "m1fme8sm"
});

__webpack_require__("./packages/core/src/markdown-div/private/markdown-container.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/markdown-div/private/markdown-container.tsx");
;// CONCATENATED MODULE: ./packages/core/src/markdown-div/markdown-div.tsx



class MarkdownDiv extends react.PureComponent {
  constructor() {
    super(...arguments);
    this.targetElement = null;

    this.containerRefHook = element => {
      this.targetElement = element;
      this.renderMarkdownIntoDiv();
    };
  }

  renderMarkdownIntoDiv() {
    const {
      targetElement,
      props
    } = this;
    if (targetElement === null) return;
    const {
      contents,
      createNode
    } = props;
    const innerHTML = (0,marked_esm/* marked */.TU)(contents);
    const childRange = document.createRange();
    childRange.selectNodeContents(targetElement);
    childRange.deleteContents();
    let newChild = createNode === null || createNode === void 0 ? void 0 : createNode(innerHTML);

    if (newChild === undefined) {
      const childDoc = document.createElement("template");
      childDoc.innerHTML = innerHTML;
      newChild = childDoc.content;
    }

    targetElement.append(newChild);
    const tags = targetElement.getElementsByTagName("a");

    for (const tag of tags) {
      tag.target = "_blank";
      tag.rel = "noreferrer noopener";
    }
  }

  render() {
    this.renderMarkdownIntoDiv();
    return react.createElement(MarkdownContainer, {
      ref: this.containerRefHook
    });
  }

}
;// CONCATENATED MODULE: ./packages/core/src/growing-entry/growing-entry-style.tsx

const InputBox = (0,styled/* default */.Z)('textarea')({
  name: "InputBox",
  class: "ifmjl02"
});
const ShadowBox = (0,styled/* default */.Z)('div')({
  name: "ShadowBox",
  class: "s71wzxx"
});
const GrowingEntryStyle = (0,styled/* default */.Z)('div')({
  name: "GrowingEntryStyle",
  class: "gecuh31"
});

__webpack_require__("./packages/core/src/growing-entry/growing-entry-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/growing-entry/growing-entry-style.tsx");
// EXTERNAL MODULE: ./packages/core/src/common/support.ts
var support = __webpack_require__("./packages/core/src/common/support.ts");
;// CONCATENATED MODULE: ./packages/core/src/growing-entry/growing-entry.tsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }




const GrowingEntry = props => {
  const {
    placeholder,
    value,
    onKeyDown,
    highlight,
    altNewline,
    validatedSelection,
    ...rest
  } = props;
  const {
    onChange,
    className
  } = rest;
  const inputRef = react.useRef(null);
  const useText = value !== null && value !== void 0 ? value : "";
  (0,support/* assert */.hu)(onChange !== undefined, "GrowingEntry must be a controlled input area");
  react.useEffect(() => {
    const ta = inputRef.current;
    if (ta === null) return;
    if (ta.disabled) return;
    const length = useText.toString().length;
    ta.focus();
    ta.setSelectionRange(highlight ? 0 : length, length);
  }, []);
  react.useLayoutEffect(() => {
    if (validatedSelection !== undefined) {
      var _inputRef$current;

      const range = typeof validatedSelection === "number" ? [validatedSelection, null] : validatedSelection;
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.setSelectionRange(range[0], range[1]);
    }
  }, [validatedSelection]);
  const onKeyDownInner = react.useCallback(e => {
    if (e.key === "Enter" && e.shiftKey && altNewline === true) {
      return;
    }

    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
  }, [altNewline, onKeyDown]);
  return react.createElement(GrowingEntryStyle, {
    className: "gdg-growing-entry"
  }, react.createElement(ShadowBox, {
    className: className
  }, useText + "\n"), react.createElement(InputBox, _extends({}, rest, {
    className: (className !== null && className !== void 0 ? className : "") + " gdg-input",
    ref: inputRef,
    onKeyDown: onKeyDownInner,
    value: useText,
    placeholder: placeholder,
    dir: "auto"
  })));
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx

const MarkdownOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "MarkdownOverlayEditorStyle",
  class: "m1bd3197",
  vars: {
    "m1bd3197-0": [p => p.targetWidth, "px"]
  }
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/markdown-overlay-editor.tsx





const MarkdownOverlayEditor = p => {
  const {
    markdown,
    onChange,
    forceEditMode,
    createNode,
    targetRect,
    readonly,
    onFinish,
    validatedSelection
  } = p;
  const [editMode, setEditMode] = react.useState(markdown === "" || forceEditMode);
  const onEditClick = react.useCallback(() => {
    setEditMode(e => !e);
  }, []);
  const addLeftPad = markdown ? "ml-6" : "";

  if (editMode) {
    return react.createElement(MarkdownOverlayEditorStyle, {
      targetWidth: targetRect.width - 20
    }, react.createElement(GrowingEntry, {
      autoFocus: true,
      highlight: false,
      validatedSelection: validatedSelection,
      value: markdown,
      onKeyDown: e => {
        if (e.key === "Enter") e.stopPropagation();
      },
      onChange: onChange
    }), react.createElement("div", {
      className: `edit-icon checkmark-hover ${addLeftPad}`,
      onClick: () => onFinish()
    }, react.createElement(utils/* Checkmark */.MC, null)));
  }

  return react.createElement(MarkdownOverlayEditorStyle, {
    targetWidth: targetRect.width
  }, react.createElement(MarkdownDiv, {
    contents: markdown,
    createNode: createNode
  }), !readonly && react.createElement(react.Fragment, null, react.createElement("div", {
    className: "spacer"
  }), react.createElement("div", {
    className: `edit-icon edit-hover ${addLeftPad}`,
    onClick: onEditClick
  }, react.createElement(utils/* EditPencil */.Wy, null))), react.createElement("textarea", {
    className: "md-edit-textarea gdg-input",
    autoFocus: true
  }));
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/markdown-cell.tsx




const markdownCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Markdown */.p6.Markdown,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  measure: (ctx, cell, t) => {
    const firstLine = cell.data.split("\n")[0];
    return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;
  },
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.data, a.cell.contentAlign),
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      target,
      onFinishedEditing,
      markdownDivCreateNode,
      forceEditMode,
      validatedSelection
    } = p;
    return react.createElement(MarkdownOverlayEditor, {
      onFinish: onFinishedEditing,
      targetRect: target,
      readonly: value.readonly === true,
      markdown: value.data,
      validatedSelection: validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      }),
      forceEditMode: forceEditMode,
      createNode: markdownDivCreateNode
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? undefined : { ...cell,
    data: toPaste
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/marker-cell.tsx


const markerCellRenderer = {
  getAccessibilityString: c => c.row.toString(),
  kind: data_grid_types/* InnerGridCellKind.Marker */.$o.Marker,
  needsHover: true,
  needsHoverPosition: false,
  drawPrep: data_grid_lib/* prepMarkerRowCell */.Z1,
  measure: () => 44,
  draw: a => (0,data_grid_lib/* drawMarkerRowCell */.ld)(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle),
  onClick: e => {
    const {
      bounds,
      cell,
      posX: x,
      posY: y
    } = e;
    const {
      width,
      height
    } = bounds;
    const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;
    const centerY = height / 2;

    if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {
      return { ...cell,
        checked: !cell.checked
      };
    }

    return undefined;
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/new-row-cell.tsx


const newRowCellRenderer = {
  getAccessibilityString: () => "",
  kind: data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow,
  needsHover: true,
  needsHoverPosition: false,
  measure: () => 200,
  draw: a => (0,data_grid_lib/* drawNewRowCell */.RM)(a, a.cell.hint, a.cell.icon),
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/number-cell.tsx



const NumberOverlayEditor = react.lazy(async () => await Promise.all(/* import() */[__webpack_require__.e(333), __webpack_require__.e(987)]).then(__webpack_require__.bind(__webpack_require__, "./packages/core/src/data-grid-overlay-editor/private/number-overlay-editor.tsx")));
const numberCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Number */.p6.Number,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.displayData, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.displayData).width + 16,
  onDelete: c => ({ ...c,
    data: undefined
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react.createElement(react.Suspense, {
      fallback: null
    }, react.createElement(NumberOverlayEditor, {
      highlight: isHighlighted,
      disabled: value.readonly === true,
      value: value.data,
      validatedSelection: validatedSelection,
      onChange: x => {
        var _x$floatValue;

        return onChange({ ...value,
          data: Number.isNaN((_x$floatValue = x.floatValue) !== null && _x$floatValue !== void 0 ? _x$floatValue : 0) ? 0 : x.floatValue
        });
      }
    }));
  },
  onPaste: (toPaste, cell) => {
    const newNumber = Number.parseFloat(toPaste);
    if (Number.isNaN(newNumber) || cell.data === newNumber) return undefined;
    return { ...cell,
      data: newNumber
    };
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/protected-cell.tsx


const protectedCellRenderer = {
  getAccessibilityString: () => "",
  measure: () => 108,
  kind: data_grid_types/* GridCellKind.Protected */.p6.Protected,
  needsHover: false,
  needsHoverPosition: false,
  draw: data_grid_lib/* drawProtectedCell */.sr,
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/row-id-cell.tsx




const rowIDCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.RowID */.p6.RowID,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: (a, b) => (0,data_grid_lib/* prepTextCell */.k0)(a, b, a.theme.textLight),
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly !== false,
      value: value.data,
      validatedSelection: validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: () => undefined
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/text-cell.tsx




const textCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Text */.p6.Text,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  useLabel: true,
  draw: a => ((0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.displayData, a.cell.contentAlign, a.cell.allowWrapping, a.hyperWrapping), true),
  measure: (ctx, cell, t) => {
    const lines = cell.displayData.split("\n").slice(0, cell.allowWrapping === true ? undefined : 1);
    return Math.max(...lines.map(l => ctx.measureText(l).width + 2 * t.cellHorizontalPadding));
  },
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly === true,
      altNewline: true,
      value: value.data,
      validatedSelection: validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? undefined : { ...cell,
    data: toPaste
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx

const UriOverlayEditorStyle = (0,styled/* default */.Z)('div')({
  name: "UriOverlayEditorStyle",
  class: "uvnt6gu"
});

__webpack_require__("./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor-style.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-overlay-editor/private/uri-overlay-editor.tsx





const UriOverlayEditor = p => {
  const {
    uri,
    onChange,
    forceEditMode,
    readonly,
    validatedSelection
  } = p;
  const [editMode, setEditMode] = react.useState(uri === "" || forceEditMode);
  const onEditClick = react.useCallback(() => {
    setEditMode(true);
  }, []);

  if (editMode) {
    return react.createElement(GrowingEntry, {
      validatedSelection: validatedSelection,
      highlight: true,
      autoFocus: true,
      value: uri,
      onChange: onChange
    });
  }

  return react.createElement(UriOverlayEditorStyle, null, react.createElement("a", {
    className: "link-area",
    href: uri,
    target: "_blank",
    rel: "noopener noreferrer"
  }, uri), !readonly && react.createElement("div", {
    className: "edit-icon",
    onClick: onEditClick
  }, react.createElement(utils/* EditPencil */.Wy, null)), react.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

/* harmony default export */ const uri_overlay_editor = (UriOverlayEditor);
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/uri-cell.tsx




const uriCellRenderer = {
  getAccessibilityString: c => {
    var _c$data$toString, _c$data;

    return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";
  },
  kind: data_grid_types/* GridCellKind.Uri */.p6.Uri,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: data_grid_lib/* prepTextCell */.k0,
  draw: a => (0,data_grid_lib/* drawTextCell */.uN)(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      forceEditMode,
      validatedSelection
    } = p;
    return react.createElement(uri_overlay_editor, {
      forceEditMode: forceEditMode,
      uri: value.data,
      validatedSelection: validatedSelection,
      readonly: value.readonly === true,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? undefined : { ...cell,
    data: toPaste
  }
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/cells/index.ts














const CellRenderers = {
  [data_grid_types/* InnerGridCellKind.Marker */.$o.Marker]: markerCellRenderer,
  [data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow]: newRowCellRenderer,
  [data_grid_types/* GridCellKind.Boolean */.p6.Boolean]: boolean_cell/* booleanCellRenderer */.j,
  [data_grid_types/* GridCellKind.Bubble */.p6.Bubble]: bubbleCellRenderer,
  [data_grid_types/* GridCellKind.Drilldown */.p6.Drilldown]: drilldownCellRenderer,
  [data_grid_types/* GridCellKind.Image */.p6.Image]: imageCellRenderer,
  [data_grid_types/* GridCellKind.Loading */.p6.Loading]: loadingCellRenderer,
  [data_grid_types/* GridCellKind.Markdown */.p6.Markdown]: markdownCellRenderer,
  [data_grid_types/* GridCellKind.Number */.p6.Number]: numberCellRenderer,
  [data_grid_types/* GridCellKind.Protected */.p6.Protected]: protectedCellRenderer,
  [data_grid_types/* GridCellKind.RowID */.p6.RowID]: rowIDCellRenderer,
  [data_grid_types/* GridCellKind.Text */.p6.Text]: textCellRenderer,
  [data_grid_types/* GridCellKind.Uri */.p6.Uri]: uriCellRenderer
};

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid-lib.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AE": () => (/* binding */ drawImage),
/* harmony export */   "Df": () => (/* binding */ drawBoolean),
/* harmony export */   "G6": () => (/* binding */ getStickyWidth),
/* harmony export */   "H1": () => (/* binding */ cellIsInRange),
/* harmony export */   "NZ": () => (/* binding */ useMappedColumns),
/* harmony export */   "PU": () => (/* binding */ isGroupEqual),
/* harmony export */   "RM": () => (/* binding */ drawNewRowCell),
/* harmony export */   "SP": () => (/* binding */ drawDrilldownCell),
/* harmony export */   "Sb": () => (/* binding */ cellIsSelected),
/* harmony export */   "Ve": () => (/* binding */ computeBounds),
/* harmony export */   "Z1": () => (/* binding */ prepMarkerRowCell),
/* harmony export */   "_n": () => (/* binding */ drawWithLastUpdate),
/* harmony export */   "_u": () => (/* binding */ drawCheckbox),
/* harmony export */   "aX": () => (/* binding */ getMiddleCenterBias),
/* harmony export */   "hp": () => (/* binding */ drawBubbles),
/* harmony export */   "ih": () => (/* binding */ getEffectiveColumns),
/* harmony export */   "k0": () => (/* binding */ prepTextCell),
/* harmony export */   "ld": () => (/* binding */ drawMarkerRowCell),
/* harmony export */   "oK": () => (/* binding */ getColumnIndexForX),
/* harmony export */   "pV": () => (/* binding */ getRowIndexForY),
/* harmony export */   "sr": () => (/* binding */ drawProtectedCell),
/* harmony export */   "uN": () => (/* binding */ drawTextCell),
/* harmony export */   "zu": () => (/* binding */ roundedPoly)
/* harmony export */ });
/* unused harmony exports measureTextCached, drawTextCellExternal, deprepMarkerRowCell */
/* harmony import */ var _data_grid_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/common/utils.tsx");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _common_support__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/common/support.ts");
/* harmony import */ var canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/canvas-hypertxt/dist/js/index.js");





function useMappedColumns(columns, freezeColumns) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => columns.map((c, i) => ({ ...c,
    sourceIndex: i,
    sticky: i < freezeColumns
  })), [columns, freezeColumns]);
}
function isGroupEqual(left, right) {
  return (left !== null && left !== void 0 ? left : "") === (right !== null && right !== void 0 ? right : "");
}
function cellIsSelected(location, cell, selection) {
  if ((selection === null || selection === void 0 ? void 0 : selection.current) === undefined) return false;
  const [col, row] = selection.current.cell;
  const [cellCol, cellRow] = location;
  if (cellRow !== row) return false;

  if (cell.span === undefined) {
    return col === cellCol;
  }

  return col >= cell.span[0] && col <= cell.span[1];
}

function cellIsInRect(location, cell, rect) {
  const startX = rect.x;
  const endX = rect.x + rect.width - 1;
  const startY = rect.y;
  const endY = rect.y + rect.height - 1;
  const [cellCol, cellRow] = location;
  if (cellRow < startY || cellRow > endY) return false;

  if (cell.span === undefined) {
    return cellCol >= startX && cellCol <= endX;
  }

  const [spanStart, spanEnd] = cell.span;
  return spanStart >= startX && spanStart <= endX || spanEnd >= startX && spanStart <= endX || spanStart < startX && spanEnd > endX;
}

function cellIsInRange(location, cell, selection) {
  let result = 0;
  if (selection.current === undefined) return result;
  if (cellIsInRect(location, cell, selection.current.range)) result++;

  for (const r of selection.current.rangeStack) {
    if (cellIsInRect(location, cell, r)) {
      result++;
    }
  }

  return result;
}

function remapForDnDState(columns, dndState) {
  let mappedCols = columns;

  if (dndState !== undefined) {
    let writable = [...columns];
    const temp = mappedCols[dndState.src];

    if (dndState.src > dndState.dest) {
      writable.splice(dndState.src, 1);
      writable.splice(dndState.dest, 0, temp);
    } else {
      writable.splice(dndState.dest + 1, 0, temp);
      writable.splice(dndState.src, 1);
    }

    writable = writable.map((c, i) => ({ ...c,
      sticky: columns[i].sticky
    }));
    mappedCols = writable;
  }

  return mappedCols;
}

function getStickyWidth(columns, dndState) {
  let result = 0;
  const remapped = remapForDnDState(columns, dndState);

  for (let i = 0; i < remapped.length; i++) {
    const c = remapped[i];
    if (c.sticky) result += c.width;else break;
  }

  return result;
}
function getEffectiveColumns(columns, cellXOffset, width, dndState, tx) {
  const mappedCols = remapForDnDState(columns, dndState);
  const sticky = [];

  for (const c of mappedCols) {
    if (c.sticky) {
      sticky.push(c);
    } else {
      break;
    }
  }

  if (sticky.length > 0) {
    for (const c of sticky) {
      width -= c.width;
    }
  }

  let endIndex = cellXOffset;
  let curX = tx !== null && tx !== void 0 ? tx : 0;

  while (curX <= width && endIndex < mappedCols.length) {
    curX += mappedCols[endIndex].width;
    endIndex++;
  }

  for (let i = cellXOffset; i < endIndex; i++) {
    const c = mappedCols[i];

    if (!c.sticky) {
      sticky.push(c);
    }
  }

  return sticky;
}
function getColumnIndexForX(targetX, effectiveColumns, translateX) {
  let x = 0;

  for (const c of effectiveColumns) {
    const cx = c.sticky ? x : x + (translateX !== null && translateX !== void 0 ? translateX : 0);

    if (targetX <= cx + c.width) {
      return c.sourceIndex;
    }

    x += c.width;
  }

  return -1;
}
function getRowIndexForY(targetY, height, hasGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, lastRowSticky) {
  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (hasGroups && targetY <= groupHeaderHeight) return -2;
  if (targetY <= totalHeaderHeight) return -1;
  const lastRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows - 1);

  if (lastRowSticky && targetY > height - lastRowHeight) {
    return rows - 1;
  }

  const effectiveRows = rows - (lastRowSticky ? 1 : 0);
  const ty = targetY - (translateY !== null && translateY !== void 0 ? translateY : 0);

  if (typeof rowHeight === "number") {
    const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;
    if (target >= effectiveRows) return undefined;
    return target;
  } else {
    let curY = totalHeaderHeight;

    for (let i = cellYOffset; i < effectiveRows; i++) {
      const rh = rowHeight(i);
      if (ty <= curY + rh) return i;
      curY += rh;
    }

    return undefined;
  }
}
let metricsSize = 0;
let metricsCache = {};
const isSSR = typeof window === "undefined";

async function clearCacheOnLoad() {
  var _document, _document$fonts;

  if (isSSR || ((_document = document) === null || _document === void 0 ? void 0 : (_document$fonts = _document.fonts) === null || _document$fonts === void 0 ? void 0 : _document$fonts.ready) === undefined) return;
  await document.fonts.ready;
  metricsSize = 0;
  metricsCache = {};
  (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__/* .clearCache */ .L)();
}

void clearCacheOnLoad();

function makeCacheKey(s, ctx, baseline, font) {
  return `${s}_${font !== null && font !== void 0 ? font : ctx.font}_${baseline}`;
}

function measureTextCached(s, ctx, font) {
  const key = makeCacheKey(s, ctx, "middle", font);
  let metrics = metricsCache[key];

  if (metrics === undefined) {
    metrics = ctx.measureText(s);
    metricsCache[key] = metrics;
    metricsSize++;
  }

  if (metricsSize > 10000) {
    metricsCache = {};
    metricsSize = 0;
  }

  return metrics;
}
function getMiddleCenterBias(ctx, font) {
  if (typeof font !== "string") {
    font = `${font.baseFontStyle} ${font.fontFamily}`;
  }

  return getMiddleCenterBiasInner(ctx, font);
}

function loadMetric(ctx, baseline) {
  const sample = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  ctx.save();
  ctx.textBaseline = baseline;
  const result = ctx.measureText(sample);
  ctx.restore();
  return result;
}

const biasCache = [];

function getMiddleCenterBiasInner(ctx, font) {
  for (const x of biasCache) {
    if (x.key === font) return x.val;
  }

  const alphabeticMetrics = loadMetric(ctx, "alphabetic");
  const middleMetrics = loadMetric(ctx, "middle");
  const bias = -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) + alphabeticMetrics.actualBoundingBoxAscent / 2;
  biasCache.push({
    key: font,
    val: bias
  });
  return bias;
}

function drawWithLastUpdate(args, lastUpdate, frameTime, lastPrep, draw) {
  const {
    ctx,
    rect,
    theme
  } = args;
  let progress = Number.MAX_SAFE_INTEGER;
  const animTime = 500;

  if (lastUpdate !== undefined) {
    progress = frameTime - lastUpdate;

    if (progress < animTime) {
      const fade = 1 - progress / animTime;
      ctx.globalAlpha = fade;
      ctx.fillStyle = theme.bgSearchResult;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
      ctx.globalAlpha = 1;

      if (lastPrep !== undefined) {
        lastPrep.fillStyle = theme.bgSearchResult;
      }
    }
  }

  draw();
  return progress < animTime;
}
function prepTextCell(args, lastPrep, overrideColor) {
  const {
    ctx,
    theme
  } = args;
  const result = lastPrep !== null && lastPrep !== void 0 ? lastPrep : {};
  const newFill = overrideColor !== null && overrideColor !== void 0 ? overrideColor : theme.textDark;

  if (newFill !== result.fillStyle) {
    ctx.fillStyle = newFill;
    result.fillStyle = newFill;
  }

  return result;
}
function drawTextCellExternal(args, data, contentAlign) {
  const {
    rect,
    ctx,
    theme
  } = args;
  ctx.fillStyle = theme.textDark;
  drawTextCell({
    ctx: ctx,
    rect,
    theme: theme
  }, data, contentAlign);
}

function drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign) {
  if (contentAlign === "right") {
    ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);
  } else if (contentAlign === "center") {
    ctx.fillText(data, x + w / 2, y + h / 2 + bias);
  } else {
    ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);
  }
}

function drawTextCell(args, data, contentAlign, allowWrapping, hyperWrapping) {
  var _allowWrapping;

  const {
    ctx,
    rect,
    theme
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  allowWrapping = (_allowWrapping = allowWrapping) !== null && _allowWrapping !== void 0 ? _allowWrapping : false;

  if (!allowWrapping) {
    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }

    const max = w / 4;

    if (data.length > max) {
      data = data.slice(0, max);
    }
  }

  const bias = getMiddleCenterBias(ctx, theme);
  const isRtl = (0,_common_utils__WEBPACK_IMPORTED_MODULE_2__/* .direction */ .o7)(data) === "rtl";

  if (contentAlign === undefined && isRtl) {
    contentAlign = "right";
  }

  if (isRtl) {
    ctx.direction = "rtl";
  }

  if (data.length > 0) {
    let changed = false;

    if (contentAlign === "right") {
      ctx.textAlign = "right";
      changed = true;
    } else if (contentAlign !== undefined && contentAlign !== "left") {
      ctx.textAlign = contentAlign;
      changed = true;
    }

    if (!allowWrapping) {
      drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);
    } else {
      const fontStyle = `${theme.fontFamily} ${theme.baseFontStyle}`;
      const split = (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__/* .split */ .V)(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping !== null && hyperWrapping !== void 0 ? hyperWrapping : false);
      const textMetrics = measureTextCached("ABCi09jgqpy", ctx, fontStyle);
      const emHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
      const lineHeight = theme.lineHeight * emHeight;
      const actualHeight = emHeight + lineHeight * (split.length - 1);
      const mustClip = actualHeight + theme.cellVerticalPadding > h;

      if (mustClip) {
        ctx.save();
        ctx.rect(x, y, w, h);
        ctx.clip();
      }

      const optimalY = y + h / 2 - actualHeight / 2;
      let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);

      for (const line of split) {
        drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);
        drawY += lineHeight;
        if (drawY > y + h) break;
      }

      if (mustClip) {
        ctx.restore();
      }
    }

    if (changed) {
      ctx.textAlign = "start";
    }

    if (isRtl) {
      ctx.direction = "inherit";
    }
  }
}
function drawNewRowCell(args, data, icon) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme,
    spriteManager
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  ctx.beginPath();
  ctx.globalAlpha = hoverAmount;
  ctx.rect(x, y, w, h);
  ctx.fillStyle = theme.bgHeaderHovered;
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.beginPath();
  const alwaysShowIcon = data !== "";
  let textX = 0;

  if (icon !== undefined) {
    const padding = 8;
    const size = h - padding;
    const px = x + padding / 2;
    const py = y + padding / 2;
    spriteManager.drawSprite(icon, "normal", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);
    textX = size;
  } else {
    textX = 24;
    const finalLineSize = 12;
    const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;
    const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;
    const padPlus = theme.cellHorizontalPadding + 4;

    if (lineSize > 0) {
      ctx.moveTo(x + padPlus + xTranslate, y + h / 2);
      ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);
      ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);
      ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);
      ctx.lineWidth = 2;
      ctx.strokeStyle = theme.bgIconHeader;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }

  ctx.fillStyle = theme.textMedium;
  ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + getMiddleCenterBias(ctx, theme));
  ctx.beginPath();
}
function drawCheckbox(ctx, theme, checked, x, y, width, height, highlighted) {
  let hoverX = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : -20;
  let hoverY = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : -20;
  const centerX = x + width / 2;
  const centerY = y + height / 2;
  const checkBoxWidth = height / 1.89;
  const emptyCheckBoxWidth = height / 2;
  const hoverHelper = height / 3.4;
  const hovered = Math.abs(hoverX - width / 2) < hoverHelper && Math.abs(hoverY - height / 2) < hoverHelper;
  const rectBordRadius = 4;
  const posHelperChecked = height / 4.25;
  const posHelperEmpty = height / 4;
  const posHelperInter = height / 8.5;

  switch (checked) {
    case true:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);
        ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperChecked + height / 9.31, centerY - posHelperChecked + height / 4.33);
        ctx.lineTo(centerX - posHelperChecked + height / 5.33, centerY - posHelperChecked + height / 3.17);
        ctx.lineTo(centerX - posHelperChecked + height / 2.83, centerY - posHelperChecked + height / 7.16);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    case _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanEmpty */ .qF:
    case false:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - posHelperEmpty, centerY - posHelperEmpty, emptyCheckBoxWidth, emptyCheckBoxWidth, rectBordRadius);
        ctx.lineWidth = 1;
        ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;
        ctx.stroke();
        break;
      }

    case _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanIndeterminate */ .sd:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - posHelperEmpty, centerY - posHelperEmpty, emptyCheckBoxWidth, emptyCheckBoxWidth, rectBordRadius);
        ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperInter, centerY);
        ctx.lineTo(centerX + posHelperInter, centerY);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    default:
      (0,_common_support__WEBPACK_IMPORTED_MODULE_4__/* .assertNever */ .vE)(checked);
  }
}
function prepMarkerRowCell(args, lastPrep) {
  const {
    ctx,
    theme
  } = args;
  const newFont = `9px ${theme.fontFamily}`;
  const result = lastPrep !== null && lastPrep !== void 0 ? lastPrep : {};

  if ((result === null || result === void 0 ? void 0 : result.font) !== newFont) {
    ctx.font = newFont;
    result.font = newFont;
  }

  result.deprep = deprepMarkerRowCell;
  ctx.textAlign = "center";
  return result;
}
function deprepMarkerRowCell(args) {
  const {
    ctx
  } = args;
  ctx.textAlign = "start";
}
function drawMarkerRowCell(args, index, checked, markerKind, drawHandle) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme
  } = args;
  const {
    x,
    y,
    width,
    height
  } = rect;
  const checkedboxAlpha = checked ? 1 : hoverAmount;

  if (markerKind !== "number" && checkedboxAlpha > 0) {
    ctx.globalAlpha = checkedboxAlpha;
    const offsetAmount = 7 * (checked ? hoverAmount : 1);
    drawCheckbox(ctx, theme, checked, drawHandle ? x + offsetAmount : x, y, drawHandle ? width - offsetAmount : width, height, true);

    if (drawHandle) {
      ctx.globalAlpha = hoverAmount;
      ctx.beginPath();

      for (const xOffset of [3, 6]) {
        for (const yOffset of [-5, -1, 3]) {
          ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);
        }
      }

      ctx.fillStyle = theme.textLight;
      ctx.fill();
      ctx.beginPath();
    }

    ctx.globalAlpha = 1;
  }

  if (markerKind === "number" || markerKind === "both" && !checked) {
    const text = index.toString();
    const start = x + width / 2;

    if (markerKind === "both" && hoverAmount !== 0) {
      ctx.globalAlpha = 1 - hoverAmount;
    }

    ctx.fillStyle = theme.textLight;
    ctx.fillText(text, start, y + height / 2 + getMiddleCenterBias(ctx, `9px ${theme.fontFamily}`));

    if (hoverAmount !== 0) {
      ctx.globalAlpha = 1;
    }
  }
}
function drawProtectedCell(args) {
  const {
    ctx,
    theme,
    rect
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  ctx.beginPath();
  const radius = 2.5;
  let xStart = x + theme.cellHorizontalPadding + radius;
  const center = y + h / 2;
  const p = Math.cos((0,_common_utils__WEBPACK_IMPORTED_MODULE_2__/* .degreesToRadians */ .Ht)(30)) * radius;
  const q = Math.sin((0,_common_utils__WEBPACK_IMPORTED_MODULE_2__/* .degreesToRadians */ .Ht)(30)) * radius;

  for (let i = 0; i < 12; i++) {
    ctx.moveTo(xStart, center - radius);
    ctx.lineTo(xStart, center + radius);
    ctx.moveTo(xStart + p, center - q);
    ctx.lineTo(xStart - p, center + q);
    ctx.moveTo(xStart - p, center - q);
    ctx.lineTo(xStart + p, center + q);
    xStart += 8;
  }

  ctx.lineWidth = 1.1;
  ctx.lineCap = "square";
  ctx.strokeStyle = theme.textLight;
  ctx.stroke();
}

function roundedRect(ctx, x, y, width, height, radius) {
  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }

  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}

function drawBoolean(args, data, canEdit) {
  if (!canEdit && data === _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanEmpty */ .qF) {
    return;
  }

  const {
    ctx,
    hoverAmount,
    theme,
    rect,
    highlighted,
    hoverX,
    hoverY
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const hoverEffect = 0.35;
  let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;

  if (data === _data_grid_types__WEBPACK_IMPORTED_MODULE_3__/* .BooleanEmpty */ .qF) {
    alpha *= hoverAmount;
  }

  if (alpha === 0) {
    return;
  }

  ctx.globalAlpha = alpha;
  drawCheckbox(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY);
  ctx.globalAlpha = 1;
}
const itemMargin = 4;
function drawBubbles(args, data) {
  const {
    rect,
    theme,
    ctx,
    highlighted
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const bubbleHeight = 20;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const renderBoxes = [];

  for (const s of data) {
    if (renderX > x + w) break;
    const textWidth = measureTextCached(s, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;
    renderBoxes.push({
      x: renderX,
      width: textWidth
    });
    renderX += textWidth + bubblePad * 2 + bubbleMargin;
  }

  ctx.beginPath();

  for (const rectInfo of renderBoxes) {
    roundedRect(ctx, rectInfo.x, y + (h - bubbleHeight) / 2, rectInfo.width + bubblePad * 2, bubbleHeight, bubbleHeight / 2);
  }

  ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;
  ctx.fill();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}
const drilldownCache = {};

function getAndCacheDrilldownBorder(bgCell, border) {
  const dpr = Math.ceil(window.devicePixelRatio);
  const targetHeight = 24;
  const shadowBlur = 5;
  const middleWidth = 4;
  const innerHeight = (targetHeight + shadowBlur * 2) * dpr;
  const innerWidth = innerHeight + middleWidth * dpr;
  const sideWidth = innerHeight / 2;
  const key = `${bgCell},${border},${dpr}`;

  if (drilldownCache[key] !== undefined) {
    return {
      el: drilldownCache[key],
      height: innerHeight,
      width: innerWidth,
      middleWidth: middleWidth * dpr,
      sideWidth
    };
  }

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (ctx === null) return null;
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  ctx.scale(dpr, dpr);
  drilldownCache[key] = canvas;
  ctx.beginPath();
  roundedRect(ctx, shadowBlur, shadowBlur, targetHeight + middleWidth, targetHeight, 6);
  ctx.shadowColor = "rgba(24, 25, 34, 0.4)";
  ctx.shadowBlur = 1;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowColor = "rgba(24, 25, 34, 0.3)";
  ctx.shadowOffsetY = 1;
  ctx.shadowBlur = 5;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  ctx.shadowBlur = 0;
  ctx.beginPath();
  roundedRect(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetHeight + middleWidth, targetHeight, 6);
  ctx.strokeStyle = border;
  ctx.lineWidth = 1;
  ctx.stroke();
  return {
    el: canvas,
    height: innerHeight,
    width: innerWidth,
    sideWidth,
    middleWidth: middleWidth * dpr
  };
}

function drawDrilldownCell(args, data) {
  const {
    rect,
    theme,
    ctx,
    imageLoader,
    col,
    row
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const bubbleHeight = 24;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder);
  const renderBoxes = [];

  for (const el of data) {
    if (renderX > x + w) break;
    const textWidth = measureTextCached(el.text, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;
    let imgWidth = 0;

    if (el.img !== undefined) {
      const img = imageLoader.loadOrGetImage(el.img, col, row);

      if (img !== undefined) {
        imgWidth = bubbleHeight - 8 + 4;
      }
    }

    const renderWidth = textWidth + imgWidth + bubblePad * 2;
    renderBoxes.push({
      x: renderX,
      width: renderWidth
    });
    renderX += renderWidth + bubbleMargin;
  }

  if (tileMap !== null) {
    const {
      el,
      height,
      middleWidth,
      sideWidth,
      width
    } = tileMap;

    for (const rectInfo of renderBoxes) {
      const rx = Math.floor(rectInfo.x);
      const rw = Math.floor(rectInfo.width);
      ctx.imageSmoothingEnabled = false;
      const maxSideWidth = Math.min(17, rw / 2 + 5);
      ctx.drawImage(el, 0, 0, sideWidth, height, rx - 5, y + h / 2 - 17, maxSideWidth, 34);
      if (rectInfo.width > 24) ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + 12, y + h / 2 - 17, rw - 24, 34);
      ctx.drawImage(el, width - sideWidth, 0, sideWidth, height, rx + rw - (maxSideWidth - 5), y + h / 2 - 17, maxSideWidth, 34);
      ctx.imageSmoothingEnabled = true;
    }
  }

  ctx.beginPath();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    const d = data[i];
    let drawX = rectInfo.x + bubblePad;

    if (d.img !== undefined) {
      const img = imageLoader.loadOrGetImage(d.img, col, row);

      if (img !== undefined) {
        const imgSize = bubbleHeight - 8;
        let srcX = 0;
        let srcY = 0;
        let srcWidth = img.width;
        let srcHeight = img.height;

        if (srcWidth > srcHeight) {
          srcX += (srcWidth - srcHeight) / 2;
          srcWidth = srcHeight;
        } else if (srcHeight > srcWidth) {
          srcY += (srcHeight - srcWidth) / 2;
          srcHeight = srcWidth;
        }

        ctx.beginPath();
        roundedRect(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, 3);
        ctx.save();
        ctx.clip();
        ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);
        ctx.restore();
        drawX += imgSize + 4;
      }
    }

    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(d.text, drawX, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}
function drawImage(args, data) {
  let rounding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
  const {
    rect,
    col,
    row,
    theme,
    ctx,
    imageLoader
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  let drawX = x + theme.cellHorizontalPadding;

  for (const i of data) {
    if (i.length === 0) continue;
    const img = imageLoader.loadOrGetImage(i, col, row);

    if (img !== undefined) {
      const imgHeight = h - theme.cellVerticalPadding * 2;
      const imgWidth = img.width * (imgHeight / img.height);

      if (rounding > 0) {
        roundedRect(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);
        ctx.save();
        ctx.clip();
      }

      ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);

      if (rounding > 0) {
        ctx.restore();
      }

      drawX += imgWidth + itemMargin;
    }
  }
}
function roundedPoly(ctx, points, radiusAll) {
  const asVec = function (p, pp) {
    const vx = pp.x - p.x;
    const vy = pp.y - p.y;
    const vlen = Math.sqrt(vx * vx + vy * vy);
    const vnx = vx / vlen;
    const vny = vy / vlen;
    return {
      x: vx,
      y: pp.y - p.y,
      len: vlen,
      nx: vnx,
      ny: vny,
      ang: Math.atan2(vny, vnx)
    };
  };

  let radius;
  const len = points.length;
  let p1 = points[len - 1];

  for (let i = 0; i < len; i++) {
    let p2 = points[i % len];
    const p3 = points[(i + 1) % len];
    const v1 = asVec(p2, p1);
    const v2 = asVec(p2, p3);
    const sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);
    let radDirection = 1;
    let drawDirection = false;

    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }

    radius = p2.radius !== undefined ? p2.radius : radiusAll;
    const halfAngle = angle / 2;
    let lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    let cRadius;

    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }

    let x = p2.x + v2.nx * lenOut;
    let y = p2.y + v2.ny * lenOut;
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    p1 = p2;
    p2 = p3;
  }

  ctx.closePath();
}
function computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight) {
  const result = {
    x: 0,
    y: totalHeaderHeight + translateY,
    width: 0,
    height: 0
  };
  const headerHeight = totalHeaderHeight - groupHeaderHeight;

  if (col >= freezeColumns) {
    const dir = cellXOffset > col ? -1 : 1;
    const freezeWidth = getStickyWidth(mappedColumns);
    result.x += freezeWidth + translateX;

    for (let i = cellXOffset; i !== col; i += dir) {
      result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;
    }
  } else {
    for (let i = 0; i < col; i++) {
      result.x += mappedColumns[i].width;
    }
  }

  result.width = mappedColumns[col].width + 1;

  if (row === -1) {
    result.y = groupHeaderHeight;
    result.height = headerHeight;
  } else if (row === -2) {
    result.y = 0;
    result.height = groupHeaderHeight;
    let start = col;
    const group = mappedColumns[col].group;
    const sticky = mappedColumns[col].sticky;

    while (start > 0 && isGroupEqual(mappedColumns[start - 1].group, group) && mappedColumns[start - 1].sticky === sticky) {
      const c = mappedColumns[start - 1];
      result.x -= c.width;
      result.width += c.width;
      start--;
    }

    let end = col;

    while (end + 1 < mappedColumns.length && isGroupEqual(mappedColumns[end + 1].group, group) && mappedColumns[end + 1].sticky === sticky) {
      const c = mappedColumns[end + 1];
      result.width += c.width;
      end++;
    }

    if (!sticky) {
      const freezeWidth = getStickyWidth(mappedColumns);
      const clip = result.x - freezeWidth;

      if (clip < 0) {
        result.x -= clip;
        result.width += clip;
      }

      if (result.x + result.width > width) {
        result.width = width - result.x;
      }
    }
  } else if (lastRowSticky && row === rows - 1) {
    const stickyHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(row);
    result.y = height - stickyHeight;
    result.height = stickyHeight;
  } else {
    const dir = cellYOffset > row ? -1 : 1;

    if (typeof rowHeight === "number") {
      const delta = row - cellYOffset;
      result.y += delta * rowHeight;
    } else {
      for (let r = cellYOffset; r !== row; r += dir) {
        result.y += rowHeight(r) * dir;
      }
    }

    result.height = (typeof rowHeight === "number" ? rowHeight : rowHeight(row)) + 1;
  }

  return result;
}

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid-types.ts":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$o": () => (/* binding */ InnerGridCellKind),
/* harmony export */   "DP": () => (/* binding */ isObjectEditorCallbackResult),
/* harmony export */   "EV": () => (/* binding */ CompactSelection),
/* harmony export */   "Gf": () => (/* binding */ headerCellCheckboxPrefix),
/* harmony export */   "PE": () => (/* binding */ GridColumnIcon),
/* harmony export */   "Qo": () => (/* binding */ isReadWriteCell),
/* harmony export */   "Sq": () => (/* binding */ isSizedGridColumn),
/* harmony export */   "T9": () => (/* binding */ isEditableGridCell),
/* harmony export */   "Xv": () => (/* binding */ outOfBoundsKind),
/* harmony export */   "YK": () => (/* binding */ headerCellUnheckedMarker),
/* harmony export */   "aZ": () => (/* binding */ headerKind),
/* harmony export */   "f": () => (/* binding */ isTextEditableGridCell),
/* harmony export */   "iJ": () => (/* binding */ headerCellIndeterminateMarker),
/* harmony export */   "kf": () => (/* binding */ booleanCellIsEditable),
/* harmony export */   "mr": () => (/* binding */ groupHeaderKind),
/* harmony export */   "p6": () => (/* binding */ GridCellKind),
/* harmony export */   "qF": () => (/* binding */ BooleanEmpty),
/* harmony export */   "qT": () => (/* binding */ headerCellCheckedMarker),
/* harmony export */   "rL": () => (/* binding */ resolveCellsThunk),
/* harmony export */   "rs": () => (/* binding */ isInnerOnlyCell),
/* harmony export */   "sd": () => (/* binding */ BooleanIndeterminate)
/* harmony export */ });
/* harmony import */ var _common_support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/common/support.ts");
/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/lodash/has.js");
/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_has_js__WEBPACK_IMPORTED_MODULE_0__);
let _Symbol$iterator;



const BooleanEmpty = null;
const BooleanIndeterminate = undefined;
const headerKind = "header";
const groupHeaderKind = "group-header";
const outOfBoundsKind = "out-of-bounds";
let GridCellKind;

(function (GridCellKind) {
  GridCellKind["Uri"] = "uri";
  GridCellKind["Text"] = "text";
  GridCellKind["Image"] = "image";
  GridCellKind["RowID"] = "row-id";
  GridCellKind["Number"] = "number";
  GridCellKind["Bubble"] = "bubble";
  GridCellKind["Boolean"] = "boolean";
  GridCellKind["Loading"] = "loading";
  GridCellKind["Markdown"] = "markdown";
  GridCellKind["Drilldown"] = "drilldown";
  GridCellKind["Protected"] = "protected";
  GridCellKind["Custom"] = "custom";
})(GridCellKind || (GridCellKind = {}));

let GridColumnIcon;

(function (GridColumnIcon) {
  GridColumnIcon["HeaderRowID"] = "headerRowID";
  GridColumnIcon["HeaderCode"] = "headerCode";
  GridColumnIcon["HeaderNumber"] = "headerNumber";
  GridColumnIcon["HeaderString"] = "headerString";
  GridColumnIcon["HeaderBoolean"] = "headerBoolean";
  GridColumnIcon["HeaderAudioUri"] = "headerAudioUri";
  GridColumnIcon["HeaderVideoUri"] = "headerVideoUri";
  GridColumnIcon["HeaderEmoji"] = "headerEmoji";
  GridColumnIcon["HeaderImage"] = "headerImage";
  GridColumnIcon["HeaderUri"] = "headerUri";
  GridColumnIcon["HeaderPhone"] = "headerPhone";
  GridColumnIcon["HeaderMarkdown"] = "headerMarkdown";
  GridColumnIcon["HeaderDate"] = "headerDate";
  GridColumnIcon["HeaderTime"] = "headerTime";
  GridColumnIcon["HeaderEmail"] = "headerEmail";
  GridColumnIcon["HeaderReference"] = "headerReference";
  GridColumnIcon["HeaderIfThenElse"] = "headerIfThenElse";
  GridColumnIcon["HeaderSingleValue"] = "headerSingleValue";
  GridColumnIcon["HeaderLookup"] = "headerLookup";
  GridColumnIcon["HeaderTextTemplate"] = "headerTextTemplate";
  GridColumnIcon["HeaderMath"] = "headerMath";
  GridColumnIcon["HeaderRollup"] = "headerRollup";
  GridColumnIcon["HeaderJoinStrings"] = "headerJoinStrings";
  GridColumnIcon["HeaderSplitString"] = "headerSplitString";
  GridColumnIcon["HeaderGeoDistance"] = "headerGeoDistance";
  GridColumnIcon["HeaderArray"] = "headerArray";
  GridColumnIcon["RowOwnerOverlay"] = "rowOwnerOverlay";
  GridColumnIcon["ProtectedColumnOverlay"] = "protectedColumnOverlay";
})(GridColumnIcon || (GridColumnIcon = {}));

const headerCellCheckboxPrefix = "___gdg_header_cell_";
const headerCellCheckedMarker = headerCellCheckboxPrefix + "checked";
const headerCellUnheckedMarker = headerCellCheckboxPrefix + "unchecked";
const headerCellIndeterminateMarker = headerCellCheckboxPrefix + "indeterminate";
function isSizedGridColumn(c) {
  return "width" in c && typeof c.width === "number";
}
async function resolveCellsThunk(thunk) {
  if (typeof thunk === "object") return thunk;
  return await thunk();
}
function isEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown) {
    return false;
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_1__/* .proveType */ .NG)(cell);
  return true;
}
function isTextEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown || cell.kind === GridCellKind.Boolean || cell.kind === GridCellKind.Image || cell.kind === GridCellKind.Custom) {
    return false;
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_1__/* .proveType */ .NG)(cell);
  return true;
}
function isInnerOnlyCell(cell) {
  return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;
}
function isReadWriteCell(cell) {
  if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image) return false;

  if (cell.kind === GridCellKind.Text || cell.kind === GridCellKind.Number || cell.kind === GridCellKind.Markdown || cell.kind === GridCellKind.Uri || cell.kind === GridCellKind.Custom || cell.kind === GridCellKind.Boolean) {
    return cell.readonly !== true;
  }

  (0,_common_support__WEBPACK_IMPORTED_MODULE_1__/* .assertNever */ .vE)(cell);
}
function isObjectEditorCallbackResult(obj) {
  return lodash_has_js__WEBPACK_IMPORTED_MODULE_0___default()(obj, "editor");
}
function booleanCellIsEditable(cell) {
  var _cell$readonly;

  return !((_cell$readonly = cell.readonly) !== null && _cell$readonly !== void 0 ? _cell$readonly : false);
}
let InnerGridCellKind;

(function (InnerGridCellKind) {
  InnerGridCellKind["NewRow"] = "new-row";
  InnerGridCellKind["Marker"] = "marker";
})(InnerGridCellKind || (InnerGridCellKind = {}));

function mergeRanges(input) {
  if (input.length === 0) {
    return [];
  }

  const ranges = [...input];
  const stack = [];
  ranges.sort(function (a, b) {
    return a[0] - b[0];
  });
  stack.push([...ranges[0]]);

  for (const range of ranges.slice(1)) {
    const top = stack[stack.length - 1];

    if (top[1] < range[0]) {
      stack.push([...range]);
    } else if (top[1] < range[1]) {
      top[1] = range[1];
    }
  }

  return stack;
}

let emptyCompactSelection;
_Symbol$iterator = Symbol.iterator;
class CompactSelection {
  constructor(items) {
    this.items = items;

    this.offset = amount => {
      if (amount === 0) return this;
      const newItems = this.items.map(x => [x[0] + amount, x[1] + amount]);
      return new CompactSelection(newItems);
    };

    this.add = selection => {
      const slice = typeof selection === "number" ? [selection, selection + 1] : selection;
      const newItems = mergeRanges([...this.items, slice]);
      return new CompactSelection(newItems);
    };

    this.remove = selection => {
      const items = [...this.items];
      const selMin = typeof selection === "number" ? selection : selection[0];
      const selMax = typeof selection === "number" ? selection + 1 : selection[1];

      for (const [i, slice] of items.entries()) {
        const [start, end] = slice;

        if (start <= selMax && selMin <= end) {
          const toAdd = [];

          if (start < selMin) {
            toAdd.push([start, selMin]);
          }

          if (selMax < end) {
            toAdd.push([selMax, end]);
          }

          items.splice(i, 1, ...toAdd);
        }
      }

      return new CompactSelection(items);
    };

    this.first = () => {
      if (this.items.length === 0) return undefined;
      return this.items[0][0];
    };

    this.last = () => {
      if (this.items.length === 0) return undefined;
      return this.items.slice(-1)[0][1] - 1;
    };

    this.hasIndex = index => {
      for (let i = 0; i < this.items.length; i++) {
        const [start, end] = this.items[i];
        if (index >= start && index < end) return true;
      }

      return false;
    };

    this.hasAll = index => {
      for (let x = index[0]; x < index[1]; x++) {
        if (!this.hasIndex(x)) return false;
      }

      return true;
    };

    this.some = predicate => {
      for (const i of this) {
        if (predicate(i)) return true;
      }

      return false;
    };

    this.equals = other => {
      if (other === this) return true;
      if (other.items.length !== this.items.length) return false;

      for (let i = 0; i < this.items.length; i++) {
        const left = other.items[i];
        const right = this.items[i];
        if (left[0] !== right[0] || left[1] !== right[1]) return false;
      }

      return true;
    };

    this.toArray = () => {
      const result = [];

      for (const [start, end] of this.items) {
        for (let x = start; x < end; x++) {
          result.push(x);
        }
      }

      return result;
    };
  }

  get length() {
    let len = 0;

    for (const [start, end] of this.items) {
      len += end - start;
    }

    return len;
  }

  *[_Symbol$iterator]() {
    for (const [start, end] of this.items) {
      for (let x = start; x < end; x++) {
        yield x;
      }
    }
  }

}

CompactSelection.empty = () => {
  var _emptyCompactSelectio;

  return (_emptyCompactSelectio = emptyCompactSelection) !== null && _emptyCompactSelectio !== void 0 ? _emptyCompactSelectio : emptyCompactSelection = new CompactSelection([]);
};

CompactSelection.fromSingleSelection = selection => {
  return CompactSelection.empty().add(selection);
};

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectedCellnotest": () => (/* binding */ SelectedCellnotest),
/* harmony export */   "SelectedColumnnotest": () => (/* binding */ SelectedColumnnotest),
/* harmony export */   "SelectedRownotest": () => (/* binding */ SelectedRownotest),
/* harmony export */   "Simplenotest": () => (/* binding */ Simplenotest),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _data_grid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-grid/data-grid.tsx");
/* harmony import */ var _data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _common_styles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/common/styles.ts");
/* harmony import */ var _cells__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/cells/index.ts");






/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Subcomponents/DataGrid",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .BuilderThemeWrapper */ .j, {
    width: 1800,
    height: 1000
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    style: {
      position: "relative"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))))]
});
const emptyGridSelection = {
  columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
  rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
  current: undefined
};

const getCellRenderer = cell => {
  if (cell.kind === _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Custom */ .p6.Custom) return undefined;
  return _cells__WEBPACK_IMPORTED_MODULE_3__/* .CellRenderers */ .L[cell.kind];
};

function Simplenotest() {
  let x = 0;
  const [y, setY] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let handle = 0;

    const cb = () => {
      setY(cv => cv + 1);
      handle = window.requestAnimationFrame(cb);
    };

    cb();
    return () => window.cancelAnimationFrame(handle);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    isFocused: true,
    cellYOffset: y,
    isFilling: false,
    onMouseMove: () => undefined,
    groupHeaderHeight: 0,
    accessibilityHeight: 50,
    enableGroups: false,
    selection: emptyGridSelection,
    rows: 100000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref => {
      let [col, row] = _ref;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
}
function SelectedCellnotest() {
  let x = 0;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    isFocused: true,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    onMouseMove: () => undefined,
    accessibilityHeight: 50,
    isFilling: false,
    cellYOffset: 0,
    groupHeaderHeight: 34,
    enableGroups: false,
    rows: 1000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref2 => {
      let [col, row] = _ref2;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    selection: {
      current: {
        cell: [2, 2],
        range: {
          x: 2,
          y: 2,
          width: 1,
          height: 1
        },
        rangeStack: []
      },
      columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
      rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
}
function SelectedRownotest() {
  let x = 0;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    onMouseMove: () => undefined,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    cellYOffset: 0,
    isFocused: true,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    groupHeaderHeight: 34,
    accessibilityHeight: 50,
    isFilling: false,
    enableGroups: false,
    rows: 1000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref3 => {
      let [col, row] = _ref3;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    selection: {
      current: undefined,
      rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.fromSingleSelection */ .EV.fromSingleSelection([2, 4]),
      columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
}
const SelectedColumnnotest = () => {
  let x = 0;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    onMouseMove: () => undefined,
    width: 1800,
    height: 1000,
    cellXOffset: 0,
    cellYOffset: 0,
    isFocused: true,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseMoveRaw: () => undefined,
    onMouseUp: () => undefined,
    smoothScrollX: undefined,
    smoothScrollY: undefined,
    allowResize: undefined,
    canvasRef: undefined,
    disabledRows: undefined,
    eventTargetRef: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    translateX: undefined,
    translateY: undefined,
    dragAndDropState: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    accessibilityHeight: 50,
    isFilling: false,
    groupHeaderHeight: 34,
    enableGroups: false,
    rows: 1000,
    headerHeight: 44,
    rowHeight: 34,
    columns: ["One", "Two", "Three", "Four", "Five", "Six", "Seven"].map(t => ({
      title: t,
      width: 122 + (x += 10)
    })),
    getCellContent: _ref4 => {
      let [col, row] = _ref4;
      return {
        kind: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
        displayData: `${col},${row} Testing things that are way too long`,
        data: `${col},${row} Testing things that are way too long`,
        allowOverlay: false,
        owned: true
      };
    },
    selection: {
      current: undefined,
      rows: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
      columns: _data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.fromSingleSelection */ .EV.fromSingleSelection([2, 4])
    },
    freezeColumns: 0,
    firstColAccessible: true,
    verticalBorder: () => true,
    trailingRowType: "none",
    isResizing: false,
    isDragging: false,
    theme: (0,_common_styles__WEBPACK_IMPORTED_MODULE_5__/* .getDataEditorTheme */ .Zu)()
  });
};
const __namedExportsOrder = ["Simplenotest", "SelectedCellnotest", "SelectedRownotest", "SelectedColumnnotest"];

/***/ }),

/***/ "./packages/core/src/data-grid/data-grid.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ data_grid)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/lodash/throttle.js
var throttle = __webpack_require__("./node_modules/lodash/throttle.js");
var throttle_default = /*#__PURE__*/__webpack_require__.n(throttle);
;// CONCATENATED MODULE: ./packages/core/src/common/image-window-loader.ts

const rowShift = 1 << 16;
const imgPool = [];

function packColRowToNumber(col, row) {
  return row * rowShift + col;
}

function unpackCol(packed) {
  return packed % rowShift;
}

function unpackRow(packed, col) {
  return (packed - col) / rowShift;
}

function unpackNumberToColRow(packed) {
  const col = unpackCol(packed);
  const row = unpackRow(packed, col);
  return [col, row];
}

class ImageWindowLoaderImpl {
  constructor() {
    this.imageLoaded = () => undefined;

    this.loadedLocations = [];
    this.visibleWindow = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this.freezeCols = 0;

    this.isInWindow = packed => {
      const col = unpackCol(packed);
      const row = unpackRow(packed, col);
      const w = this.visibleWindow;
      if (col < this.freezeCols && row >= w.y && row <= w.y + w.height) return true;
      return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;
    };

    this.cache = {};
    this.sendLoaded = throttle_default()(() => {
      this.imageLoaded(this.loadedLocations);
      this.loadedLocations = [];
    }, 20);

    this.clearOutOfWindow = () => {
      const keys = Object.keys(this.cache);

      for (const key of keys) {
        const obj = this.cache[key];
        let keep = false;

        for (let j = 0; j < obj.cells.length; j++) {
          const packed = obj.cells[j];

          if (this.isInWindow(packed)) {
            keep = true;
            break;
          }
        }

        if (keep) {
          obj.cells = obj.cells.filter(this.isInWindow);
        } else {
          obj.cancel();
          delete this.cache[key];
        }
      }
    };
  }

  setCallback(imageLoaded) {
    this.imageLoaded = imageLoaded;
  }

  setWindow(newWindow, freezeCols) {
    if (this.visibleWindow.x === newWindow.x && this.visibleWindow.y === newWindow.y && this.visibleWindow.width === newWindow.width && this.visibleWindow.height === newWindow.height && this.freezeCols === freezeCols) return;
    this.visibleWindow = newWindow;
    this.freezeCols = freezeCols;
    this.clearOutOfWindow();
  }

  loadImage(url, col, row, key) {
    var _imgPool$pop;

    let loaded = false;
    const img = (_imgPool$pop = imgPool.pop()) !== null && _imgPool$pop !== void 0 ? _imgPool$pop : new Image();
    let canceled = false;
    const result = {
      img: undefined,
      cells: [packColRowToNumber(col, row)],
      url,
      cancel: () => {
        if (canceled) return;
        canceled = true;

        if (imgPool.length < 12) {
          imgPool.unshift(img);
        } else if (!loaded) {
          img.src = "";
        }
      }
    };
    const loadPromise = new Promise(r => img.addEventListener("load", () => r(null)));
    requestAnimationFrame(async () => {
      try {
        img.src = url;
        await loadPromise;
        await img.decode();
        const toWrite = this.cache[key];

        if (toWrite !== undefined && !canceled) {
          toWrite.img = img;

          for (const packed of toWrite.cells) {
            this.loadedLocations.push(unpackNumberToColRow(packed));
          }

          loaded = true;
          this.sendLoaded();
        }
      } catch {
        result.cancel();
      }
    });
    this.cache[key] = result;
  }

  loadOrGetImage(url, col, row) {
    const key = url;
    const current = this.cache[key];

    if (current !== undefined) {
      const packed = packColRowToNumber(col, row);

      if (!current.cells.includes(packed)) {
        current.cells.push(packed);
      }

      return current.img;
    } else {
      this.loadImage(url, col, row, key);
    }

    return undefined;
  }

}

/* harmony default export */ const image_window_loader = (ImageWindowLoaderImpl);
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-lib.ts
var data_grid_lib = __webpack_require__("./packages/core/src/data-grid/data-grid-lib.ts");
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid-types.ts
var data_grid_types = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/sprites.ts
const iconHead = `<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">`;

const headerRowID = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/><path d="M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z" fill="${fg}"/></svg>`;
};

const headerCode = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="4" fill="${bg}"/><path d="m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z" fill="${fg}"/></svg>`;
};

const headerNumber = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z" fill="${fg}"/>
  </svg>`;
};

const headerString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z" fill="${fg}"/>
</svg>`;
};

const headerBoolean = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path
        d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
        fill="${bg}"
    />
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z"
        fill="${fg}"
    />
</svg>`;
};

const headerUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
<path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z" fill="${fg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z" fill="${fg}"/>
</svg>
  `;
};

const renameIcon = props => {
  const bg = props.bgColor;
  return `${iconHead}
    <path stroke="${bg}" stroke-width="2" d="M12 3v14"/>
    <path stroke="${bg}" stroke-width="2" stroke-linecap="round" d="M10 4h4m-4 12h4"/>
    <path d="M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z" fill="${bg}"/>
  </svg>
`;
};

const headerAudioUri = headerUri;

const headerVideoUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z" fill="${fg}"/>
</svg>`;
};

const headerEmoji = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z" fill="${fg}"/>
    <path d="M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z" fill="${fg}"/>
    <path d="M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
  </svg>`;
};

const headerImage = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path opacity=".5" fill-rule="evenodd" clip-rule="evenodd" d="M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z" fill="${fg}"/>
</svg>`;
};

const headerPhone = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path fill="${fg}" d="M3 3h14v14H3z"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z" fill="${bg}"/>
  </svg>`;
};

const headerMarkdown = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z" fill="${fg}"/>
  </svg>`;
};

const headerDate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z" fill="${fg}"/>
</svg>`;
};

const headerTime = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z" fill="${fg}"/>
    <path d="M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z" fill="${fg}"/>
  </svg>`;
};

const headerEmail = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z" fill="${fg}"/>
</svg>`;
};

const headerReference = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="8" width="10" height="8" rx="2" fill="${bg}"/>
    <rect x="8" y="4" width="10" height="8" rx="2" fill="${bg}"/>
    <path d="M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z" fill="${fg}"/>
  </svg>`;
};

const headerIfThenElse = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path fill="${fg}" d="M4 3h12v14H4z"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z" fill="${bg}"/>
</svg>`;
};

const headerSingleValue = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z" fill="${fg}"/>
  </svg>`;
};

const headerLookup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z" fill="${fg}"/>
  </svg>`;
};

const headerTextTemplate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z" fill="${fg}"/>
</svg>`;
};

const headerMath = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z" fill="${fg}"/>
  <path d="M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z" fill="${fg}"/>
</svg>`;
};

const headerRollup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z" fill="${fg}"/>
  </svg>`;
};

const headerJoinStrings = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z" fill="${fg}"/>
</svg>`;
};

const headerSplitString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z" fill="${fg}"/>
  </svg>`;
};

const headerGeoDistance = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z" fill="${fg}"/>
</svg>`;
};

const headerArray = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z" fill="${fg}"/>
</svg>`;
};

const rowOwnerOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>`;
};

const protectedColumnOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>
`;
};

const sprites = {
  headerRowID,
  headerNumber,
  headerCode,
  headerString,
  headerBoolean,
  headerAudioUri,
  headerVideoUri,
  headerEmoji,
  headerImage,
  headerUri,
  headerPhone,
  headerMarkdown,
  headerDate,
  headerTime,
  headerEmail,
  headerReference,
  headerIfThenElse,
  headerSingleValue,
  headerLookup,
  headerTextTemplate,
  headerMath,
  headerRollup,
  headerJoinStrings,
  headerSplitString,
  headerGeoDistance,
  headerArray,
  rowOwnerOverlay,
  protectedColumnOverlay,
  renameIcon
};
;// CONCATENATED MODULE: ./packages/core/src/data-grid/data-grid-sprites.ts


function getColors(variant, theme) {
  if (variant === "normal") {
    return [theme.bgIconHeader, theme.fgIconHeader];
  } else if (variant === "selected") {
    return ["white", theme.accentColor];
  } else {
    return [theme.accentColor, theme.bgHeader];
  }
}

class SpriteManager {
  constructor(headerIcons, onSettled) {
    this.onSettled = onSettled;
    this.spriteMap = new Map();
    this.headerIcons = void 0;
    this.inFlight = 0;
    this.headerIcons = { ...sprites,
      ...headerIcons
    };
  }

  drawSprite(sprite, variant, ctx, x, y, size, theme) {
    let alpha = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
    const [bgColor, fgColor] = getColors(variant, theme);
    const rSize = size * Math.ceil(window.devicePixelRatio);
    const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;
    let spriteCanvas = this.spriteMap.get(key);

    if (spriteCanvas === undefined) {
      const spriteCb = this.headerIcons[sprite];
      if (spriteCb === undefined) return;
      spriteCanvas = document.createElement("canvas");
      const spriteCtx = spriteCanvas.getContext("2d");
      if (spriteCtx === null) return;
      const imgSource = new Image();
      imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({
        fgColor,
        bgColor
      }))}`;
      this.spriteMap.set(key, spriteCanvas);
      const promise = imgSource.decode();
      if (promise === undefined) return;
      this.inFlight++;
      promise.then(() => {
        spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);
      }).finally(() => {
        this.inFlight--;

        if (this.inFlight === 0) {
          this.onSettled();
        }
      });
    } else {
      if (alpha < 1) {
        ctx.globalAlpha = alpha;
      }

      ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);

      if (alpha < 1) {
        ctx.globalAlpha = 1;
      }
    }
  }

}
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__("./node_modules/lodash/clamp.js");
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);
// EXTERNAL MODULE: ./node_modules/lodash/range.js
var lodash_range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(lodash_range);
// EXTERNAL MODULE: ./node_modules/lodash/groupBy.js
var groupBy = __webpack_require__("./node_modules/lodash/groupBy.js");
var groupBy_default = /*#__PURE__*/__webpack_require__.n(groupBy);
;// CONCATENATED MODULE: ./packages/core/src/data-grid/color-parser.ts
const cache = {};
let div = null;

function createDiv() {
  const d = document.createElement("div");
  d.style.opacity = "0";
  d.style.pointerEvents = "none";
  d.style.position = "fixed";
  document.body.append(d);
  return d;
}

function parseToRgba(color) {
  const normalizedColor = color.toLowerCase().trim();
  if (cache[normalizedColor] !== undefined) return cache[normalizedColor];
  div = div || createDiv();
  div.style.color = "#000";
  div.style.color = normalizedColor;
  const control = getComputedStyle(div).color;
  div.style.color = "#fff";
  div.style.color = normalizedColor;
  const computedColor = getComputedStyle(div).color;
  if (computedColor !== control) throw new Error("Could not parse color");
  const result = computedColor.replace(/[^\d.,]/g, "").split(",").map(Number.parseFloat);

  if (result.length < 4) {
    result.push(1);
  }

  cache[normalizedColor] = result;
  return result;
}
function withAlpha(color, alpha) {
  const [r, g, b] = parseToRgba(color);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
function blend(color, background) {
  if (background === undefined) return color;
  const [r, g, b, a] = parseToRgba(color);
  if (a === 1) return color;
  const [br, bg, bb, ba] = parseToRgba(background);
  const ao = a + ba * (1 - a);
  const ro = (a * r + ba * br * (1 - a)) / ao;
  const go = (a * g + ba * bg * (1 - a)) / ao;
  const bo = (a * b + ba * bb * (1 - a)) / ao;
  return `rgba(${ro}, ${go}, ${bo}, ${ao})`;
}
function interpolateColors(leftColor, rightColor, val) {
  if (val <= 0) return leftColor;
  if (val >= 1) return rightColor;
  const left = [...parseToRgba(leftColor)];
  left[0] = left[0] * left[3];
  left[1] = left[1] * left[3];
  left[2] = left[2] * left[3];
  const right = [...parseToRgba(rightColor)];
  right[0] = right[0] * right[3];
  right[1] = right[1] * right[3];
  right[2] = right[2] * right[3];
  const hScaler = val;
  const nScaler = 1 - val;
  const a = left[3] * nScaler + right[3] * hScaler;
  const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);
  const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);
  const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
// EXTERNAL MODULE: ./packages/core/src/common/support.ts
var support = __webpack_require__("./packages/core/src/common/support.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/data-grid-render.tsx





const loadingCell = {
  kind: data_grid_types/* GridCellKind.Loading */.p6.Loading,
  allowOverlay: false
};
function drawCell(ctx, row, cell, col, x, y, w, h, highlighted, theme, drawCustomCell, imageLoader, spriteManager, hoverAmount, hoverInfo, hyperWrapping, frameTime, lastPrep, enqueue, getCellRenderer) {
  let hoverX;
  let hoverY;

  if (hoverInfo !== undefined && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {
    hoverX = hoverInfo[1][0];
    hoverY = hoverInfo[1][1];
  }

  let result = undefined;
  const args = {
    ctx,
    theme,
    col,
    row,
    cell,
    rect: {
      x,
      y,
      width: w,
      height: h
    },
    highlighted,
    hoverAmount,
    hoverX,
    hoverY,
    imageLoader,
    spriteManager,
    hyperWrapping,
    requestAnimationFrame: () => {
      forceAnim = true;
    }
  };
  let forceAnim = false;
  const needsAnim = (0,data_grid_lib/* drawWithLastUpdate */._n)(args, cell.lastUpdated, frameTime, lastPrep, () => {
    const drawn = (0,data_grid_types/* isInnerOnlyCell */.rs)(cell) ? false : (drawCustomCell === null || drawCustomCell === void 0 ? void 0 : drawCustomCell(args)) === true;

    if (!drawn) {
      const r = getCellRenderer(cell);

      if (r !== undefined) {
        var _lastPrep, _r$drawPrep;

        if (((_lastPrep = lastPrep) === null || _lastPrep === void 0 ? void 0 : _lastPrep.renderer) !== r) {
          var _lastPrep2, _lastPrep2$deprep;

          (_lastPrep2 = lastPrep) === null || _lastPrep2 === void 0 ? void 0 : (_lastPrep2$deprep = _lastPrep2.deprep) === null || _lastPrep2$deprep === void 0 ? void 0 : _lastPrep2$deprep.call(_lastPrep2, args);
          lastPrep = undefined;
        }

        const partialPrepResult = (_r$drawPrep = r.drawPrep) === null || _r$drawPrep === void 0 ? void 0 : _r$drawPrep.call(r, args, lastPrep);
        r.draw(args, cell);
        result = {
          deprep: partialPrepResult === null || partialPrepResult === void 0 ? void 0 : partialPrepResult.deprep,
          fillStyle: partialPrepResult === null || partialPrepResult === void 0 ? void 0 : partialPrepResult.fillStyle,
          font: partialPrepResult === null || partialPrepResult === void 0 ? void 0 : partialPrepResult.font,
          renderer: r
        };
      }
    }
  });
  if (needsAnim || forceAnim) enqueue === null || enqueue === void 0 ? void 0 : enqueue([col, row]);
  return result;
}

function blitLastFrame(ctx, canvas, last, cellXOffset, cellYOffset, translateX, translateY, lastRowSticky, width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, getRowHeight, doubleBuffer) {
  const drawRegions = [];
  let blittedYOnly = false;
  ctx.imageSmoothingEnabled = false;
  const minY = Math.min(last.cellYOffset, cellYOffset);
  const maxY = Math.max(last.cellYOffset, cellYOffset);
  let deltaY = 0;

  if (typeof getRowHeight === "number") {
    deltaY += (maxY - minY) * getRowHeight;
  } else {
    for (let i = minY; i < maxY; i++) {
      deltaY += getRowHeight(i);
    }
  }

  if (cellYOffset > last.cellYOffset) {
    deltaY = -deltaY;
  }

  deltaY += translateY - last.translateY;
  const minX = Math.min(last.cellXOffset, cellXOffset);
  const maxX = Math.max(last.cellXOffset, cellXOffset);
  let deltaX = 0;

  for (let i = minX; i < maxX; i++) {
    deltaX += mappedColumns[i].width;
  }

  if (cellXOffset > last.cellXOffset) {
    deltaX = -deltaX;
  }

  deltaX += translateX - last.translateX;
  let stickyWidth = (0,data_grid_lib/* getStickyWidth */.G6)(effectiveCols);
  if (stickyWidth > 0) stickyWidth++;

  if (deltaX !== 0 && deltaY !== 0) {
    return {
      regions: [],
      yOnly: false
    };
  }

  const stickyRowHeight = lastRowSticky ? typeof getRowHeight === "number" ? getRowHeight : getRowHeight(rows - 1) : 0;
  const blitWidth = width - stickyWidth - Math.abs(deltaX);
  const blitHeight = height - totalHeaderHeight - stickyRowHeight - Math.abs(deltaY) - 1;

  if (blitWidth > 150 && blitHeight > 150) {
    blittedYOnly = deltaX === 0;
    const args = {
      sx: 0,
      sy: 0,
      sw: width * dpr,
      sh: height * dpr,
      dx: 0,
      dy: 0,
      dw: width * dpr,
      dh: height * dpr
    };

    if (deltaY > 0) {
      args.sy = (totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (deltaY + totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: totalHeaderHeight,
        width: width,
        height: deltaY + 1
      });
    } else if (deltaY < 0) {
      args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: height + deltaY - stickyRowHeight,
        width: width,
        height: -deltaY + stickyRowHeight
      });
    }

    if (deltaX > 0) {
      args.sx = stickyWidth * dpr;
      args.sw = blitWidth * dpr;
      args.dx = (deltaX + stickyWidth) * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: stickyWidth - 1,
        y: 0,
        width: deltaX + 2,
        height: height
      });
    } else if (deltaX < 0) {
      args.sx = (stickyWidth - deltaX) * dpr;
      args.sw = blitWidth * dpr;
      args.dx = stickyWidth * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: width + deltaX,
        y: 0,
        width: -deltaX,
        height: height
      });
    }

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    if (stickyWidth > 0 && deltaX !== 0 && deltaY === 0 && doubleBuffer) {
      ctx.drawImage(canvas, 0, 0, stickyWidth * dpr, height * dpr, 0, 0, stickyWidth * dpr, height * dpr);
    }

    ctx.drawImage(canvas, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);
    ctx.scale(dpr, dpr);
  }

  ctx.imageSmoothingEnabled = true;
  return {
    regions: drawRegions,
    yOnly: blittedYOnly
  };
}

function blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedIndex) {
  const drawRegions = [];

  if (cellXOffset !== last.cellXOffset || cellYOffset !== last.cellYOffset || translateX !== last.translateX || translateY !== last.translateY) {
    return drawRegions;
  }

  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {
    if (c.sourceIndex === resizedIndex) {
      const x = Math.max(drawX, clipX) + 1;
      drawRegions.push({
        x,
        y: 0,
        width: width - x,
        height
      });
      return true;
    }
  });
  return drawRegions;
}

function drawGridLines(ctx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme) {
  var _theme$horizontalBord;

  let verticalOnly = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : false;

  if (spans !== undefined) {
    ctx.beginPath();
    ctx.save();
    ctx.rect(0, 0, width, height);

    for (const span of spans) {
      ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);
    }

    ctx.clip("evenodd");
  }

  const hColor = (_theme$horizontalBord = theme.horizontalBorderColor) !== null && _theme$horizontalBord !== void 0 ? _theme$horizontalBord : theme.borderColor;
  const vColor = theme.borderColor;
  let minX = 0;
  let maxX = width;
  let minY = 0;
  let maxY = height;

  if (drawRegions !== undefined && drawRegions.length > 0) {
    minX = Number.MAX_SAFE_INTEGER;
    minY = Number.MAX_SAFE_INTEGER;
    maxX = Number.MIN_SAFE_INTEGER;
    maxY = Number.MIN_SAFE_INTEGER;

    for (const r of drawRegions) {
      minX = Math.min(minX, r.x - 1);
      maxX = Math.max(maxX, r.x + r.width + 1);
      minY = Math.min(minY, r.y - 1);
      maxY = Math.max(maxY, r.y + r.height + 1);
    }
  }

  const toDraw = [];
  ctx.beginPath();
  let x = 0.5;

  for (let index = 0; index < effectiveCols.length; index++) {
    const c = effectiveCols[index];
    if (c.width === 0) continue;
    x += c.width;
    const tx = c.sticky ? x : x + translateX;

    if (tx >= minX && tx <= maxX - 1 && verticalBorder(index + 1)) {
      toDraw.push({
        x1: tx,
        y1: Math.max(groupHeaderHeight, minY),
        x2: tx,
        y2: Math.min(height, maxY),
        color: vColor
      });
    }
  }

  const stickyHeight = getRowHeight(rows - 1);
  const stickyRowY = height - stickyHeight + 0.5;
  const lastRowSticky = trailingRowType === "sticky";

  if (lastRowSticky) {
    toDraw.push({
      x1: minX,
      y1: stickyRowY,
      x2: maxX,
      y2: stickyRowY,
      color: hColor
    });
  }

  if (verticalOnly !== true) {
    let y = totalHeaderHeight + 0.5;
    let row = cellYOffset;
    const target = lastRowSticky ? height - stickyHeight : height;

    while (y + translateY <= target) {
      const ty = y + translateY;

      if (ty >= minY && ty <= maxY - 1 && (!lastRowSticky || row !== rows - 1 || Math.abs(ty - stickyRowY) > 1)) {
        var _ref, _rowTheme$horizontalB;

        const rowTheme = getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row);
        toDraw.push({
          x1: minX,
          y1: ty,
          x2: maxX,
          y2: ty,
          color: (_ref = (_rowTheme$horizontalB = rowTheme === null || rowTheme === void 0 ? void 0 : rowTheme.horizontalBorderColor) !== null && _rowTheme$horizontalB !== void 0 ? _rowTheme$horizontalB : rowTheme === null || rowTheme === void 0 ? void 0 : rowTheme.borderColor) !== null && _ref !== void 0 ? _ref : hColor
        });
      }

      y += getRowHeight(row);
      row++;
    }
  }

  const groups = groupBy_default()(toDraw, line => line.color);

  for (const g of Object.keys(groups)) {
    ctx.strokeStyle = g;

    for (const line of groups[g]) {
      ctx.moveTo(line.x1, line.y1);
      ctx.lineTo(line.x2, line.y2);
    }

    ctx.stroke();
    ctx.beginPath();
  }

  if (spans !== undefined) {
    ctx.restore();
  }
}

function getActionBoundsForGroup(box, actions) {
  const result = [];
  let x = box.x + box.width - 26 * actions.length;
  const y = box.y + box.height / 2 - 13;
  const height = 26;
  const width = 26;

  for (let i = 0; i < actions.length; i++) {
    result.push({
      x,
      y,
      width,
      height
    });
    x += 26;
  }

  return result;
}
function pointInRect(rect, x, y) {
  return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
}

function drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, theme, spriteManager, _hoverValues, verticalBorder, getGroupDetails, damage) {
  var _hovered$;

  const xPad = 8;
  const [hCol, hRow] = (_hovered$ = hovered === null || hovered === void 0 ? void 0 : hovered[0]) !== null && _hovered$ !== void 0 ? _hovered$ : [];
  let finalX = 0;
  walkGroups(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {
    var _groupTheme$textGroup;

    if (damage !== undefined && !damage.some(d => d[1] === -2 && d[0] >= span[0] && d[0] <= span[1])) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip();
    const group = getGroupDetails(groupName);
    const groupTheme = (group === null || group === void 0 ? void 0 : group.overrideTheme) === undefined ? theme : { ...theme,
      ...group.overrideTheme
    };
    const isHovered = hRow === -2 && hCol !== undefined && hCol >= span[0] && hCol <= span[1];
    const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;

    if (fillColor !== theme.bgHeader) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }

    ctx.fillStyle = (_groupTheme$textGroup = groupTheme.textGroupHeader) !== null && _groupTheme$textGroup !== void 0 ? _groupTheme$textGroup : groupTheme.textHeader;

    if (group !== undefined) {
      let drawX = x;

      if (group.icon !== undefined) {
        spriteManager.drawSprite(group.icon, "normal", ctx, drawX + xPad, (groupHeaderHeight - 20) / 2, 20, groupTheme);
        drawX += 26;
      }

      ctx.fillText(group.name, drawX + xPad, groupHeaderHeight / 2 + (0,data_grid_lib/* getMiddleCenterBias */.aX)(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

      if (group.actions !== undefined && isHovered) {
        var _hovered$2;

        const actionBoxes = getActionBoundsForGroup({
          x,
          y,
          width: w,
          height: h
        }, group.actions);
        ctx.beginPath();
        const fadeStartX = actionBoxes[0].x - 10;
        const fadeWidth = x + w - fadeStartX;
        ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);
        const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);
        const trans = withAlpha(fillColor, 0);
        grad.addColorStop(0, trans);
        grad.addColorStop(10 / fadeWidth, fillColor);
        grad.addColorStop(1, fillColor);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 0.6;
        const [mouseX, mouseY] = (_hovered$2 = hovered === null || hovered === void 0 ? void 0 : hovered[1]) !== null && _hovered$2 !== void 0 ? _hovered$2 : [-1, -1];

        for (let i = 0; i < group.actions.length; i++) {
          const action = group.actions[i];
          const box = actionBoxes[i];
          const actionHovered = pointInRect(box, mouseX + x, mouseY);

          if (actionHovered) {
            ctx.globalAlpha = 1;
          }

          spriteManager.drawSprite(action.icon, "normal", ctx, box.x + box.width / 2 - 10, box.y + box.height / 2 - 10, 20, groupTheme);

          if (actionHovered) {
            ctx.globalAlpha = 0.6;
          }
        }

        ctx.globalAlpha = 1;
      }
    }

    if (x !== 0 && verticalBorder(span[0])) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, groupHeaderHeight);
      ctx.strokeStyle = theme.borderColor;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.restore();
    finalX = x + w;
  });
  ctx.beginPath();
  ctx.moveTo(finalX + 0.5, 0);
  ctx.lineTo(finalX + 0.5, groupHeaderHeight);
  ctx.moveTo(0, groupHeaderHeight + 0.5);
  ctx.lineTo(width, groupHeaderHeight + 0.5);
  ctx.strokeStyle = theme.borderColor;
  ctx.lineWidth = 1;
  ctx.stroke();
}

const menuButtonSize = 30;
function getHeaderMenuBounds(x, y, width, height) {
  return {
    x: x + width - menuButtonSize,
    y: Math.max(y, y + height / 2 - menuButtonSize / 2),
    width: menuButtonSize,
    height: Math.min(menuButtonSize, height)
  };
}
function drawHeader(ctx, x, y, width, height, c, selected, theme, isHovered, hasSelectedCell, hoverAmount, spriteManager, drawHeaderCallback, touchMode) {
  const isCheckboxHeader = c.title.startsWith(data_grid_types/* headerCellCheckboxPrefix */.Gf);
  const menuBounds = getHeaderMenuBounds(x, y, width, height);

  if (drawHeaderCallback !== undefined) {
    let passCol = c;

    if (isCheckboxHeader) {
      passCol = { ...c,
        title: ""
      };
    }

    if (drawHeaderCallback({
      ctx,
      theme,
      rect: {
        x,
        y,
        width,
        height
      },
      column: passCol,
      columnIndex: passCol.sourceIndex,
      isSelected: selected,
      hoverAmount,
      isHovered,
      hasSelectedCell,
      spriteManager,
      menuBounds
    })) {
      return;
    }
  }

  if (isCheckboxHeader) {
    let checked = undefined;
    if (c.title === data_grid_types/* headerCellCheckedMarker */.qT) checked = true;
    if (c.title === data_grid_types/* headerCellUnheckedMarker */.YK) checked = false;

    if (checked !== true) {
      ctx.globalAlpha = hoverAmount;
    }

    (0,data_grid_lib/* drawCheckbox */._u)(ctx, theme, checked, x, y, width, height, false, undefined, undefined);

    if (checked !== true) {
      ctx.globalAlpha = 1;
    }

    return;
  }

  const xPad = 8;
  const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;
  const shouldDrawMenu = c.hasMenu === true && (isHovered || touchMode && selected);
  let drawX = x + xPad;

  if (c.icon !== undefined) {
    let variant = selected ? "selected" : "normal";

    if (c.style === "highlight") {
      variant = selected ? "selected" : "special";
    }

    spriteManager.drawSprite(c.icon, variant, ctx, drawX, y + (height - 20) / 2, 20, theme);

    if (c.overlayIcon !== undefined) {
      spriteManager.drawSprite(c.overlayIcon, selected ? "selected" : "special", ctx, drawX + 9, y + ((height - 18) / 2 + 6), 18, theme);
    }

    drawX += 26;
  }

  if (shouldDrawMenu && c.hasMenu === true && width > 35) {
    const fadeWidth = 35;
    const fadeStart = width - fadeWidth;
    const fadeEnd = width - fadeWidth * 0.7;
    const fadeStartPercent = fadeStart / width;
    const fadeEndPercent = fadeEnd / width;
    const grad = ctx.createLinearGradient(x, 0, x + width, 0);
    const trans = withAlpha(fillStyle, 0);
    grad.addColorStop(0, fillStyle);
    grad.addColorStop(fadeStartPercent, fillStyle);
    grad.addColorStop(fadeEndPercent, trans);
    grad.addColorStop(1, trans);
    ctx.fillStyle = grad;
  } else {
    ctx.fillStyle = fillStyle;
  }

  ctx.fillText(c.title, drawX, y + height / 2 + (0,data_grid_lib/* getMiddleCenterBias */.aX)(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

  if (shouldDrawMenu && c.hasMenu === true) {
    ctx.beginPath();
    const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;
    const triangleY = menuBounds.y + menuBounds.height / 2 - 3;
    (0,data_grid_lib/* roundedPoly */.zu)(ctx, [{
      x: triangleX,
      y: triangleY
    }, {
      x: triangleX + 11,
      y: triangleY
    }, {
      x: triangleX + 5.5,
      y: triangleY + 6
    }], 1);
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }
}

function drawGridHeaders(ctx, effectiveCols, enableGroups, hovered, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode) {
  var _hovered$3;

  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (totalHeaderHeight <= 0) return;
  ctx.fillStyle = outerTheme.bgHeader;
  ctx.fillRect(0, 0, width, totalHeaderHeight);
  const [hCol, hRow] = (_hovered$3 = hovered === null || hovered === void 0 ? void 0 : hovered[0]) !== null && _hovered$3 !== void 0 ? _hovered$3 : [];
  const font = `${outerTheme.headerFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  walkColumns(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {
    var _c$group, _hoverValues$find$hov, _hoverValues$find;

    if (damage !== undefined && !damage.some(d => d[1] === -1 && d[0] === c.sourceIndex)) return;
    const diff = Math.max(0, clipX - x);
    ctx.save();
    ctx.beginPath();
    ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);
    ctx.clip();
    const groupTheme = getGroupDetails((_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : "").overrideTheme;
    const theme = c.themeOverride === undefined && groupTheme === undefined ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };

    if (theme.bgHeader !== outerTheme.bgHeader) {
      ctx.fillStyle = theme.bgHeader;
      ctx.fill();
    }

    const f = `${theme.headerFontStyle} ${theme.fontFamily}`;

    if (font !== f) {
      ctx.font = f;
    }

    const selected = selection.columns.hasIndex(c.sourceIndex);
    const noHover = dragAndDropState !== undefined || isResizing;
    const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;
    const hover = noHover ? 0 : (_hoverValues$find$hov = (_hoverValues$find = hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)) === null || _hoverValues$find === void 0 ? void 0 : _hoverValues$find.hoverAmount) !== null && _hoverValues$find$hov !== void 0 ? _hoverValues$find$hov : 0;
    const hasSelectedCell = (selection === null || selection === void 0 ? void 0 : selection.current) !== undefined && selection.current.cell[0] === c.sourceIndex;
    const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;
    const y = enableGroups ? groupHeaderHeight : 0;
    const xOffset = c.sourceIndex === 0 ? 0 : 1;

    if (selected) {
      ctx.fillStyle = bgFillStyle;
      ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);
    } else if (hasSelectedCell || hover > 0) {
      ctx.beginPath();
      ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);

      if (hasSelectedCell) {
        ctx.fillStyle = theme.bgHeaderHasFocus;
        ctx.fill();
      }

      if (hover > 0) {
        ctx.globalAlpha = hover;
        ctx.fillStyle = theme.bgHeaderHovered;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    drawHeader(ctx, x, y, c.width, headerHeight, c, selected, theme, hoveredBoolean, hasSelectedCell, hover, spriteManager, drawHeaderCallback, touchMode);
    ctx.restore();
  });

  if (enableGroups) {
    drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage);
  }
}

function intersectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
  return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;
}

function clipDamage(ctx, effectiveColumns, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, includeCells) {
  if (damage === undefined || damage.length === 0) return;
  const stickyRowHeight = trailingRowType === "sticky" ? getRowHeight(rows - 1) : 0;
  ctx.beginPath();
  walkGroups(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {
    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[1] === -2 && d[0] >= span[0] && d[0] <= span[1]) {
        ctx.rect(x, y, w, h);
        break;
      }
    }
  });
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    const diff = Math.max(0, clipX - drawX);
    const finalX = drawX + diff + 1;
    const finalWidth = c.width - diff - 1;

    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[0] === c.sourceIndex && (d[1] === -1 || d[1] === undefined)) {
        ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);
        break;
      }
    }

    if (!includeCells) return;
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      let isDamaged = false;

      for (let i = 0; i < damage.length; i++) {
        const d = damage[i];

        if (d[0] === c.sourceIndex && d[1] === row) {
          isDamaged = true;
          break;
        }
      }

      if (isDamaged) {
        const top = drawY + 1;
        const bottom = isSticky ? top + rh - 1 : Math.min(top + rh - 1, height - stickyRowHeight);
        const h = bottom - top;

        if (h > 0) {
          ctx.rect(finalX, top, finalWidth, h);
        }
      }
    });
  });
  ctx.clip();
}

function getSpanBounds(span, cellX, cellY, cellW, cellH, column, allColumns) {
  var _allColumns$find$sour, _allColumns$find;

  const [startCol, endCol] = span;
  let frozenRect;
  let contentRect;
  const firstNonSticky = (_allColumns$find$sour = (_allColumns$find = allColumns.find(x => !x.sticky)) === null || _allColumns$find === void 0 ? void 0 : _allColumns$find.sourceIndex) !== null && _allColumns$find$sour !== void 0 ? _allColumns$find$sour : 0;

  if (endCol > firstNonSticky) {
    const renderFromCol = Math.max(startCol, firstNonSticky);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= endCol; x++) {
      tempW += allColumns[x].width;
    }

    contentRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  if (firstNonSticky > startCol) {
    const renderToCol = Math.min(endCol, firstNonSticky - 1);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= startCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {
      tempW += allColumns[x].width;
    }

    frozenRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  return [frozenRect, contentRect];
}

function drawCells(ctx, effectiveColumns, allColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, outerTheme, enqueue, getCellRenderer) {
  var _damage$length;

  let toDraw = (_damage$length = damage === null || damage === void 0 ? void 0 : damage.length) !== null && _damage$length !== void 0 ? _damage$length : Number.MAX_SAFE_INTEGER;
  const frameTime = performance.now();
  let font = `${outerTheme.baseFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  let result;
  const handledSpans = new Set();
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawStartY, clipX, startRow) => {
    var _c$group2;

    const diff = Math.max(0, clipX - drawX);
    const colDrawX = drawX + diff;
    const colDrawY = totalHeaderHeight + 1;
    const colWidth = c.width - diff;
    const colHeight = height - totalHeaderHeight - 1;

    if (drawRegions.length > 0) {
      let found = false;

      for (let i = 0; i < drawRegions.length; i++) {
        const dr = drawRegions[i];

        if (intersectRect(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {
          found = true;
          break;
        }
      }

      if (!found) return;
    }

    const reclip = () => {
      ctx.save();
      ctx.beginPath();
      ctx.rect(colDrawX, colDrawY, colWidth, colHeight);
      ctx.clip();
    };

    const colSelected = selection.columns.hasIndex(c.sourceIndex);
    const groupTheme = getGroupDetails((_c$group2 = c.group) !== null && _c$group2 !== void 0 ? _c$group2 : "").overrideTheme;
    const colTheme = c.themeOverride === undefined && groupTheme === undefined ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };
    const colFont = `${colTheme.baseFontStyle} ${colTheme.fontFamily}`;

    if (colFont !== font) {
      font = colFont;
      ctx.font = colFont;
    }

    reclip();
    let prepResult = undefined;
    walkRowsInCol(startRow, colDrawStartY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky, isTrailingRow) => {
      var _c$trailingRowOptions, _c$trailingRowOptions2;

      if (row < 0) return;

      if (damage !== undefined) {
        let found = false;

        for (let i = 0; i < damage.length; i++) {
          const d = damage[i];

          if (d[0] === c.sourceIndex && d[1] === row) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      if (drawRegions.length > 0) {
        let found = false;

        for (let i = 0; i < drawRegions.length; i++) {
          const dr = drawRegions[i];

          if (intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      const rowSelected = selection.rows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      const cell = row < rows ? getCellContent([c.sourceIndex, row]) : loadingCell;
      let cellX = drawX;
      let cellWidth = c.width;
      let drawingSpan = false;
      let skipContents = false;

      if (cell.span !== undefined) {
        const [startCol, endCol] = cell.span;
        const spanKey = `${row},${startCol},${endCol},${c.sticky}`;

        if (!handledSpans.has(spanKey)) {
          const areas = getSpanBounds(cell.span, drawX, drawY, c.width, rh, c, allColumns);
          const area = c.sticky ? areas[0] : areas[1];

          if (!c.sticky && areas[0] !== undefined) {
            skipContents = true;
          }

          if (area !== undefined) {
            cellX = area.x;
            cellWidth = area.width;
            handledSpans.add(spanKey);
            ctx.restore();
            prepResult = undefined;
            ctx.save();
            ctx.beginPath();
            const d = Math.max(0, clipX - area.x);
            ctx.rect(area.x + d, drawY, area.width - d, rh);

            if (result === undefined) {
              result = [];
            }

            result.push({
              x: area.x + d,
              y: drawY,
              width: area.width - d,
              height: rh
            });
            ctx.clip();
            drawingSpan = true;
          }
        } else {
          toDraw--;
          return;
        }
      }

      const rowTheme = getRowThemeOverride === null || getRowThemeOverride === void 0 ? void 0 : getRowThemeOverride(row);
      const trailingTheme = isTrailingRow && ((_c$trailingRowOptions = c.trailingRowOptions) === null || _c$trailingRowOptions === void 0 ? void 0 : _c$trailingRowOptions.themeOverride) !== undefined ? (_c$trailingRowOptions2 = c.trailingRowOptions) === null || _c$trailingRowOptions2 === void 0 ? void 0 : _c$trailingRowOptions2.themeOverride : undefined;
      const theme = cell.themeOverride === undefined && rowTheme === undefined && trailingTheme === undefined ? colTheme : { ...colTheme,
        ...rowTheme,
        ...trailingTheme,
        ...cell.themeOverride
      };
      ctx.beginPath();
      const cellIndex = [c.sourceIndex, row];
      const isSelected = (0,data_grid_lib/* cellIsSelected */.Sb)(cellIndex, cell, selection);
      let accentCount = (0,data_grid_lib/* cellIsInRange */.H1)(cellIndex, cell, selection);
      const spanIsHighlighted = cell.span !== undefined && selection.columns.some(index => cell.span !== undefined && index >= cell.span[0] && index <= cell.span[1]);

      if (isSelected && !isFocused && drawFocus) {
        accentCount = 0;
      } else if (isSelected) {
        accentCount = Math.max(accentCount, 1);
      }

      if (spanIsHighlighted) {
        accentCount++;
      }

      if (!isSelected) {
        if (rowSelected) accentCount++;
        if (colSelected && !isSticky) accentCount++;
      }

      const bgCell = cell.kind === data_grid_types/* GridCellKind.Protected */.p6.Protected ? theme.bgCellMedium : theme.bgCell;
      let fill;

      if (isSticky || bgCell !== outerTheme.bgCell) {
        fill = blend(bgCell, fill);
      }

      if (accentCount > 0 || rowDisabled) {
        if (rowDisabled) {
          fill = blend(theme.bgHeader, fill);
        }

        for (let i = 0; i < accentCount; i++) {
          fill = blend(theme.accentLight, fill);
        }
      } else {
        if ((prelightCells === null || prelightCells === void 0 ? void 0 : prelightCells.some(pre => pre[0] === c.sourceIndex && pre[1] === row)) === true) {
          fill = blend(theme.bgSearchResult, fill);
        }
      }

      if (highlightRegions !== undefined) {
        for (const region of highlightRegions) {
          const r = region.range;

          if (r.x <= c.sourceIndex && c.sourceIndex < r.x + r.width && r.y <= row && row < r.y + r.height) {
            fill = blend(region.color, fill);
          }
        }
      }

      if (fill !== undefined) {
        ctx.fillStyle = fill;

        if (prepResult !== undefined) {
          prepResult.fillStyle = fill;
        }

        ctx.fillRect(cellX, drawY, cellWidth, rh);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 0.6;
      }

      const hoverValue = hoverValues.find(hv => hv.item[0] === c.sourceIndex && hv.item[1] === row);

      if (cellWidth > 10 && !skipContents) {
        var _hoverValue$hoverAmou;

        const cellFont = `${theme.baseFontStyle} ${theme.fontFamily}`;

        if (cellFont !== font) {
          ctx.font = cellFont;
          font = cellFont;
        }

        prepResult = drawCell(ctx, row, cell, c.sourceIndex, cellX, drawY, cellWidth, rh, accentCount > 0, theme, drawCustomCell, imageLoader, spriteManager, (_hoverValue$hoverAmou = hoverValue === null || hoverValue === void 0 ? void 0 : hoverValue.hoverAmount) !== null && _hoverValue$hoverAmou !== void 0 ? _hoverValue$hoverAmou : 0, hoverInfo, hyperWrapping, frameTime, prepResult, enqueue, getCellRenderer);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 1;
      }

      toDraw--;

      if (drawingSpan) {
        var _prepResult, _prepResult$deprep;

        ctx.restore();
        (_prepResult = prepResult) === null || _prepResult === void 0 ? void 0 : (_prepResult$deprep = _prepResult.deprep) === null || _prepResult$deprep === void 0 ? void 0 : _prepResult$deprep.call(_prepResult, {
          ctx
        });
        prepResult = undefined;
        reclip();
        font = colFont;
        ctx.font = colFont;
      }

      return toDraw <= 0;
    });
    ctx.restore();
    return toDraw <= 0;
  });
  return result;
}

function drawBlanks(ctx, effectiveColumns, allColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowTheme, selectedRows, disabledRows, trailingRowType, drawRegions, damage, theme) {
  if (damage !== undefined || effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1]) return;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    if (c !== effectiveColumns[effectiveColumns.length - 1]) return;
    drawX += c.width;
    const x = Math.max(drawX, clipX);
    if (x > width) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, totalHeaderHeight + 1, 10000, height - totalHeaderHeight - 1);
    ctx.clip();
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      if (!isSticky && drawRegions.length > 0 && !drawRegions.some(dr => intersectRect(drawX, drawY, 10000, rh, dr.x, dr.y, dr.width, dr.height))) {
        return;
      }

      const rowSelected = selectedRows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      ctx.beginPath();
      const rowTheme = getRowTheme === null || getRowTheme === void 0 ? void 0 : getRowTheme(row);
      const blankTheme = rowTheme === undefined ? theme : { ...theme,
        ...rowTheme
      };

      if (blankTheme.bgCell !== theme.bgCell) {
        ctx.fillStyle = blankTheme.bgCell;
        ctx.fillRect(drawX, drawY, 10000, rh);
      }

      if (rowDisabled) {
        ctx.fillStyle = blankTheme.bgHeader;
        ctx.fillRect(drawX, drawY, 10000, rh);
      }

      if (rowSelected) {
        ctx.fillStyle = blankTheme.accentLight;
        ctx.fillRect(drawX, drawY, 10000, rh);
      }
    });
    ctx.restore();
  });
}

function overdrawStickyBoundaries(ctx, effectiveCols, width, height, lastRowSticky, rows, verticalBorder, getRowHeight, theme) {
  var _theme$horizontalBord2;

  let drawFreezeBorder = false;

  for (const c of effectiveCols) {
    if (c.sticky) continue;
    drawFreezeBorder = verticalBorder(c.sourceIndex);
    break;
  }

  const hColor = (_theme$horizontalBord2 = theme.horizontalBorderColor) !== null && _theme$horizontalBord2 !== void 0 ? _theme$horizontalBord2 : theme.borderColor;
  const vColor = theme.borderColor;
  const drawX = drawFreezeBorder ? (0,data_grid_lib/* getStickyWidth */.G6)(effectiveCols) : 0;

  if (drawX !== 0) {
    ctx.beginPath();
    ctx.moveTo(drawX + 0.5, 0);
    ctx.lineTo(drawX + 0.5, height);
    ctx.strokeStyle = blend(vColor, theme.bgCell);
    ctx.stroke();
  }

  if (lastRowSticky) {
    const h = getRowHeight(rows - 1);
    ctx.beginPath();
    ctx.moveTo(0, height - h + 0.5);
    ctx.lineTo(width, height - h + 0.5);
    ctx.strokeStyle = blend(hColor, theme.bgCell);
    ctx.stroke();
  }
}

function drawHighlightRings(ctx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, lastRowSticky, rows, allHighlightRegions) {
  const highlightRegions = allHighlightRegions === null || allHighlightRegions === void 0 ? void 0 : allHighlightRegions.filter(x => x.style !== "no-outline");
  if (highlightRegions === undefined || highlightRegions.length === 0) return undefined;
  const drawRects = highlightRegions.map(h => {
    const r = h.range;
    const topLeftBounds = (0,data_grid_lib/* computeBounds */.Ve)(r.x, r.y, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.width === 1 && r.height === 1) {
      var _h$style2;

      if (r.x < freezeColumns) {
        var _h$style;

        return [{
          color: h.color,
          style: (_h$style = h.style) !== null && _h$style !== void 0 ? _h$style : "dashed",
          rect: topLeftBounds
        }, undefined];
      }

      return [undefined, {
        color: h.color,
        style: (_h$style2 = h.style) !== null && _h$style2 !== void 0 ? _h$style2 : "dashed",
        rect: topLeftBounds
      }];
    }

    const bottomRightBounds = (0,data_grid_lib/* computeBounds */.Ve)(r.x + r.width - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.x < freezeColumns && r.x + r.width >= freezeColumns) {
      var _h$style3, _h$style4;

      const freezeSectionRightBounds = (0,data_grid_lib/* computeBounds */.Ve)(freezeColumns - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      const unfreezeSectionleftBounds = (0,data_grid_lib/* computeBounds */.Ve)(freezeColumns, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      return [{
        color: h.color,
        style: (_h$style3 = h.style) !== null && _h$style3 !== void 0 ? _h$style3 : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: freezeSectionRightBounds.x + freezeSectionRightBounds.width - topLeftBounds.x,
          height: freezeSectionRightBounds.y + freezeSectionRightBounds.height - topLeftBounds.y
        }
      }, {
        color: h.color,
        style: (_h$style4 = h.style) !== null && _h$style4 !== void 0 ? _h$style4 : "dashed",
        rect: {
          x: unfreezeSectionleftBounds.x,
          y: unfreezeSectionleftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - unfreezeSectionleftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - unfreezeSectionleftBounds.y
        }
      }];
    } else {
      var _h$style5;

      return [undefined, {
        color: h.color,
        style: (_h$style5 = h.style) !== null && _h$style5 !== void 0 ? _h$style5 : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y
        }
      }];
    }
  });
  const stickyWidth = (0,data_grid_lib/* getStickyWidth */.G6)(mappedColumns);

  const drawCb = () => {
    ctx.beginPath();
    ctx.save();
    let dashed = false;

    const setDashed = dash => {
      if (dashed === dash) return;
      ctx.setLineDash(dash ? [5, 3] : []);
      dashed = dash;
    };

    ctx.lineWidth = 1;

    for (const dr of drawRects) {
      const [s] = dr;

      if (s !== undefined && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");
        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    let clipped = false;

    for (const dr of drawRects) {
      const [, s] = dr;

      if (s !== undefined && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");

        if (!clipped && s.rect.x < stickyWidth) {
          ctx.rect(stickyWidth, 0, width, height);
          ctx.clip();
          clipped = true;
        }

        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    ctx.restore();
  };

  drawCb();
  return drawCb;
}

function drawFocusRing(ctx, width, height, cellYOffset, translateX, translateY, effectiveCols, allColumns, theme, totalHeaderHeight, selectedCell, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) {
  var _cell$span;

  if (selectedCell.current === undefined || !effectiveCols.some(c => {
    var _selectedCell$current;

    return c.sourceIndex === ((_selectedCell$current = selectedCell.current) === null || _selectedCell$current === void 0 ? void 0 : _selectedCell$current.cell[0]);
  })) return undefined;
  const [targetCol, targetRow] = selectedCell.current.cell;
  const cell = getCellContent(selectedCell.current.cell);
  const targetColSpan = (_cell$span = cell.span) !== null && _cell$span !== void 0 ? _cell$span : [targetCol, targetCol];
  const isStickyRow = trailingRowType === "sticky" && targetRow === rows - 1;
  const stickRowHeight = trailingRowType === "sticky" && !isStickyRow ? getRowHeight(rows - 1) - 1 : 0;
  let drawCb = undefined;
  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (col, drawX, colDrawY, clipX, startRow) => {
    if (col.sticky && targetCol > col.sourceIndex) return;

    if (col.sourceIndex < targetColSpan[0] || col.sourceIndex > targetColSpan[1]) {
      return;
    }

    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh) => {
      if (row !== targetRow) return;
      let cellX = drawX;
      let cellWidth = col.width;

      if (cell.span !== undefined) {
        const areas = getSpanBounds(cell.span, drawX, drawY, col.width, rh, col, allColumns);
        const area = col.sticky ? areas[0] : areas[1];

        if (area !== undefined) {
          cellX = area.x;
          cellWidth = area.width;
        }
      }

      drawCb = () => {
        var _col$themeOverride$ac, _col$themeOverride;

        if (clipX > cellX && !col.sticky) {
          ctx.beginPath();
          ctx.rect(clipX, 0, width - clipX, height);
          ctx.clip();
        }

        ctx.beginPath();
        ctx.rect(cellX + 0.5, drawY + 0.5, cellWidth, rh);
        ctx.strokeStyle = (_col$themeOverride$ac = (_col$themeOverride = col.themeOverride) === null || _col$themeOverride === void 0 ? void 0 : _col$themeOverride.accentColor) !== null && _col$themeOverride$ac !== void 0 ? _col$themeOverride$ac : theme.accentColor;
        ctx.lineWidth = 1;
        ctx.stroke();

        if (fillHandle) {
          var _col$themeOverride$ac2, _col$themeOverride2;

          ctx.beginPath();
          ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);
          ctx.fillStyle = (_col$themeOverride$ac2 = (_col$themeOverride2 = col.themeOverride) === null || _col$themeOverride2 === void 0 ? void 0 : _col$themeOverride2.accentColor) !== null && _col$themeOverride$ac2 !== void 0 ? _col$themeOverride$ac2 : theme.accentColor;
          ctx.fill();
        }
      };

      return true;
    });
    return true;
  });
  if (drawCb === undefined) return undefined;

  const result = () => {
    var _drawCb;

    ctx.save();
    ctx.beginPath();
    ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);
    ctx.clip();
    (_drawCb = drawCb) === null || _drawCb === void 0 ? void 0 : _drawCb();
    ctx.restore();
  };

  result();
  return result;
}

function getLastRow(effectiveColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType) {
  let result = 0;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (_c, __drawX, colDrawY, _clipX, startRow) => {
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (_drawY, row, _rh, isSticky) => {
      if (!isSticky) {
        result = Math.max(row, result);
      }
    });
    return true;
  });
  return result;
}

function computeCanBlit(current, last) {
  if (last === undefined) return false;

  if (current.width !== last.width || current.height !== last.height || current.theme !== last.theme || current.headerHeight !== last.headerHeight || current.rowHeight !== last.rowHeight || current.rows !== last.rows || current.getRowThemeOverride !== last.getRowThemeOverride || current.isFocused !== last.isFocused || current.isResizing !== last.isResizing || current.verticalBorder !== last.verticalBorder || current.getCellContent !== last.getCellContent || current.highlightRegions !== last.highlightRegions || current.selection !== last.selection || current.dragAndDropState !== last.dragAndDropState || current.prelightCells !== last.prelightCells || current.touchMode !== last.touchMode || current.scrolling !== last.scrolling) {
    return false;
  }

  if (current.mappedColumns !== last.mappedColumns) {
    if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {
      return false;
    }

    let resized;

    for (let i = 0; i < current.mappedColumns.length; i++) {
      const curCol = current.mappedColumns[i];
      const lastCol = last.mappedColumns[i];
      if ((0,support/* deepEqual */.vZ)(curCol, lastCol)) continue;
      if (resized !== undefined) return false;
      if (curCol.width === lastCol.width) return false;
      const {
        width,
        ...curRest
      } = curCol;
      const {
        width: lastWidth,
        ...lastRest
      } = lastCol;
      if (!(0,support/* deepEqual */.vZ)(curRest, lastRest)) return false;
      resized = i;
    }

    if (resized === undefined) {
      return true;
    }

    return resized;
  }

  return true;
}

function drawGrid(arg, lastArg) {
  var _window$devicePixelRa, _selection$current;

  const {
    canvas,
    headerCanvas,
    width,
    height,
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mappedColumns,
    enableGroups,
    freezeColumns,
    dragAndDropState,
    theme,
    drawFocus,
    headerHeight,
    groupHeaderHeight,
    disabledRows,
    rowHeight,
    verticalBorder,
    isResizing,
    selection,
    fillHandle,
    lastRowSticky: trailingRowType,
    rows,
    getCellContent,
    getGroupDetails,
    getRowThemeOverride,
    isFocused,
    drawCustomCell,
    drawHeaderCallback,
    prelightCells,
    highlightRegions,
    imageLoader,
    lastBlitData,
    hoverValues,
    hyperWrapping,
    hoverInfo,
    spriteManager,
    scrolling,
    touchMode,
    enqueue,
    getCellRenderer,
    renderStrategy,
    bufferA,
    bufferB
  } = arg;
  let {
    damage
  } = arg;
  if (width === 0 || height === 0) return;
  const doubleBuffer = renderStrategy === "double-buffer";
  const dpr = scrolling ? 1 : Math.ceil((_window$devicePixelRa = window.devicePixelRatio) !== null && _window$devicePixelRa !== void 0 ? _window$devicePixelRa : 1);
  const canBlit = renderStrategy !== "direct" && computeCanBlit(arg, lastArg);

  if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
  }

  const overlayCanvas = headerCanvas;
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const overlayHeight = totalHeaderHeight + 1;

  if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {
    overlayCanvas.width = width * dpr;
    overlayCanvas.height = overlayHeight * dpr;
    overlayCanvas.style.width = width + "px";
    overlayCanvas.style.height = overlayHeight + "px";
  }

  if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {
    bufferA.width = width * dpr;
    bufferA.height = height * dpr;
  }

  if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {
    bufferB.width = width * dpr;
    bufferB.height = height * dpr;
  }

  const last = lastBlitData.current;
  if (canBlit === true && cellXOffset === (last === null || last === void 0 ? void 0 : last.cellXOffset) && cellYOffset === (last === null || last === void 0 ? void 0 : last.cellYOffset) && translateX === (last === null || last === void 0 ? void 0 : last.translateX) && translateY === (last === null || last === void 0 ? void 0 : last.translateY)) return;
  let mainCtx = null;

  if (doubleBuffer) {
    mainCtx = canvas.getContext("2d", {
      alpha: false
    });
  }

  const overlayCtx = overlayCanvas.getContext("2d", {
    alpha: false
  });
  let targetBuffer;

  if (!doubleBuffer) {
    targetBuffer = canvas;
  } else if (damage !== undefined) {
    targetBuffer = (last === null || last === void 0 ? void 0 : last.lastBuffer) === "b" ? bufferB : bufferA;
  } else {
    targetBuffer = (last === null || last === void 0 ? void 0 : last.lastBuffer) === "b" ? bufferA : bufferB;
  }

  const targetCtx = targetBuffer.getContext("2d", {
    alpha: false
  });
  const blitSource = doubleBuffer ? targetBuffer === bufferA ? bufferB : bufferA : canvas;
  if (overlayCtx === null || targetCtx === null) return;
  const getRowHeight = typeof rowHeight === "number" ? () => rowHeight : rowHeight;
  overlayCtx.save();
  overlayCtx.beginPath();
  targetCtx.save();
  targetCtx.beginPath();
  overlayCtx.textBaseline = "middle";
  targetCtx.textBaseline = "middle";

  if (dpr !== 1) {
    overlayCtx.scale(dpr, dpr);
    targetCtx.scale(dpr, dpr);
  }

  const effectiveCols = (0,data_grid_lib/* getEffectiveColumns */.ih)(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
  let drawRegions = [];
  const mustDrawFocusOnHeader = drawFocus && ((_selection$current = selection.current) === null || _selection$current === void 0 ? void 0 : _selection$current.cell[1]) === cellYOffset && translateY === 0;

  const drawHeaderTexture = () => {
    var _ref2, _theme$headerBottomBo;

    drawGridHeaders(overlayCtx, effectiveCols, enableGroups, hoverInfo, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, theme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode);
    drawGridLines(overlayCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, undefined, undefined, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme, true);
    overlayCtx.beginPath();
    overlayCtx.moveTo(0, overlayHeight - 0.5);
    overlayCtx.lineTo(width, overlayHeight - 0.5);
    overlayCtx.strokeStyle = blend((_ref2 = (_theme$headerBottomBo = theme.headerBottomBorderColor) !== null && _theme$headerBottomBo !== void 0 ? _theme$headerBottomBo : theme.horizontalBorderColor) !== null && _ref2 !== void 0 ? _ref2 : theme.borderColor, theme.bgHeader);
    overlayCtx.stroke();

    if (mustDrawFocusOnHeader) {
      drawFocusRing(overlayCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
    }
  };

  if (damage !== undefined) {
    let doHeaders = false;
    damage = damage.filter(x => {
      doHeaders = doHeaders || x[1] < 0;
      return x[1] < 0 || intersectRect(cellXOffset, cellYOffset, effectiveCols.length, 300, x[0], x[1], 1, 1) || intersectRect(0, cellYOffset, freezeColumns, 300, x[0], x[1], 1, 1) || trailingRowType && intersectRect(cellXOffset, rows - 1, effectiveCols.length, 1, x[0], x[1], 1, 1);
    });

    if (damage.length > 0) {
      clipDamage(targetCtx, effectiveCols, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, true);
      targetCtx.fillStyle = theme.bgCell;
      targetCtx.fillRect(0, totalHeaderHeight + 1, width, height - totalHeaderHeight - 1);
      drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);

      if (fillHandle && drawFocus && selection.current !== undefined && damage.some(x => {
        var _selection$current2, _selection$current3;

        return x[0] === ((_selection$current2 = selection.current) === null || _selection$current2 === void 0 ? void 0 : _selection$current2.cell[0]) && x[1] === ((_selection$current3 = selection.current) === null || _selection$current3 === void 0 ? void 0 : _selection$current3.cell[1]);
      })) {
        drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
      }
    }

    if (doHeaders) {
      clipDamage(overlayCtx, effectiveCols, width, totalHeaderHeight, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, false);
      drawHeaderTexture();
    }

    targetCtx.restore();
    overlayCtx.restore();

    if (mainCtx !== null) {
      mainCtx.fillStyle = theme.bgCell;
      mainCtx.fillRect(0, 0, width, height);
      mainCtx.drawImage(targetCtx.canvas, 0, 0);
    }

    return;
  }

  if (canBlit !== true || cellXOffset !== (last === null || last === void 0 ? void 0 : last.cellXOffset) || translateX !== (last === null || last === void 0 ? void 0 : last.translateX) || mustDrawFocusOnHeader !== (last === null || last === void 0 ? void 0 : last.mustDrawFocusOnHeader)) {
    drawHeaderTexture();
  }

  if (canBlit === true) {
    (0,support/* assert */.hu)(blitSource !== undefined && last !== undefined);
    const {
      regions
    } = blitLastFrame(targetCtx, blitSource, last, cellXOffset, cellYOffset, translateX, translateY, trailingRowType === "sticky", width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, rowHeight, doubleBuffer);
    drawRegions = regions;
  } else if (canBlit !== false) {
    (0,support/* assert */.hu)(last !== undefined);
    const resizedCol = canBlit;
    drawRegions = blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedCol);
  }

  overdrawStickyBoundaries(targetCtx, effectiveCols, width, height, trailingRowType === "sticky", rows, verticalBorder, getRowHeight, theme);
  const focusRedraw = drawFocus ? drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) : undefined;
  const highlightRedraw = drawHighlightRings(targetCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, trailingRowType === "sticky", rows, highlightRegions);
  targetCtx.fillStyle = theme.bgCell;

  if (drawRegions.length > 0) {
    targetCtx.beginPath();

    for (const r of drawRegions) {
      targetCtx.rect(r.x, r.y, r.width, r.height);
    }

    targetCtx.clip();
    targetCtx.fill();
    targetCtx.beginPath();
  } else {
    targetCtx.fillRect(0, 0, width, height);
  }

  const spans = drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);
  drawBlanks(targetCtx, effectiveCols, mappedColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowThemeOverride, selection.rows, disabledRows, trailingRowType, drawRegions, damage, theme);
  drawGridLines(targetCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme);
  focusRedraw === null || focusRedraw === void 0 ? void 0 : focusRedraw();
  highlightRedraw === null || highlightRedraw === void 0 ? void 0 : highlightRedraw();

  if (mainCtx !== null) {
    mainCtx.fillStyle = theme.bgCell;
    mainCtx.fillRect(0, 0, width, height);
    mainCtx.drawImage(targetCtx.canvas, 0, 0);
  }

  const lastRowDrawn = getLastRow(effectiveCols, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType);
  imageLoader === null || imageLoader === void 0 ? void 0 : imageLoader.setWindow({
    x: cellXOffset,
    y: cellYOffset,
    width: effectiveCols.length,
    height: lastRowDrawn - cellYOffset
  }, freezeColumns);
  lastBlitData.current = {
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mustDrawFocusOnHeader,
    lastBuffer: doubleBuffer ? targetBuffer === bufferA ? "a" : "b" : undefined
  };
  targetCtx.restore();
  overlayCtx.restore();
}

function walkRowsInCol(startRow, drawY, height, rows, getRowHeight, trailingRowType, cb) {
  let y = drawY;
  let row = startRow;
  let doSticky = trailingRowType === "sticky";

  while (y < height || doSticky) {
    const doingSticky = doSticky && y >= height;

    if (doingSticky) {
      doSticky = false;
      row = rows - 1;
    }

    const rh = getRowHeight(row);

    if (doingSticky) {
      y = height - rh;
    }

    const isMovedStickyRow = doSticky && row === rows - 1;

    if (!isMovedStickyRow && cb(y, row, rh, doingSticky, trailingRowType !== "none" && row === rows - 1) === true) {
      break;
    }

    if (doingSticky) {
      break;
    }

    y += rh;
    row++;
  }
}

function walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, cb) {
  let x = 0;
  let clipX = 0;
  const drawY = totalHeaderHeight + translateY;

  for (const c of effectiveCols) {
    const drawX = c.sticky ? clipX : x + translateX;

    if (cb(c, drawX, drawY, clipX, cellYOffset) === true) {
      break;
    }

    x += c.width;
    clipX += c.sticky ? c.width : 0;
  }
}

function walkGroups(effectiveCols, width, translateX, groupHeaderHeight, cb) {
  let x = 0;
  let clipX = 0;

  for (let index = 0; index < effectiveCols.length; index++) {
    var _startCol$group;

    const startCol = effectiveCols[index];
    let end = index + 1;
    let boxWidth = startCol.width;

    if (startCol.sticky) {
      clipX += boxWidth;
    }

    while (end < effectiveCols.length && (0,data_grid_lib/* isGroupEqual */.PU)(effectiveCols[end].group, startCol.group) && effectiveCols[end].sticky === effectiveCols[index].sticky) {
      const endCol = effectiveCols[end];
      boxWidth += endCol.width;
      end++;
      index++;

      if (endCol.sticky) {
        clipX += endCol.width;
      }
    }

    const t = startCol.sticky ? 0 : translateX;
    const localX = x + t;
    const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);
    const w = Math.min(boxWidth - delta, width - (localX + delta));
    cb([startCol.sourceIndex, effectiveCols[end - 1].sourceIndex], (_startCol$group = startCol.group) !== null && _startCol$group !== void 0 ? _startCol$group : "", localX + delta, 0, w, groupHeaderHeight);
    x += boxWidth;
  }
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid/animation-manager.ts

const hoverTime = 80;

function easeOutCubic(x) {
  const x1 = x - 1;
  return x1 * x1 * x1 + 1;
}

class AnimationManager {
  constructor(callback) {
    this.callback = callback;
    this.currentHoveredItem = undefined;
    this.leavingItems = [];
    this.lastAnimationTime = void 0;

    this.areSameItems = (left, right) => {
      return (left === null || left === void 0 ? void 0 : left[0]) === (right === null || right === void 0 ? void 0 : right[0]) && (left === null || left === void 0 ? void 0 : left[1]) === (right === null || right === void 0 ? void 0 : right[1]);
    };

    this.addToLeavingItems = item => {
      const isAlreadyLeaving = this.leavingItems.some(i => this.areSameItems(i.item, item.item));

      if (isAlreadyLeaving) {
        return;
      }

      this.leavingItems.push(item);
    };

    this.removeFromLeavingItems = item => {
      var _leavingItem$hoverAmo;

      const leavingItem = this.leavingItems.find(e => this.areSameItems(e.item, item));
      this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);
      return (_leavingItem$hoverAmo = leavingItem === null || leavingItem === void 0 ? void 0 : leavingItem.hoverAmount) !== null && _leavingItem$hoverAmo !== void 0 ? _leavingItem$hoverAmo : 0;
    };

    this.cleanUpLeavingElements = () => {
      this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);
    };

    this.shouldStep = () => {
      const hasLeavingItems = this.leavingItems.length > 0;
      const currentHoveredIsAnimating = this.currentHoveredItem !== undefined && this.currentHoveredItem.hoverAmount < 1;
      return hasLeavingItems || currentHoveredIsAnimating;
    };

    this.getAnimatingItems = () => {
      if (this.currentHoveredItem !== undefined) {
        return [...this.leavingItems, this.currentHoveredItem];
      }

      return this.leavingItems.map(x => ({ ...x,
        hoverAmount: easeOutCubic(x.hoverAmount)
      }));
    };

    this.step = timestamp => {
      if (this.lastAnimationTime === undefined) {
        this.lastAnimationTime = timestamp;
      } else {
        const step = timestamp - this.lastAnimationTime;
        const delta = step / hoverTime;

        for (const item of this.leavingItems) {
          item.hoverAmount = clamp_default()(item.hoverAmount - delta, 0, 1);
        }

        if (this.currentHoveredItem !== undefined) {
          this.currentHoveredItem.hoverAmount = clamp_default()(this.currentHoveredItem.hoverAmount + delta, 0, 1);
        }

        const animating = this.getAnimatingItems();
        this.callback(animating);
        this.cleanUpLeavingElements();
      }

      if (this.shouldStep()) {
        this.lastAnimationTime = timestamp;
        window.requestAnimationFrame(this.step);
      } else {
        this.lastAnimationTime = undefined;
      }
    };

    this.setHovered = item => {
      var _this$currentHoveredI;

      if (this.areSameItems((_this$currentHoveredI = this.currentHoveredItem) === null || _this$currentHoveredI === void 0 ? void 0 : _this$currentHoveredI.item, item)) {
        return;
      }

      if (this.currentHoveredItem !== undefined) {
        this.addToLeavingItems(this.currentHoveredItem);
      }

      if (item !== undefined) {
        const hoverAmount = this.removeFromLeavingItems(item);
        this.currentHoveredItem = {
          item,
          hoverAmount
        };
      } else {
        this.currentHoveredItem = undefined;
      }

      if (this.lastAnimationTime === undefined) {
        window.requestAnimationFrame(this.step);
      }
    };
  }

}
// EXTERNAL MODULE: ./packages/core/src/common/browser-detect.ts
var browser_detect = __webpack_require__("./packages/core/src/common/browser-detect.ts");
;// CONCATENATED MODULE: ./packages/core/src/data-grid/use-animation-queue.ts


function hasItem(arr, item) {
  for (const element of arr) {
    if (element[0] === item[0] && element[1] === item[1]) return true;
  }

  return false;
}

function useAnimationQueue(draw) {
  const queue = react.useRef([]);
  const seq = react.useRef(0);
  const drawRef = react.useRef(draw);
  drawRef.current = draw;
  const loop = react.useCallback(() => {
    const requeue = () => window.requestAnimationFrame(fn);

    const fn = () => {
      const toDraw = queue.current;
      queue.current = [];
      drawRef.current(toDraw);

      if (queue.current.length > 0) {
        seq.current++;
      } else {
        seq.current = 0;
      }
    };

    window.requestAnimationFrame(seq.current > 600 ? requeue : fn);
  }, []);
  return react.useCallback(item => {
    if (hasItem(queue.current, item)) return;

    if (queue.current.length === 0) {
      loop();
    }

    queue.current.push(item);
  }, [loop]);
}
;// CONCATENATED MODULE: ./packages/core/src/data-grid/data-grid.tsx














const getRowData = (cell, getCellRenderer) => {
  var _r$getAccessibilitySt;

  if (cell.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom) return cell.copyData;
  const r = getCellRenderer === null || getCellRenderer === void 0 ? void 0 : getCellRenderer(cell);
  return (_r$getAccessibilitySt = r === null || r === void 0 ? void 0 : r.getAccessibilityString(cell)) !== null && _r$getAccessibilitySt !== void 0 ? _r$getAccessibilitySt : "";
};

const DataGrid = (p, forwardedRef) => {
  var _p$translateX, _p$translateY, _eventTargetRef$curre, _eventTargetRef$curre2, _eventTargetRef$curre3, _eventTargetRef$curre4, _eventTargetRef$curre5, _eventTargetRef$curre6;

  const {
    width,
    height,
    accessibilityHeight,
    columns,
    cellXOffset: cellXOffsetReal,
    cellYOffset,
    headerHeight,
    fillHandle = false,
    groupHeaderHeight,
    rowHeight,
    rows,
    getCellContent,
    getRowThemeOverride,
    onHeaderMenuClick,
    enableGroups,
    isFilling,
    onCanvasFocused,
    onCanvasBlur,
    isFocused,
    selection,
    freezeColumns,
    onContextMenu,
    trailingRowType: trailingRowType,
    fixedShadowX = true,
    fixedShadowY = true,
    drawFocusRing = true,
    onMouseDown,
    onMouseUp,
    onMouseMoveRaw,
    onMouseMove,
    onItemHovered,
    dragAndDropState,
    firstColAccessible,
    onKeyDown,
    onKeyUp,
    highlightRegions,
    canvasRef,
    onDragStart,
    onDragEnd,
    eventTargetRef,
    isResizing,
    isDragging,
    isDraggable = false,
    allowResize,
    disabledRows,
    getGroupDetails,
    theme,
    prelightCells,
    headerIcons,
    verticalBorder,
    drawHeader: drawHeaderCallback,
    drawCustomCell,
    onCellFocused,
    onDragOverCell,
    onDrop,
    onDragLeave,
    imageWindowLoader,
    smoothScrollX = false,
    smoothScrollY = false,
    experimental,
    getCellRenderer
  } = p;
  const translateX = (_p$translateX = p.translateX) !== null && _p$translateX !== void 0 ? _p$translateX : 0;
  const translateY = (_p$translateY = p.translateY) !== null && _p$translateY !== void 0 ? _p$translateY : 0;
  const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));
  const ref = react.useRef(null);
  const imageWindowLoaderInternal = react.useMemo(() => new image_window_loader(), []);
  const imageLoader = imageWindowLoader !== null && imageWindowLoader !== void 0 ? imageWindowLoader : imageWindowLoaderInternal;
  const damageRegion = react.useRef();
  const [scrolling, setScrolling] = react.useState(false);
  const hoverValues = react.useRef([]);
  const lastBlitData = react.useRef();
  const [hoveredItemInfo, setHoveredItemInfo] = react.useState();
  const [hoveredOnEdge, setHoveredOnEdge] = react.useState();
  const overlayRef = react.useRef(null);
  const [lastWasTouch, setLastWasTouch] = react.useState(false);
  const lastWasTouchRef = react.useRef(lastWasTouch);
  lastWasTouchRef.current = lastWasTouch;
  const spriteManager = react.useMemo(() => new SpriteManager(headerIcons, () => {
    lastArgsRef.current = undefined;
    lastDrawRef.current();
  }), [headerIcons]);
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const scrollingStopRef = react.useRef(-1);
  const disableFirefoxRescaling = (experimental === null || experimental === void 0 ? void 0 : experimental.enableFirefoxRescaling) !== true;
  react.useLayoutEffect(() => {
    if (!browser_detect/* browserIsFirefox.value */.uC.value || window.devicePixelRatio === 1 || disableFirefoxRescaling) return;

    if (scrollingStopRef.current !== -1) {
      setScrolling(true);
    }

    window.clearTimeout(scrollingStopRef.current);
    scrollingStopRef.current = window.setTimeout(() => {
      setScrolling(false);
      scrollingStopRef.current = -1;
    }, 200);
  }, [cellYOffset, cellXOffset, translateX, translateY, disableFirefoxRescaling]);
  const mappedColumns = (0,data_grid_lib/* useMappedColumns */.NZ)(columns, freezeColumns);
  const getBoundsForItem = react.useCallback((canvas, col, row) => {
    const rect = canvas.getBoundingClientRect();

    if (col >= mappedColumns.length || row >= rows) {
      return undefined;
    }

    const scale = rect.width / width;
    const result = (0,data_grid_lib/* computeBounds */.Ve)(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType === "sticky", mappedColumns, rowHeight);

    if (scale !== 1) {
      result.x *= scale;
      result.y *= scale;
      result.width *= scale;
      result.height *= scale;
    }

    result.x += rect.x;
    result.y += rect.y;
    return result;
  }, [width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType, mappedColumns, rowHeight]);
  const getMouseArgsForPosition = react.useCallback((canvas, posX, posY, ev) => {
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / width;
    const x = (posX - rect.left) / scale;
    const y = (posY - rect.top) / scale;
    const edgeDetectionBuffer = 5;
    const effectiveCols = (0,data_grid_lib/* getEffectiveColumns */.ih)(mappedColumns, cellXOffset, width, undefined, translateX);
    let button = 0;

    if (ev instanceof MouseEvent) {
      button = ev.button;
    }

    const col = (0,data_grid_lib/* getColumnIndexForX */.oK)(x, effectiveCols, translateX);
    const row = (0,data_grid_lib/* getRowIndexForY */.pV)(y, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType === "sticky");
    const shiftKey = (ev === null || ev === void 0 ? void 0 : ev.shiftKey) === true;
    const ctrlKey = (ev === null || ev === void 0 ? void 0 : ev.ctrlKey) === true;
    const metaKey = (ev === null || ev === void 0 ? void 0 : ev.metaKey) === true;
    const isTouch = ev !== undefined && !(ev instanceof MouseEvent);
    const edgeSize = 20;
    const scrollEdge = [Math.abs(x) < edgeSize ? -1 : Math.abs(rect.width - x) < edgeSize ? 1 : 0, Math.abs(y) < edgeSize ? -1 : Math.abs(rect.height - y) < edgeSize ? 1 : 0];
    let result;

    if (col === -1 || y < 0 || x < 0 || row === undefined || x > width || y > height) {
      const horizontal = x > width ? -1 : x < 0 ? 1 : 0;
      const vertical = y > height ? 1 : y < 0 ? -1 : 0;
      let isEdge = false;

      if (col === -1 && row === -1) {
        const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);
        (0,support/* assert */.hu)(b !== undefined);
        isEdge = posX < b.x + b.width + edgeDetectionBuffer;
      }

      result = {
        kind: data_grid_types/* outOfBoundsKind */.Xv,
        location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row !== null && row !== void 0 ? row : rows - 1],
        direction: [horizontal, vertical],
        shiftKey,
        ctrlKey,
        metaKey,
        isEdge,
        isTouch,
        button,
        scrollEdge
      };
    } else if (row <= -1) {
      let bounds = getBoundsForItem(canvas, col, row);
      (0,support/* assert */.hu)(bounds !== undefined);
      let isEdge = bounds !== undefined && bounds.x + bounds.width - posX <= edgeDetectionBuffer;
      const previousCol = col - 1;

      if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {
        var _mappedColumns$previo;

        isEdge = true;
        bounds = getBoundsForItem(canvas, previousCol, row);
        (0,support/* assert */.hu)(bounds !== undefined);
        result = {
          kind: enableGroups && row === -2 ? data_grid_types/* groupHeaderKind */.mr : data_grid_types/* headerKind */.aZ,
          location: [previousCol, row],
          bounds: bounds,
          group: (_mappedColumns$previo = mappedColumns[previousCol].group) !== null && _mappedColumns$previo !== void 0 ? _mappedColumns$previo : "",
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      } else {
        var _mappedColumns$col$gr;

        result = {
          kind: enableGroups && row === -2 ? data_grid_types/* groupHeaderKind */.mr : data_grid_types/* headerKind */.aZ,
          group: (_mappedColumns$col$gr = mappedColumns[col].group) !== null && _mappedColumns$col$gr !== void 0 ? _mappedColumns$col$gr : "",
          location: [col, row],
          bounds: bounds,
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      }
    } else {
      const bounds = getBoundsForItem(canvas, col, row);
      (0,support/* assert */.hu)(bounds !== undefined);
      const isEdge = bounds !== undefined && bounds.x + bounds.width - posX < edgeDetectionBuffer;
      const isFillHandle = fillHandle && bounds !== undefined && bounds.x + bounds.width - posX < 6 && bounds.y + bounds.height - posY < 6;
      result = {
        kind: "cell",
        location: [col, row],
        bounds: bounds,
        isEdge,
        shiftKey,
        ctrlKey,
        isFillHandle,
        metaKey,
        isTouch,
        localEventX: posX - bounds.x,
        localEventY: posY - bounds.y,
        button,
        scrollEdge
      };
    }

    return result;
  }, [mappedColumns, cellXOffset, width, translateX, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType, getBoundsForItem, fillHandle]);

  function isSameItem(item, other) {
    if (item === other) return true;
    return (item === null || item === void 0 ? void 0 : item.kind) === (other === null || other === void 0 ? void 0 : other.kind) && (item === null || item === void 0 ? void 0 : item.location[0]) === (other === null || other === void 0 ? void 0 : other.location[0]) && (item === null || item === void 0 ? void 0 : item.location[1]) === (other === null || other === void 0 ? void 0 : other.location[1]);
  }

  const [hoveredItem] = hoveredItemInfo !== null && hoveredItemInfo !== void 0 ? hoveredItemInfo : [];
  const enqueueRef = react.useRef(_item => {});
  const hoverInfoRef = react.useRef(hoveredItemInfo);
  hoverInfoRef.current = hoveredItemInfo;
  const [bufferA, bufferB] = react.useMemo(() => {
    return [document.createElement("canvas"), document.createElement("canvas")];
  }, []);
  const lastArgsRef = react.useRef();
  const draw = react.useCallback(() => {
    var _experimental$hyperWr, _experimental$renderS;

    const canvas = ref.current;
    const overlay = overlayRef.current;
    if (canvas === null || overlay === null) return;
    const last = lastArgsRef.current;
    const current = {
      canvas,
      bufferA,
      bufferB,
      headerCanvas: overlay,
      width,
      height,
      cellXOffset,
      cellYOffset,
      translateX: Math.round(translateX),
      translateY: Math.round(translateY),
      mappedColumns,
      enableGroups,
      freezeColumns,
      dragAndDropState,
      theme,
      headerHeight,
      groupHeaderHeight,
      disabledRows: disabledRows !== null && disabledRows !== void 0 ? disabledRows : data_grid_types/* CompactSelection.empty */.EV.empty(),
      rowHeight,
      verticalBorder,
      isResizing,
      isFocused,
      selection,
      fillHandle,
      lastRowSticky: trailingRowType,
      rows,
      drawFocus: drawFocusRing,
      getCellContent,
      getGroupDetails: getGroupDetails !== null && getGroupDetails !== void 0 ? getGroupDetails : name => ({
        name
      }),
      getRowThemeOverride,
      drawCustomCell,
      drawHeaderCallback,
      prelightCells,
      highlightRegions,
      imageLoader,
      lastBlitData,
      damage: damageRegion.current,
      hoverValues: hoverValues.current,
      hoverInfo: hoverInfoRef.current,
      spriteManager,
      scrolling,
      hyperWrapping: (_experimental$hyperWr = experimental === null || experimental === void 0 ? void 0 : experimental.hyperWrapping) !== null && _experimental$hyperWr !== void 0 ? _experimental$hyperWr : false,
      touchMode: lastWasTouch,
      enqueue: enqueueRef.current,
      renderStrategy: (_experimental$renderS = experimental === null || experimental === void 0 ? void 0 : experimental.renderStrategy) !== null && _experimental$renderS !== void 0 ? _experimental$renderS : browser_detect/* browserIsSafari.value */.Pq.value ? "double-buffer" : "single-buffer",
      getCellRenderer
    };

    if (current.damage === undefined) {
      lastArgsRef.current = current;
      drawGrid(current, last);
    } else {
      drawGrid(current, undefined);
    }
  }, [bufferA, bufferB, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, enableGroups, freezeColumns, dragAndDropState, theme, headerHeight, groupHeaderHeight, disabledRows, rowHeight, verticalBorder, isResizing, isFocused, selection, fillHandle, trailingRowType, rows, drawFocusRing, getCellContent, getGroupDetails, getRowThemeOverride, drawCustomCell, drawHeaderCallback, prelightCells, highlightRegions, imageLoader, spriteManager, scrolling, experimental === null || experimental === void 0 ? void 0 : experimental.hyperWrapping, experimental === null || experimental === void 0 ? void 0 : experimental.renderStrategy, lastWasTouch, getCellRenderer]);
  const lastDrawRef = react.useRef(draw);
  react.useLayoutEffect(() => {
    draw();
    lastDrawRef.current = draw;
  }, [draw]);
  react.useLayoutEffect(() => {
    const fn = async () => {
      var _document, _document$fonts;

      if (((_document = document) === null || _document === void 0 ? void 0 : (_document$fonts = _document.fonts) === null || _document$fonts === void 0 ? void 0 : _document$fonts.ready) === undefined) return;
      await document.fonts.ready;
      lastArgsRef.current = undefined;
      lastDrawRef.current();
    };

    void fn();
  }, []);
  const damageInternal = react.useCallback(locations => {
    damageRegion.current = locations;
    lastDrawRef.current();
    damageRegion.current = undefined;
  }, []);
  const enqueue = useAnimationQueue(damageInternal);
  enqueueRef.current = enqueue;
  const damage = react.useCallback(cells => {
    damageInternal(cells.map(x => x.cell));
  }, [damageInternal]);
  imageLoader.setCallback(damageInternal);
  const [overFill, setOverFill] = react.useState(false);
  const [hCol, hRow] = hoveredItem !== null && hoveredItem !== void 0 ? hoveredItem : [];
  const headerHovered = hCol !== undefined && hRow === -1;
  const groupHeaderHovered = hCol !== undefined && hRow === -2;
  let clickableInnerCellHovered = false;
  let editableBoolHovered = false;
  let cursorOverride;

  if (hCol !== undefined && hRow !== undefined && hRow > -1) {
    const cell = getCellContent([hCol, hRow]);
    clickableInnerCellHovered = cell.kind === data_grid_types/* InnerGridCellKind.NewRow */.$o.NewRow || cell.kind === data_grid_types/* InnerGridCellKind.Marker */.$o.Marker && cell.markerKind !== "number";
    editableBoolHovered = cell.kind === data_grid_types/* GridCellKind.Boolean */.p6.Boolean && (0,data_grid_types/* booleanCellIsEditable */.kf)(cell);
    cursorOverride = cell.cursor;
  }

  const canDrag = hoveredOnEdge !== null && hoveredOnEdge !== void 0 ? hoveredOnEdge : false;
  const cursor = isDragging ? "grabbing" : canDrag || isResizing ? "col-resize" : overFill || isFilling ? "crosshair" : cursorOverride !== undefined ? cursorOverride : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered ? "pointer" : "default";
  const style = react.useMemo(() => ({
    contain: "strict",
    display: "block",
    cursor
  }), [cursor]);
  const lastSetCursor = react.useRef("default");
  const target = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current;

  if (target !== null && target !== undefined && lastSetCursor.current !== style.cursor) {
    target.style.cursor = lastSetCursor.current = style.cursor;
  }

  const groupHeaderActionForEvent = react.useCallback((group, bounds, localEventX, localEventY) => {
    if (getGroupDetails === undefined) return undefined;
    const groupDesc = getGroupDetails(group);

    if (groupDesc.actions !== undefined) {
      const boxes = getActionBoundsForGroup(bounds, groupDesc.actions);

      for (const [i, box] of boxes.entries()) {
        if (pointInRect(box, localEventX + bounds.x, localEventY + box.y)) {
          return groupDesc.actions[i];
        }
      }
    }

    return undefined;
  }, [getGroupDetails]);
  const isOverHeaderMenu = react.useCallback((canvas, col, clientX, clientY) => {
    const header = columns[col];

    if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge !== null && hoveredOnEdge !== void 0 ? hoveredOnEdge : false)) {
      const headerBounds = getBoundsForItem(canvas, col, -1);
      (0,support/* assert */.hu)(headerBounds !== undefined);
      const menuBounds = getHeaderMenuBounds(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height);

      if (clientX > menuBounds.x && clientX < menuBounds.x + menuBounds.width && clientY > menuBounds.y && clientY < menuBounds.y + menuBounds.height) {
        return headerBounds;
      }
    }

    return undefined;
  }, [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]);
  const downTime = react.useRef(0);
  const downPosition = react.useRef();
  const onMouseDownImpl = react.useCallback(ev => {
    const canvas = ref.current;
    const eventTarget = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current;
    if (canvas === null || ev.target !== canvas && ev.target !== eventTarget) return;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.touches[0].clientX;
      clientY = ev.touches[0].clientY;
    }

    if (ev.target === eventTarget && eventTarget !== null) {
      const bounds = eventTarget.getBoundingClientRect();
      if (clientX > bounds.left + eventTarget.clientWidth) return;
      if (clientY > bounds.top + eventTarget.clientHeight) return;
    }

    const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);
    downPosition.current = args.location;

    if (args.isTouch) {
      downTime.current = Date.now();
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (args.kind === data_grid_types/* headerKind */.aZ && isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== undefined) {
      return;
    } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== undefined) {
        return;
      }
    }

    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(args);

    if (!args.isTouch && isDraggable !== true && isDraggable !== args.kind) {
      ev.preventDefault();
    }
  }, [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]);
  (0,utils/* useEventListener */.OR)("touchstart", onMouseDownImpl, window, false);
  (0,utils/* useEventListener */.OR)("mousedown", onMouseDownImpl, window, false);
  const onMouseUpImpl = react.useCallback(ev => {
    const canvas = ref.current;
    if (onMouseUp === undefined || canvas === null) return;
    const eventTarget = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current;
    const isOutside = ev.target !== canvas && ev.target !== eventTarget;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.changedTouches[0].clientX;
      clientY = ev.changedTouches[0].clientY;
    }

    let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);

    if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {
      args = { ...args,
        isLongTouch: true
      };
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (!isOutside && ev.cancelable) {
      ev.preventDefault();
    }

    if (args.kind === data_grid_types/* headerKind */.aZ && isOverHeaderMenu(canvas, args.location[0], clientX, clientY)) {
      const [col] = args.location;
      const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);

      if (headerBounds !== undefined) {
        var _downPosition$current, _downPosition$current2;

        if (args.button === 0 && ((_downPosition$current = downPosition.current) === null || _downPosition$current === void 0 ? void 0 : _downPosition$current[0]) === col && ((_downPosition$current2 = downPosition.current) === null || _downPosition$current2 === void 0 ? void 0 : _downPosition$current2[1]) === -1) {
          onHeaderMenuClick === null || onHeaderMenuClick === void 0 ? void 0 : onHeaderMenuClick(col, headerBounds);
        } else {
          onMouseUp(args, true);
        }

        return;
      }
    } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== undefined) {
        if (args.button === 0) {
          action.onClick(args);
        }

        return;
      }
    }

    onMouseUp(args, isOutside);
  }, [onMouseUp, eventTargetRef, getMouseArgsForPosition, isOverHeaderMenu, onHeaderMenuClick, groupHeaderActionForEvent]);
  (0,utils/* useEventListener */.OR)("mouseup", onMouseUpImpl, window, false);
  (0,utils/* useEventListener */.OR)("touchend", onMouseUpImpl, window, false);
  const onContextMenuImpl = react.useCallback(ev => {
    const canvas = ref.current;
    if (canvas === null || onContextMenu === undefined) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);
    onContextMenu(args, () => {
      if (ev.cancelable) ev.preventDefault();
    });
  }, [getMouseArgsForPosition, onContextMenu]);
  (0,utils/* useEventListener */.OR)("contextmenu", onContextMenuImpl, (_eventTargetRef$curre = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre !== void 0 ? _eventTargetRef$curre : null, false);
  const onAnimationFrame = react.useCallback(values => {
    damageRegion.current = values.map(x => x.item);
    hoverValues.current = values;
    lastDrawRef.current();
    damageRegion.current = undefined;
  }, []);
  const animManagerValue = react.useMemo(() => new AnimationManager(onAnimationFrame), [onAnimationFrame]);
  const animationManager = react.useRef(animManagerValue);
  animationManager.current = animManagerValue;
  react.useLayoutEffect(() => {
    const am = animationManager.current;

    if (hoveredItem === undefined || hoveredItem[1] < 0) {
      am.setHovered(hoveredItem);
      return;
    }

    const cell = getCellContent(hoveredItem);
    const r = getCellRenderer(cell);
    am.setHovered(r === undefined && cell.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom || (r === null || r === void 0 ? void 0 : r.needsHover) === true ? hoveredItem : undefined);
  }, [getCellContent, getCellRenderer, hoveredItem]);
  const hoveredRef = react.useRef();
  const onMouseMoveImpl = react.useCallback(ev => {
    const canvas = ref.current;
    if (canvas === null) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);

    if (!isSameItem(args, hoveredRef.current)) {
      onItemHovered === null || onItemHovered === void 0 ? void 0 : onItemHovered(args);
      setHoveredItemInfo(args.kind === data_grid_types/* outOfBoundsKind */.Xv ? undefined : [args.location, [args.localEventX, args.localEventY]]);
      hoveredRef.current = args;
    } else if (args.kind === "cell" || args.kind === data_grid_types/* headerKind */.aZ || args.kind === data_grid_types/* groupHeaderKind */.mr) {
      const newInfo = [args.location, [args.localEventX, args.localEventY]];
      setHoveredItemInfo(newInfo);
      hoverInfoRef.current = newInfo;

      if (args.kind === "cell") {
        var _getCellRenderer;

        const toCheck = getCellContent(args.location);

        if (toCheck.kind === data_grid_types/* GridCellKind.Custom */.p6.Custom || ((_getCellRenderer = getCellRenderer(toCheck)) === null || _getCellRenderer === void 0 ? void 0 : _getCellRenderer.needsHoverPosition) === true) {
          damageInternal([args.location]);
        }
      } else if (args.kind === data_grid_types/* groupHeaderKind */.mr) {
        damageInternal([args.location]);
      }
    }

    setHoveredOnEdge(args.kind === data_grid_types/* headerKind */.aZ && args.isEdge && allowResize === true);

    if (fillHandle && selection.current !== undefined) {
      const [col, row] = selection.current.cell;
      const sb = getBoundsForItem(canvas, col, row);
      const x = ev.clientX;
      const y = ev.clientY;
      (0,support/* assert */.hu)(sb !== undefined);
      setOverFill(x >= sb.x + sb.width - 6 && x <= sb.x + sb.width && y >= sb.y + sb.height - 6 && y <= sb.y + sb.height);
    } else {
      setOverFill(false);
    }

    onMouseMoveRaw === null || onMouseMoveRaw === void 0 ? void 0 : onMouseMoveRaw(ev);
    onMouseMove(args);
  }, [getMouseArgsForPosition, allowResize, fillHandle, selection, onMouseMoveRaw, onMouseMove, onItemHovered, getCellContent, getCellRenderer, damageInternal, getBoundsForItem]);
  (0,utils/* useEventListener */.OR)("mousemove", onMouseMoveImpl, window, true);
  const onKeyDownImpl = react.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== undefined) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => undefined,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyDown, selection, getBoundsForItem]);
  const onKeyUpImpl = react.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== undefined) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => undefined,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyUp, selection, getBoundsForItem]);
  const refImpl = react.useCallback(instance => {
    ref.current = instance;

    if (canvasRef !== undefined) {
      canvasRef.current = instance;
    }
  }, [canvasRef]);
  const onDragStartImpl = react.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || isDraggable === false || isResizing) {
      event.preventDefault();
      return;
    }

    let dragMime;
    let dragData;
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);

    if (isDraggable !== true && args.kind !== isDraggable) {
      event.preventDefault();
      return;
    }

    const setData = (mime, payload) => {
      dragMime = mime;
      dragData = payload;
    };

    let dragImage;
    let dragImageX;
    let dragImageY;

    const setDragImage = (image, x, y) => {
      dragImage = image;
      dragImageX = x;
      dragImageY = y;
    };

    let prevented = false;
    onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({ ...args,
      setData,
      setDragImage,
      preventDefault: () => prevented = true,
      defaultPrevented: () => prevented
    });

    if (!prevented && dragMime !== undefined && dragData !== undefined && event.dataTransfer !== null) {
      event.dataTransfer.setData(dragMime, dragData);
      event.dataTransfer.effectAllowed = "copyLink";

      if (dragImage !== undefined && dragImageX !== undefined && dragImageY !== undefined) {
        event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);
      } else {
        const [col, row] = args.location;

        if (row !== undefined) {
          const offscreen = document.createElement("canvas");
          const boundsForDragTarget = getBoundsForItem(canvas, col, row);
          (0,support/* assert */.hu)(boundsForDragTarget !== undefined);
          offscreen.width = boundsForDragTarget.width;
          offscreen.height = boundsForDragTarget.height;
          const ctx = offscreen.getContext("2d");

          if (ctx !== null) {
            ctx.textBaseline = "middle";

            if (row === -1) {
              ctx.font = `${theme.headerFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgHeader;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawHeader(ctx, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, mappedColumns[col], false, theme, false, false, 0, spriteManager, drawHeaderCallback, false);
            } else {
              ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgCell;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawCell(ctx, row, getCellContent([col, row]), 0, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, false, theme, drawCustomCell, imageLoader, spriteManager, 1, undefined, false, 0, undefined, undefined, getCellRenderer);
            }
          }

          offscreen.style.left = "-100%";
          offscreen.style.position = "absolute";
          document.body.append(offscreen);
          event.dataTransfer.setDragImage(offscreen, boundsForDragTarget.width / 2, boundsForDragTarget.height / 2);
          window.setTimeout(() => {
            offscreen.remove();
          }, 0);
        }
      }
    } else {
      event.preventDefault();
    }
  }, [isDraggable, isResizing, getMouseArgsForPosition, onDragStart, getBoundsForItem, theme, mappedColumns, spriteManager, drawHeaderCallback, getCellContent, drawCustomCell, imageLoader, getCellRenderer]);
  (0,utils/* useEventListener */.OR)("dragstart", onDragStartImpl, (_eventTargetRef$curre2 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre2 !== void 0 ? _eventTargetRef$curre2 : null, false, false);
  const activeDropTarget = react.useRef();
  const onDragOverImpl = react.useCallback(event => {
    var _activeDropTarget$cur;

    const canvas = ref.current;

    if (onDrop !== undefined) {
      event.preventDefault();
    }

    if (canvas === null || onDragOverCell === undefined) {
      return;
    }

    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    const [activeCol, activeRow] = (_activeDropTarget$cur = activeDropTarget.current) !== null && _activeDropTarget$cur !== void 0 ? _activeDropTarget$cur : [];

    if (activeCol !== col || activeRow !== row) {
      activeDropTarget.current = [col, row];
      onDragOverCell([col, row], event.dataTransfer);
    }
  }, [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]);
  (0,utils/* useEventListener */.OR)("dragover", onDragOverImpl, (_eventTargetRef$curre3 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre3 !== void 0 ? _eventTargetRef$curre3 : null, false, false);
  const onDragEndImpl = react.useCallback(() => {
    activeDropTarget.current = undefined;
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd();
  }, [onDragEnd]);
  (0,utils/* useEventListener */.OR)("dragend", onDragEndImpl, (_eventTargetRef$curre4 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre4 !== void 0 ? _eventTargetRef$curre4 : null, false, false);
  const onDropImpl = react.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || onDrop === undefined) {
      return;
    }

    event.preventDefault();
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    onDrop([col, row], event.dataTransfer);
  }, [firstColAccessible, getMouseArgsForPosition, onDrop]);
  (0,utils/* useEventListener */.OR)("drop", onDropImpl, (_eventTargetRef$curre5 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre5 !== void 0 ? _eventTargetRef$curre5 : null, false, false);
  const onDragLeaveImpl = react.useCallback(() => {
    onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave();
  }, [onDragLeave]);
  (0,utils/* useEventListener */.OR)("dragleave", onDragLeaveImpl, (_eventTargetRef$curre6 = eventTargetRef === null || eventTargetRef === void 0 ? void 0 : eventTargetRef.current) !== null && _eventTargetRef$curre6 !== void 0 ? _eventTargetRef$curre6 : null, false, false);
  const selectionRef = react.useRef(selection);
  selectionRef.current = selection;
  const focusRef = react.useRef(null);
  const focusElement = react.useCallback(el => {
    if (ref.current === null || !ref.current.contains(document.activeElement)) return;

    if (el === null && selectionRef.current.current !== undefined) {
      var _canvasRef$current;

      canvasRef === null || canvasRef === void 0 ? void 0 : (_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 ? void 0 : _canvasRef$current.focus({
        preventScroll: true
      });
    } else if (el !== null) {
      el.focus({
        preventScroll: true
      });
    }

    focusRef.current = el;
  }, [canvasRef]);
  react.useImperativeHandle(forwardedRef, () => ({
    focus: () => {
      const el = focusRef.current;

      if (el === null || !document.contains(el)) {
        var _canvasRef$current2;

        canvasRef === null || canvasRef === void 0 ? void 0 : (_canvasRef$current2 = canvasRef.current) === null || _canvasRef$current2 === void 0 ? void 0 : _canvasRef$current2.focus({
          preventScroll: true
        });
      } else {
        el.focus({
          preventScroll: true
        });
      }
    },
    getBounds: (col, row) => {
      if (canvasRef === undefined || canvasRef.current === null) {
        return undefined;
      }

      return getBoundsForItem(canvasRef.current, col, row !== null && row !== void 0 ? row : -1);
    },
    damage
  }), [canvasRef, damage, getBoundsForItem]);
  const lastFocusedSubdomNode = react.useRef();
  const accessibilityTree = (0,utils/* useDebouncedMemo */.Qy)(() => {
    var _effectiveCols$, _selection$current$ce, _selection$current, _selection$current2;

    if (width < 50) return null;
    let effectiveCols = (0,data_grid_lib/* getEffectiveColumns */.ih)(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
    const colOffset = firstColAccessible ? 0 : -1;

    if (!firstColAccessible && ((_effectiveCols$ = effectiveCols[0]) === null || _effectiveCols$ === void 0 ? void 0 : _effectiveCols$.sourceIndex) === 0) {
      effectiveCols = effectiveCols.slice(1);
    }

    const [fCol, fRow] = (_selection$current$ce = (_selection$current = selection.current) === null || _selection$current === void 0 ? void 0 : _selection$current.cell) !== null && _selection$current$ce !== void 0 ? _selection$current$ce : [];
    const range = (_selection$current2 = selection.current) === null || _selection$current2 === void 0 ? void 0 : _selection$current2.range;
    const visibleCols = effectiveCols.map(c => c.sourceIndex);
    const visibleRows = range_default()(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));

    if (fCol !== undefined && fRow !== undefined && !(visibleCols.includes(fCol) && visibleRows.includes(fRow))) {
      focusElement(null);
    }

    return react.createElement("table", {
      key: "access-tree",
      role: "grid",
      "aria-rowcount": rows + 1,
      "aria-multiselectable": "true",
      "aria-colcount": mappedColumns.length + colOffset
    }, react.createElement("thead", {
      role: "rowgroup"
    }, react.createElement("tr", {
      role: "row",
      "aria-rowindex": 1
    }, effectiveCols.map(c => react.createElement("th", {
      role: "columnheader",
      "aria-selected": selection.columns.hasIndex(c.sourceIndex),
      "aria-colindex": c.sourceIndex + 1 + colOffset,
      tabIndex: -1,
      onFocus: e => {
        if (e.target === focusRef.current) return;
        return onCellFocused === null || onCellFocused === void 0 ? void 0 : onCellFocused([c.sourceIndex, -1]);
      },
      key: c.sourceIndex
    }, c.title)))), react.createElement("tbody", {
      role: "rowgroup"
    }, visibleRows.map(row => react.createElement("tr", {
      role: "row",
      "aria-selected": selection.rows.hasIndex(row),
      key: row,
      "aria-rowindex": row + 2
    }, effectiveCols.map(c => {
      const col = c.sourceIndex;
      const key = `${col},${row}`;
      const focused = fCol === col && fRow === row;
      const selected = range !== undefined && col >= range.x && col < range.x + range.width && row >= range.y && row < range.y + range.height;
      const id = `glide-cell-${col}-${row}`;
      const cellContent = getCellContent([col, row]);
      return react.createElement("td", {
        key: key,
        role: "gridcell",
        "aria-colindex": col + 1 + colOffset,
        "aria-selected": selected,
        "aria-readonly": (0,data_grid_types/* isInnerOnlyCell */.rs)(cellContent) || !(0,data_grid_types/* isReadWriteCell */.Qo)(cellContent),
        id: id,
        "data-testid": id,
        onClick: () => {
          const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;
          if (canvas === null || canvas === undefined) return;
          return onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown({
            bounds: getBoundsForItem(canvas, col, row),
            cancel: () => undefined,
            preventDefault: () => undefined,
            stopPropagation: () => undefined,
            ctrlKey: false,
            key: "Enter",
            keyCode: 13,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: undefined
          });
        },
        onFocusCapture: e => {
          var _lastFocusedSubdomNod, _lastFocusedSubdomNod2;

          if (e.target === focusRef.current || ((_lastFocusedSubdomNod = lastFocusedSubdomNode.current) === null || _lastFocusedSubdomNod === void 0 ? void 0 : _lastFocusedSubdomNod[0]) === col && ((_lastFocusedSubdomNod2 = lastFocusedSubdomNode.current) === null || _lastFocusedSubdomNod2 === void 0 ? void 0 : _lastFocusedSubdomNod2[1]) === row) return;
          lastFocusedSubdomNode.current = [col, row];
          return onCellFocused === null || onCellFocused === void 0 ? void 0 : onCellFocused([col, row]);
        },
        ref: focused ? focusElement : undefined,
        tabIndex: -1
      }, getRowData(cellContent, getCellRenderer));
    })))));
  }, [width, mappedColumns, cellXOffset, dragAndDropState, translateX, rows, cellYOffset, accessibilityHeight, selection, focusElement, getCellContent, canvasRef, onKeyDown, getBoundsForItem, onCellFocused], 200);
  const stickyX = fixedShadowX ? (0,data_grid_lib/* getStickyWidth */.G6)(mappedColumns, dragAndDropState) : 0;
  const opacityX = freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : clamp_default()(-translateX / 100, 0, 1);
  const absoluteOffsetY = -cellYOffset * 32 + translateY;
  const opacityY = !fixedShadowY ? 0 : clamp_default()(-absoluteOffsetY / 100, 0, 1);
  const stickyShadow = react.useMemo(() => {
    if (!opacityX && !opacityY) {
      return null;
    }

    const styleX = {
      position: "absolute",
      top: 0,
      left: stickyX,
      width: width - stickyX,
      height: height,
      opacity: opacityX,
      pointerEvents: "none",
      transition: !smoothScrollX ? "opacity 0.2s" : undefined,
      boxShadow: "inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)"
    };
    const styleY = {
      position: "absolute",
      top: totalHeaderHeight,
      left: 0,
      width: width,
      height: height,
      opacity: opacityY,
      pointerEvents: "none",
      transition: !smoothScrollY ? "opacity 0.2s" : undefined,
      boxShadow: "inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)"
    };
    return react.createElement(react.Fragment, null, opacityX > 0 && react.createElement("div", {
      id: "shadow-x",
      style: styleX
    }), opacityY > 0 && react.createElement("div", {
      id: "shadow-y",
      style: styleY
    }));
  }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);
  const overlayStyle = react.useMemo(() => ({
    position: "absolute",
    top: 0,
    left: 0
  }), []);
  return react.createElement(react.Fragment, null, react.createElement("canvas", {
    "data-testid": "data-grid-canvas",
    tabIndex: 0,
    onKeyDown: onKeyDownImpl,
    onKeyUp: onKeyUpImpl,
    onFocus: onCanvasFocused,
    onBlur: onCanvasBlur,
    ref: refImpl,
    style: style
  }, accessibilityTree), react.createElement("canvas", {
    ref: overlayRef,
    style: overlayStyle
  }), stickyShadow);
};

/* harmony default export */ const data_grid = (react.memo(react.forwardRef(DataGrid)));

/***/ }),

/***/ "./packages/core/src/docs/00-faq.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FAQ": () => (/* binding */ FAQ),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const FAQ = () => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_2__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_2__/* .Marked */ .M2, null, `
# FAQ

### Nothing shows up? It crashes when I edit a cell?

Please read the [Prerequisites section in the docs](https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md).

### Does it work with screen readers and other a11y tools?

Yes. Unfortunately none of the primary developers are accessibility users so there are likely flaws in the implementation we are not aware of. Bug reports welcome!

### Does it support my data source?

Yes.

Data Grid is agnostic about the way you load/store/generate/mutate your data. What it requires is that you tell it which columns you have, how many rows, and to give it a function it can call to get the data for a cell in a specific row and column.

### Does it do sorting?

Yes through the [glide-data-grid-source](https://www.npmjs.com/package/@glideapps/glide-data-grid-source) package.

### Does it do search?

Yes, built in! There are examples in the storybook.

### Can it filter?

Nothing built in yet. It is planned for the \`glide-data-grid-source\`.

### Can it do frozen columns?

Yes

### Can I render my own cells?

Yes

`));
};
FAQ.storyName = "00. FAQ";
FAQ.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["FAQ"];

/***/ }),

/***/ "./packages/core/src/docs/01-getting-started.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GettingStarted": () => (/* binding */ GettingStarted),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const GettingStarted = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: false,
      displayData: d,
      data: d
    };
  }, []);
  const [rowMarkers, setRowMarkers] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [smoothScroll, setSmoothScroll] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [verticalBorder, setVerticalBorder] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Getting Started

Glide data grid is a powerful but flexible library requiring very few concepts required to get started. The grid will need data, columns, and a \`getCellContent\` callback to convert our data into cells on demand. Because the callback is used, there is no need to pre-format the data in any particular way, so long as it can be transformed into a cell. This example uses a flat array of objects.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const data = [
    {
      "name": "Hines Fowler",
      "company": "BUZZNESS",
      "email": "hinesfowler@buzzness.com",
      "phone": "+1 (869) 405-3127"
    },
    ...rest
]
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
The columns of the data grid may contain many options, including icons, menus, theme overrides, however at their most basic they only require a \`title\` and an \`id\`. The id is technically optional but it is best not to omit it.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    {
        title: "Name",
        id: "name"
    },
    {
        title: "Company",
        id: "company"
    },
    {
        title: "Email",
        id: "email"
    },
    {
        title: "Phone",
        id: "phone"
    }
]
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
Each column will automatically size based on its contents. If desired the sise of each column can be overridden by setting the width parameter.

Finally the data grid requires a cell fetch callback. This callback should be memoized using \`React.useCallback\` or be a static function.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    const [col, row] = cell;
    const dataRow = data[row];
    // dumb but simple way to do this
    const indexes: (keyof DummyItem)[] = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]]
    return {
        kind: GridCellKind.Text,
        allowOverlay: false,
        displayData: d,
        data: d,
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
> Avoid excessive changes to the identity of the \`getCellContent\` callback as the grid will re-render from scratch every time it changes.

That is all the basic requirements put together.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor getCellContent={getContent} columns={columns} rows={data.length} />;
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Going further

There is so much more that can be done:

- Header icons
- Smooth scrolling
- Header menus
- Grouping
- Row markers
- Freeze Columns
- Column reordering and resizing
- Cell spans
- Search
- Copy/paste support

Here are a few to play with.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    style: {
      display: "block"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    checked: rowMarkers,
    onChange: e => setRowMarkers(e.target.checked)
  }), " Row Markers"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    style: {
      display: "block"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    checked: smoothScroll,
    onChange: e => setSmoothScroll(e.target.checked)
  }), " ", "Smooth Scroll"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
    style: {
      display: "block"
    }
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
    type: "checkbox",
    checked: verticalBorder,
    onChange: e => setVerticalBorder(e.target.checked)
  }), " ", "Vertical Borders"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    verticalBorder: verticalBorder,
    smoothScrollX: smoothScroll,
    smoothScrollY: smoothScroll,
    rowMarkers: rowMarkers ? "both" : "none",
    columns: columns,
    rows: data.length
  })));
};
GettingStarted.storyName = "01. Getting Started";
GettingStarted.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["GettingStarted"];

/***/ }),

/***/ "./packages/core/src/docs/02-editing-data.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditingData": () => (/* binding */ EditingData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const fixedData = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const EditingData = () => {
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332"
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227"
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826"
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320"
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472"
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651"
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331"
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134"
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194"
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271"
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454"
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982"
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444"
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805"
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012"
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442"
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883"
  }]);
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = dataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const getFixedContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = fixedData[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const onCellEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue) => {
    if (newValue.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text) {
      return;
    }

    const indexes = ["name", "company", "email", "phone"];
    const [col, row] = cell;
    const key = indexes[col];
    dataRef.current[row][key] = newValue.data;
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Editing Data

Editing data is handled via callbacks. Taking the getting started example as a starting point, the \`getContent\` callback can be modified to allow editing.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes: (keyof DummyItem)[] = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
        kind: GridCellKind.Text,
        allowOverlay: true,
        readonly: false,
        displayData: d,
        data: d,
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
\`allowOverlay\` has been set to true. This allows the overlay to come up. For explanatory purposes the \`readonly\` field is being set to false. This is the default value, setting it to true would allow the overlay to come up but not allow editing.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getFixedContent,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
> You can see the editor now, but the data is not saved.

Implementing the \`onCellEdited\` callback allows responding to cell edit events. Edit events pass back a mutated version of the original \`GridCell\` returned from \`getContent\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const onCellEdited = React.useCallback((cell: Item, newValue: EditableGridCell) => {
    if (newValue.kind !== GridCellKind.Text) {
        // we only have text cells, might as well just die here.
        return;
    }

    const indexes: (keyof DummyItem)[] = ["name", "company", "email", "phone"];
    const [col, row] = cell;
    const key = indexes[col];
    data[row][key] = newValue.data;
}, []);`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    onCellEdited: onCellEdited,
    columns: columns,
    rows: dataRef.current.length
  })));
};
EditingData.storyName = "02. Editing Data";
EditingData.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["EditingData"];

/***/ }),

/***/ "./packages/core/src/docs/03-grid-column.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GridColumns": () => (/* binding */ GridColumns),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const GridColumns = () => {
  const basicGetCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: false,
      displayData: cell.toString(),
      data: cell.toString()
    };
  }, []);
  const cols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "First",
      width: 150
    }, {
      title: "Second",
      width: 150
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Basic usage

> The \`GridColumn[]\` passed to the \`DataEditor\` in the \`columns\` property should be memoized to avoid excessive re-rendering. These samples may not do this for the sake of brevity.

There are only two mandatory properties for each \`GridColumn\`: \`title\` and \`id\`. The id should be a stable id and not the index of the column. Additionally a \`width\` property can be provided which represents the width of the column in pixels. If a width is provided the id may be omited. This may change in a future version.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    { title: "First", id: "first", width: 150 },
    { title: "Second", id: "second", width: 150 }
];

<DataEditor {...rest} columns={columns} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: basicGetCellContent,
    columns: cols,
    rows: 50
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Header icons

Default header icons are available. They can also be reaplced by passing a new map to the \`headerIcons\` property.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    { title: "Name", id: "name", width: 250, icon: GridColumnIcon.HeaderString, 
      overlayIcon: GridColumnIcon.RowOwnerOverlay 
    },
    { title: "Age", id: "age", width: 100, icon: GridColumnIcon.HeaderNumber },
    { title: "Avatar", id: "avatar", width: 80, icon: GridColumnIcon.HeaderImage },
];

<DataEditor {...rest} columns={columns} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: basicGetCellContent,
    columns: [{
      title: "Name",
      width: 250,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderString */ .PE.HeaderString,
      overlayIcon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.RowOwnerOverlay */ .PE.RowOwnerOverlay
    }, {
      title: "Age",
      width: 120,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber
    }, {
      title: "Avatar",
      width: 100,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage
    }],
    rows: 50
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Header theming

Headers can be provided with individual theme overrides which themes both the header and its column cells.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns: GridColumn[] = [
    { title: "Name", id="name", width: 250, icon: GridColumnIcon.HeaderString },
    { title: "Age", id="age", width: 100, icon: GridColumnIcon.HeaderNumber, themeOverride: {
        bgIconHeader: "#00967d",
        textDark: "#00c5a4",
        textHeader: "#00c5a4",
    } },
    { title: "Avatar", id="avatar", width: 80, icon: GridColumnIcon.HeaderImage },
];

<DataEditor {...rest} columns={columns} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: basicGetCellContent,
    columns: [{
      title: "Name",
      width: 250,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderString */ .PE.HeaderString
    }, {
      title: "Age",
      width: 100,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderNumber */ .PE.HeaderNumber,
      themeOverride: {
        bgIconHeader: "#00967d",
        textDark: "#00c5a4",
        textHeader: "#00c5a4"
      }
    }, {
      title: "Avatar",
      width: 80,
      icon: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridColumnIcon.HeaderImage */ .PE.HeaderImage
    }],
    rows: 50
  })));
};
GridColumns.storyName = "03. Grid Columns";
GridColumns.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["GridColumns"];

/***/ }),

/***/ "./packages/core/src/docs/04-streaming-data.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StreamingData": () => (/* binding */ StreamingData),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const StreamingData = () => {
  const highlightDataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332",
    update: 0
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227",
    update: 0
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826",
    update: 0
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320",
    update: 0
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472",
    update: 0
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651",
    update: 0
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331",
    update: 0
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134",
    update: 0
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194",
    update: 0
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271",
    update: 0
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454",
    update: 0
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982",
    update: 0
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444",
    update: 0
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805",
    update: 0
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012",
    update: 0
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442",
    update: 0
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883",
    update: 0
  }]);
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332",
    update: 0
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227",
    update: 0
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826",
    update: 0
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320",
    update: 0
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472",
    update: 0
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651",
    update: 0
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331",
    update: 0
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134",
    update: 0
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194",
    update: 0
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271",
    update: 0
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454",
    update: 0
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982",
    update: 0
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444",
    update: 0
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805",
    update: 0
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012",
    update: 0
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442",
    update: 0
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883",
    update: 0
  }]);
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = dataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const getContentHighlighted = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = highlightDataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d,
      lastUpdated: dataRow.update
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);

  const onButtonClick = () => {
    var _ref$current;

    const randomRow1 = Math.floor(Math.random() * dataRef.current.length);
    const randomRow2 = Math.floor(Math.random() * dataRef.current.length);
    const temp = dataRef.current[randomRow1].email;
    dataRef.current[randomRow1].email = dataRef.current[randomRow2].email;
    dataRef.current[randomRow2].email = temp;
    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.updateCells([randomRow1, randomRow2].map(r => ({
      cell: [2, r]
    })));
  };

  const onHighlightButtonClick = () => {
    var _ref$current2;

    const randomRow1 = Math.floor(Math.random() * highlightDataRef.current.length);
    const randomRow2 = Math.floor(Math.random() * highlightDataRef.current.length);
    const temp = highlightDataRef.current[randomRow1].email;
    highlightDataRef.current[randomRow1].email = highlightDataRef.current[randomRow2].email;
    highlightDataRef.current[randomRow2].email = temp;
    highlightDataRef.current[randomRow1].update = performance.now();
    highlightDataRef.current[randomRow2].update = performance.now();
    (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.updateCells([randomRow1, randomRow2].map(r => ({
      cell: [2, r]
    })));
  };

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Streaming Data

> Glide Data Grid is capable of streaming hundreds of thousands of updates per second. You won't need that, but every millisecond the grid doesn't take is another millisecond your app has to process data and remain responsive.

Streaming data is done as a two step process.

1. Update the data backing store.
2. Inform the Glide Data Grid of the changed data.

The Grid does not care of the data is coming down over the wire or being generated locally. Informing the grid of changes to the data is done by calling the \`updateCells\` function on a bound ref.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const ref = React.useRef<DataEditorRef | null>(null);

return <DataEditor {...rest} ref={ref} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
Data can now be updated by calling mutating the backing store and using the ref to update cells.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const onButtonClick = () => {
    // Swap the emails of 2 random people
    const randomRow1 = Math.floor(Math.random()*data.length);
    const randomRow2 = Math.floor(Math.random()*data.length);

    const temp = data[randomRow1].email;
    data[randomRow1].email = data[randomRow2].email;
    data[randomRow2].email = temp;

    ref.current?.updateCells([randomRow1, randomRow2].map(r => ({ cell: [2, r]})));
}
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    onClick: onButtonClick
  }, "Swappy Swappy"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 400
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    ref: ref,
    getCellContent: getContent,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
## Showing updates
        
If \`getContent\` is updated to also return the last time a cell was updated the data grid will highlight cells as they update.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    const [col, row] = cell;
    const data = fetchDataFromBackend(col, row);
    return {
        kind: GridCellKind.Text,
        allowOverlay: true,
        displayData: data.value,
        data: data.value,
        lastUpdated: data.updatedAt,
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
> Note that timestamps are based on performance.now() and not Date.now(). This is to ensure that timestamps always increase monotonically and nothing weird will happen if the clock adjusts.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    style: {
      marginTop: 16
    },
    onClick: onHighlightButtonClick
  }, "Swapity Swap Swap"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 600
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    ref: ref,
    getCellContent: getContentHighlighted,
    columns: columns,
    rows: dataRef.current.length
  })));
};
StreamingData.storyName = "04. Streaming Data";
StreamingData.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["StreamingData"];

/***/ }),

/***/ "./packages/core/src/docs/05-copy-paste.stories.tsx.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CopyPaste": () => (/* binding */ CopyPaste),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const CopyPaste = () => {
  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([{
    name: "Deidre Morris",
    company: "GONKLE",
    email: "deidremorris@gonkle.com",
    phone: "+1 (867) 507-3332"
  }, {
    name: "Sheryl Craig",
    company: "EVENTAGE",
    email: "sherylcraig@eventage.com",
    phone: "+1 (869) 520-2227"
  }, {
    name: "Lidia Bowers",
    company: "ANOCHA",
    email: "lidiabowers@anocha.com",
    phone: "+1 (808) 414-3826"
  }, {
    name: "Jones Norton",
    company: "REPETWIRE",
    email: "jonesnorton@repetwire.com",
    phone: "+1 (875) 582-3320"
  }, {
    name: "Lula Bruce",
    company: "COMDOM",
    email: "lulabruce@comdom.com",
    phone: "+1 (873) 452-2472"
  }, {
    name: "Larsen Montgomery",
    company: "SQUISH",
    email: "larsenmontgomery@squish.com",
    phone: "+1 (893) 482-3651"
  }, {
    name: "Becky Bright",
    company: "COMCUR",
    email: "beckybright@comcur.com",
    phone: "+1 (879) 494-2331"
  }, {
    name: "Charlotte Rowland",
    company: "FROLIX",
    email: "charlotterowland@frolix.com",
    phone: "+1 (861) 439-2134"
  }, {
    name: "Sonya Hensley",
    company: "GEEKETRON",
    email: "sonyahensley@geeketron.com",
    phone: "+1 (802) 553-2194"
  }, {
    name: "Stephenson Guthrie",
    company: "EXOSWITCH",
    email: "stephensonguthrie@exoswitch.com",
    phone: "+1 (903) 449-3271"
  }, {
    name: "Mcmillan Cline",
    company: "TURNLING",
    email: "mcmillancline@turnling.com",
    phone: "+1 (982) 496-2454"
  }, {
    name: "Kemp Davis",
    company: "TETRATREX",
    email: "kempdavis@tetratrex.com",
    phone: "+1 (859) 594-2982"
  }, {
    name: "Matilda Levy",
    company: "SLOFAST",
    email: "matildalevy@slofast.com",
    phone: "+1 (841) 521-2444"
  }, {
    name: "Hattie Simpson",
    company: "COMTRAK",
    email: "hattiesimpson@comtrak.com",
    phone: "+1 (962) 587-3805"
  }, {
    name: "Kinney Munoz",
    company: "IDETICA",
    email: "kinneymunoz@idetica.com",
    phone: "+1 (921) 513-2012"
  }, {
    name: "Lambert Raymond",
    company: "TURNABOUT",
    email: "lambertraymond@turnabout.com",
    phone: "+1 (919) 519-2442"
  }, {
    name: "Bryant Dunlap",
    company: "BYTREX",
    email: "bryantdunlap@bytrex.com",
    phone: "+1 (872) 583-2883"
  }]);
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = dataRef.current[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const onCellEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue) => {
    if (newValue.kind !== _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text) {
      return;
    }

    const indexes = ["name", "company", "email", "phone"];
    const [col, row] = cell;
    const key = indexes[col];
    dataRef.current[row][key] = newValue.data;
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Copy Paste

Copy and Paste support is built in to Glide Data Grid. It is not enabled by default to ensure developers are expecting its behavior.

## Copy

By default copy is not enabled, to enabled copy implement the \`getCellsForSelection\` callback. The callback returns results as row-major ordering.

> \`getCellsForSelection\` is used instead of \`getCellContent\` to allow optimization when fetching large amounts of data outside of the visible region.

This example uses the built in generic function which simply calls \`getContent\`, which is inefficient but fine for a local data source.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor {...rest} getCellsForSelection={true} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    getCellsForSelection: true,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    style: {
      padding: 12,
      width: "100%",
      height: "200px",
      borderRadius: 9
    },
    placeholder: "Highlight some stuff up there and paste it here"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
Implementations may wish to use far more efficient mechanisms for fetching data.

## Paste

The easiest way to enable paste is to set \`onPaste\` to true when \`onCellEdited\` is already working. The Glide Data Grid will automatically parse the paste buffer and send cell update events.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor {...rest} onCellEdited={onCellEdited} onPaste={true} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    onCellEdited: onCellEdited,
    getCellsForSelection: true,
    onPaste: true,
    columns: columns,
    rows: dataRef.current.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `Try copying this.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    style: {
      padding: 12,
      width: "100%",
      height: "80px",
      borderRadius: 9
    },
    value: "Sheryl Craig\tEVENTAGE\tsherylcraig@eventage.com\nLidia Bowers\tANOCHA\tlidiabowers@anocha.com\nJones Norton\tREPETWIRE\tjonesnorton@repetwire.com"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
If desired paste events can be handled manually. Passing a callback to \`onPaste\` will instead receive a parsed verison of the pasted data. Returning \`true\` from the callback will cause the paste event to be handled the same as before, emitting \`onCellEdited\`. Returning \`false\` will prevent the edit callback from being emitted.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor
    {...rest}
    onCellEdited={onCellEdited}
    onPaste={(target, value) => {
        window.alert(JSON.stringify({ target, value }));
        return false;
    }}
/>
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    onCellEdited: onCellEdited,
    getCellsForSelection: true,
    columns: columns,
    onPaste: (target, value) => {
      window.alert(JSON.stringify({
        target,
        value
      }));
      return false;
    },
    rows: dataRef.current.length
  })));
};
CopyPaste.storyName = "05. Copy/Paste Support";
CopyPaste.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["CopyPaste"];

/***/ }),

/***/ "./packages/core/src/docs/06-search.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Search": () => (/* binding */ Search),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const Search = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const [showSearch, setShowSearch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const onSearchClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => setShowSearch(false), []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Search

Search is a controlled property in Glide Data Grid. Triggering the search interface is up to the application but once triggered search is handled interally on the data grid. Search always depends on a properly implemented \`getCellsForSelection\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const [showSearch, setShowSearch] = React.useState(false);
const onSearchClose = React.useCallback(() => setShowSearch(false), []);

return <DataEditor {...rest} showSearch={showSearch} getCellsForSelection={true} onSearchClose={onSearchClose}  />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    onClick: () => setShowSearch(true)
  }, "Show Search"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    showSearch: showSearch,
    onSearchClose: onSearchClose,
    getCellContent: getContent,
    getCellsForSelection: true,
    columns: columns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Automatic Search

Search can also be handled by the data grid automatically if you enable the search keybinding.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor {...rest} keybindings={{search: true}} getCellsForSelection={true}  />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    keybindings: {
      search: true
    },
    getCellContent: getContent,
    getCellsForSelection: true,
    columns: columns,
    rows: data.length
  })));
};
Search.storyName = "06. Search";
Search.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["Search"];

/***/ }),

/***/ "./packages/core/src/docs/07-column-grouping.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColumnGrouping": () => (/* binding */ ColumnGrouping),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const ColumnGrouping = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name",
      group: "Core"
    }, {
      title: "Company",
      id: "company",
      group: "Core"
    }, {
      title: "Email",
      id: "email",
      group: "Extra"
    }, {
      title: "Phone",
      id: "phone",
      group: "Extra"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Column Grouping

Columns can be grouped by assinging them a group. Easy peasy.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns = React.useMemo<GridColumn[]>(() => {
    return [
        {
            title: "Name",
            id: "name",
            group: "Core",
        },
        {
            title: "Company",
            id: "company",
            group: "Core",
        },
        {
            title: "Email",
            id: "email",
            group: "Extra",
        },
        {
            title: "Phone",
            id: "phone",
            group: "Extra",
        },
    ];
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 500
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length
  })));
};
ColumnGrouping.storyName = "07. Column Grouping";
ColumnGrouping.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["ColumnGrouping"];

/***/ }),

/***/ "./packages/core/src/docs/08-theming.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Theming": () => (/* binding */ Theming),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const Theming = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const getContentThemed = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    let theme = undefined;

    if (col === 1 && row === 1) {
      theme = {
        textDark: "#FF0000"
      };
    }

    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d,
      themeOverride: theme
    };
  }, []);
  const getRowThemeOverride = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(row => {
    if (row % 2 === 0) {
      return {
        bgCell: "#F9FDFF"
      };
    }

    return undefined;
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  const themeColumns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name"
    }, {
      title: "Company",
      themeOverride: {
        textDark: "#225588",
        baseFontStyle: "600 13px"
      },
      id: "company"
    }, {
      title: "Email",
      id: "email"
    }, {
      title: "Phone",
      id: "phone"
    }];
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `
# Theming

Theming the Glide Data Grid is a cascaded through 5 levels

0. Default theme
1. Global
2. Group
3. Column
4. Row
5. Cell

At each level parts of the theme can be overridden. This example will pro

## Global Theming

The global theme is provided by the DataEditor by default and can be overriden by setting the \`theme\` prop. All themes contain the following properties.

| Property | CSS Variable | Type | Description |
|---|---|---|----|
| accentColor | --gdg-accent-color | string | The primary accent color of the grid. This will show up in focus rings and selected rows/headers. |
| accentFg | --gdg-accent-fg | string | A foreground color which works well on top of the accent color. |
| accentLight | --gdg-accent-light | string | A lighter version of the accent color used to hint selection. |
| textDark | --gdg-text-dark | string | The standard text color. |
| textMedium | --gdg-text-medium | string | A lighter text color used for non-editable data in some cases. |
| textLight | --gdg-text-light | string | An even lighter text color |
| textBubble | --gdg-text-bubble | string | The text color used in bubbles |
| bgIconHeader | --gdg-bg-icon-header | string | The background color for header icons |
| fgIconHeader | --gdg-fg-icon-header | string | The foreground color for header icons |
| textHeader | --gdg-text-header | string | The header text color |
| textGroupHeader | --gdg-text-group-header | string \\| undefined | The group header text color, if none provided the \`textHeader\` is used instead. |
| textHeaderSelected | --gdg-text-header-selected | string | The text color used for selected headers |
| bgCell | --gdg-bg-cell | string | The primary background color of the data grid. |
| bgCellMedium | --gdg-bg-cell-medium | string | Used for disabled or otherwise off colored cells. |
| bgHeader | --gdg-bg-header | string | The header background color |
| bgHeaderHasFocus | --gdg-bg-header-has | string | The header background color when its column contains the selected cell |
| bgHeaderHovered | --gdg-bg-header-hovered | string | The header background color when it is hovered |
| bgBubble | --gdg-bg-bubble | string | The background color used in bubbles |
| bgBubbleSelected | --gdg-bg-bubble-selected | string | The background color used in bubbles when the cell is selected |
| bgSearchResult | --gdg-bg-search-result | string | The background color used for cells which match the search string |
| borderColor | --gdg-border-color | string | The color of all vertical borders and horizontal borders if a horizontal override is not provided |
| horizontalBorderColor | --gdg-horizontal-border-color | string \\| undefined | The horizontal border color override |
| drilldownBorder | --gdg-drilldown-border | string | The ring color of a drilldown cell |
| linkColor | --gdg-link-color | string | What color to render links |
| cellHorizontalPadding | --gdg-cell-horizontal-padding | number | The internal horizontal padding size of a cell. |
| cellVerticalPadding | --gdg-cell-vertical-padding | number | The internal vertical padding size of a cell. |
| headerFontStyle | --gdg-header-font-style | string | The font style of the header. e.g. \`bold 15px\` |
| baseFontStyle | --gdg-base-font-style | string | The font style used for cells by default, e.g. \`13px\` |
| fontFamily | --gdg-font-family | string | The font family used by the data grid. |
| editorFontSize | --gdg-editor-font-size | string | The font size used by overlay editors. |
| lineHeight | None | number | A unitless scaler which defines the height of a line of text relative to the ink size. |

If an option is missing from any theme it will be filled in with the default theme.
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
return <DataEditor 
        theme={{
          bgCell: "#F2F9FF"
        }} 
        getCellContent={getContent} columns={columns} rows={data.length} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getCellContent: getContent,
    columns: columns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `### Column themes
Themes can be applied at the column level as well by setting the \`themeOverride\` on the \`GridColumn\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const columns = React.useMemo<GridColumn[]>(() => {
    return [
        {
            title: "Name",
            id: "name",
        },
        {
            title: "Company",
            themeOverride: {
                textDark: "#225588",
                baseFontStyle: "600 13px",
            },
            id: "company",
        },
        {
            title: "Email",
            id: "email",
        },
        {
            title: "Phone",
            id: "phone",
        },
    ];
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getCellContent: getContent,
    columns: themeColumns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `### Row themes`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getRowThemeOverride = React.useCallback((row: number): Partial<Theme> | undefined => {
    if (row % 2 === 0) {
        return {
            bgCell: "#F9FDFF"
        }
    }
    return undefined;
}, []);

return <DataEditor {...rest} getRowThemeOverride={getRowThemeOverride} />
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getRowThemeOverride: getRowThemeOverride,
    getCellContent: getContent,
    columns: themeColumns,
    rows: data.length
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Marked */ .M2, null, `### Cell themes`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Highlight */ .y$, null, `
const getContent = React.useCallback((cell: Item): GridCell => {
    let theme: Partial<Theme> | undefined = undefined;
    if (col === 1 && row === 1) {
        theme = {
            textDark: "#FF0000",
        }
    }
    
    const d = getDataForCell(col, row);
    return {
        kind: GridCellKind.Text,
        allowOverlay: true,
        displayData: d,
        data: d,
        themeOverride: theme
    };
}, []);
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_3__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_4__/* .DataEditor */ .N, {
    theme: {
      bgCell: "#F2F9FF"
    },
    getRowThemeOverride: getRowThemeOverride,
    getCellContent: getContentThemed,
    columns: themeColumns,
    rows: data.length
  })));
};
Theming.storyName = "08. Theming";
Theming.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["Theming"];

/***/ }),

/***/ "./packages/core/src/docs/09-menus.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Menus": () => (/* binding */ Menus),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var _data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/data-editor/data-editor.tsx");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _doc_wrapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/docs/doc-wrapper.tsx");
/* harmony import */ var react_laag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/react-laag/dist/react-laag.esm.js");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Glide-Data-Grid/Docs",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_1__/* .SimpleThemeWrapper */ .X, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))]
});
const data = [{
  name: "Deidre Morris",
  company: "GONKLE",
  email: "deidremorris@gonkle.com",
  phone: "+1 (867) 507-3332"
}, {
  name: "Sheryl Craig",
  company: "EVENTAGE",
  email: "sherylcraig@eventage.com",
  phone: "+1 (869) 520-2227"
}, {
  name: "Lidia Bowers",
  company: "ANOCHA",
  email: "lidiabowers@anocha.com",
  phone: "+1 (808) 414-3826"
}, {
  name: "Jones Norton",
  company: "REPETWIRE",
  email: "jonesnorton@repetwire.com",
  phone: "+1 (875) 582-3320"
}, {
  name: "Lula Bruce",
  company: "COMDOM",
  email: "lulabruce@comdom.com",
  phone: "+1 (873) 452-2472"
}, {
  name: "Larsen Montgomery",
  company: "SQUISH",
  email: "larsenmontgomery@squish.com",
  phone: "+1 (893) 482-3651"
}, {
  name: "Becky Bright",
  company: "COMCUR",
  email: "beckybright@comcur.com",
  phone: "+1 (879) 494-2331"
}, {
  name: "Charlotte Rowland",
  company: "FROLIX",
  email: "charlotterowland@frolix.com",
  phone: "+1 (861) 439-2134"
}, {
  name: "Sonya Hensley",
  company: "GEEKETRON",
  email: "sonyahensley@geeketron.com",
  phone: "+1 (802) 553-2194"
}, {
  name: "Stephenson Guthrie",
  company: "EXOSWITCH",
  email: "stephensonguthrie@exoswitch.com",
  phone: "+1 (903) 449-3271"
}, {
  name: "Mcmillan Cline",
  company: "TURNLING",
  email: "mcmillancline@turnling.com",
  phone: "+1 (982) 496-2454"
}, {
  name: "Kemp Davis",
  company: "TETRATREX",
  email: "kempdavis@tetratrex.com",
  phone: "+1 (859) 594-2982"
}, {
  name: "Matilda Levy",
  company: "SLOFAST",
  email: "matildalevy@slofast.com",
  phone: "+1 (841) 521-2444"
}, {
  name: "Hattie Simpson",
  company: "COMTRAK",
  email: "hattiesimpson@comtrak.com",
  phone: "+1 (962) 587-3805"
}, {
  name: "Kinney Munoz",
  company: "IDETICA",
  email: "kinneymunoz@idetica.com",
  phone: "+1 (921) 513-2012"
}, {
  name: "Lambert Raymond",
  company: "TURNABOUT",
  email: "lambertraymond@turnabout.com",
  phone: "+1 (919) 519-2442"
}, {
  name: "Bryant Dunlap",
  company: "BYTREX",
  email: "bryantdunlap@bytrex.com",
  phone: "+1 (872) 583-2883"
}];
const Menus = () => {
  const getContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;
    const dataRow = data[row];
    const indexes = ["name", "company", "email", "phone"];
    const d = dataRow[indexes[col]];
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      allowOverlay: true,
      displayData: d,
      data: d
    };
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [{
      title: "Name",
      id: "name",
      hasMenu: true
    }, {
      title: "Company",
      id: "company",
      hasMenu: true
    }, {
      title: "Email",
      id: "email",
      hasMenu: true
    }, {
      title: "Phone",
      id: "phone",
      hasMenu: true
    }];
  }, []);
  const onHeaderMenuClickedStage1 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, position) => {
    window.alert("Header menu clicked " + col + JSON.stringify(position));
  }, []);
  const [showMenu, setShowMenu] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const onHeaderMenuClickedStage2 = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, bounds) => {
    setShowMenu({
      col,
      bounds
    });
  }, []);
  const {
    renderLayer,
    layerProps
  } = (0,react_laag__WEBPACK_IMPORTED_MODULE_3__/* .useLayer */ .sJ)({
    isOpen: showMenu !== undefined,
    triggerOffset: 4,
    onOutsideClick: () => setShowMenu(undefined),
    trigger: {
      getBounds: () => {
        var _showMenu$bounds$y, _showMenu$bounds$heig, _showMenu$bounds$heig2, _showMenu$bounds$x, _showMenu$bounds$x2, _showMenu$bounds$widt, _showMenu$bounds$y2, _showMenu$bounds$widt2;

        return {
          bottom: ((_showMenu$bounds$y = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.y) !== null && _showMenu$bounds$y !== void 0 ? _showMenu$bounds$y : 0) + ((_showMenu$bounds$heig = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.height) !== null && _showMenu$bounds$heig !== void 0 ? _showMenu$bounds$heig : 0),
          height: (_showMenu$bounds$heig2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.height) !== null && _showMenu$bounds$heig2 !== void 0 ? _showMenu$bounds$heig2 : 0,
          left: (_showMenu$bounds$x = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.x) !== null && _showMenu$bounds$x !== void 0 ? _showMenu$bounds$x : 0,
          right: ((_showMenu$bounds$x2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.x) !== null && _showMenu$bounds$x2 !== void 0 ? _showMenu$bounds$x2 : 0) + ((_showMenu$bounds$widt = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.width) !== null && _showMenu$bounds$widt !== void 0 ? _showMenu$bounds$widt : 0),
          top: (_showMenu$bounds$y2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.y) !== null && _showMenu$bounds$y2 !== void 0 ? _showMenu$bounds$y2 : 0,
          width: (_showMenu$bounds$widt2 = showMenu === null || showMenu === void 0 ? void 0 : showMenu.bounds.width) !== null && _showMenu$bounds$widt2 !== void 0 ? _showMenu$bounds$widt2 : 0
        };
      }
    },
    placement: "bottom-start",
    auto: true,
    possiblePlacements: ["bottom-start", "bottom-end"]
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .DocWrapper */ .kT, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Marked */ .M2, null, `
# Menus

Glide Data Grid doesn't come with built in menus. Instead it is evented and ready to work with whatever menus you want 
to use. Let's learn how to add basic menus using [react-laag](https://www.react-laag.com/). Adding menu drop down indicators to headers is as simple
as passing a bool and listening to click events using \`onHeaderMenuClick\`.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Highlight */ .y$, null, `
const columns = React.useMemo<GridColumn[]>(() => {
    return [
        {
            title: "Name",
            id: "name",
            hasMenu: true,
        },
        {
            title: "Company",
            id: "company",
            hasMenu: true,
        },
        {
            title: "Email",
            id: "email",
            hasMenu: true,
        },
        {
            title: "Phone",
            id: "phone",
            hasMenu: true,
        },
    ];
}, []);

const onHeaderMenuClick = React.useCallback((col: number, position: Rectangle) => {
    window.alert("Header menu clicked " + col + JSON.stringify(position));
}, []);

return <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />;
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length,
    onHeaderMenuClick: onHeaderMenuClickedStage1
  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Marked */ .M2, null, `
The provided coordinates are in page space. This makes it trivial to use [react-laag](https://www.react-laag.com/) to create a basic menu. Some 
styling would go a long way here.`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Highlight */ .y$, null, `
const [showMenu, setShowMenu] = React.useState<{ bounds: Rectangle; col: number }>();

const onHeaderMenuClick = React.useCallback((col: number, bounds: Rectangle) => {
    setShowMenu({ col, bounds });
}, []);

const { renderLayer, layerProps } = useLayer({
    isOpen: showMenu !== undefined,
    triggerOffset: 4,
    onOutsideClick: () => setShowMenu(undefined),
    trigger: {
        getBounds: () => ({
            bottom: (showMenu?.bounds.y ?? 0) + (showMenu?.bounds.height ?? 0),
            height: showMenu?.bounds.height ?? 0,
            left: showMenu?.bounds.x ?? 0,
            right: (showMenu?.bounds.x ?? 0) + (showMenu?.bounds.width ?? 0),
            top: showMenu?.bounds.y ?? 0,
            width: showMenu?.bounds.width ?? 0,
        }),
    },
    placement: "bottom-start",
    auto: true,
    possiblePlacements: ["bottom-start", "bottom-end"],
    });

return <>
    <DataEditor {...rest} onHeaderMenuClick={onHeaderMenuClick} />
    {showMenu !== undefined &&
        renderLayer(
            <div
                {...layerProps}
                style={{
                    ...layerProps.style,
                    width: 300,
                    padding: 4,
                    borderRadius: 8,
                    backgroundColor: "white",
                    border: "1px solid black",
                }}>
                <ul>
                    <li>Item 1</li>
                    <li>Item 2</li>
                    <li>Item 3</li>
                </ul>
            </div>
        )}
</>;
`), react__WEBPACK_IMPORTED_MODULE_0__.createElement(_doc_wrapper__WEBPACK_IMPORTED_MODULE_4__/* .Wrapper */ .im, {
    height: 200
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor__WEBPACK_IMPORTED_MODULE_5__/* .DataEditor */ .N, {
    getCellContent: getContent,
    columns: columns,
    rows: data.length,
    onHeaderMenuClick: onHeaderMenuClickedStage2
  }), showMenu !== undefined && renderLayer(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", _extends({}, layerProps, {
    style: { ...layerProps.style,
      width: 300,
      padding: 4,
      borderRadius: 8,
      backgroundColor: "white",
      border: "1px solid black"
    }
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("ul", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, "Item 1"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, "Item 2"), react__WEBPACK_IMPORTED_MODULE_0__.createElement("li", null, "Item 3"))))));
};
Menus.storyName = "09. Menus";
Menus.parameters = {
  options: {
    showPanel: false
  }
};
const __namedExportsOrder = ["Menus"];

/***/ }),

/***/ "./packages/core/src/docs/doc-wrapper.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "M2": () => (/* binding */ Marked),
/* harmony export */   "im": () => (/* binding */ Wrapper),
/* harmony export */   "kT": () => (/* binding */ DocWrapper),
/* harmony export */   "y$": () => (/* binding */ Highlight)
/* harmony export */ });
/* unused harmony exports PropName, Description, MoreInfo */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/marked/lib/marked.esm.js");
/* harmony import */ var react_syntax_highlighter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/react-syntax-highlighter/dist/esm/default-highlight.js");
/* harmony import */ var react_syntax_highlighter_dist_esm_styles_hljs_github__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/react-syntax-highlighter/dist/esm/styles/hljs/github.js");





const Wrapper = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "Wrapper",
  class: "w1gh5fuv",
  vars: {
    "w1gh5fuv-0": [p => p.height, "px"]
  }
});
const Highlight = p => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_syntax_highlighter__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z, {
    style: react_syntax_highlighter_dist_esm_styles_hljs_github__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z,
    showLineNumbers: true,
    lineNumberStyle: {
      opacity: 0.5
    },
    language: "typescript"
  }, p.children.trim());
};
const Marked = p => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "marked",
    dangerouslySetInnerHTML: {
      __html: (0,marked__WEBPACK_IMPORTED_MODULE_1__/* .marked */ .TU)(p.children)
    }
  });
};
const BeautifulStyle = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "BeautifulStyle",
  class: "b1bk6rj1"
});
const PropName = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('span')({
  name: "PropName",
  class: "p65g85a"
});
const Description = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('p')({
  name: "Description",
  class: "d2b9oy3"
});
const MoreInfo = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('p')({
  name: "MoreInfo",
  class: "mnvl60p"
});
const DocWrapper = p => {
  const {
    children
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(BeautifulStyle, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "inner"
  }, children));
};

__webpack_require__("./packages/core/src/docs/doc-wrapper.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/docs/doc-wrapper.tsx");

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Simplenotest": () => (/* binding */ Simplenotest),
/* harmony export */   "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _stories_story_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./packages/core/src/stories/story-utils.tsx");
/* harmony import */ var _scrolling_data_grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./packages/core/src/data-grid/data-grid-types.ts");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./packages/core/src/common/styles.ts");
/* harmony import */ var _data_grid_cells__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./packages/core/src/data-grid/cells/index.ts");







const InnerContainer = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)('div')({
  name: "InnerContainer",
  class: "i1ua65x0"
});

const getCellRenderer = cell => {
  if (cell.kind === _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Custom */ .p6.Custom) return undefined;
  return _data_grid_cells__WEBPACK_IMPORTED_MODULE_3__/* .CellRenderers */ .L[cell.kind];
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  title: "Subcomponents/ScrollingDataGrid",
  decorators: [Story => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stories_story_utils__WEBPACK_IMPORTED_MODULE_4__/* .BuilderThemeWrapper */ .j, {
    width: 1500,
    height: 1000
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerContainer, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Story, null))))]
});
function Simplenotest() {
  const [x, setX] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [y, setY] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [translateX, setTx] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [translateY, setTy] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const onVisibleRegionChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((range, tx, ty) => {
    setX(range.x);
    setY(range.y);
    setTx(tx);
    setTy(ty);
  }, []);
  const columns = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let j = 0;
    return ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten"].map(t => ({
      title: t,
      width: 122 + (j += 50)
    }));
  }, []);
  const getCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;
    return {
      kind: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .GridCellKind.Text */ .p6.Text,
      displayData: `${col},${row} Testing things that are way too long`,
      data: `${col},${row} Testing things that are way too long`,
      allowOverlay: true
    };
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_scrolling_data_grid__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z, {
    getCellRenderer: getCellRenderer,
    onMouseMove: () => undefined,
    rows: 10000,
    enableGroups: false,
    clientSize: [1000, 1000],
    cellXOffset: x,
    cellYOffset: y,
    drawHeader: undefined,
    experimental: undefined,
    headerIcons: undefined,
    isDraggable: undefined,
    onCanvasBlur: () => undefined,
    onCanvasFocused: () => undefined,
    onCellFocused: () => undefined,
    onContextMenu: () => undefined,
    onDragEnd: () => undefined,
    onDragLeave: () => undefined,
    onDragOverCell: () => undefined,
    onDragStart: () => undefined,
    onDrop: () => undefined,
    onItemHovered: () => undefined,
    onKeyDown: () => undefined,
    onKeyUp: () => undefined,
    onMouseDown: () => undefined,
    onMouseUp: () => undefined,
    canvasRef: undefined,
    className: undefined,
    disabledRows: undefined,
    fillHandle: undefined,
    fixedShadowX: undefined,
    fixedShadowY: undefined,
    getGroupDetails: undefined,
    getRowThemeOverride: undefined,
    highlightRegions: undefined,
    imageWindowLoader: undefined,
    onHeaderMenuClick: undefined,
    prelightCells: undefined,
    drawCustomCell: undefined,
    drawFocusRing: undefined,
    initialSize: undefined,
    overscrollX: undefined,
    overscrollY: undefined,
    preventDiagonalScrolling: undefined,
    rightElement: undefined,
    rightElementProps: undefined,
    scrollRef: undefined,
    showMinimap: undefined,
    scrollToEnd: undefined,
    minColumnWidth: 50,
    isFocused: true,
    theme: (0,___WEBPACK_IMPORTED_MODULE_6__/* .getDataEditorTheme */ .Zu)(),
    isFilling: false,
    maxColumnWidth: 500,
    accessibilityHeight: 50,
    translateX: translateX,
    translateY: translateY,
    lockColumns: 0,
    selection: {
      current: undefined,
      rows: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty(),
      columns: _data_grid_data_grid_types__WEBPACK_IMPORTED_MODULE_2__/* .CompactSelection.empty */ .EV.empty()
    },
    firstColAccessible: true,
    groupHeaderHeight: 34,
    headerHeight: 44,
    trailingRowType: "none",
    rowHeight: 34,
    onVisibleRegionChanged: onVisibleRegionChanged,
    columns: columns,
    getCellContent: getCellContent,
    freezeColumns: 0,
    verticalBorder: () => true,
    smoothScrollX: true,
    smoothScrollY: true
  });
}

__webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx");

const __namedExportsOrder = ["Simplenotest"];

/***/ }),

/***/ "./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ scrolling_data_grid)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
// EXTERNAL MODULE: ./node_modules/lodash/clamp.js
var clamp = __webpack_require__("./node_modules/lodash/clamp.js");
var clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);
// EXTERNAL MODULE: ./packages/core/src/data-grid/data-grid.tsx + 7 modules
var data_grid = __webpack_require__("./packages/core/src/data-grid/data-grid.tsx");
;// CONCATENATED MODULE: ./packages/core/src/data-grid-dnd/data-grid-dnd.tsx




function offsetColumnSize(column, width, min, max) {
  var _column$growOffset;

  return clamp_default()(Math.round(width - ((_column$growOffset = column.growOffset) !== null && _column$growOffset !== void 0 ? _column$growOffset : 0)), Math.ceil(min), Math.floor(max));
}

const DataGridDnd = p => {
  var _ref;

  const [resizeColStartX, setResizeColStartX] = react.useState();
  const [resizeCol, setResizeCol] = react.useState();
  const [dragCol, setDragCol] = react.useState();
  const [dropCol, setDropCol] = react.useState();
  const [dragColActive, setDragColActive] = react.useState(false);
  const [dragStartX, setDragStartX] = react.useState();
  const [dragRow, setDragRow] = react.useState();
  const [dropRow, setDropRow] = react.useState();
  const [dragRowActive, setDragRowActive] = react.useState(false);
  const [dragStartY, setDragStartY] = react.useState();
  const {
    onHeaderMenuClick,
    getCellContent,
    onColumnMoved,
    onColumnResize,
    onColumnResizeStart,
    onColumnResizeEnd,
    gridRef,
    maxColumnWidth,
    minColumnWidth,
    onRowMoved,
    lockColumns,
    onMouseDown,
    onMouseUp,
    onItemHovered,
    onDragStart
  } = p;
  const canResize = ((_ref = onColumnResize !== null && onColumnResize !== void 0 ? onColumnResize : onColumnResizeEnd) !== null && _ref !== void 0 ? _ref : onColumnResizeStart) !== undefined;
  const {
    columns,
    selection
  } = p;
  const selectedColumns = selection.columns;
  const onItemHoveredImpl = react.useCallback(args => {
    const [col, row] = args.location;

    if (dragCol !== undefined && dropCol !== col && col >= lockColumns) {
      setDragColActive(true);
      setDropCol(col);
    } else if (dragRow !== undefined && row !== undefined) {
      setDragRowActive(true);
      setDropRow(Math.max(0, row));
    } else {
      onItemHovered === null || onItemHovered === void 0 ? void 0 : onItemHovered(args);
    }
  }, [dragCol, dragRow, dropCol, onItemHovered, lockColumns]);
  const canDragCol = onColumnMoved !== undefined;
  const onMouseDownImpl = react.useCallback(args => {
    if (args.button === 0) {
      const [col, row] = args.location;

      if (args.kind === "out-of-bounds" && args.isEdge && canResize) {
        var _gridRef$current;

        const bounds = gridRef === null || gridRef === void 0 ? void 0 : (_gridRef$current = gridRef.current) === null || _gridRef$current === void 0 ? void 0 : _gridRef$current.getBounds(columns.length - 1, -1);

        if (bounds !== undefined) {
          setResizeColStartX(bounds.x);
          setResizeCol(columns.length - 1);
        }
      } else if (args.kind === "header" && col >= lockColumns) {
        if (args.isEdge && canResize) {
          var _columns$col$growOffs;

          setResizeColStartX(args.bounds.x);
          setResizeCol(col);
          onColumnResizeStart === null || onColumnResizeStart === void 0 ? void 0 : onColumnResizeStart(columns[col], args.bounds.width, col, args.bounds.width + ((_columns$col$growOffs = columns[col].growOffset) !== null && _columns$col$growOffs !== void 0 ? _columns$col$growOffs : 0));
        } else if (args.kind === "header" && canDragCol) {
          setDragStartX(args.bounds.x);
          setDragCol(col);
        }
      } else if (args.kind === "cell" && lockColumns > 0 && col === 0 && row !== undefined && onRowMoved !== undefined) {
        setDragStartY(args.bounds.y);
        setDragRow(row);
      }
    }

    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(args);
  }, [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart]);
  const onHeaderMenuClickMangled = react.useCallback((col, screenPosition) => {
    if (dragColActive || dragRowActive) return;
    onHeaderMenuClick === null || onHeaderMenuClick === void 0 ? void 0 : onHeaderMenuClick(col, screenPosition);
  }, [dragColActive, dragRowActive, onHeaderMenuClick]);
  const lastResizeWidthRef = react.useRef(-1);
  const clearAll = react.useCallback(() => {
    lastResizeWidthRef.current = -1;
    setDragRow(undefined);
    setDropRow(undefined);
    setDragStartY(undefined);
    setDragRowActive(false);
    setDragCol(undefined);
    setDropCol(undefined);
    setDragStartX(undefined);
    setDragColActive(false);
    setResizeCol(undefined);
    setResizeColStartX(undefined);
  }, []);
  const onMouseUpImpl = react.useCallback((args, isOutside) => {
    if (args.button === 0) {
      if (resizeCol !== undefined) {
        var _columns$resizeCol$gr;

        if ((selectedColumns === null || selectedColumns === void 0 ? void 0 : selectedColumns.hasIndex(resizeCol)) === true) {
          for (const c of selectedColumns) {
            var _col$growOffset;

            if (c === resizeCol) continue;
            const col = columns[c];
            const newSize = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
            onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(col, newSize, c, newSize + ((_col$growOffset = col.growOffset) !== null && _col$growOffset !== void 0 ? _col$growOffset : 0));
          }
        }

        const ns = offsetColumnSize(columns[resizeCol], lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
        onColumnResizeEnd === null || onColumnResizeEnd === void 0 ? void 0 : onColumnResizeEnd(columns[resizeCol], ns, resizeCol, ns + ((_columns$resizeCol$gr = columns[resizeCol].growOffset) !== null && _columns$resizeCol$gr !== void 0 ? _columns$resizeCol$gr : 0));

        for (const c of selectedColumns) {
          var _col$growOffset2;

          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResizeEnd === null || onColumnResizeEnd === void 0 ? void 0 : onColumnResizeEnd(col, s, c, s + ((_col$growOffset2 = col.growOffset) !== null && _col$growOffset2 !== void 0 ? _col$growOffset2 : 0));
        }
      }

      clearAll();

      if (dragCol !== undefined && dropCol !== undefined) {
        onColumnMoved === null || onColumnMoved === void 0 ? void 0 : onColumnMoved(dragCol, dropCol);
      }

      if (dragRow !== undefined && dropRow !== undefined) {
        onRowMoved === null || onRowMoved === void 0 ? void 0 : onRowMoved(dragRow, dropRow);
      }
    }

    onMouseUp === null || onMouseUp === void 0 ? void 0 : onMouseUp(args, isOutside);
  }, [onMouseUp, resizeCol, dragCol, dropCol, dragRow, dropRow, selectedColumns, onColumnResizeEnd, columns, minColumnWidth, maxColumnWidth, onColumnResize, onColumnMoved, onRowMoved, clearAll]);
  const dragOffset = react.useMemo(() => {
    if (dragCol === undefined || dropCol === undefined) return undefined;
    if (dragCol === dropCol) return undefined;
    return {
      src: dragCol,
      dest: dropCol
    };
  }, [dragCol, dropCol]);
  const onMouseMove = react.useCallback(event => {
    if (dragCol !== undefined && dragStartX !== undefined) {
      const diff = Math.abs(event.clientX - dragStartX);

      if (diff > 20) {
        setDragColActive(true);
      }
    } else if (dragRow !== undefined && dragStartY !== undefined) {
      const diff = Math.abs(event.clientY - dragStartY);

      if (diff > 20) {
        setDragRowActive(true);
      }
    } else if (resizeCol !== undefined && resizeColStartX !== undefined) {
      var _column$growOffset2;

      const column = columns[resizeCol];
      const newWidth = event.clientX - resizeColStartX;
      const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);
      onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(column, ns, resizeCol, ns + ((_column$growOffset2 = column.growOffset) !== null && _column$growOffset2 !== void 0 ? _column$growOffset2 : 0));
      lastResizeWidthRef.current = newWidth;

      if ((selectedColumns === null || selectedColumns === void 0 ? void 0 : selectedColumns.first()) === resizeCol) {
        for (const c of selectedColumns) {
          var _col$growOffset3;

          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(col, s, c, s + ((_col$growOffset3 = col.growOffset) !== null && _col$growOffset3 !== void 0 ? _col$growOffset3 : 0));
        }
      }
    }
  }, [dragCol, dragStartX, dragRow, dragStartY, resizeCol, resizeColStartX, columns, minColumnWidth, maxColumnWidth, onColumnResize, selectedColumns]);
  const getMangledCellContent = react.useCallback(cell => {
    if (dragRow === undefined || dropRow === undefined) return getCellContent(cell);
    let [col, row] = cell;

    if (row === dropRow) {
      row = dragRow;
    } else {
      if (row > dropRow) row -= 1;
      if (row >= dragRow) row += 1;
    }

    return getCellContent([col, row]);
  }, [dragRow, dropRow, getCellContent]);
  const onDragStartImpl = react.useCallback(args => {
    onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(args);

    if (!args.defaultPrevented()) {
      clearAll();
    }
  }, [clearAll, onDragStart]);
  return react.createElement(data_grid/* default */.Z, {
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    enableGroups: p.enableGroups,
    eventTargetRef: p.eventTargetRef,
    experimental: p.experimental,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    headerIcons: p.headerIcons,
    height: p.height,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isDraggable: p.isDraggable,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDrop: p.onDrop,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    width: p.width,
    getCellContent: getMangledCellContent,
    isResizing: resizeCol !== undefined,
    onHeaderMenuClick: onHeaderMenuClickMangled,
    isDragging: dragColActive,
    onItemHovered: onItemHoveredImpl,
    onDragStart: onDragStartImpl,
    onMouseDown: onMouseDownImpl,
    allowResize: onColumnResize !== undefined,
    onMouseUp: onMouseUpImpl,
    dragAndDropState: dragOffset,
    onMouseMoveRaw: onMouseMove,
    ref: gridRef
  });
};

/* harmony default export */ const data_grid_dnd = (DataGridDnd);
;// CONCATENATED MODULE: ./packages/core/src/common/resize-detector.ts

function useResizeDetector(initialSize) {
  const ref = (0,react.useRef)(null);
  const [size, setSize] = (0,react.useState)({
    width: initialSize === null || initialSize === void 0 ? void 0 : initialSize[0],
    height: initialSize === null || initialSize === void 0 ? void 0 : initialSize[1]
  });
  (0,react.useLayoutEffect)(() => {
    const resizeCallback = entries => {
      for (const entry of entries) {
        const {
          width,
          height
        } = entry && entry.contentRect || {};
        setSize(cv => cv.width === width && cv.height === height ? cv : {
          width,
          height
        });
      }
    };

    const resizeObserver = new window.ResizeObserver(resizeCallback);

    if (ref.current) {
      resizeObserver.observe(ref.current, undefined);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [ref.current]);
  return {
    ref,
    ...size
  };
}
// EXTERNAL MODULE: ./packages/core/src/common/browser-detect.ts
var browser_detect = __webpack_require__("./packages/core/src/common/browser-detect.ts");
// EXTERNAL MODULE: ./packages/core/src/common/utils.tsx
var utils = __webpack_require__("./packages/core/src/common/utils.tsx");
;// CONCATENATED MODULE: ./packages/core/src/scrolling-data-grid/infinite-scroller.tsx





const ScrollRegionStyle = (0,styled/* default */.Z)('div')({
  name: "ScrollRegionStyle",
  class: "s3se5hb",
  vars: {
    "s3se5hb-0": [p => p.isSafari ? "scroll" : "auto"]
  }
});

function eatEvent(e) {
  e.stopPropagation();
}

function useTouchUpDelayed(delay) {
  const [hasTouches, setHasTouches] = react.useState(false);
  const cbTimer = react.useRef(0);
  (0,utils/* useEventListener */.OR)("touchstart", react.useCallback(() => {
    window.clearTimeout(cbTimer.current);
    setHasTouches(true);
  }, []), window, true, false);
  (0,utils/* useEventListener */.OR)("touchend", react.useCallback(e => {
    if (e.touches.length === 0) {
      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);
    }
  }, [delay]), window, true, false);
  return hasTouches;
}

const InfiniteScroller = p => {
  var _rightElementProps$st, _rightElementProps$fi, _lastProps$current, _lastProps$current2;

  const {
    children,
    clientHeight,
    scrollHeight,
    scrollWidth,
    update,
    draggable,
    className,
    preventDiagonalScrolling = false,
    paddingBottom = 0,
    paddingRight = 0,
    rightElement,
    rightElementProps,
    scrollRef,
    scrollToEnd,
    initialSize,
    minimap
  } = p;
  const padders = [];
  const rightElementSticky = (_rightElementProps$st = rightElementProps === null || rightElementProps === void 0 ? void 0 : rightElementProps.sticky) !== null && _rightElementProps$st !== void 0 ? _rightElementProps$st : false;
  const rightElementFill = (_rightElementProps$fi = rightElementProps === null || rightElementProps === void 0 ? void 0 : rightElementProps.fill) !== null && _rightElementProps$fi !== void 0 ? _rightElementProps$fi : false;
  const offsetY = react.useRef(0);
  const lastScrollY = react.useRef(0);
  const scroller = react.useRef(null);
  const dpr = window.devicePixelRatio;
  react.useEffect(() => {
    const el = scroller.current;
    if (el === null || scrollToEnd !== true) return;
    el.scrollLeft = el.scrollWidth - el.clientWidth;
  }, [scrollToEnd]);
  const lastScrollPosition = react.useRef({
    scrollLeft: 0,
    scrollTop: 0,
    lockDirection: undefined
  });
  const rightWrapRef = react.useRef(null);
  const hasTouches = useTouchUpDelayed(200);
  const [isIdle, setIsIdle] = react.useState(true);
  const idleTimer = react.useRef(0);
  react.useEffect(() => {
    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;
    const el = scroller.current;
    if (el === null) return;
    const [lx, ly] = lastScrollPosition.current.lockDirection;

    if (lx !== undefined) {
      el.scrollLeft = lx;
    } else if (ly !== undefined) {
      el.scrollTop = ly;
    }

    lastScrollPosition.current.lockDirection = undefined;
  }, [hasTouches, isIdle]);
  const onScroll = react.useCallback(() => {
    var _lock$, _lock$2, _rightWrapRef$current, _rightWrapRef$current2;

    const el = scroller.current;
    if (el === null) return;
    let scrollTop = el.scrollTop;
    let scrollLeft = el.scrollLeft;
    const lastScrollTop = lastScrollPosition.current.scrollTop;
    const lastScrollLeft = lastScrollPosition.current.scrollLeft;
    const dx = scrollLeft - lastScrollLeft;
    const dy = scrollTop - lastScrollTop;

    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === undefined) {
      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];
    }

    const lock = lastScrollPosition.current.lockDirection;
    scrollLeft = (_lock$ = lock === null || lock === void 0 ? void 0 : lock[0]) !== null && _lock$ !== void 0 ? _lock$ : scrollLeft;
    scrollTop = (_lock$2 = lock === null || lock === void 0 ? void 0 : lock[1]) !== null && _lock$2 !== void 0 ? _lock$2 : scrollTop;
    lastScrollPosition.current.scrollLeft = scrollLeft;
    lastScrollPosition.current.scrollTop = scrollTop;
    const newY = scrollTop;
    const delta = lastScrollY.current - newY;
    const scrollableHeight = el.scrollHeight - el.clientHeight;
    lastScrollY.current = newY;

    if (scrollableHeight > 0 && (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {
      const prog = newY / scrollableHeight;
      const recomputed = (scrollHeight - el.clientHeight) * prog;
      offsetY.current = recomputed - newY;
    }

    if (lock !== undefined) {
      window.clearTimeout(idleTimer.current);
      setIsIdle(false);
      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);
    }

    update({
      x: scrollLeft,
      y: newY + offsetY.current,
      width: el.clientWidth - paddingRight,
      height: el.clientHeight - paddingBottom,
      paddingRight: (_rightWrapRef$current = (_rightWrapRef$current2 = rightWrapRef.current) === null || _rightWrapRef$current2 === void 0 ? void 0 : _rightWrapRef$current2.clientWidth) !== null && _rightWrapRef$current !== void 0 ? _rightWrapRef$current : 0
    });
  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);
  const onScrollRef = react.useRef(onScroll);
  onScrollRef.current = onScroll;
  const lastProps = react.useRef();
  react.useEffect(() => {
    onScroll();
  }, [onScroll, paddingBottom, paddingRight]);
  const setRefs = react.useCallback(instance => {
    scroller.current = instance;

    if (scrollRef !== undefined) {
      scrollRef.current = instance;
    }
  }, [scrollRef]);
  let key = 0;
  let h = 0;
  padders.push(react.createElement("div", {
    key: key++,
    style: {
      width: scrollWidth,
      height: 0
    }
  }));

  while (h < scrollHeight) {
    const toAdd = Math.min(5000000, scrollHeight - h);
    padders.push(react.createElement("div", {
      key: key++,
      style: {
        width: 0,
        height: toAdd
      }
    }));
    h += toAdd;
  }

  const {
    ref,
    width,
    height
  } = useResizeDetector(initialSize);

  if (((_lastProps$current = lastProps.current) === null || _lastProps$current === void 0 ? void 0 : _lastProps$current.height) !== height || ((_lastProps$current2 = lastProps.current) === null || _lastProps$current2 === void 0 ? void 0 : _lastProps$current2.width) !== width) {
    window.setTimeout(() => onScrollRef.current(), 0);
    lastProps.current = {
      width,
      height
    };
  }

  if ((width !== null && width !== void 0 ? width : 0) === 0 || (height !== null && height !== void 0 ? height : 0) === 0) return react.createElement("div", {
    ref: ref
  });
  return react.createElement("div", {
    ref: ref
  }, react.createElement(ScrollRegionStyle, {
    isSafari: browser_detect/* browserIsSafari.value */.Pq.value
  }, minimap, react.createElement("div", {
    className: "dvn-underlay"
  }, children), react.createElement("div", {
    ref: setRefs,
    style: lastProps.current,
    draggable: draggable,
    onDragStart: e => {
      if (!draggable) {
        e.stopPropagation();
        e.preventDefault();
      }
    },
    className: "dvn-scroller " + (className !== null && className !== void 0 ? className : ""),
    onScroll: onScroll
  }, react.createElement("div", {
    className: "dvn-scroll-inner" + (rightElement === undefined ? " hidden" : "")
  }, react.createElement("div", {
    className: "dvn-stack"
  }, padders), rightElement !== undefined && react.createElement(react.Fragment, null, !rightElementFill && react.createElement("div", {
    className: "dvn-spacer"
  }), react.createElement("div", {
    ref: rightWrapRef,
    onMouseDown: eatEvent,
    onMouseUp: eatEvent,
    onMouseMove: eatEvent,
    style: {
      height,
      maxHeight: clientHeight - Math.ceil(dpr % 1),
      position: "sticky",
      top: 0,
      paddingLeft: 1,
      marginBottom: -40,
      marginRight: paddingRight,
      flexGrow: rightElementFill ? 1 : undefined,
      right: rightElementSticky ? paddingRight !== null && paddingRight !== void 0 ? paddingRight : 0 : undefined,
      pointerEvents: "auto"
    }
  }, rightElement))))));
};

__webpack_require__("./packages/core/src/scrolling-data-grid/infinite-scroller.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/infinite-scroller.tsx");
;// CONCATENATED MODULE: ./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx





const MinimapStyle = (0,styled/* default */.Z)('div')({
  name: "MinimapStyle",
  class: "m3brspx"
});

const GridScroller = p => {
  var _scrollRef$current, _scroller$scrollLeft, _scroller$scrollTop;

  const {
    columns,
    rows,
    rowHeight,
    headerHeight,
    groupHeaderHeight,
    enableGroups,
    freezeColumns,
    experimental,
    clientSize,
    className,
    onVisibleRegionChanged,
    scrollToEnd,
    scrollRef,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    overscrollX,
    overscrollY,
    showMinimap = false,
    initialSize,
    smoothScrollX = false,
    smoothScrollY = false,
    isDraggable
  } = p;
  const {
    paddingRight,
    paddingBottom
  } = experimental !== null && experimental !== void 0 ? experimental : {};
  const [clientWidth, clientHeight] = clientSize;
  const last = react.useRef();
  const lastX = react.useRef();
  const lastY = react.useRef();
  const lastSize = react.useRef();
  const width = react.useMemo(() => {
    let r = Math.max(0, overscrollX !== null && overscrollX !== void 0 ? overscrollX : 0);

    for (const c of columns) {
      r += c.width;
    }

    return r;
  }, [columns, overscrollX]);
  let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;

  if (typeof rowHeight === "number") {
    height += rows * rowHeight;
  } else {
    for (let r = 0; r < rows; r++) {
      height += rowHeight(r);
    }
  }

  if (overscrollY !== undefined) {
    height += overscrollY;
  }

  const lastArgs = react.useRef();
  const processArgs = react.useCallback(() => {
    var _lastSize$current, _lastSize$current2;

    if (lastArgs.current === undefined) return;
    const args = { ...lastArgs.current
    };
    let x = 0;
    let tx = args.x < 0 ? -args.x : 0;
    let cellRight = 0;
    let cellX = 0;
    args.x = args.x < 0 ? 0 : args.x;
    let stickyColWidth = 0;

    for (let i = 0; i < freezeColumns; i++) {
      stickyColWidth += columns[i].width;
    }

    for (const c of columns) {
      const cx = x - stickyColWidth;

      if (args.x >= cx + c.width) {
        x += c.width;
        cellX++;
        cellRight++;
      } else if (args.x > cx) {
        x += c.width;

        if (smoothScrollX) {
          tx += cx - args.x;
        } else {
          cellX++;
        }

        cellRight++;
      } else if (args.x + args.width > cx) {
        x += c.width;
        cellRight++;
      } else {
        break;
      }
    }

    let ty = 0;
    let cellY = 0;
    let cellBottom = 0;

    if (typeof rowHeight === "number") {
      if (smoothScrollY) {
        cellY = Math.floor(args.y / rowHeight);
        ty = cellY * rowHeight - args.y;
      } else {
        cellY = Math.ceil(args.y / rowHeight);
      }

      cellBottom = Math.ceil(args.height / rowHeight) + cellY;
      if (ty < 0) cellBottom++;
    } else {
      let y = 0;

      for (let row = 0; row < rows; row++) {
        const rh = rowHeight(row);
        const cy = y + (smoothScrollY ? 0 : rh / 2);

        if (args.y >= y + rh) {
          y += rh;
          cellY++;
          cellBottom++;
        } else if (args.y > cy) {
          y += rh;

          if (smoothScrollY) {
            ty += cy - args.y;
          } else {
            cellY++;
          }

          cellBottom++;
        } else if (args.y + args.height > rh / 2 + y) {
          y += rh;
          cellBottom++;
        } else {
          break;
        }
      }
    }

    const rect = {
      x: cellX,
      y: cellY,
      width: cellRight - cellX,
      height: cellBottom - cellY
    };
    const oldRect = last.current;

    if (oldRect === undefined || oldRect.y !== rect.y || oldRect.x !== rect.x || oldRect.height !== rect.height || oldRect.width !== rect.width || lastX.current !== tx || lastY.current !== ty || args.width !== ((_lastSize$current = lastSize.current) === null || _lastSize$current === void 0 ? void 0 : _lastSize$current[0]) || args.height !== ((_lastSize$current2 = lastSize.current) === null || _lastSize$current2 === void 0 ? void 0 : _lastSize$current2[1])) {
      var _args$paddingRight;

      onVisibleRegionChanged === null || onVisibleRegionChanged === void 0 ? void 0 : onVisibleRegionChanged({
        x: cellX,
        y: cellY,
        width: cellRight - cellX,
        height: cellBottom - cellY
      }, args.width, args.height, (_args$paddingRight = args.paddingRight) !== null && _args$paddingRight !== void 0 ? _args$paddingRight : 0, tx, ty);
      last.current = rect;
      lastX.current = tx;
      lastY.current = ty;
      lastSize.current = [args.width, args.height];
    }
  }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);
  const onScrollUpdate = react.useCallback(args => {
    lastArgs.current = args;
    processArgs();
  }, [processArgs]);
  react.useEffect(() => {
    processArgs();
  }, [processArgs]);
  const scroller = (_scrollRef$current = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) !== null && _scrollRef$current !== void 0 ? _scrollRef$current : undefined;
  const aspect = clamp_default()(width / height, 2 / 3, 1.5);
  const maxSize = 200;
  const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);
  const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;
  const hRatio = w / width;
  const vRatio = h / height;
  const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);
  const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);
  const left = ((_scroller$scrollLeft = scroller === null || scroller === void 0 ? void 0 : scroller.scrollLeft) !== null && _scroller$scrollLeft !== void 0 ? _scroller$scrollLeft : 0) / (width - clientWidth) * (w - vWidth);
  const top = ((_scroller$scrollTop = scroller === null || scroller === void 0 ? void 0 : scroller.scrollTop) !== null && _scroller$scrollTop !== void 0 ? _scroller$scrollTop : 0) / (height - clientHeight) * (h - vHeight);
  const minimap = react.useMemo(() => {
    if (!showMinimap || vWidth === 0 || vHeight === 0) return undefined;

    const handleMouse = e => {
      if (scroller === undefined) return;
      const bounds = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - bounds.x - vWidth / 2;
      const y = e.clientY - bounds.y - vHeight / 2;
      const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));
      const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));
      scroller.scrollTo({
        left: newScrollLeft,
        top: newScrollTop,
        behavior: e.type === "mousemove" ? "auto" : "smooth"
      });
    };

    return react.createElement(MinimapStyle, {
      style: {
        width: w,
        height: h
      },
      "data-testid": "minimap-container",
      onMouseMove: e => {
        if (e.buttons !== 1) return;
        handleMouse(e);
      },
      onClick: handleMouse
    }, react.createElement("div", {
      className: "header"
    }), react.createElement("div", {
      className: "locationMarker",
      onDragStart: e => e.preventDefault(),
      style: {
        left,
        top,
        width: vWidth,
        height: vHeight,
        borderRadius: Math.min(vWidth, vHeight * 0.2, 9)
      }
    }));
  }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);
  return react.createElement(InfiniteScroller, {
    scrollRef: scrollRef,
    minimap: minimap,
    className: className,
    preventDiagonalScrolling: preventDiagonalScrolling,
    draggable: isDraggable === true || typeof isDraggable === "string",
    scrollWidth: width + (paddingRight !== null && paddingRight !== void 0 ? paddingRight : 0),
    scrollHeight: height + (paddingBottom !== null && paddingBottom !== void 0 ? paddingBottom : 0),
    clientHeight: clientHeight,
    rightElement: rightElement,
    paddingBottom: paddingBottom,
    paddingRight: paddingRight,
    rightElementProps: rightElementProps,
    update: onScrollUpdate,
    initialSize: initialSize,
    scrollToEnd: scrollToEnd
  }, react.createElement(data_grid_dnd, {
    eventTargetRef: scrollRef,
    width: clientWidth,
    height: clientHeight,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY
  }));
};

/* harmony default export */ const scrolling_data_grid = (GridScroller);

__webpack_require__("./packages/core/src/scrolling-data-grid/scrolling-data-grid.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/scrolling-data-grid/scrolling-data-grid.tsx");

/***/ }),

/***/ "./packages/core/src/stories/story-utils.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ SimpleThemeWrapper),
/* harmony export */   "j": () => (/* binding */ BuilderThemeWrapper)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
/* harmony import */ var react_responsive_carousel_lib_styles_carousel_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/react-responsive-carousel/lib/styles/carousel.min.css");



const BuilderWrapper = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "BuilderWrapper",
  class: "bheiboo",
  vars: {
    "bheiboo-0": [p => p.width, "px"],
    "bheiboo-1": [p => p.height, "px"]
  }
});
const SimpleWrapper = (0,_linaria_react__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)('div')({
  name: "SimpleWrapper",
  class: "s15ez7jv"
});
class BuilderThemeWrapper extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  render() {
    const {
      context,
      children,
      ...rest
    } = this.props;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(BuilderWrapper, rest, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "content"
    }, children)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "portal"
    }));
  }

}
const SimpleThemeWrapper = p => {
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SimpleWrapper, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "content"
  }, p.children));
};

__webpack_require__("./packages/core/src/stories/story-utils.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/core/src/stories/story-utils.tsx");

/***/ }),

/***/ "./packages/source/src/use-data-source.stories.tsx":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "UseDataSource": () => (/* binding */ UseDataSource),
  "__namedExportsOrder": () => (/* binding */ __namedExportsOrder),
  "default": () => (/* binding */ use_data_source_stories)
});

// EXTERNAL MODULE: ./node_modules/@linaria/react/esm/styled.js + 3 modules
var styled = __webpack_require__("./node_modules/@linaria/react/esm/styled.js");
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__("./node_modules/react/index.js");
// EXTERNAL MODULE: ./node_modules/react-resize-detector/build/index.esm.js
var index_esm = __webpack_require__("./node_modules/react-resize-detector/build/index.esm.js");
// EXTERNAL MODULE: ./packages/core/dist/js/index.js
var js = __webpack_require__("./packages/core/dist/js/index.js");
// EXTERNAL MODULE: ./node_modules/faker/index.js
var faker = __webpack_require__("./node_modules/faker/index.js");
var faker_default = /*#__PURE__*/__webpack_require__.n(faker);
// EXTERNAL MODULE: ./node_modules/lodash/orderBy.js
var orderBy = __webpack_require__("./node_modules/lodash/orderBy.js");
var orderBy_default = /*#__PURE__*/__webpack_require__.n(orderBy);
;// CONCATENATED MODULE: ./packages/source/src/use-movable-columns.ts



function colToKey(c) {
  var _c$id, _c$group;

  return (_c$id = c.id) !== null && _c$id !== void 0 ? _c$id : `${(_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : ""}/${c.title}`;
}

function looseCompareCol(a, b) {
  if (typeof b === "string") {
    return colToKey(a) === b;
  }

  return colToKey(a) === colToKey(b);
}

function getSortIndexByKey(needle, current, keys) {
  const index = current.indexOf(needle);
  if (index === -1) return Number.MAX_SAFE_INTEGER;
  const remapped = keys.findIndex(key => looseCompareCol(needle, key));
  if (remapped !== -1) return remapped;

  for (let n = index; n >= 0; n--) {
    const ind = keys.findIndex(key => looseCompareCol(current[n], key));
    if (ind !== -1) return ind + 0.5;
  }

  return -1;
}

function useMoveableColumns(p) {
  const {
    columns: columnsIn,
    getCellContent: getCellContentIn,
    onColumnMoved: onColumnMovedIn
  } = p;
  const [keys, setKeys] = react.useState(() => columnsIn.map(colToKey));
  const columns = react.useMemo(() => {
    return orderBy_default()(columnsIn, c => getSortIndexByKey(c, columnsIn, keys));
  }, [keys, columnsIn]);
  const onColumnMovedRef = react.useRef(onColumnMovedIn);
  onColumnMovedRef.current = onColumnMovedIn;
  const onColumnMoved = react.useCallback((startIndex, endIndex) => {
    var _onColumnMovedRef$cur;

    setKeys(old => {
      const newCols = [...old];
      const [toMove] = newCols.splice(startIndex, 1);
      newCols.splice(endIndex, 0, toMove);
      return newCols;
    });
    (_onColumnMovedRef$cur = onColumnMovedRef.current) === null || _onColumnMovedRef$cur === void 0 ? void 0 : _onColumnMovedRef$cur.call(onColumnMovedRef, startIndex, endIndex);
  }, []);
  react.useEffect(() => {
    setKeys(cv => {
      return orderBy_default()(columnsIn, x => getSortIndexByKey(x, columnsIn, cv)).map(colToKey);
    });
  }, [columnsIn]);
  const getCellContent = react.useCallback(cell => {
    const [col, row] = cell;
    const needle = columns[col];
    const index = columnsIn.indexOf(needle);
    return getCellContentIn([index, row]);
  }, [columns, columnsIn, getCellContentIn]);
  return {
    columns,
    onColumnMoved,
    getCellContent
  };
}
// EXTERNAL MODULE: ./node_modules/lodash/range.js
var range = __webpack_require__("./node_modules/lodash/range.js");
var range_default = /*#__PURE__*/__webpack_require__.n(range);
;// CONCATENATED MODULE: ./packages/source/src/use-column-sort.ts




function cellToSortData(c) {
  var _c$data$toString, _c$data, _c$data$toString2, _c$data2, _c$data3;

  switch (c.kind) {
    case js/* GridCellKind.Number */.p6.Number:
      return (_c$data$toString = (_c$data = c.data) === null || _c$data === void 0 ? void 0 : _c$data.toString()) !== null && _c$data$toString !== void 0 ? _c$data$toString : "";

    case js/* GridCellKind.Boolean */.p6.Boolean:
      return (_c$data$toString2 = (_c$data2 = c.data) === null || _c$data2 === void 0 ? void 0 : _c$data2.toString()) !== null && _c$data$toString2 !== void 0 ? _c$data$toString2 : "";

    case js/* GridCellKind.Markdown */.p6.Markdown:
    case js/* GridCellKind.RowID */.p6.RowID:
    case js/* GridCellKind.Text */.p6.Text:
    case js/* GridCellKind.Uri */.p6.Uri:
      return (_c$data3 = c.data) !== null && _c$data3 !== void 0 ? _c$data3 : "";

    case js/* GridCellKind.Bubble */.p6.Bubble:
    case js/* GridCellKind.Image */.p6.Image:
      return c.data.join("");

    case js/* GridCellKind.Drilldown */.p6.Drilldown:
      return c.data.map(x => x.text).join("");

    case js/* GridCellKind.Protected */.p6.Protected:
    case js/* GridCellKind.Loading */.p6.Loading:
      return "";

    case js/* GridCellKind.Custom */.p6.Custom:
      return c.copyData;
  }
}

function tryParse(val) {
  if (typeof val === "number") return val;

  if (val.length > 0) {
    const x = parseFloat(val);

    if (!isNaN(x)) {
      val = x;
    }
  }

  return val;
}

function compareSmart(a, b) {
  a = tryParse(a);
  b = tryParse(b);

  if (typeof a === "string" && typeof b === "string") {
    return a.localeCompare(b);
  } else if (typeof a === "number" && typeof b === "number") {
    if (a === b) return 0;
    return a > b ? 1 : -1;
  } else if (a == b) {
    return 0;
  }

  return a > b ? 1 : -1;
}
function compareRaw(a, b) {
  if (a > b) return 1;
  if (a === b) return 0;
  return -1;
}
function useColumnSort(p) {
  var _sort$direction;

  const {
    sort,
    rows,
    getCellContent: getCellContentIn
  } = p;
  let sortCol = sort === undefined ? undefined : p.columns.findIndex(c => sort.column === c || c.id !== undefined && sort.column.id === c.id);
  if (sortCol === -1) sortCol = undefined;
  const dir = (_sort$direction = sort === null || sort === void 0 ? void 0 : sort.direction) !== null && _sort$direction !== void 0 ? _sort$direction : "asc";
  const sortMap = react.useMemo(() => {
    if (sortCol === undefined) return undefined;
    const vals = new Array(rows);
    const index = [sortCol, 0];

    for (let i = 0; i < rows; i++) {
      index[1] = i;
      vals[i] = cellToSortData(getCellContentIn(index));
    }

    let result;

    if ((sort === null || sort === void 0 ? void 0 : sort.mode) === "raw") {
      result = range_default()(rows).sort((a, b) => compareRaw(vals[a], vals[b]));
    } else if ((sort === null || sort === void 0 ? void 0 : sort.mode) === "smart") {
      result = range_default()(rows).sort((a, b) => compareSmart(vals[a], vals[b]));
    } else {
      result = range_default()(rows).sort((a, b) => vals[a].localeCompare(vals[b]));
    }

    if (dir === "desc") {
      result.reverse();
    }

    return result;
  }, [getCellContentIn, rows, sort === null || sort === void 0 ? void 0 : sort.mode, dir, sortCol]);
  const getOriginalIndex = react.useCallback(index => {
    if (sortMap === undefined) return index;
    return sortMap[index];
  }, [sortMap]);
  const getCellContent = react.useCallback(_ref => {
    let [col, row] = _ref;
    if (sortMap === undefined) return getCellContentIn([col, row]);
    row = sortMap[row];
    return getCellContentIn([col, row]);
  }, [getCellContentIn, sortMap]);

  if (sortMap === undefined) {
    return {
      getCellContent: p.getCellContent,
      getOriginalIndex
    };
  }

  return {
    getOriginalIndex,
    getCellContent
  };
}
;// CONCATENATED MODULE: ./packages/source/src/use-collapsing-groups.ts

function useCollapsingGroups(props) {
  const [collapsed, setCollapsed] = react.useState([]);
  const [gridSelectionInner, setGridSelectionsInner] = react.useState(undefined);
  const {
    columns: columnsIn,
    onGroupHeaderClicked: onGroupHeaderClickedIn,
    onGridSelectionChange: onGridSelectionChangeIn,
    getGroupDetails: getGroupDetailsIn,
    gridSelection: gridSelectionIn,
    freezeColumns = 0,
    theme
  } = props;
  const gridSelection = gridSelectionIn !== null && gridSelectionIn !== void 0 ? gridSelectionIn : gridSelectionInner;
  const spans = react.useMemo(() => {
    const result = [];
    let current = [-1, -1];
    let lastGroup;

    for (let i = freezeColumns; i < columnsIn.length; i++) {
      var _c$group;

      const c = columnsIn[i];
      const group = (_c$group = c.group) !== null && _c$group !== void 0 ? _c$group : "";
      const isCollapsed = collapsed.includes(group);

      if (lastGroup !== group && current[0] !== -1) {
        result.push(current);
        current = [-1, -1];
      }

      if (isCollapsed && current[0] !== -1) {
        current[1] += 1;
      } else if (isCollapsed) {
        current = [i, 1];
      } else if (current[0] !== -1) {
        result.push(current);
        current = [-1, -1];
      }

      lastGroup = group;
    }

    if (current[0] !== -1) result.push(current);
    return result;
  }, [collapsed, columnsIn, freezeColumns]);
  const columns = react.useMemo(() => {
    if (spans.length === 0) return columnsIn;
    return columnsIn.map((c, index) => {
      for (const [start, length] of spans) {
        if (index >= start && index < start + length) {
          let width = 8;

          if (index === start + length - 1) {
            width = 36;
          }

          return { ...c,
            width,
            themeOverride: {
              bgCell: theme.bgCellMedium
            }
          };
        }
      }

      return c;
    });
  }, [columnsIn, spans, theme.bgCellMedium]);
  const onGroupHeaderClicked = react.useCallback((index, a) => {
    var _columns$index$group, _columns$index;

    onGroupHeaderClickedIn === null || onGroupHeaderClickedIn === void 0 ? void 0 : onGroupHeaderClickedIn(index, a);
    const group = (_columns$index$group = (_columns$index = columns[index]) === null || _columns$index === void 0 ? void 0 : _columns$index.group) !== null && _columns$index$group !== void 0 ? _columns$index$group : "";
    if (group === "") return;
    a.preventDefault();
    setCollapsed(cv => cv.includes(group) ? cv.filter(x => x !== group) : [...cv, group]);
  }, [columns, onGroupHeaderClickedIn]);
  const onGridSelectionChange = react.useCallback(s => {
    if (s.current !== undefined) {
      const col = s.current.cell[0];
      const column = columns[col];
      setCollapsed(cv => {
        var _column$group;

        if (cv.includes((_column$group = column === null || column === void 0 ? void 0 : column.group) !== null && _column$group !== void 0 ? _column$group : "")) {
          return cv.filter(g => g !== column.group);
        }

        return cv;
      });
    }

    if (onGridSelectionChangeIn !== undefined) {
      onGridSelectionChangeIn(s);
    } else {
      setGridSelectionsInner(s);
    }
  }, [columns, onGridSelectionChangeIn]);
  const getGroupDetails = react.useCallback(group => {
    const result = getGroupDetailsIn === null || getGroupDetailsIn === void 0 ? void 0 : getGroupDetailsIn(group);
    return { ...result,
      name: group,
      overrideTheme: collapsed.includes(group !== null && group !== void 0 ? group : "") ? {
        bgHeader: theme.bgHeaderHasFocus
      } : undefined
    };
  }, [collapsed, getGroupDetailsIn, theme.bgHeaderHasFocus]);
  return {
    columns,
    onGroupHeaderClicked,
    onGridSelectionChange,
    getGroupDetails,
    gridSelection
  };
}
;// CONCATENATED MODULE: ./packages/source/src/use-data-source.stories.tsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }







faker_default().seed(1337);
const SimpleWrapper = (0,styled/* default */.Z)('div')({
  name: "SimpleWrapper",
  class: "s1qcunhi"
});

const SimpleThemeWrapper = p => {
  return react.createElement(SimpleWrapper, null, react.createElement("div", {
    className: "content"
  }, p.children));
};

/* harmony default export */ const use_data_source_stories = ({
  title: "Extra Packages/Source",
  decorators: [Story => react.createElement(SimpleThemeWrapper, null, react.createElement(Story, null))]
});
const BeautifulStyle = (0,styled/* default */.Z)('div')({
  name: "BeautifulStyle",
  class: "bd6h1gz"
});

const BeautifulWrapper = p => {
  const {
    title,
    children,
    description
  } = p;
  const {
    ref,
    width,
    height
  } = (0,index_esm/* useResizeDetector */.NB)();
  return react.createElement(BeautifulStyle, null, react.createElement("h1", null, title), description, react.createElement("div", {
    className: "sizer"
  }, react.createElement("div", {
    className: "sizer-clip",
    ref: ref
  }, react.createElement("div", {
    style: {
      position: "relative",
      width: width !== null && width !== void 0 ? width : 100,
      height: height !== null && height !== void 0 ? height : 100
    }
  }, children))));
};

const Description = (0,styled/* default */.Z)('p')({
  name: "Description",
  class: "d8qm2x5"
});
const defaultProps = {
  smoothScrollX: true,
  smoothScrollY: true,
  isDraggable: false,
  rowMarkers: "none",
  width: "100%"
};
const testTheme = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  horizontalBorderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#4F5DFF",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  editorFontSize: "13px",
  lineHeight: 1.4,
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif"
};
const cols = [{
  title: "A",
  width: 200,
  group: "Group 1"
}, {
  title: "B",
  width: 200,
  group: "Group 1"
}, {
  title: "C",
  width: 200,
  group: "Group 2"
}, {
  title: "D",
  width: 200,
  group: "Group 2"
}, {
  title: "E",
  width: 200,
  group: "Group 2"
}];
const UseDataSource = () => {
  const cache = react.useRef({});
  const rows = 100000;
  const moveArgs = useMoveableColumns({
    columns: cols,
    getCellContent: react.useCallback(_ref => {
      let [col, row] = _ref;

      if (col === 0) {
        return {
          kind: js/* GridCellKind.Text */.p6.Text,
          allowOverlay: true,
          data: `${row}`,
          displayData: `${row}`
        };
      }

      const key = `${col},${row}`;

      if (cache.current[key] === undefined) {
        cache.current[key] = faker_default().name.firstName() + " " + faker_default().name.lastName();
      }

      const d = cache.current[key];
      return {
        kind: js/* GridCellKind.Text */.p6.Text,
        allowOverlay: true,
        data: d,
        displayData: d
      };
    }, [])
  });
  const [sort, setSort] = react.useState();
  const sortArgs = useColumnSort({
    columns: moveArgs.columns,
    getCellContent: moveArgs.getCellContent,
    rows,
    sort: sort === undefined ? undefined : {
      column: moveArgs.columns[sort],
      direction: "desc",
      mode: "smart"
    }
  });
  const collapseArgs = useCollapsingGroups({
    columns: moveArgs.columns,
    theme: testTheme,
    freezeColumns: 0
  });
  const onHeaderClick = react.useCallback(index => {
    setSort(index);
  }, []);
  return react.createElement(BeautifulWrapper, {
    title: "Custom source extensions",
    description: react.createElement(Description, null, "Fixme.")
  }, react.createElement(js/* DataEditor */.Nd, _extends({}, defaultProps, moveArgs, sortArgs, collapseArgs, {
    rows: rows,
    onColumnMoved: moveArgs.onColumnMoved,
    onHeaderClicked: onHeaderClick
  })));
};
UseDataSource.parameters = {
  options: {
    showPanel: false
  }
};

__webpack_require__("./packages/source/src/use-data-source.stories.linaria.css!=!./node_modules/@linaria/webpack5-loader/lib/outputCssLoader.js?cacheProvider=!./packages/source/src/use-data-source.stories.tsx");

const __namedExportsOrder = ["UseDataSource"];

/***/ }),

/***/ "./storybook-init-framework-entry.js":
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _storybook_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@storybook/react/dist/esm/client/index.js");


/***/ }),

/***/ "./. sync recursive ^\\.(?:(?:^%7C\\/%7C(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/)src(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.tsx)$":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./packages/cells/src/cell.stories.tsx": "./packages/cells/src/cell.stories.tsx",
	"./packages/core/src/data-editor/stories/data-editor-async.stories.tsx": "./packages/core/src/data-editor/stories/data-editor-async.stories.tsx",
	"./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx": "./packages/core/src/data-editor/stories/data-editor-beautiful.stories.tsx",
	"./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx": "./packages/core/src/data-editor/stories/data-editor-repros.stories.tsx",
	"./packages/core/src/data-editor/stories/data-editor.stories.tsx": "./packages/core/src/data-editor/stories/data-editor.stories.tsx",
	"./packages/core/src/data-grid/data-grid.stories.tsx": "./packages/core/src/data-grid/data-grid.stories.tsx",
	"./packages/core/src/docs/00-faq.stories.tsx": "./packages/core/src/docs/00-faq.stories.tsx",
	"./packages/core/src/docs/01-getting-started.stories.tsx": "./packages/core/src/docs/01-getting-started.stories.tsx",
	"./packages/core/src/docs/02-editing-data.stories.tsx": "./packages/core/src/docs/02-editing-data.stories.tsx",
	"./packages/core/src/docs/03-grid-column.stories.tsx": "./packages/core/src/docs/03-grid-column.stories.tsx",
	"./packages/core/src/docs/04-streaming-data.stories.tsx": "./packages/core/src/docs/04-streaming-data.stories.tsx",
	"./packages/core/src/docs/05-copy-paste.stories.tsx": "./packages/core/src/docs/05-copy-paste.stories.tsx.tsx",
	"./packages/core/src/docs/06-search.stories.tsx": "./packages/core/src/docs/06-search.stories.tsx",
	"./packages/core/src/docs/07-column-grouping.stories.tsx": "./packages/core/src/docs/07-column-grouping.stories.tsx",
	"./packages/core/src/docs/08-theming.stories.tsx": "./packages/core/src/docs/08-theming.stories.tsx",
	"./packages/core/src/docs/09-menus.stories.tsx": "./packages/core/src/docs/09-menus.stories.tsx",
	"./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx": "./packages/core/src/scrolling-data-grid/scrolling-data-grid.stories.tsx",
	"./packages/source/src/use-data-source.stories.tsx": "./packages/source/src/use-data-source.stories.tsx"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./. sync recursive ^\\.(?:(?:^%7C\\/%7C(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/)src(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.tsx)$";

/***/ }),

/***/ "?4f7e":
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./generated-stories-entry.cjs":
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _frameworkImportPath = __webpack_require__("./node_modules/@storybook/react/dist/esm/client/index.js");

/* eslint-disable import/no-unresolved */
(0, _frameworkImportPath.configure)([__webpack_require__("./. sync recursive ^\\.(?:(?:^%7C\\/%7C(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/)src(?:\\/(?%21\\.)(?:(?:(?%21(?:^%7C\\/)\\.).)*?)\\/%7C\\/%7C$)(?%21\\.)(?=.)[^/]*?\\.stories\\.tsx)$")], module, false);

/***/ }),

/***/ "./packages/core/dist/js/chunk-TRLYFRER.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": () => (/* binding */ styled_default)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var memoize_browser_esm_default = memoize;
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var index = memoize_browser_esm_default(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});
var is_prop_valid_browser_esm_default = index;


var cx = function cx2() {
  const presentClassNames = Array.prototype.slice.call(arguments).filter(Boolean);
  const atomicClasses = {};
  const nonAtomicClasses = [];
  presentClassNames.forEach(arg => {
    const individualClassNames = arg ? arg.split(" ") : [];
    individualClassNames.forEach(className => {
      if (className.startsWith("atm_")) {
        const [, keyHash] = className.split("_");
        atomicClasses[keyHash] = className;
      } else {
        nonAtomicClasses.push(className);
      }
    });
  });
  const result = [];

  for (const keyHash in atomicClasses) {
    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {
      result.push(atomicClasses[keyHash]);
    }
  }

  result.push(...nonAtomicClasses);
  return result.join(" ");
};

var cx_default = cx;

var isCapital = ch => ch.toUpperCase() === ch;

var filterKey = keys => key => keys.indexOf(key) === -1;

var omit = (obj, keys) => {
  const res = {};
  Object.keys(obj).filter(filterKey(keys)).forEach(key => {
    res[key] = obj[key];
  });
  return res;
};

function filterProps(component, props, omitKeys) {
  const filteredProps = omit(props, omitKeys);

  if (typeof component === "string" && component.indexOf("-") === -1 && !isCapital(component[0])) {
    Object.keys(filteredProps).forEach(key => {
      if (!is_prop_valid_browser_esm_default(key)) {
        delete filteredProps[key];
      }
    });
  }

  return filteredProps;
}

var warnIfInvalid = (value, componentName) => {
  if (true) {
    if (typeof value === "string" || typeof value === "number" && isFinite(value)) {
      return;
    }

    const stringified = typeof value === "object" ? JSON.stringify(value) : String(value);
    console.warn(`An interpolation evaluated to '${stringified}' in the component '${componentName}', which is probably a mistake. You should explicitly cast or transform the value to a string.`);
  }
};

function styled(tag) {
  return options => {
    if (true) {
      if (Array.isArray(options)) {
        throw new Error('Using the "styled" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly. See https://github.com/callstack/linaria#setup');
      }
    }

    const render = (props, ref) => {
      const {
        as: component = tag,
        class: className
      } = props;
      const filteredProps = filterProps(component, props, ["as", "class"]);
      filteredProps.ref = ref;
      filteredProps.className = options.atomic ? cx_default(options.class, filteredProps.className || className) : cx_default(filteredProps.className || className, options.class);
      const {
        vars
      } = options;

      if (vars) {
        const style = {};

        for (const name in vars) {
          const variable = vars[name];
          const result = variable[0];
          const unit = variable[1] || "";
          const value = typeof result === "function" ? result(props) : result;
          warnIfInvalid(value, options.name);
          style[`--${name}`] = `${value}${unit}`;
        }

        const ownStyle = filteredProps.style || {};
        const keys = Object.keys(ownStyle);

        if (keys.length > 0) {
          keys.forEach(key => {
            style[key] = ownStyle[key];
          });
        }

        filteredProps.style = style;
      }

      if (tag.__linaria && tag !== component) {
        filteredProps.as = component;
        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(tag, filteredProps);
      }

      return react__WEBPACK_IMPORTED_MODULE_0__.createElement(component, filteredProps);
    };

    const Result = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef ? react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(render) : props => {
      const rest = omit(props, ["innerRef"]);
      return render(rest, props.innerRef);
    };
    Result.displayName = options.name;
    Result.__linaria = {
      className: options.class,
      extends: tag
    };
    return Result;
  };
}

var styled_default =  true ? new Proxy(styled, {
  get(o, prop) {
    return o(prop);
  }

}) : 0;


/***/ }),

/***/ "./packages/core/dist/js/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fg": () => (/* binding */ useTheme),
/* harmony export */   "NH": () => (/* binding */ blend),
/* harmony export */   "Nd": () => (/* binding */ DataEditor),
/* harmony export */   "Nz": () => (/* binding */ interpolateColors),
/* harmony export */   "P7": () => (/* binding */ measureTextCached),
/* harmony export */   "R$": () => (/* binding */ useCustomCells),
/* harmony export */   "aX": () => (/* binding */ getMiddleCenterBias),
/* harmony export */   "dF": () => (/* binding */ parseToRgba),
/* harmony export */   "p6": () => (/* binding */ GridCellKind),
/* harmony export */   "t5": () => (/* binding */ GrowingEntry),
/* harmony export */   "uN": () => (/* binding */ drawTextCellExternal)
/* harmony export */ });
/* unused harmony exports BooleanEmpty, BooleanIndeterminate, CompactSelection, GridColumnIcon, ImageOverlayEditor, InnerGridCellKind, MarkdownDiv, booleanCellIsEditable, default, getDefaultTheme, groupHeaderKind, headerCellCheckboxPrefix, headerCellCheckedMarker, headerCellIndeterminateMarker, headerCellUnheckedMarker, headerKind, isEditableGridCell, isInnerOnlyCell, isObjectEditorCallbackResult, isReadWriteCell, isSizedGridColumn, isTextEditableGridCell, outOfBoundsKind, resolveCellsThunk, useColumnSizer, withAlpha */
/* harmony import */ var _chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./packages/core/dist/js/chunk-TRLYFRER.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/react/index.js");
/* harmony import */ var lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/lodash/clamp.js");
/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/lodash/uniq.js");
/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/lodash/flatten.js");
/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./node_modules/lodash/range.js");
/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./node_modules/lodash/debounce.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/react-dom/index.js");
/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./node_modules/lodash/has.js");
/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./node_modules/lodash/throttle.js");
/* harmony import */ var canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./node_modules/canvas-hypertxt/dist/js/index.js");
/* harmony import */ var lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/lodash/groupBy.js");
/* harmony import */ var react_responsive_carousel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./node_modules/react-responsive-carousel/lib/js/index.js");
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./node_modules/marked/lib/marked.esm.js");



function proveType(_val) {}

function panic() {
  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "This should not happen";
  throw new Error(message);
}

function assert(fact) {
  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";
  if (fact) return;
  return panic(message);
}

function assertNever(_never) {
  return panic("Hell froze over");
}

function maybe(fn, defaultValue) {
  try {
    return fn();
  } catch (e) {
    return defaultValue;
  }
}

var has = Object.prototype.hasOwnProperty;

function deepEqual(foo, bar) {
  let ctor, len;
  if (foo === bar) return true;

  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();

    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && deepEqual(foo[len], bar[len]));
      }

      return len === -1;
    }

    if (!ctor || typeof foo === "object") {
      len = 0;

      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor])) return false;
      }

      return Object.keys(bar).length === len;
    }
  }

  return foo !== foo && bar !== bar;
}









var ClickOutsideContainer = class extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor() {
    super(...arguments);
    this.wrapperRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();

    this.clickOutside = event => {
      if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target)) {
        let node = event.target;

        while (node !== null) {
          if (node.classList.contains("click-outside-ignore")) {
            return;
          }

          node = node.parentElement;
        }

        this.props.onClickOutside();
      }
    };
  }

  componentDidMount() {
    document.addEventListener("mousedown", this.clickOutside, true);
    document.addEventListener("contextmenu", this.clickOutside, true);
  }

  componentWillUnmount() {
    document.removeEventListener("mousedown", this.clickOutside);
    document.removeEventListener("contextmenu", this.clickOutside);
  }

  render() {
    const {
      onClickOutside,
      ...rest
    } = this.props;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { ...rest,
      ref: this.wrapperRef
    }, this.props.children);
  }

};


function makeCSSStyle(theme) {
  var _a, _b;

  return {
    "--gdg-accent-color": theme.accentColor,
    "--gdg-accent-fg": theme.accentFg,
    "--gdg-accent-light": theme.accentLight,
    "--gdg-text-dark": theme.textDark,
    "--gdg-text-medium": theme.textMedium,
    "--gdg-text-light": theme.textLight,
    "--gdg-text-bubble": theme.textBubble,
    "--gdg-bg-icon-header": theme.bgIconHeader,
    "--gdg-fg-icon-header": theme.fgIconHeader,
    "--gdg-text-header": theme.textHeader,
    "--gdg-text-group-header": (_a = theme.textGroupHeader) != null ? _a : theme.textHeader,
    "--gdg-text-header-selected": theme.textHeaderSelected,
    "--gdg-bg-cell": theme.bgCell,
    "--gdg-bg-cell-medium": theme.bgCellMedium,
    "--gdg-bg-header": theme.bgHeader,
    "--gdg-bg-header-has-focus": theme.bgHeaderHasFocus,
    "--gdg-bg-header-hovered": theme.bgHeaderHovered,
    "--gdg-bg-bubble": theme.bgBubble,
    "--gdg-bg-bubble-selected": theme.bgBubbleSelected,
    "--gdg-bg-search-result": theme.bgSearchResult,
    "--gdg-border-color": theme.borderColor,
    "--gdg-horizontal-border-color": (_b = theme.horizontalBorderColor) != null ? _b : theme.borderColor,
    "--gdg-drilldown-border": theme.drilldownBorder,
    "--gdg-link-color": theme.linkColor,
    "--gdg-cell-horizontal-padding": `${theme.cellHorizontalPadding}px`,
    "--gdg-cell-vertical-padding": `${theme.cellVerticalPadding}px`,
    "--gdg-header-font-style": theme.headerFontStyle,
    "--gdg-base-font-style": theme.baseFontStyle,
    "--gdg-font-family": theme.fontFamily,
    "--gdg-editor-font-size": theme.editorFontSize
  };
}

var dataEditorBaseTheme = {
  accentColor: "#4F5DFF",
  accentFg: "#FFFFFF",
  accentLight: "rgba(62, 116, 253, 0.1)",
  textDark: "#313139",
  textMedium: "#737383",
  textLight: "#B2B2C0",
  textBubble: "#313139",
  bgIconHeader: "#737383",
  fgIconHeader: "#FFFFFF",
  textHeader: "#313139",
  textGroupHeader: "#313139BB",
  textHeaderSelected: "#FFFFFF",
  bgCell: "#FFFFFF",
  bgCellMedium: "#FAFAFB",
  bgHeader: "#F7F7F8",
  bgHeaderHasFocus: "#E9E9EB",
  bgHeaderHovered: "#EFEFF1",
  bgBubble: "#EDEDF3",
  bgBubbleSelected: "#FFFFFF",
  bgSearchResult: "#fff9e3",
  borderColor: "rgba(115, 116, 131, 0.16)",
  drilldownBorder: "rgba(0, 0, 0, 0)",
  linkColor: "#4F5DFF",
  cellHorizontalPadding: 8,
  cellVerticalPadding: 3,
  headerFontStyle: "600 13px",
  baseFontStyle: "13px",
  fontFamily: "Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif",
  editorFontSize: "13px",
  lineHeight: 1.4
};

function getDataEditorTheme() {
  return dataEditorBaseTheme;
}

var ThemeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(dataEditorBaseTheme);

function useTheme() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext);
}


var BooleanEmpty = null;
var BooleanIndeterminate = void 0;
var headerKind = "header";
var groupHeaderKind = "group-header";
var outOfBoundsKind = "out-of-bounds";
var GridCellKind;

(function (GridCellKind2) {
  GridCellKind2["Uri"] = "uri";
  GridCellKind2["Text"] = "text";
  GridCellKind2["Image"] = "image";
  GridCellKind2["RowID"] = "row-id";
  GridCellKind2["Number"] = "number";
  GridCellKind2["Bubble"] = "bubble";
  GridCellKind2["Boolean"] = "boolean";
  GridCellKind2["Loading"] = "loading";
  GridCellKind2["Markdown"] = "markdown";
  GridCellKind2["Drilldown"] = "drilldown";
  GridCellKind2["Protected"] = "protected";
  GridCellKind2["Custom"] = "custom";
})(GridCellKind || (GridCellKind = {}));

var GridColumnIcon;

(function (GridColumnIcon2) {
  GridColumnIcon2["HeaderRowID"] = "headerRowID";
  GridColumnIcon2["HeaderCode"] = "headerCode";
  GridColumnIcon2["HeaderNumber"] = "headerNumber";
  GridColumnIcon2["HeaderString"] = "headerString";
  GridColumnIcon2["HeaderBoolean"] = "headerBoolean";
  GridColumnIcon2["HeaderAudioUri"] = "headerAudioUri";
  GridColumnIcon2["HeaderVideoUri"] = "headerVideoUri";
  GridColumnIcon2["HeaderEmoji"] = "headerEmoji";
  GridColumnIcon2["HeaderImage"] = "headerImage";
  GridColumnIcon2["HeaderUri"] = "headerUri";
  GridColumnIcon2["HeaderPhone"] = "headerPhone";
  GridColumnIcon2["HeaderMarkdown"] = "headerMarkdown";
  GridColumnIcon2["HeaderDate"] = "headerDate";
  GridColumnIcon2["HeaderTime"] = "headerTime";
  GridColumnIcon2["HeaderEmail"] = "headerEmail";
  GridColumnIcon2["HeaderReference"] = "headerReference";
  GridColumnIcon2["HeaderIfThenElse"] = "headerIfThenElse";
  GridColumnIcon2["HeaderSingleValue"] = "headerSingleValue";
  GridColumnIcon2["HeaderLookup"] = "headerLookup";
  GridColumnIcon2["HeaderTextTemplate"] = "headerTextTemplate";
  GridColumnIcon2["HeaderMath"] = "headerMath";
  GridColumnIcon2["HeaderRollup"] = "headerRollup";
  GridColumnIcon2["HeaderJoinStrings"] = "headerJoinStrings";
  GridColumnIcon2["HeaderSplitString"] = "headerSplitString";
  GridColumnIcon2["HeaderGeoDistance"] = "headerGeoDistance";
  GridColumnIcon2["HeaderArray"] = "headerArray";
  GridColumnIcon2["RowOwnerOverlay"] = "rowOwnerOverlay";
  GridColumnIcon2["ProtectedColumnOverlay"] = "protectedColumnOverlay";
})(GridColumnIcon || (GridColumnIcon = {}));

var headerCellCheckboxPrefix = "___gdg_header_cell_";
var headerCellCheckedMarker = headerCellCheckboxPrefix + "checked";
var headerCellUnheckedMarker = headerCellCheckboxPrefix + "unchecked";
var headerCellIndeterminateMarker = headerCellCheckboxPrefix + "indeterminate";

function isSizedGridColumn(c) {
  return "width" in c && typeof c.width === "number";
}

async function resolveCellsThunk(thunk) {
  if (typeof thunk === "object") return thunk;
  return await thunk();
}

function isEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown) {
    return false;
  }

  proveType(cell);
  return true;
}

function isTextEditableGridCell(cell) {
  if (cell.kind === GridCellKind.Loading || cell.kind === GridCellKind.Bubble || cell.kind === GridCellKind.RowID || cell.kind === GridCellKind.Protected || cell.kind === GridCellKind.Drilldown || cell.kind === GridCellKind.Boolean || cell.kind === GridCellKind.Image || cell.kind === GridCellKind.Custom) {
    return false;
  }

  proveType(cell);
  return true;
}

function isInnerOnlyCell(cell) {
  return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;
}

function isReadWriteCell(cell) {
  if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image) return false;

  if (cell.kind === GridCellKind.Text || cell.kind === GridCellKind.Number || cell.kind === GridCellKind.Markdown || cell.kind === GridCellKind.Uri || cell.kind === GridCellKind.Custom || cell.kind === GridCellKind.Boolean) {
    return cell.readonly !== true;
  }

  assertNever(cell);
}

function isObjectEditorCallbackResult(obj) {
  return lodash_has_js__WEBPACK_IMPORTED_MODULE_7__(obj, "editor");
}

function booleanCellIsEditable(cell) {
  var _a;

  return !((_a = cell.readonly) != null ? _a : false);
}

var InnerGridCellKind;

(function (InnerGridCellKind2) {
  InnerGridCellKind2["NewRow"] = "new-row";
  InnerGridCellKind2["Marker"] = "marker";
})(InnerGridCellKind || (InnerGridCellKind = {}));

function mergeRanges(input) {
  if (input.length === 0) {
    return [];
  }

  const ranges = [...input];
  const stack = [];
  ranges.sort(function (a, b) {
    return a[0] - b[0];
  });
  stack.push([...ranges[0]]);

  for (const range2 of ranges.slice(1)) {
    const top = stack[stack.length - 1];

    if (top[1] < range2[0]) {
      stack.push([...range2]);
    } else if (top[1] < range2[1]) {
      top[1] = range2[1];
    }
  }

  return stack;
}

var emptyCompactSelection;

var _CompactSelection = class {
  constructor(items) {
    this.items = items;

    this.offset = amount => {
      if (amount === 0) return this;
      const newItems = this.items.map(x => [x[0] + amount, x[1] + amount]);
      return new _CompactSelection(newItems);
    };

    this.add = selection => {
      const slice = typeof selection === "number" ? [selection, selection + 1] : selection;
      const newItems = mergeRanges([...this.items, slice]);
      return new _CompactSelection(newItems);
    };

    this.remove = selection => {
      const items2 = [...this.items];
      const selMin = typeof selection === "number" ? selection : selection[0];
      const selMax = typeof selection === "number" ? selection + 1 : selection[1];

      for (const [i, slice] of items2.entries()) {
        const [start, end] = slice;

        if (start <= selMax && selMin <= end) {
          const toAdd = [];

          if (start < selMin) {
            toAdd.push([start, selMin]);
          }

          if (selMax < end) {
            toAdd.push([selMax, end]);
          }

          items2.splice(i, 1, ...toAdd);
        }
      }

      return new _CompactSelection(items2);
    };

    this.first = () => {
      if (this.items.length === 0) return void 0;
      return this.items[0][0];
    };

    this.last = () => {
      if (this.items.length === 0) return void 0;
      return this.items.slice(-1)[0][1] - 1;
    };

    this.hasIndex = index => {
      for (let i = 0; i < this.items.length; i++) {
        const [start, end] = this.items[i];
        if (index >= start && index < end) return true;
      }

      return false;
    };

    this.hasAll = index => {
      for (let x = index[0]; x < index[1]; x++) {
        if (!this.hasIndex(x)) return false;
      }

      return true;
    };

    this.some = predicate => {
      for (const i of this) {
        if (predicate(i)) return true;
      }

      return false;
    };

    this.equals = other => {
      if (other === this) return true;
      if (other.items.length !== this.items.length) return false;

      for (let i = 0; i < this.items.length; i++) {
        const left = other.items[i];
        const right = this.items[i];
        if (left[0] !== right[0] || left[1] !== right[1]) return false;
      }

      return true;
    };

    this.toArray = () => {
      const result = [];

      for (const [start, end] of this.items) {
        for (let x = start; x < end; x++) {
          result.push(x);
        }
      }

      return result;
    };
  }

  get length() {
    let len = 0;

    for (const [start, end] of this.items) {
      len += end - start;
    }

    return len;
  }

  *[Symbol.iterator]() {
    for (const [start, end] of this.items) {
      for (let x = start; x < end; x++) {
        yield x;
      }
    }
  }

};

var CompactSelection = _CompactSelection;

CompactSelection.empty = () => {
  return emptyCompactSelection != null ? emptyCompactSelection : emptyCompactSelection = new _CompactSelection([]);
};

CompactSelection.fromSingleSelection = selection => {
  return _CompactSelection.empty().add(selection);
};

var DataGridOverlayEditorStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "DataGridOverlayEditorStyle",
  class: "d1t1th9s",
  vars: {
    "d1t1th9s-0": [p => p.targetY, "px"],
    "d1t1th9s-1": [p => p.targetX - 1, "px"],
    "d1t1th9s-2": [p => p.targetY - 1, "px"],
    "d1t1th9s-3": [p => p.targetWidth + 2, "px"],
    "d1t1th9s-4": [p => p.targetHeight + 2, "px"],
    "d1t1th9s-5": [p => p.targetY + 10, "px"],
    "d1t1th9s-6": [p => Math.max(0, (p.targetHeight - 28) / 2), "px"]
  }
});


function useRefState() {
  const [refState, setRefState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  return [refState != null ? refState : void 0, setRefState];
}

function useStayOnScreen() {
  const [ref, setRef] = useRefState();
  const [xOffset, setXOffset] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);
  const [isIntersecting, setIsIntersecting] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (ref === void 0) return;
    if (!("IntersectionObserver" in window)) return;
    const observer = new IntersectionObserver(ents => {
      if (ents.length === 0) return;
      setIsIntersecting(ents[0].isIntersecting);
    }, {
      threshold: 1
    });
    observer.observe(ref);
    return () => observer.disconnect();
  }, [ref]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (isIntersecting || ref === void 0) return;
    let rafHandle;

    const fn = () => {
      const {
        right: refRight
      } = ref.getBoundingClientRect();
      setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));
      rafHandle = requestAnimationFrame(fn);
    };

    rafHandle = requestAnimationFrame(fn);
    return () => {
      if (rafHandle !== void 0) {
        cancelAnimationFrame(rafHandle);
      }
    };
  }, [ref, isIntersecting]);
  const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      transform: `translateX(${xOffset}px)`
    };
  }, [xOffset]);
  return {
    ref: setRef,
    style
  };
}

var DataGridOverlayEditor = p => {
  const {
    target,
    content,
    onFinishEditing: onFinishEditingIn,
    forceEditMode,
    initialValue,
    imageEditorOverride,
    markdownDivCreateNode,
    highlight,
    className,
    theme,
    id,
    cell,
    validateCell,
    getCellRenderer,
    provideEditor
  } = p;
  const [tempValue, setTempValueRaw] = react__WEBPACK_IMPORTED_MODULE_0__.useState(forceEditMode ? content : void 0);
  const lastValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(tempValue != null ? tempValue : content);
  lastValueRef.current = tempValue != null ? tempValue : content;
  const [isValid, setIsValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    if (validateCell === void 0) return true;
    return !(isEditableGridCell(content) && (validateCell == null ? void 0 : validateCell(cell, content, lastValueRef.current)) === false);
  });
  const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCell, movement) => {
    onFinishEditingIn(isValid ? newCell : void 0, movement);
  }, [isValid, onFinishEditingIn]);
  const setTempValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newVal => {
    if (validateCell !== void 0 && newVal !== void 0 && isEditableGridCell(newVal)) {
      const validResult = validateCell(cell, newVal, lastValueRef.current);

      if (validResult === false) {
        setIsValid(false);
      } else if (typeof validResult === "object") {
        newVal = validResult;
        setIsValid(true);
      } else {
        setIsValid(true);
      }
    }

    setTempValueRaw(newVal);
  }, [cell, validateCell]);
  const finished = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const customMotion = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);
  const onClickOutside = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    onFinishEditing(tempValue, [0, 0]);
    finished.current = true;
  }, [tempValue, onFinishEditing]);
  const onEditorFinished = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newValue => {
    var _a;

    onFinishEditing(newValue, (_a = customMotion.current) != null ? _a : [0, 0]);
    finished.current = true;
  }, [onFinishEditing]);
  const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async event => {
    let save = false;

    if (event.key === "Escape") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 0];
    } else if (event.key === "Enter" && !event.shiftKey) {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [0, 1];
      save = true;
    } else if (event.key === "Tab") {
      event.stopPropagation();
      event.preventDefault();
      customMotion.current = [event.shiftKey ? -1 : 1, 0];
      save = true;
    }

    window.setTimeout(() => {
      if (!finished.current && customMotion.current !== void 0) {
        onFinishEditing(save ? tempValue : void 0, customMotion.current);
        finished.current = true;
      }
    }, 0);
  }, [onFinishEditing, tempValue]);
  const targetValue = tempValue != null ? tempValue : content;
  const [editorProvider, useLabel] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a, _b;

    if (isInnerOnlyCell(content)) return [];
    const external = provideEditor == null ? void 0 : provideEditor(content);
    if (external !== void 0) return [external, false];
    return [(_b = (_a = getCellRenderer(content)) == null ? void 0 : _a.provideEditor) == null ? void 0 : _b.call(_a, content), false];
  }, [content, getCellRenderer, provideEditor]);
  const {
    ref,
    style: stayOnScreenStyle
  } = useStayOnScreen();
  let pad = true;
  let editor;
  let style = true;
  let styleOverride;

  if (editorProvider !== void 0) {
    pad = editorProvider.disablePadding !== true;
    style = editorProvider.disableStyling !== true;
    const isObjectEditor = isObjectEditorCallbackResult(editorProvider);

    if (isObjectEditor) {
      styleOverride = editorProvider.styleOverride;
    }

    const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;
    editor = react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomEditor, {
      isHighlighted: highlight,
      onChange: setTempValue,
      value: targetValue,
      initialValue,
      onFinishedEditing: onEditorFinished,
      validatedSelection: isEditableGridCell(targetValue) ? targetValue.selectionRange : void 0,
      forceEditMode,
      target,
      imageEditorOverride,
      markdownDivCreateNode,
      isValid
    });
  }

  styleOverride = { ...styleOverride,
    ...stayOnScreenStyle
  };
  const portalElement = document.getElementById("portal");

  if (portalElement === null) {
    console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id="portal" />` as the last child of your `<body>`.');
    return null;
  }

  let classWrap = style ? "gdg-style" : "gdg-unstyle";

  if (!isValid) {
    classWrap += " invalid";
  }

  if (pad) {
    classWrap += " pad";
  }

  return (0,react_dom__WEBPACK_IMPORTED_MODULE_6__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThemeContext.Provider, {
    value: theme
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClickOutsideContainer, {
    style: makeCSSStyle(theme),
    className,
    onClickOutside
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataGridOverlayEditorStyle, {
    ref,
    id,
    className: classWrap,
    style: styleOverride,
    as: useLabel === true ? "label" : void 0,
    targetX: target.x,
    targetY: target.y,
    targetWidth: target.width,
    targetHeight: target.height
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "clip-region",
    onKeyDown
  }, editor)))), portalElement);
};

var data_grid_overlay_editor_default = DataGridOverlayEditor;






var rowShift = 1 << 16;
var imgPool = [];

function packColRowToNumber(col, row) {
  return row * rowShift + col;
}

function unpackCol(packed) {
  return packed % rowShift;
}

function unpackRow(packed, col) {
  return (packed - col) / rowShift;
}

function unpackNumberToColRow(packed) {
  const col = unpackCol(packed);
  const row = unpackRow(packed, col);
  return [col, row];
}

var ImageWindowLoaderImpl = class {
  constructor() {
    this.imageLoaded = () => void 0;

    this.loadedLocations = [];
    this.visibleWindow = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    this.freezeCols = 0;

    this.isInWindow = packed => {
      const col = unpackCol(packed);
      const row = unpackRow(packed, col);
      const w = this.visibleWindow;
      if (col < this.freezeCols && row >= w.y && row <= w.y + w.height) return true;
      return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;
    };

    this.cache = {};
    this.sendLoaded = lodash_throttle_js__WEBPACK_IMPORTED_MODULE_9__(() => {
      this.imageLoaded(this.loadedLocations);
      this.loadedLocations = [];
    }, 20);

    this.clearOutOfWindow = () => {
      const keys = Object.keys(this.cache);

      for (const key of keys) {
        const obj = this.cache[key];
        let keep = false;

        for (let j = 0; j < obj.cells.length; j++) {
          const packed = obj.cells[j];

          if (this.isInWindow(packed)) {
            keep = true;
            break;
          }
        }

        if (keep) {
          obj.cells = obj.cells.filter(this.isInWindow);
        } else {
          obj.cancel();
          delete this.cache[key];
        }
      }
    };
  }

  setCallback(imageLoaded) {
    this.imageLoaded = imageLoaded;
  }

  setWindow(newWindow, freezeCols) {
    if (this.visibleWindow.x === newWindow.x && this.visibleWindow.y === newWindow.y && this.visibleWindow.width === newWindow.width && this.visibleWindow.height === newWindow.height && this.freezeCols === freezeCols) return;
    this.visibleWindow = newWindow;
    this.freezeCols = freezeCols;
    this.clearOutOfWindow();
  }

  loadImage(url, col, row, key) {
    var _a;

    let loaded = false;
    const img = (_a = imgPool.pop()) != null ? _a : new Image();
    let canceled = false;
    const result = {
      img: void 0,
      cells: [packColRowToNumber(col, row)],
      url,
      cancel: () => {
        if (canceled) return;
        canceled = true;

        if (imgPool.length < 12) {
          imgPool.unshift(img);
        } else if (!loaded) {
          img.src = "";
        }
      }
    };
    const loadPromise = new Promise(r => img.addEventListener("load", () => r(null)));
    requestAnimationFrame(async () => {
      try {
        img.src = url;
        await loadPromise;
        await img.decode();
        const toWrite = this.cache[key];

        if (toWrite !== void 0 && !canceled) {
          toWrite.img = img;

          for (const packed of toWrite.cells) {
            this.loadedLocations.push(unpackNumberToColRow(packed));
          }

          loaded = true;
          this.sendLoaded();
        }
      } catch (e) {
        result.cancel();
      }
    });
    this.cache[key] = result;
  }

  loadOrGetImage(url, col, row) {
    const key = url;
    const current = this.cache[key];

    if (current !== void 0) {
      const packed = packColRowToNumber(col, row);

      if (!current.cells.includes(packed)) {
        current.cells.push(packed);
      }

      return current.img;
    } else {
      this.loadImage(url, col, row, key);
    }

    return void 0;
  }

};
var image_window_loader_default = ImageWindowLoaderImpl;



function useEventListener(eventName, handler, element, passive) {
  let capture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const savedHandler = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  savedHandler.current = handler;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (element === null || element.addEventListener === void 0) return;
    const el = element;

    const eventListener = event => {
      var _a;

      (_a = savedHandler.current) == null ? void 0 : _a.call(el, event);
    };

    el.addEventListener(eventName, eventListener, {
      passive,
      capture
    });
    return () => {
      el.removeEventListener(eventName, eventListener, {
        capture
      });
    };
  }, [eventName, element, passive, capture]);
}

function whenDefined(obj, result) {
  return obj === void 0 ? void 0 : result;
}

var PI = Math.PI;

function degreesToRadians(degrees) {
  return degrees * PI / 180;
}

var EditPencil = props => {
  var _a;

  const fg = (_a = props.fgColor) != null ? _a : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    vectorEffect: "non-scaling-stroke"
  }));
};

var Checkmark = props => {
  var _a;

  const fg = (_a = props.fgColor) != null ? _a : "currentColor";
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
    d: "M19 6L10.3802 17L5.34071 11.8758",
    vectorEffect: "non-scaling-stroke",
    stroke: fg,
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};

function useDebouncedMemo(factory, deps, time) {
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(factory);
  const mountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => {
    mountedRef.current = false;
  }, []);
  const debouncedSetState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__(x => {
    if (mountedRef.current) {
      setState(x);
    }
  }, time));
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (mountedRef.current) {
      debouncedSetState.current(() => factory());
    }
  }, deps);
  return state;
}

var rtlRange = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
var ltrRange = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
var rtl = new RegExp("^[^" + ltrRange + "]*[" + rtlRange + "]");
var ltr = new RegExp("^[^" + rtlRange + "]*[" + ltrRange + "]");

function direction(value) {
  return rtl.test(value) ? "rtl" : ltr.test(value) ? "ltr" : "neutral";
}

var scrollbarWidthCache = void 0;

function getScrollBarWidth() {
  if (scrollbarWidthCache !== void 0) return scrollbarWidthCache;
  const inner = document.createElement("p");
  inner.style.width = "100%";
  inner.style.height = "200px";
  const outer = document.createElement("div");
  outer.id = "testScrollbar";
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.append(inner);
  document.body.append(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;

  if (w1 === w2) {
    w2 = outer.clientWidth;
  }

  outer.remove();
  scrollbarWidthCache = w1 - w2;
  return scrollbarWidthCache;
}

var empty = Symbol();

function useStateWithReactiveInput(inputState) {
  const inputStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([empty, inputState]);

  if (inputStateRef.current[1] !== inputState) {
    inputStateRef.current[0] = inputState;
  }

  inputStateRef.current[1] = inputState;
  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(inputState);
  const [, forceRender] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const setStateOuter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(nv => {
    const s = inputStateRef.current[0];

    if (s !== empty) {
      nv = typeof nv === "function" ? nv(s) : nv;
      if (nv === s) return;
    }

    if (s !== empty) forceRender({});
    setState(pv => {
      if (typeof nv === "function") {
        return nv(s === empty ? pv : s);
      }

      return nv;
    });
    inputStateRef.current[0] = empty;
  }, []);
  const onEmpty = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    inputStateRef.current[0] = empty;
    forceRender({});
  }, []);
  return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];
}




function useMappedColumns(columns, freezeColumns) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => columns.map((c, i) => ({ ...c,
    sourceIndex: i,
    sticky: i < freezeColumns
  })), [columns, freezeColumns]);
}

function isGroupEqual(left, right) {
  return (left != null ? left : "") === (right != null ? right : "");
}

function cellIsSelected(location, cell, selection) {
  if ((selection == null ? void 0 : selection.current) === void 0) return false;
  const [col, row] = selection.current.cell;
  const [cellCol, cellRow] = location;
  if (cellRow !== row) return false;

  if (cell.span === void 0) {
    return col === cellCol;
  }

  return col >= cell.span[0] && col <= cell.span[1];
}

function cellIsInRect(location, cell, rect) {
  const startX = rect.x;
  const endX = rect.x + rect.width - 1;
  const startY = rect.y;
  const endY = rect.y + rect.height - 1;
  const [cellCol, cellRow] = location;
  if (cellRow < startY || cellRow > endY) return false;

  if (cell.span === void 0) {
    return cellCol >= startX && cellCol <= endX;
  }

  const [spanStart, spanEnd] = cell.span;
  return spanStart >= startX && spanStart <= endX || spanEnd >= startX && spanStart <= endX || spanStart < startX && spanEnd > endX;
}

function cellIsInRange(location, cell, selection) {
  let result = 0;
  if (selection.current === void 0) return result;
  if (cellIsInRect(location, cell, selection.current.range)) result++;

  for (const r of selection.current.rangeStack) {
    if (cellIsInRect(location, cell, r)) {
      result++;
    }
  }

  return result;
}

function remapForDnDState(columns, dndState) {
  let mappedCols = columns;

  if (dndState !== void 0) {
    let writable = [...columns];
    const temp = mappedCols[dndState.src];

    if (dndState.src > dndState.dest) {
      writable.splice(dndState.src, 1);
      writable.splice(dndState.dest, 0, temp);
    } else {
      writable.splice(dndState.dest + 1, 0, temp);
      writable.splice(dndState.src, 1);
    }

    writable = writable.map((c, i) => ({ ...c,
      sticky: columns[i].sticky
    }));
    mappedCols = writable;
  }

  return mappedCols;
}

function getStickyWidth(columns, dndState) {
  let result = 0;
  const remapped = remapForDnDState(columns, dndState);

  for (let i = 0; i < remapped.length; i++) {
    const c = remapped[i];
    if (c.sticky) result += c.width;else break;
  }

  return result;
}

function getEffectiveColumns(columns, cellXOffset, width, dndState, tx) {
  const mappedCols = remapForDnDState(columns, dndState);
  const sticky = [];

  for (const c of mappedCols) {
    if (c.sticky) {
      sticky.push(c);
    } else {
      break;
    }
  }

  if (sticky.length > 0) {
    for (const c of sticky) {
      width -= c.width;
    }
  }

  let endIndex = cellXOffset;
  let curX = tx != null ? tx : 0;

  while (curX <= width && endIndex < mappedCols.length) {
    curX += mappedCols[endIndex].width;
    endIndex++;
  }

  for (let i = cellXOffset; i < endIndex; i++) {
    const c = mappedCols[i];

    if (!c.sticky) {
      sticky.push(c);
    }
  }

  return sticky;
}

function getColumnIndexForX(targetX, effectiveColumns, translateX) {
  let x = 0;

  for (const c of effectiveColumns) {
    const cx = c.sticky ? x : x + (translateX != null ? translateX : 0);

    if (targetX <= cx + c.width) {
      return c.sourceIndex;
    }

    x += c.width;
  }

  return -1;
}

function getRowIndexForY(targetY, height, hasGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, lastRowSticky) {
  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (hasGroups && targetY <= groupHeaderHeight) return -2;
  if (targetY <= totalHeaderHeight) return -1;
  const lastRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows - 1);

  if (lastRowSticky && targetY > height - lastRowHeight) {
    return rows - 1;
  }

  const effectiveRows = rows - (lastRowSticky ? 1 : 0);
  const ty = targetY - (translateY != null ? translateY : 0);

  if (typeof rowHeight === "number") {
    const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;
    if (target >= effectiveRows) return void 0;
    return target;
  } else {
    let curY = totalHeaderHeight;

    for (let i = cellYOffset; i < effectiveRows; i++) {
      const rh = rowHeight(i);
      if (ty <= curY + rh) return i;
      curY += rh;
    }

    return void 0;
  }
}

var metricsSize = 0;
var metricsCache = {};
var isSSR = typeof window === "undefined";

async function clearCacheOnLoad() {
  var _a;

  if (isSSR || ((_a = document == null ? void 0 : document.fonts) == null ? void 0 : _a.ready) === void 0) return;
  await document.fonts.ready;
  metricsSize = 0;
  metricsCache = {};
  (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__/* .clearCache */ .L)();
}

void clearCacheOnLoad();

function makeCacheKey(s, ctx, baseline, font) {
  return `${s}_${font != null ? font : ctx.font}_${baseline}`;
}

function measureTextCached(s, ctx, font) {
  const key = makeCacheKey(s, ctx, "middle", font);
  let metrics = metricsCache[key];

  if (metrics === void 0) {
    metrics = ctx.measureText(s);
    metricsCache[key] = metrics;
    metricsSize++;
  }

  if (metricsSize > 1e4) {
    metricsCache = {};
    metricsSize = 0;
  }

  return metrics;
}

function getMiddleCenterBias(ctx, font) {
  if (typeof font !== "string") {
    font = `${font.baseFontStyle} ${font.fontFamily}`;
  }

  return getMiddleCenterBiasInner(ctx, font);
}

function loadMetric(ctx, baseline) {
  const sample = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  ctx.save();
  ctx.textBaseline = baseline;
  const result = ctx.measureText(sample);
  ctx.restore();
  return result;
}

var biasCache = [];

function getMiddleCenterBiasInner(ctx, font) {
  for (const x of biasCache) {
    if (x.key === font) return x.val;
  }

  const alphabeticMetrics = loadMetric(ctx, "alphabetic");
  const middleMetrics = loadMetric(ctx, "middle");
  const bias = -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) + alphabeticMetrics.actualBoundingBoxAscent / 2;
  biasCache.push({
    key: font,
    val: bias
  });
  return bias;
}

function drawWithLastUpdate(args, lastUpdate, frameTime, lastPrep, draw) {
  const {
    ctx,
    rect,
    theme
  } = args;
  let progress = Number.MAX_SAFE_INTEGER;
  const animTime = 500;

  if (lastUpdate !== void 0) {
    progress = frameTime - lastUpdate;

    if (progress < animTime) {
      const fade = 1 - progress / animTime;
      ctx.globalAlpha = fade;
      ctx.fillStyle = theme.bgSearchResult;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
      ctx.globalAlpha = 1;

      if (lastPrep !== void 0) {
        lastPrep.fillStyle = theme.bgSearchResult;
      }
    }
  }

  draw();
  return progress < animTime;
}

function prepTextCell(args, lastPrep, overrideColor) {
  const {
    ctx,
    theme
  } = args;
  const result = lastPrep != null ? lastPrep : {};
  const newFill = overrideColor != null ? overrideColor : theme.textDark;

  if (newFill !== result.fillStyle) {
    ctx.fillStyle = newFill;
    result.fillStyle = newFill;
  }

  return result;
}

function drawTextCellExternal(args, data, contentAlign) {
  const {
    rect,
    ctx,
    theme
  } = args;
  ctx.fillStyle = theme.textDark;
  drawTextCell({
    ctx,
    rect,
    theme
  }, data, contentAlign);
}

function drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign) {
  if (contentAlign === "right") {
    ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);
  } else if (contentAlign === "center") {
    ctx.fillText(data, x + w / 2, y + h / 2 + bias);
  } else {
    ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);
  }
}

function drawTextCell(args, data, contentAlign, allowWrapping, hyperWrapping) {
  const {
    ctx,
    rect,
    theme
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  allowWrapping = allowWrapping != null ? allowWrapping : false;

  if (!allowWrapping) {
    if (data.includes("\n")) {
      data = data.split(/\r?\n/)[0];
    }

    const max = w / 4;

    if (data.length > max) {
      data = data.slice(0, max);
    }
  }

  const bias = getMiddleCenterBias(ctx, theme);
  const isRtl = direction(data) === "rtl";

  if (contentAlign === void 0 && isRtl) {
    contentAlign = "right";
  }

  if (isRtl) {
    ctx.direction = "rtl";
  }

  if (data.length > 0) {
    let changed = false;

    if (contentAlign === "right") {
      ctx.textAlign = "right";
      changed = true;
    } else if (contentAlign !== void 0 && contentAlign !== "left") {
      ctx.textAlign = contentAlign;
      changed = true;
    }

    if (!allowWrapping) {
      drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);
    } else {
      const fontStyle = `${theme.fontFamily} ${theme.baseFontStyle}`;
      const split = (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_10__/* .split */ .V)(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping != null ? hyperWrapping : false);
      const textMetrics = measureTextCached("ABCi09jgqpy", ctx, fontStyle);
      const emHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;
      const lineHeight = theme.lineHeight * emHeight;
      const actualHeight = emHeight + lineHeight * (split.length - 1);
      const mustClip = actualHeight + theme.cellVerticalPadding > h;

      if (mustClip) {
        ctx.save();
        ctx.rect(x, y, w, h);
        ctx.clip();
      }

      const optimalY = y + h / 2 - actualHeight / 2;
      let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);

      for (const line of split) {
        drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);
        drawY += lineHeight;
        if (drawY > y + h) break;
      }

      if (mustClip) {
        ctx.restore();
      }
    }

    if (changed) {
      ctx.textAlign = "start";
    }

    if (isRtl) {
      ctx.direction = "inherit";
    }
  }
}

function drawNewRowCell(args, data, icon) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme,
    spriteManager
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  ctx.beginPath();
  ctx.globalAlpha = hoverAmount;
  ctx.rect(x, y, w, h);
  ctx.fillStyle = theme.bgHeaderHovered;
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.beginPath();
  const alwaysShowIcon = data !== "";
  let textX = 0;

  if (icon !== void 0) {
    const padding = 8;
    const size = h - padding;
    const px = x + padding / 2;
    const py = y + padding / 2;
    spriteManager.drawSprite(icon, "normal", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);
    textX = size;
  } else {
    textX = 24;
    const finalLineSize = 12;
    const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;
    const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;
    const padPlus = theme.cellHorizontalPadding + 4;

    if (lineSize > 0) {
      ctx.moveTo(x + padPlus + xTranslate, y + h / 2);
      ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);
      ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);
      ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);
      ctx.lineWidth = 2;
      ctx.strokeStyle = theme.bgIconHeader;
      ctx.lineCap = "round";
      ctx.stroke();
    }
  }

  ctx.fillStyle = theme.textMedium;
  ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + getMiddleCenterBias(ctx, theme));
  ctx.beginPath();
}

function drawCheckbox(ctx, theme, checked, x, y, width, height, highlighted) {
  let hoverX = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : -20;
  let hoverY = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : -20;
  const centerX = x + width / 2;
  const centerY = y + height / 2;
  const checkBoxWidth = height / 1.89;
  const emptyCheckBoxWidth = height / 2;
  const hoverHelper = height / 3.4;
  const hovered = Math.abs(hoverX - width / 2) < hoverHelper && Math.abs(hoverY - height / 2) < hoverHelper;
  const rectBordRadius = 4;
  const posHelperChecked = height / 4.25;
  const posHelperEmpty = height / 4;
  const posHelperInter = height / 8.5;

  switch (checked) {
    case true:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);
        ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperChecked + height / 9.31, centerY - posHelperChecked + height / 4.33);
        ctx.lineTo(centerX - posHelperChecked + height / 5.33, centerY - posHelperChecked + height / 3.17);
        ctx.lineTo(centerX - posHelperChecked + height / 2.83, centerY - posHelperChecked + height / 7.16);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    case BooleanEmpty:
    case false:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - posHelperEmpty, centerY - posHelperEmpty, emptyCheckBoxWidth, emptyCheckBoxWidth, rectBordRadius);
        ctx.lineWidth = 1;
        ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;
        ctx.stroke();
        break;
      }

    case BooleanIndeterminate:
      {
        ctx.beginPath();
        roundedRect(ctx, centerX - posHelperEmpty, centerY - posHelperEmpty, emptyCheckBoxWidth, emptyCheckBoxWidth, rectBordRadius);
        ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX - posHelperInter, centerY);
        ctx.lineTo(centerX + posHelperInter, centerY);
        ctx.strokeStyle = theme.bgCell;
        ctx.lineCap = "round";
        ctx.lineWidth = 1.9;
        ctx.stroke();
        break;
      }

    default:
      assertNever(checked);
  }
}

function prepMarkerRowCell(args, lastPrep) {
  const {
    ctx,
    theme
  } = args;
  const newFont = `9px ${theme.fontFamily}`;
  const result = lastPrep != null ? lastPrep : {};

  if ((result == null ? void 0 : result.font) !== newFont) {
    ctx.font = newFont;
    result.font = newFont;
  }

  result.deprep = deprepMarkerRowCell;
  ctx.textAlign = "center";
  return result;
}

function deprepMarkerRowCell(args) {
  const {
    ctx
  } = args;
  ctx.textAlign = "start";
}

function drawMarkerRowCell(args, index, checked, markerKind, drawHandle) {
  const {
    ctx,
    rect,
    hoverAmount,
    theme
  } = args;
  const {
    x,
    y,
    width,
    height
  } = rect;
  const checkedboxAlpha = checked ? 1 : hoverAmount;

  if (markerKind !== "number" && checkedboxAlpha > 0) {
    ctx.globalAlpha = checkedboxAlpha;
    const offsetAmount = 7 * (checked ? hoverAmount : 1);
    drawCheckbox(ctx, theme, checked, drawHandle ? x + offsetAmount : x, y, drawHandle ? width - offsetAmount : width, height, true);

    if (drawHandle) {
      ctx.globalAlpha = hoverAmount;
      ctx.beginPath();

      for (const xOffset of [3, 6]) {
        for (const yOffset of [-5, -1, 3]) {
          ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);
        }
      }

      ctx.fillStyle = theme.textLight;
      ctx.fill();
      ctx.beginPath();
    }

    ctx.globalAlpha = 1;
  }

  if (markerKind === "number" || markerKind === "both" && !checked) {
    const text = index.toString();
    const start = x + width / 2;

    if (markerKind === "both" && hoverAmount !== 0) {
      ctx.globalAlpha = 1 - hoverAmount;
    }

    ctx.fillStyle = theme.textLight;
    ctx.fillText(text, start, y + height / 2 + getMiddleCenterBias(ctx, `9px ${theme.fontFamily}`));

    if (hoverAmount !== 0) {
      ctx.globalAlpha = 1;
    }
  }
}

function drawProtectedCell(args) {
  const {
    ctx,
    theme,
    rect
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  ctx.beginPath();
  const radius = 2.5;
  let xStart = x + theme.cellHorizontalPadding + radius;
  const center = y + h / 2;
  const p = Math.cos(degreesToRadians(30)) * radius;
  const q = Math.sin(degreesToRadians(30)) * radius;

  for (let i = 0; i < 12; i++) {
    ctx.moveTo(xStart, center - radius);
    ctx.lineTo(xStart, center + radius);
    ctx.moveTo(xStart + p, center - q);
    ctx.lineTo(xStart - p, center + q);
    ctx.moveTo(xStart - p, center - q);
    ctx.lineTo(xStart + p, center + q);
    xStart += 8;
  }

  ctx.lineWidth = 1.1;
  ctx.lineCap = "square";
  ctx.strokeStyle = theme.textLight;
  ctx.stroke();
}

function roundedRect(ctx, x, y, width, height, radius) {
  if (typeof radius === "number") {
    radius = {
      tl: radius,
      tr: radius,
      br: radius,
      bl: radius
    };
  }

  radius = {
    tl: Math.min(radius.tl, height / 2, width / 2),
    tr: Math.min(radius.tr, height / 2, width / 2),
    bl: Math.min(radius.bl, height / 2, width / 2),
    br: Math.min(radius.br, height / 2, width / 2)
  };
  ctx.moveTo(x + radius.tl, y);
  ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);
  ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);
  ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);
  ctx.arcTo(x, y, x + radius.tl, y, radius.tl);
}

function drawBoolean(args, data, canEdit) {
  if (!canEdit && data === BooleanEmpty) {
    return;
  }

  const {
    ctx,
    hoverAmount,
    theme,
    rect,
    highlighted,
    hoverX,
    hoverY
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const hoverEffect = 0.35;
  let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;

  if (data === BooleanEmpty) {
    alpha *= hoverAmount;
  }

  if (alpha === 0) {
    return;
  }

  ctx.globalAlpha = alpha;
  drawCheckbox(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY);
  ctx.globalAlpha = 1;
}

var itemMargin = 4;

function drawBubbles(args, data) {
  const {
    rect,
    theme,
    ctx,
    highlighted
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const bubbleHeight = 20;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const renderBoxes = [];

  for (const s of data) {
    if (renderX > x + w) break;
    const textWidth = measureTextCached(s, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;
    renderBoxes.push({
      x: renderX,
      width: textWidth
    });
    renderX += textWidth + bubblePad * 2 + bubbleMargin;
  }

  ctx.beginPath();

  for (const rectInfo of renderBoxes) {
    roundedRect(ctx, rectInfo.x, y + (h - bubbleHeight) / 2, rectInfo.width + bubblePad * 2, bubbleHeight, bubbleHeight / 2);
  }

  ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;
  ctx.fill();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}

var drilldownCache = {};

function getAndCacheDrilldownBorder(bgCell, border) {
  const dpr = Math.ceil(window.devicePixelRatio);
  const targetHeight = 24;
  const shadowBlur = 5;
  const middleWidth = 4;
  const innerHeight = (targetHeight + shadowBlur * 2) * dpr;
  const innerWidth = innerHeight + middleWidth * dpr;
  const sideWidth = innerHeight / 2;
  const key = `${bgCell},${border},${dpr}`;

  if (drilldownCache[key] !== void 0) {
    return {
      el: drilldownCache[key],
      height: innerHeight,
      width: innerWidth,
      middleWidth: middleWidth * dpr,
      sideWidth
    };
  }

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (ctx === null) return null;
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  ctx.scale(dpr, dpr);
  drilldownCache[key] = canvas;
  ctx.beginPath();
  roundedRect(ctx, shadowBlur, shadowBlur, targetHeight + middleWidth, targetHeight, 6);
  ctx.shadowColor = "rgba(24, 25, 34, 0.4)";
  ctx.shadowBlur = 1;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowColor = "rgba(24, 25, 34, 0.3)";
  ctx.shadowOffsetY = 1;
  ctx.shadowBlur = 5;
  ctx.fillStyle = bgCell;
  ctx.fill();
  ctx.shadowOffsetY = 0;
  ctx.shadowBlur = 0;
  ctx.shadowBlur = 0;
  ctx.beginPath();
  roundedRect(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetHeight + middleWidth, targetHeight, 6);
  ctx.strokeStyle = border;
  ctx.lineWidth = 1;
  ctx.stroke();
  return {
    el: canvas,
    height: innerHeight,
    width: innerWidth,
    sideWidth,
    middleWidth: middleWidth * dpr
  };
}

function drawDrilldownCell(args, data) {
  const {
    rect,
    theme,
    ctx,
    imageLoader,
    col,
    row
  } = args;
  const {
    x,
    y,
    width: w,
    height: h
  } = rect;
  const bubbleHeight = 24;
  const bubblePad = 8;
  const bubbleMargin = itemMargin;
  let renderX = x + theme.cellHorizontalPadding;
  const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder);
  const renderBoxes = [];

  for (const el of data) {
    if (renderX > x + w) break;
    const textWidth = measureTextCached(el.text, ctx, `${theme.baseFontStyle} ${theme.fontFamily}`).width;
    let imgWidth = 0;

    if (el.img !== void 0) {
      const img = imageLoader.loadOrGetImage(el.img, col, row);

      if (img !== void 0) {
        imgWidth = bubbleHeight - 8 + 4;
      }
    }

    const renderWidth = textWidth + imgWidth + bubblePad * 2;
    renderBoxes.push({
      x: renderX,
      width: renderWidth
    });
    renderX += renderWidth + bubbleMargin;
  }

  if (tileMap !== null) {
    const {
      el,
      height,
      middleWidth,
      sideWidth,
      width
    } = tileMap;

    for (const rectInfo of renderBoxes) {
      const rx = Math.floor(rectInfo.x);
      const rw = Math.floor(rectInfo.width);
      ctx.imageSmoothingEnabled = false;
      const maxSideWidth = Math.min(17, rw / 2 + 5);
      ctx.drawImage(el, 0, 0, sideWidth, height, rx - 5, y + h / 2 - 17, maxSideWidth, 34);
      if (rectInfo.width > 24) ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + 12, y + h / 2 - 17, rw - 24, 34);
      ctx.drawImage(el, width - sideWidth, 0, sideWidth, height, rx + rw - (maxSideWidth - 5), y + h / 2 - 17, maxSideWidth, 34);
      ctx.imageSmoothingEnabled = true;
    }
  }

  ctx.beginPath();

  for (const [i, rectInfo] of renderBoxes.entries()) {
    const d = data[i];
    let drawX = rectInfo.x + bubblePad;

    if (d.img !== void 0) {
      const img = imageLoader.loadOrGetImage(d.img, col, row);

      if (img !== void 0) {
        const imgSize = bubbleHeight - 8;
        let srcX = 0;
        let srcY = 0;
        let srcWidth = img.width;
        let srcHeight = img.height;

        if (srcWidth > srcHeight) {
          srcX += (srcWidth - srcHeight) / 2;
          srcWidth = srcHeight;
        } else if (srcHeight > srcWidth) {
          srcY += (srcHeight - srcWidth) / 2;
          srcHeight = srcWidth;
        }

        ctx.beginPath();
        roundedRect(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, 3);
        ctx.save();
        ctx.clip();
        ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);
        ctx.restore();
        drawX += imgSize + 4;
      }
    }

    ctx.beginPath();
    ctx.fillStyle = theme.textBubble;
    ctx.fillText(d.text, drawX, y + h / 2 + getMiddleCenterBias(ctx, theme));
  }
}

function drawImage(args, data) {
  let rounding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
  const {
    rect,
    col,
    row,
    theme,
    ctx,
    imageLoader
  } = args;
  const {
    x,
    y,
    height: h
  } = rect;
  let drawX = x + theme.cellHorizontalPadding;

  for (const i of data) {
    if (i.length === 0) continue;
    const img = imageLoader.loadOrGetImage(i, col, row);

    if (img !== void 0) {
      const imgHeight = h - theme.cellVerticalPadding * 2;
      const imgWidth = img.width * (imgHeight / img.height);

      if (rounding > 0) {
        roundedRect(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);
        ctx.save();
        ctx.clip();
      }

      ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);

      if (rounding > 0) {
        ctx.restore();
      }

      drawX += imgWidth + itemMargin;
    }
  }
}

function roundedPoly(ctx, points, radiusAll) {
  const asVec = function (p, pp) {
    const vx = pp.x - p.x;
    const vy = pp.y - p.y;
    const vlen = Math.sqrt(vx * vx + vy * vy);
    const vnx = vx / vlen;
    const vny = vy / vlen;
    return {
      x: vx,
      y: pp.y - p.y,
      len: vlen,
      nx: vnx,
      ny: vny,
      ang: Math.atan2(vny, vnx)
    };
  };

  let radius;
  const len = points.length;
  let p1 = points[len - 1];

  for (let i = 0; i < len; i++) {
    let p2 = points[i % len];
    const p3 = points[(i + 1) % len];
    const v1 = asVec(p2, p1);
    const v2 = asVec(p2, p3);
    const sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);
    let radDirection = 1;
    let drawDirection = false;

    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }

    radius = p2.radius !== void 0 ? p2.radius : radiusAll;
    const halfAngle = angle / 2;
    let lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    let cRadius;

    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }

    let x = p2.x + v2.nx * lenOut;
    let y = p2.y + v2.ny * lenOut;
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    p1 = p2;
    p2 = p3;
  }

  ctx.closePath();
}

function computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight) {
  const result = {
    x: 0,
    y: totalHeaderHeight + translateY,
    width: 0,
    height: 0
  };
  const headerHeight = totalHeaderHeight - groupHeaderHeight;

  if (col >= freezeColumns) {
    const dir = cellXOffset > col ? -1 : 1;
    const freezeWidth = getStickyWidth(mappedColumns);
    result.x += freezeWidth + translateX;

    for (let i = cellXOffset; i !== col; i += dir) {
      result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;
    }
  } else {
    for (let i = 0; i < col; i++) {
      result.x += mappedColumns[i].width;
    }
  }

  result.width = mappedColumns[col].width + 1;

  if (row === -1) {
    result.y = groupHeaderHeight;
    result.height = headerHeight;
  } else if (row === -2) {
    result.y = 0;
    result.height = groupHeaderHeight;
    let start = col;
    const group = mappedColumns[col].group;
    const sticky = mappedColumns[col].sticky;

    while (start > 0 && isGroupEqual(mappedColumns[start - 1].group, group) && mappedColumns[start - 1].sticky === sticky) {
      const c = mappedColumns[start - 1];
      result.x -= c.width;
      result.width += c.width;
      start--;
    }

    let end = col;

    while (end + 1 < mappedColumns.length && isGroupEqual(mappedColumns[end + 1].group, group) && mappedColumns[end + 1].sticky === sticky) {
      const c = mappedColumns[end + 1];
      result.width += c.width;
      end++;
    }

    if (!sticky) {
      const freezeWidth = getStickyWidth(mappedColumns);
      const clip = result.x - freezeWidth;

      if (clip < 0) {
        result.x -= clip;
        result.width += clip;
      }

      if (result.x + result.width > width) {
        result.width = width - result.x;
      }
    }
  } else if (lastRowSticky && row === rows - 1) {
    const stickyHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(row);
    result.y = height - stickyHeight;
    result.height = stickyHeight;
  } else {
    const dir = cellYOffset > row ? -1 : 1;

    if (typeof rowHeight === "number") {
      const delta = row - cellYOffset;
      result.y += delta * rowHeight;
    } else {
      for (let r = cellYOffset; r !== row; r += dir) {
        result.y += rowHeight(r) * dir;
      }
    }

    result.height = (typeof rowHeight === "number" ? rowHeight : rowHeight(row)) + 1;
  }

  return result;
}

var iconHead = `<svg width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg">`;

var headerRowID = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/><path d="M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z" fill="${fg}"/></svg>`;
};

var headerCode = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}<rect x="2" y="2" width="16" height="16" rx="4" fill="${bg}"/><path d="m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z" fill="${fg}"/></svg>`;
};

var headerNumber = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z" fill="${fg}"/>
  </svg>`;
};

var headerString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z" fill="${fg}"/>
</svg>`;
};

var headerBoolean = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
    <path
        d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
        fill="${bg}"
    />
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z"
        fill="${fg}"
    />
</svg>`;
};

var headerUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
<path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z" fill="${fg}"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z" fill="${fg}"/>
</svg>
  `;
};

var renameIcon = props => {
  const bg = props.bgColor;
  return `${iconHead}
    <path stroke="${bg}" stroke-width="2" d="M12 3v14"/>
    <path stroke="${bg}" stroke-width="2" stroke-linecap="round" d="M10 4h4m-4 12h4"/>
    <path d="M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z" fill="${bg}"/>
  </svg>
`;
};

var headerAudioUri = headerUri;

var headerVideoUri = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z" fill="${fg}"/>
</svg>`;
};

var headerEmoji = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z" fill="${fg}"/>
    <path d="M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z" fill="${fg}"/>
    <path d="M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z" fill="${fg}"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z" fill="${fg}"/>
  </svg>`;
};

var headerImage = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path opacity=".5" fill-rule="evenodd" clip-rule="evenodd" d="M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z" fill="${fg}"/>
</svg>`;
};

var headerPhone = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path fill="${fg}" d="M3 3h14v14H3z"/>
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z" fill="${bg}"/>
  </svg>`;
};

var headerMarkdown = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z" fill="${fg}"/>
  </svg>`;
};

var headerDate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z" fill="${fg}"/>
</svg>`;
};

var headerTime = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z" fill="${fg}"/>
    <path d="M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z" fill="${fg}"/>
  </svg>`;
};

var headerEmail = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z" fill="${fg}"/>
</svg>`;
};

var headerReference = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="8" width="10" height="8" rx="2" fill="${bg}"/>
    <rect x="8" y="4" width="10" height="8" rx="2" fill="${bg}"/>
    <path d="M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z" fill="${fg}"/>
  </svg>`;
};

var headerIfThenElse = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path fill="${fg}" d="M4 3h12v14H4z"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z" fill="${bg}"/>
</svg>`;
};

var headerSingleValue = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z" fill="${fg}"/>
  </svg>`;
};

var headerLookup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z" fill="${fg}"/>
  </svg>`;
};

var headerTextTemplate = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z" fill="${fg}"/>
</svg>`;
};

var headerMath = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z" fill="${fg}"/>
  <path d="M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z" fill="${fg}"/>
</svg>`;
};

var headerRollup = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <path d="M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z" fill="${bg}"/>
    <path d="M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z" fill="${fg}"/>
  </svg>`;
};

var headerJoinStrings = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path d="M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z" fill="${fg}"/>
</svg>`;
};

var headerSplitString = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    ${iconHead}
    <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
    <path d="M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z" fill="${fg}"/>
  </svg>`;
};

var headerGeoDistance = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <path d="M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z" fill="${bg}"/>
  <path d="M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z" fill="${fg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z" fill="${fg}"/>
</svg>`;
};

var headerArray = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `${iconHead}
  <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z" fill="${fg}"/>
</svg>`;
};

var rowOwnerOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>`;
};

var protectedColumnOverlay = props => {
  const fg = props.fgColor;
  const bg = props.bgColor;
  return `
    <svg width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z" fill="${bg}" stroke="${fg}" stroke-width="2"/>
  </svg>
`;
};

var sprites = {
  headerRowID,
  headerNumber,
  headerCode,
  headerString,
  headerBoolean,
  headerAudioUri,
  headerVideoUri,
  headerEmoji,
  headerImage,
  headerUri,
  headerPhone,
  headerMarkdown,
  headerDate,
  headerTime,
  headerEmail,
  headerReference,
  headerIfThenElse,
  headerSingleValue,
  headerLookup,
  headerTextTemplate,
  headerMath,
  headerRollup,
  headerJoinStrings,
  headerSplitString,
  headerGeoDistance,
  headerArray,
  rowOwnerOverlay,
  protectedColumnOverlay,
  renameIcon
};

function getColors(variant, theme) {
  if (variant === "normal") {
    return [theme.bgIconHeader, theme.fgIconHeader];
  } else if (variant === "selected") {
    return ["white", theme.accentColor];
  } else {
    return [theme.accentColor, theme.bgHeader];
  }
}

var SpriteManager = class {
  constructor(headerIcons, onSettled) {
    this.onSettled = onSettled;
    this.spriteMap = new Map();
    this.inFlight = 0;
    this.headerIcons = { ...sprites,
      ...headerIcons
    };
  }

  drawSprite(sprite, variant, ctx, x, y, size, theme) {
    let alpha = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
    const [bgColor, fgColor] = getColors(variant, theme);
    const rSize = size * Math.ceil(window.devicePixelRatio);
    const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;
    let spriteCanvas = this.spriteMap.get(key);

    if (spriteCanvas === void 0) {
      const spriteCb = this.headerIcons[sprite];
      if (spriteCb === void 0) return;
      spriteCanvas = document.createElement("canvas");
      const spriteCtx = spriteCanvas.getContext("2d");
      if (spriteCtx === null) return;
      const imgSource = new Image();
      imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({
        fgColor,
        bgColor
      }))}`;
      this.spriteMap.set(key, spriteCanvas);
      const promise = imgSource.decode();
      if (promise === void 0) return;
      this.inFlight++;
      promise.then(() => {
        spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);
      }).finally(() => {
        this.inFlight--;

        if (this.inFlight === 0) {
          this.onSettled();
        }
      });
    } else {
      if (alpha < 1) {
        ctx.globalAlpha = alpha;
      }

      ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);

      if (alpha < 1) {
        ctx.globalAlpha = 1;
      }
    }
  }

};



var cache = {};
var div = null;

function createDiv() {
  const d = document.createElement("div");
  d.style.opacity = "0";
  d.style.pointerEvents = "none";
  d.style.position = "fixed";
  document.body.append(d);
  return d;
}

function parseToRgba(color) {
  const normalizedColor = color.toLowerCase().trim();
  if (cache[normalizedColor] !== void 0) return cache[normalizedColor];
  div = div || createDiv();
  div.style.color = "#000";
  div.style.color = normalizedColor;
  const control = getComputedStyle(div).color;
  div.style.color = "#fff";
  div.style.color = normalizedColor;
  const computedColor = getComputedStyle(div).color;
  if (computedColor !== control) throw new Error("Could not parse color");
  const result = computedColor.replace(/[^\d.,]/g, "").split(",").map(Number.parseFloat);

  if (result.length < 4) {
    result.push(1);
  }

  cache[normalizedColor] = result;
  return result;
}

function withAlpha(color, alpha) {
  const [r, g, b] = parseToRgba(color);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function blend(color, background) {
  if (background === void 0) return color;
  const [r, g, b, a] = parseToRgba(color);
  if (a === 1) return color;
  const [br, bg, bb, ba] = parseToRgba(background);
  const ao = a + ba * (1 - a);
  const ro = (a * r + ba * br * (1 - a)) / ao;
  const go = (a * g + ba * bg * (1 - a)) / ao;
  const bo = (a * b + ba * bb * (1 - a)) / ao;
  return `rgba(${ro}, ${go}, ${bo}, ${ao})`;
}

function interpolateColors(leftColor, rightColor, val) {
  if (val <= 0) return leftColor;
  if (val >= 1) return rightColor;
  const left = [...parseToRgba(leftColor)];
  left[0] = left[0] * left[3];
  left[1] = left[1] * left[3];
  left[2] = left[2] * left[3];
  const right = [...parseToRgba(rightColor)];
  right[0] = right[0] * right[3];
  right[1] = right[1] * right[3];
  right[2] = right[2] * right[3];
  const hScaler = val;
  const nScaler = 1 - val;
  const a = left[3] * nScaler + right[3] * hScaler;
  const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);
  const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);
  const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}

var loadingCell = {
  kind: GridCellKind.Loading,
  allowOverlay: false
};

function drawCell(ctx, row, cell, col, x, y, w, h, highlighted, theme, drawCustomCell, imageLoader, spriteManager, hoverAmount, hoverInfo, hyperWrapping, frameTime, lastPrep, enqueue, getCellRenderer) {
  let hoverX;
  let hoverY;

  if (hoverInfo !== void 0 && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {
    hoverX = hoverInfo[1][0];
    hoverY = hoverInfo[1][1];
  }

  let result = void 0;
  const args = {
    ctx,
    theme,
    col,
    row,
    cell,
    rect: {
      x,
      y,
      width: w,
      height: h
    },
    highlighted,
    hoverAmount,
    hoverX,
    hoverY,
    imageLoader,
    spriteManager,
    hyperWrapping,
    requestAnimationFrame: () => {
      forceAnim = true;
    }
  };
  let forceAnim = false;
  const needsAnim = drawWithLastUpdate(args, cell.lastUpdated, frameTime, lastPrep, () => {
    var _a, _b;

    const drawn = isInnerOnlyCell(cell) ? false : (drawCustomCell == null ? void 0 : drawCustomCell(args)) === true;

    if (!drawn) {
      const r = getCellRenderer(cell);

      if (r !== void 0) {
        if ((lastPrep == null ? void 0 : lastPrep.renderer) !== r) {
          (_a = lastPrep == null ? void 0 : lastPrep.deprep) == null ? void 0 : _a.call(lastPrep, args);
          lastPrep = void 0;
        }

        const partialPrepResult = (_b = r.drawPrep) == null ? void 0 : _b.call(r, args, lastPrep);
        r.draw(args, cell);
        result = {
          deprep: partialPrepResult == null ? void 0 : partialPrepResult.deprep,
          fillStyle: partialPrepResult == null ? void 0 : partialPrepResult.fillStyle,
          font: partialPrepResult == null ? void 0 : partialPrepResult.font,
          renderer: r
        };
      }
    }
  });
  if (needsAnim || forceAnim) enqueue == null ? void 0 : enqueue([col, row]);
  return result;
}

function blitLastFrame(ctx, canvas, last, cellXOffset, cellYOffset, translateX, translateY, lastRowSticky, width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, getRowHeight, doubleBuffer) {
  const drawRegions = [];
  let blittedYOnly = false;
  ctx.imageSmoothingEnabled = false;
  const minY = Math.min(last.cellYOffset, cellYOffset);
  const maxY = Math.max(last.cellYOffset, cellYOffset);
  let deltaY = 0;

  if (typeof getRowHeight === "number") {
    deltaY += (maxY - minY) * getRowHeight;
  } else {
    for (let i = minY; i < maxY; i++) {
      deltaY += getRowHeight(i);
    }
  }

  if (cellYOffset > last.cellYOffset) {
    deltaY = -deltaY;
  }

  deltaY += translateY - last.translateY;
  const minX = Math.min(last.cellXOffset, cellXOffset);
  const maxX = Math.max(last.cellXOffset, cellXOffset);
  let deltaX = 0;

  for (let i = minX; i < maxX; i++) {
    deltaX += mappedColumns[i].width;
  }

  if (cellXOffset > last.cellXOffset) {
    deltaX = -deltaX;
  }

  deltaX += translateX - last.translateX;
  let stickyWidth = getStickyWidth(effectiveCols);
  if (stickyWidth > 0) stickyWidth++;

  if (deltaX !== 0 && deltaY !== 0) {
    return {
      regions: [],
      yOnly: false
    };
  }

  const stickyRowHeight = lastRowSticky ? typeof getRowHeight === "number" ? getRowHeight : getRowHeight(rows - 1) : 0;
  const blitWidth = width - stickyWidth - Math.abs(deltaX);
  const blitHeight = height - totalHeaderHeight - stickyRowHeight - Math.abs(deltaY) - 1;

  if (blitWidth > 150 && blitHeight > 150) {
    blittedYOnly = deltaX === 0;
    const args = {
      sx: 0,
      sy: 0,
      sw: width * dpr,
      sh: height * dpr,
      dx: 0,
      dy: 0,
      dw: width * dpr,
      dh: height * dpr
    };

    if (deltaY > 0) {
      args.sy = (totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (deltaY + totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: totalHeaderHeight,
        width,
        height: deltaY + 1
      });
    } else if (deltaY < 0) {
      args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;
      args.sh = blitHeight * dpr;
      args.dy = (totalHeaderHeight + 1) * dpr;
      args.dh = blitHeight * dpr;
      drawRegions.push({
        x: 0,
        y: height + deltaY - stickyRowHeight,
        width,
        height: -deltaY + stickyRowHeight
      });
    }

    if (deltaX > 0) {
      args.sx = stickyWidth * dpr;
      args.sw = blitWidth * dpr;
      args.dx = (deltaX + stickyWidth) * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: stickyWidth - 1,
        y: 0,
        width: deltaX + 2,
        height
      });
    } else if (deltaX < 0) {
      args.sx = (stickyWidth - deltaX) * dpr;
      args.sw = blitWidth * dpr;
      args.dx = stickyWidth * dpr;
      args.dw = blitWidth * dpr;
      drawRegions.push({
        x: width + deltaX,
        y: 0,
        width: -deltaX,
        height
      });
    }

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    if (stickyWidth > 0 && deltaX !== 0 && deltaY === 0 && doubleBuffer) {
      ctx.drawImage(canvas, 0, 0, stickyWidth * dpr, height * dpr, 0, 0, stickyWidth * dpr, height * dpr);
    }

    ctx.drawImage(canvas, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);
    ctx.scale(dpr, dpr);
  }

  ctx.imageSmoothingEnabled = true;
  return {
    regions: drawRegions,
    yOnly: blittedYOnly
  };
}

function blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedIndex) {
  const drawRegions = [];

  if (cellXOffset !== last.cellXOffset || cellYOffset !== last.cellYOffset || translateX !== last.translateX || translateY !== last.translateY) {
    return drawRegions;
  }

  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {
    if (c.sourceIndex === resizedIndex) {
      const x = Math.max(drawX, clipX) + 1;
      drawRegions.push({
        x,
        y: 0,
        width: width - x,
        height
      });
      return true;
    }
  });
  return drawRegions;
}

function drawGridLines(ctx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme) {
  let verticalOnly = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : false;

  var _a, _b, _c;

  if (spans !== void 0) {
    ctx.beginPath();
    ctx.save();
    ctx.rect(0, 0, width, height);

    for (const span of spans) {
      ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);
    }

    ctx.clip("evenodd");
  }

  const hColor = (_a = theme.horizontalBorderColor) != null ? _a : theme.borderColor;
  const vColor = theme.borderColor;
  let minX = 0;
  let maxX = width;
  let minY = 0;
  let maxY = height;

  if (drawRegions !== void 0 && drawRegions.length > 0) {
    minX = Number.MAX_SAFE_INTEGER;
    minY = Number.MAX_SAFE_INTEGER;
    maxX = Number.MIN_SAFE_INTEGER;
    maxY = Number.MIN_SAFE_INTEGER;

    for (const r of drawRegions) {
      minX = Math.min(minX, r.x - 1);
      maxX = Math.max(maxX, r.x + r.width + 1);
      minY = Math.min(minY, r.y - 1);
      maxY = Math.max(maxY, r.y + r.height + 1);
    }
  }

  const toDraw = [];
  ctx.beginPath();
  let x = 0.5;

  for (let index = 0; index < effectiveCols.length; index++) {
    const c = effectiveCols[index];
    if (c.width === 0) continue;
    x += c.width;
    const tx = c.sticky ? x : x + translateX;

    if (tx >= minX && tx <= maxX - 1 && verticalBorder(index + 1)) {
      toDraw.push({
        x1: tx,
        y1: Math.max(groupHeaderHeight, minY),
        x2: tx,
        y2: Math.min(height, maxY),
        color: vColor
      });
    }
  }

  const stickyHeight = getRowHeight(rows - 1);
  const stickyRowY = height - stickyHeight + 0.5;
  const lastRowSticky = trailingRowType === "sticky";

  if (lastRowSticky) {
    toDraw.push({
      x1: minX,
      y1: stickyRowY,
      x2: maxX,
      y2: stickyRowY,
      color: hColor
    });
  }

  if (verticalOnly !== true) {
    let y = totalHeaderHeight + 0.5;
    let row = cellYOffset;
    const target = lastRowSticky ? height - stickyHeight : height;

    while (y + translateY <= target) {
      const ty = y + translateY;

      if (ty >= minY && ty <= maxY - 1 && (!lastRowSticky || row !== rows - 1 || Math.abs(ty - stickyRowY) > 1)) {
        const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
        toDraw.push({
          x1: minX,
          y1: ty,
          x2: maxX,
          y2: ty,
          color: (_c = (_b = rowTheme == null ? void 0 : rowTheme.horizontalBorderColor) != null ? _b : rowTheme == null ? void 0 : rowTheme.borderColor) != null ? _c : hColor
        });
      }

      y += getRowHeight(row);
      row++;
    }
  }

  const groups = lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_11__(toDraw, line => line.color);

  for (const g of Object.keys(groups)) {
    ctx.strokeStyle = g;

    for (const line of groups[g]) {
      ctx.moveTo(line.x1, line.y1);
      ctx.lineTo(line.x2, line.y2);
    }

    ctx.stroke();
    ctx.beginPath();
  }

  if (spans !== void 0) {
    ctx.restore();
  }
}

function getActionBoundsForGroup(box, actions) {
  const result = [];
  let x = box.x + box.width - 26 * actions.length;
  const y = box.y + box.height / 2 - 13;
  const height = 26;
  const width = 26;

  for (let i = 0; i < actions.length; i++) {
    result.push({
      x,
      y,
      width,
      height
    });
    x += 26;
  }

  return result;
}

function pointInRect(rect, x, y) {
  return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
}

function drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, theme, spriteManager, _hoverValues, verticalBorder, getGroupDetails, damage) {
  var _a;

  const xPad = 8;
  const [hCol, hRow] = (_a = hovered == null ? void 0 : hovered[0]) != null ? _a : [];
  let finalX = 0;
  walkGroups(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {
    var _a2, _b;

    if (damage !== void 0 && !damage.some(d => d[1] === -2 && d[0] >= span[0] && d[0] <= span[1])) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip();
    const group = getGroupDetails(groupName);
    const groupTheme = (group == null ? void 0 : group.overrideTheme) === void 0 ? theme : { ...theme,
      ...group.overrideTheme
    };
    const isHovered = hRow === -2 && hCol !== void 0 && hCol >= span[0] && hCol <= span[1];
    const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;

    if (fillColor !== theme.bgHeader) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }

    ctx.fillStyle = (_a2 = groupTheme.textGroupHeader) != null ? _a2 : groupTheme.textHeader;

    if (group !== void 0) {
      let drawX = x;

      if (group.icon !== void 0) {
        spriteManager.drawSprite(group.icon, "normal", ctx, drawX + xPad, (groupHeaderHeight - 20) / 2, 20, groupTheme);
        drawX += 26;
      }

      ctx.fillText(group.name, drawX + xPad, groupHeaderHeight / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

      if (group.actions !== void 0 && isHovered) {
        const actionBoxes = getActionBoundsForGroup({
          x,
          y,
          width: w,
          height: h
        }, group.actions);
        ctx.beginPath();
        const fadeStartX = actionBoxes[0].x - 10;
        const fadeWidth = x + w - fadeStartX;
        ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);
        const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);
        const trans = withAlpha(fillColor, 0);
        grad.addColorStop(0, trans);
        grad.addColorStop(10 / fadeWidth, fillColor);
        grad.addColorStop(1, fillColor);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 0.6;
        const [mouseX, mouseY] = (_b = hovered == null ? void 0 : hovered[1]) != null ? _b : [-1, -1];

        for (let i = 0; i < group.actions.length; i++) {
          const action = group.actions[i];
          const box = actionBoxes[i];
          const actionHovered = pointInRect(box, mouseX + x, mouseY);

          if (actionHovered) {
            ctx.globalAlpha = 1;
          }

          spriteManager.drawSprite(action.icon, "normal", ctx, box.x + box.width / 2 - 10, box.y + box.height / 2 - 10, 20, groupTheme);

          if (actionHovered) {
            ctx.globalAlpha = 0.6;
          }
        }

        ctx.globalAlpha = 1;
      }
    }

    if (x !== 0 && verticalBorder(span[0])) {
      ctx.beginPath();
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, groupHeaderHeight);
      ctx.strokeStyle = theme.borderColor;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.restore();
    finalX = x + w;
  });
  ctx.beginPath();
  ctx.moveTo(finalX + 0.5, 0);
  ctx.lineTo(finalX + 0.5, groupHeaderHeight);
  ctx.moveTo(0, groupHeaderHeight + 0.5);
  ctx.lineTo(width, groupHeaderHeight + 0.5);
  ctx.strokeStyle = theme.borderColor;
  ctx.lineWidth = 1;
  ctx.stroke();
}

var menuButtonSize = 30;

function getHeaderMenuBounds(x, y, width, height) {
  return {
    x: x + width - menuButtonSize,
    y: Math.max(y, y + height / 2 - menuButtonSize / 2),
    width: menuButtonSize,
    height: Math.min(menuButtonSize, height)
  };
}

function drawHeader(ctx, x, y, width, height, c, selected, theme, isHovered, hasSelectedCell, hoverAmount, spriteManager, drawHeaderCallback, touchMode) {
  const isCheckboxHeader = c.title.startsWith(headerCellCheckboxPrefix);
  const menuBounds = getHeaderMenuBounds(x, y, width, height);

  if (drawHeaderCallback !== void 0) {
    let passCol = c;

    if (isCheckboxHeader) {
      passCol = { ...c,
        title: ""
      };
    }

    if (drawHeaderCallback({
      ctx,
      theme,
      rect: {
        x,
        y,
        width,
        height
      },
      column: passCol,
      columnIndex: passCol.sourceIndex,
      isSelected: selected,
      hoverAmount,
      isHovered,
      hasSelectedCell,
      spriteManager,
      menuBounds
    })) {
      return;
    }
  }

  if (isCheckboxHeader) {
    let checked = void 0;
    if (c.title === headerCellCheckedMarker) checked = true;
    if (c.title === headerCellUnheckedMarker) checked = false;

    if (checked !== true) {
      ctx.globalAlpha = hoverAmount;
    }

    drawCheckbox(ctx, theme, checked, x, y, width, height, false, void 0, void 0);

    if (checked !== true) {
      ctx.globalAlpha = 1;
    }

    return;
  }

  const xPad = 8;
  const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;
  const shouldDrawMenu = c.hasMenu === true && (isHovered || touchMode && selected);
  let drawX = x + xPad;

  if (c.icon !== void 0) {
    let variant = selected ? "selected" : "normal";

    if (c.style === "highlight") {
      variant = selected ? "selected" : "special";
    }

    spriteManager.drawSprite(c.icon, variant, ctx, drawX, y + (height - 20) / 2, 20, theme);

    if (c.overlayIcon !== void 0) {
      spriteManager.drawSprite(c.overlayIcon, selected ? "selected" : "special", ctx, drawX + 9, y + ((height - 18) / 2 + 6), 18, theme);
    }

    drawX += 26;
  }

  if (shouldDrawMenu && c.hasMenu === true && width > 35) {
    const fadeWidth = 35;
    const fadeStart = width - fadeWidth;
    const fadeEnd = width - fadeWidth * 0.7;
    const fadeStartPercent = fadeStart / width;
    const fadeEndPercent = fadeEnd / width;
    const grad = ctx.createLinearGradient(x, 0, x + width, 0);
    const trans = withAlpha(fillStyle, 0);
    grad.addColorStop(0, fillStyle);
    grad.addColorStop(fadeStartPercent, fillStyle);
    grad.addColorStop(fadeEndPercent, trans);
    grad.addColorStop(1, trans);
    ctx.fillStyle = grad;
  } else {
    ctx.fillStyle = fillStyle;
  }

  ctx.fillText(c.title, drawX, y + height / 2 + getMiddleCenterBias(ctx, `${theme.headerFontStyle} ${theme.fontFamily}`));

  if (shouldDrawMenu && c.hasMenu === true) {
    ctx.beginPath();
    const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;
    const triangleY = menuBounds.y + menuBounds.height / 2 - 3;
    roundedPoly(ctx, [{
      x: triangleX,
      y: triangleY
    }, {
      x: triangleX + 11,
      y: triangleY
    }, {
      x: triangleX + 5.5,
      y: triangleY + 6
    }], 1);
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }
}

function drawGridHeaders(ctx, effectiveCols, enableGroups, hovered, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode) {
  var _a;

  const totalHeaderHeight = headerHeight + groupHeaderHeight;
  if (totalHeaderHeight <= 0) return;
  ctx.fillStyle = outerTheme.bgHeader;
  ctx.fillRect(0, 0, width, totalHeaderHeight);
  const [hCol, hRow] = (_a = hovered == null ? void 0 : hovered[0]) != null ? _a : [];
  const font = `${outerTheme.headerFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  walkColumns(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {
    var _a2, _b, _c;

    if (damage !== void 0 && !damage.some(d => d[1] === -1 && d[0] === c.sourceIndex)) return;
    const diff = Math.max(0, clipX - x);
    ctx.save();
    ctx.beginPath();
    ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);
    ctx.clip();
    const groupTheme = getGroupDetails((_a2 = c.group) != null ? _a2 : "").overrideTheme;
    const theme = c.themeOverride === void 0 && groupTheme === void 0 ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };

    if (theme.bgHeader !== outerTheme.bgHeader) {
      ctx.fillStyle = theme.bgHeader;
      ctx.fill();
    }

    const f = `${theme.headerFontStyle} ${theme.fontFamily}`;

    if (font !== f) {
      ctx.font = f;
    }

    const selected = selection.columns.hasIndex(c.sourceIndex);
    const noHover = dragAndDropState !== void 0 || isResizing;
    const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;
    const hover = noHover ? 0 : (_c = (_b = hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)) == null ? void 0 : _b.hoverAmount) != null ? _c : 0;
    const hasSelectedCell = (selection == null ? void 0 : selection.current) !== void 0 && selection.current.cell[0] === c.sourceIndex;
    const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;
    const y = enableGroups ? groupHeaderHeight : 0;
    const xOffset = c.sourceIndex === 0 ? 0 : 1;

    if (selected) {
      ctx.fillStyle = bgFillStyle;
      ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);
    } else if (hasSelectedCell || hover > 0) {
      ctx.beginPath();
      ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);

      if (hasSelectedCell) {
        ctx.fillStyle = theme.bgHeaderHasFocus;
        ctx.fill();
      }

      if (hover > 0) {
        ctx.globalAlpha = hover;
        ctx.fillStyle = theme.bgHeaderHovered;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    drawHeader(ctx, x, y, c.width, headerHeight, c, selected, theme, hoveredBoolean, hasSelectedCell, hover, spriteManager, drawHeaderCallback, touchMode);
    ctx.restore();
  });

  if (enableGroups) {
    drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage);
  }
}

function intersectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
  return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;
}

function clipDamage(ctx, effectiveColumns, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, includeCells) {
  if (damage === void 0 || damage.length === 0) return;
  const stickyRowHeight = trailingRowType === "sticky" ? getRowHeight(rows - 1) : 0;
  ctx.beginPath();
  walkGroups(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {
    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[1] === -2 && d[0] >= span[0] && d[0] <= span[1]) {
        ctx.rect(x, y, w, h);
        break;
      }
    }
  });
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    const diff = Math.max(0, clipX - drawX);
    const finalX = drawX + diff + 1;
    const finalWidth = c.width - diff - 1;

    for (let i = 0; i < damage.length; i++) {
      const d = damage[i];

      if (d[0] === c.sourceIndex && (d[1] === -1 || d[1] === void 0)) {
        ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);
        break;
      }
    }

    if (!includeCells) return;
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      let isDamaged = false;

      for (let i = 0; i < damage.length; i++) {
        const d = damage[i];

        if (d[0] === c.sourceIndex && d[1] === row) {
          isDamaged = true;
          break;
        }
      }

      if (isDamaged) {
        const top = drawY + 1;
        const bottom = isSticky ? top + rh - 1 : Math.min(top + rh - 1, height - stickyRowHeight);
        const h = bottom - top;

        if (h > 0) {
          ctx.rect(finalX, top, finalWidth, h);
        }
      }
    });
  });
  ctx.clip();
}

function getSpanBounds(span, cellX, cellY, cellW, cellH, column, allColumns) {
  var _a, _b;

  const [startCol, endCol] = span;
  let frozenRect;
  let contentRect;
  const firstNonSticky = (_b = (_a = allColumns.find(x => !x.sticky)) == null ? void 0 : _a.sourceIndex) != null ? _b : 0;

  if (endCol > firstNonSticky) {
    const renderFromCol = Math.max(startCol, firstNonSticky);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= endCol; x++) {
      tempW += allColumns[x].width;
    }

    contentRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  if (firstNonSticky > startCol) {
    const renderToCol = Math.min(endCol, firstNonSticky - 1);
    let tempX = cellX;
    let tempW = cellW;

    for (let x = column.sourceIndex - 1; x >= startCol; x--) {
      tempX -= allColumns[x].width;
      tempW += allColumns[x].width;
    }

    for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {
      tempW += allColumns[x].width;
    }

    frozenRect = {
      x: tempX,
      y: cellY,
      width: tempW,
      height: cellH
    };
  }

  return [frozenRect, contentRect];
}

function drawCells(ctx, effectiveColumns, allColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, outerTheme, enqueue, getCellRenderer) {
  var _a;

  let toDraw = (_a = damage == null ? void 0 : damage.length) != null ? _a : Number.MAX_SAFE_INTEGER;
  const frameTime = performance.now();
  let font = `${outerTheme.baseFontStyle} ${outerTheme.fontFamily}`;
  ctx.font = font;
  let result;
  const handledSpans = new Set();
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawStartY, clipX, startRow) => {
    var _a2;

    const diff = Math.max(0, clipX - drawX);
    const colDrawX = drawX + diff;
    const colDrawY = totalHeaderHeight + 1;
    const colWidth = c.width - diff;
    const colHeight = height - totalHeaderHeight - 1;

    if (drawRegions.length > 0) {
      let found = false;

      for (let i = 0; i < drawRegions.length; i++) {
        const dr = drawRegions[i];

        if (intersectRect(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {
          found = true;
          break;
        }
      }

      if (!found) return;
    }

    const reclip = () => {
      ctx.save();
      ctx.beginPath();
      ctx.rect(colDrawX, colDrawY, colWidth, colHeight);
      ctx.clip();
    };

    const colSelected = selection.columns.hasIndex(c.sourceIndex);
    const groupTheme = getGroupDetails((_a2 = c.group) != null ? _a2 : "").overrideTheme;
    const colTheme = c.themeOverride === void 0 && groupTheme === void 0 ? outerTheme : { ...outerTheme,
      ...groupTheme,
      ...c.themeOverride
    };
    const colFont = `${colTheme.baseFontStyle} ${colTheme.fontFamily}`;

    if (colFont !== font) {
      font = colFont;
      ctx.font = colFont;
    }

    reclip();
    let prepResult = void 0;
    walkRowsInCol(startRow, colDrawStartY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky, isTrailingRow) => {
      var _a3, _b, _c, _d;

      if (row < 0) return;

      if (damage !== void 0) {
        let found = false;

        for (let i = 0; i < damage.length; i++) {
          const d = damage[i];

          if (d[0] === c.sourceIndex && d[1] === row) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      if (drawRegions.length > 0) {
        let found = false;

        for (let i = 0; i < drawRegions.length; i++) {
          const dr = drawRegions[i];

          if (intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {
            found = true;
            break;
          }
        }

        if (!found) return;
      }

      const rowSelected = selection.rows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      const cell = row < rows ? getCellContent([c.sourceIndex, row]) : loadingCell;
      let cellX = drawX;
      let cellWidth = c.width;
      let drawingSpan = false;
      let skipContents = false;

      if (cell.span !== void 0) {
        const [startCol, endCol] = cell.span;
        const spanKey = `${row},${startCol},${endCol},${c.sticky}`;

        if (!handledSpans.has(spanKey)) {
          const areas = getSpanBounds(cell.span, drawX, drawY, c.width, rh, c, allColumns);
          const area = c.sticky ? areas[0] : areas[1];

          if (!c.sticky && areas[0] !== void 0) {
            skipContents = true;
          }

          if (area !== void 0) {
            cellX = area.x;
            cellWidth = area.width;
            handledSpans.add(spanKey);
            ctx.restore();
            prepResult = void 0;
            ctx.save();
            ctx.beginPath();
            const d = Math.max(0, clipX - area.x);
            ctx.rect(area.x + d, drawY, area.width - d, rh);

            if (result === void 0) {
              result = [];
            }

            result.push({
              x: area.x + d,
              y: drawY,
              width: area.width - d,
              height: rh
            });
            ctx.clip();
            drawingSpan = true;
          }
        } else {
          toDraw--;
          return;
        }
      }

      const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
      const trailingTheme = isTrailingRow && ((_a3 = c.trailingRowOptions) == null ? void 0 : _a3.themeOverride) !== void 0 ? (_b = c.trailingRowOptions) == null ? void 0 : _b.themeOverride : void 0;
      const theme = cell.themeOverride === void 0 && rowTheme === void 0 && trailingTheme === void 0 ? colTheme : { ...colTheme,
        ...rowTheme,
        ...trailingTheme,
        ...cell.themeOverride
      };
      ctx.beginPath();
      const cellIndex = [c.sourceIndex, row];
      const isSelected = cellIsSelected(cellIndex, cell, selection);
      let accentCount = cellIsInRange(cellIndex, cell, selection);
      const spanIsHighlighted = cell.span !== void 0 && selection.columns.some(index => cell.span !== void 0 && index >= cell.span[0] && index <= cell.span[1]);

      if (isSelected && !isFocused && drawFocus) {
        accentCount = 0;
      } else if (isSelected) {
        accentCount = Math.max(accentCount, 1);
      }

      if (spanIsHighlighted) {
        accentCount++;
      }

      if (!isSelected) {
        if (rowSelected) accentCount++;
        if (colSelected && !isSticky) accentCount++;
      }

      const bgCell = cell.kind === GridCellKind.Protected ? theme.bgCellMedium : theme.bgCell;
      let fill;

      if (isSticky || bgCell !== outerTheme.bgCell) {
        fill = blend(bgCell, fill);
      }

      if (accentCount > 0 || rowDisabled) {
        if (rowDisabled) {
          fill = blend(theme.bgHeader, fill);
        }

        for (let i = 0; i < accentCount; i++) {
          fill = blend(theme.accentLight, fill);
        }
      } else {
        if ((prelightCells == null ? void 0 : prelightCells.some(pre => pre[0] === c.sourceIndex && pre[1] === row)) === true) {
          fill = blend(theme.bgSearchResult, fill);
        }
      }

      if (highlightRegions !== void 0) {
        for (const region of highlightRegions) {
          const r = region.range;

          if (r.x <= c.sourceIndex && c.sourceIndex < r.x + r.width && r.y <= row && row < r.y + r.height) {
            fill = blend(region.color, fill);
          }
        }
      }

      if (fill !== void 0) {
        ctx.fillStyle = fill;

        if (prepResult !== void 0) {
          prepResult.fillStyle = fill;
        }

        ctx.fillRect(cellX, drawY, cellWidth, rh);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 0.6;
      }

      const hoverValue = hoverValues.find(hv => hv.item[0] === c.sourceIndex && hv.item[1] === row);

      if (cellWidth > 10 && !skipContents) {
        const cellFont = `${theme.baseFontStyle} ${theme.fontFamily}`;

        if (cellFont !== font) {
          ctx.font = cellFont;
          font = cellFont;
        }

        prepResult = drawCell(ctx, row, cell, c.sourceIndex, cellX, drawY, cellWidth, rh, accentCount > 0, theme, drawCustomCell, imageLoader, spriteManager, (_c = hoverValue == null ? void 0 : hoverValue.hoverAmount) != null ? _c : 0, hoverInfo, hyperWrapping, frameTime, prepResult, enqueue, getCellRenderer);
      }

      if (cell.style === "faded") {
        ctx.globalAlpha = 1;
      }

      toDraw--;

      if (drawingSpan) {
        ctx.restore();
        (_d = prepResult == null ? void 0 : prepResult.deprep) == null ? void 0 : _d.call(prepResult, {
          ctx
        });
        prepResult = void 0;
        reclip();
        font = colFont;
        ctx.font = colFont;
      }

      return toDraw <= 0;
    });
    ctx.restore();
    return toDraw <= 0;
  });
  return result;
}

function drawBlanks(ctx, effectiveColumns, allColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowTheme, selectedRows, disabledRows, trailingRowType, drawRegions, damage, theme) {
  if (damage !== void 0 || effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1]) return;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {
    if (c !== effectiveColumns[effectiveColumns.length - 1]) return;
    drawX += c.width;
    const x = Math.max(drawX, clipX);
    if (x > width) return;
    ctx.save();
    ctx.beginPath();
    ctx.rect(x, totalHeaderHeight + 1, 1e4, height - totalHeaderHeight - 1);
    ctx.clip();
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh, isSticky) => {
      if (!isSticky && drawRegions.length > 0 && !drawRegions.some(dr => intersectRect(drawX, drawY, 1e4, rh, dr.x, dr.y, dr.width, dr.height))) {
        return;
      }

      const rowSelected = selectedRows.hasIndex(row);
      const rowDisabled = disabledRows.hasIndex(row);
      ctx.beginPath();
      const rowTheme = getRowTheme == null ? void 0 : getRowTheme(row);
      const blankTheme = rowTheme === void 0 ? theme : { ...theme,
        ...rowTheme
      };

      if (blankTheme.bgCell !== theme.bgCell) {
        ctx.fillStyle = blankTheme.bgCell;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }

      if (rowDisabled) {
        ctx.fillStyle = blankTheme.bgHeader;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }

      if (rowSelected) {
        ctx.fillStyle = blankTheme.accentLight;
        ctx.fillRect(drawX, drawY, 1e4, rh);
      }
    });
    ctx.restore();
  });
}

function overdrawStickyBoundaries(ctx, effectiveCols, width, height, lastRowSticky, rows, verticalBorder, getRowHeight, theme) {
  var _a;

  let drawFreezeBorder = false;

  for (const c of effectiveCols) {
    if (c.sticky) continue;
    drawFreezeBorder = verticalBorder(c.sourceIndex);
    break;
  }

  const hColor = (_a = theme.horizontalBorderColor) != null ? _a : theme.borderColor;
  const vColor = theme.borderColor;
  const drawX = drawFreezeBorder ? getStickyWidth(effectiveCols) : 0;

  if (drawX !== 0) {
    ctx.beginPath();
    ctx.moveTo(drawX + 0.5, 0);
    ctx.lineTo(drawX + 0.5, height);
    ctx.strokeStyle = blend(vColor, theme.bgCell);
    ctx.stroke();
  }

  if (lastRowSticky) {
    const h = getRowHeight(rows - 1);
    ctx.beginPath();
    ctx.moveTo(0, height - h + 0.5);
    ctx.lineTo(width, height - h + 0.5);
    ctx.strokeStyle = blend(hColor, theme.bgCell);
    ctx.stroke();
  }
}

function drawHighlightRings(ctx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, lastRowSticky, rows, allHighlightRegions) {
  const highlightRegions = allHighlightRegions == null ? void 0 : allHighlightRegions.filter(x => x.style !== "no-outline");
  if (highlightRegions === void 0 || highlightRegions.length === 0) return void 0;
  const drawRects = highlightRegions.map(h => {
    var _a, _b, _c, _d, _e;

    const r = h.range;
    const topLeftBounds = computeBounds(r.x, r.y, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.width === 1 && r.height === 1) {
      if (r.x < freezeColumns) {
        return [{
          color: h.color,
          style: (_a = h.style) != null ? _a : "dashed",
          rect: topLeftBounds
        }, void 0];
      }

      return [void 0, {
        color: h.color,
        style: (_b = h.style) != null ? _b : "dashed",
        rect: topLeftBounds
      }];
    }

    const bottomRightBounds = computeBounds(r.x + r.width - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);

    if (r.x < freezeColumns && r.x + r.width >= freezeColumns) {
      const freezeSectionRightBounds = computeBounds(freezeColumns - 1, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      const unfreezeSectionleftBounds = computeBounds(freezeColumns, r.y + r.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, lastRowSticky, mappedColumns, rowHeight);
      return [{
        color: h.color,
        style: (_c = h.style) != null ? _c : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: freezeSectionRightBounds.x + freezeSectionRightBounds.width - topLeftBounds.x,
          height: freezeSectionRightBounds.y + freezeSectionRightBounds.height - topLeftBounds.y
        }
      }, {
        color: h.color,
        style: (_d = h.style) != null ? _d : "dashed",
        rect: {
          x: unfreezeSectionleftBounds.x,
          y: unfreezeSectionleftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - unfreezeSectionleftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - unfreezeSectionleftBounds.y
        }
      }];
    } else {
      return [void 0, {
        color: h.color,
        style: (_e = h.style) != null ? _e : "dashed",
        rect: {
          x: topLeftBounds.x,
          y: topLeftBounds.y,
          width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,
          height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y
        }
      }];
    }
  });
  const stickyWidth = getStickyWidth(mappedColumns);

  const drawCb = () => {
    ctx.beginPath();
    ctx.save();
    let dashed = false;

    const setDashed = dash => {
      if (dashed === dash) return;
      ctx.setLineDash(dash ? [5, 3] : []);
      dashed = dash;
    };

    ctx.lineWidth = 1;

    for (const dr of drawRects) {
      const [s] = dr;

      if (s !== void 0 && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");
        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    let clipped = false;

    for (const dr of drawRects) {
      const [, s] = dr;

      if (s !== void 0 && intersectRect(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {
        setDashed(s.style === "dashed");

        if (!clipped && s.rect.x < stickyWidth) {
          ctx.rect(stickyWidth, 0, width, height);
          ctx.clip();
          clipped = true;
        }

        ctx.strokeStyle = withAlpha(s.color, 1);
        ctx.strokeRect(s.rect.x + 1, s.rect.y + 1, s.rect.width - 2, s.rect.height - 2);
      }
    }

    ctx.restore();
  };

  drawCb();
  return drawCb;
}

function drawFocusRing(ctx, width, height, cellYOffset, translateX, translateY, effectiveCols, allColumns, theme, totalHeaderHeight, selectedCell, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) {
  var _a;

  if (selectedCell.current === void 0 || !effectiveCols.some(c => {
    var _a2;

    return c.sourceIndex === ((_a2 = selectedCell.current) == null ? void 0 : _a2.cell[0]);
  })) return void 0;
  const [targetCol, targetRow] = selectedCell.current.cell;
  const cell = getCellContent(selectedCell.current.cell);
  const targetColSpan = (_a = cell.span) != null ? _a : [targetCol, targetCol];
  const isStickyRow = trailingRowType === "sticky" && targetRow === rows - 1;
  const stickRowHeight = trailingRowType === "sticky" && !isStickyRow ? getRowHeight(rows - 1) - 1 : 0;
  let drawCb = void 0;
  walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (col, drawX, colDrawY, clipX, startRow) => {
    if (col.sticky && targetCol > col.sourceIndex) return;

    if (col.sourceIndex < targetColSpan[0] || col.sourceIndex > targetColSpan[1]) {
      return;
    }

    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (drawY, row, rh) => {
      if (row !== targetRow) return;
      let cellX = drawX;
      let cellWidth = col.width;

      if (cell.span !== void 0) {
        const areas = getSpanBounds(cell.span, drawX, drawY, col.width, rh, col, allColumns);
        const area = col.sticky ? areas[0] : areas[1];

        if (area !== void 0) {
          cellX = area.x;
          cellWidth = area.width;
        }
      }

      drawCb = () => {
        var _a2, _b, _c, _d;

        if (clipX > cellX && !col.sticky) {
          ctx.beginPath();
          ctx.rect(clipX, 0, width - clipX, height);
          ctx.clip();
        }

        ctx.beginPath();
        ctx.rect(cellX + 0.5, drawY + 0.5, cellWidth, rh);
        ctx.strokeStyle = (_b = (_a2 = col.themeOverride) == null ? void 0 : _a2.accentColor) != null ? _b : theme.accentColor;
        ctx.lineWidth = 1;
        ctx.stroke();

        if (fillHandle) {
          ctx.beginPath();
          ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);
          ctx.fillStyle = (_d = (_c = col.themeOverride) == null ? void 0 : _c.accentColor) != null ? _d : theme.accentColor;
          ctx.fill();
        }
      };

      return true;
    });
    return true;
  });
  if (drawCb === void 0) return void 0;

  const result = () => {
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);
    ctx.clip();
    drawCb == null ? void 0 : drawCb();
    ctx.restore();
  };

  result();
  return result;
}

function getLastRow(effectiveColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType) {
  let result = 0;
  walkColumns(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (_c, __drawX, colDrawY, _clipX, startRow) => {
    walkRowsInCol(startRow, colDrawY, height, rows, getRowHeight, trailingRowType, (_drawY, row, _rh, isSticky) => {
      if (!isSticky) {
        result = Math.max(row, result);
      }
    });
    return true;
  });
  return result;
}

function computeCanBlit(current, last) {
  if (last === void 0) return false;

  if (current.width !== last.width || current.height !== last.height || current.theme !== last.theme || current.headerHeight !== last.headerHeight || current.rowHeight !== last.rowHeight || current.rows !== last.rows || current.getRowThemeOverride !== last.getRowThemeOverride || current.isFocused !== last.isFocused || current.isResizing !== last.isResizing || current.verticalBorder !== last.verticalBorder || current.getCellContent !== last.getCellContent || current.highlightRegions !== last.highlightRegions || current.selection !== last.selection || current.dragAndDropState !== last.dragAndDropState || current.prelightCells !== last.prelightCells || current.touchMode !== last.touchMode || current.scrolling !== last.scrolling) {
    return false;
  }

  if (current.mappedColumns !== last.mappedColumns) {
    if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {
      return false;
    }

    let resized;

    for (let i = 0; i < current.mappedColumns.length; i++) {
      const curCol = current.mappedColumns[i];
      const lastCol = last.mappedColumns[i];
      if (deepEqual(curCol, lastCol)) continue;
      if (resized !== void 0) return false;
      if (curCol.width === lastCol.width) return false;
      const {
        width,
        ...curRest
      } = curCol;
      const {
        width: lastWidth,
        ...lastRest
      } = lastCol;
      if (!deepEqual(curRest, lastRest)) return false;
      resized = i;
    }

    if (resized === void 0) {
      return true;
    }

    return resized;
  }

  return true;
}

function drawGrid(arg, lastArg) {
  var _a, _b;

  const {
    canvas,
    headerCanvas,
    width,
    height,
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mappedColumns,
    enableGroups,
    freezeColumns,
    dragAndDropState,
    theme,
    drawFocus,
    headerHeight,
    groupHeaderHeight,
    disabledRows,
    rowHeight,
    verticalBorder,
    isResizing,
    selection,
    fillHandle,
    lastRowSticky: trailingRowType,
    rows,
    getCellContent,
    getGroupDetails,
    getRowThemeOverride,
    isFocused,
    drawCustomCell,
    drawHeaderCallback,
    prelightCells,
    highlightRegions,
    imageLoader,
    lastBlitData,
    hoverValues,
    hyperWrapping,
    hoverInfo,
    spriteManager,
    scrolling,
    touchMode,
    enqueue,
    getCellRenderer,
    renderStrategy,
    bufferA,
    bufferB
  } = arg;
  let {
    damage
  } = arg;
  if (width === 0 || height === 0) return;
  const doubleBuffer = renderStrategy === "double-buffer";
  const dpr = scrolling ? 1 : Math.ceil((_a = window.devicePixelRatio) != null ? _a : 1);
  const canBlit = renderStrategy !== "direct" && computeCanBlit(arg, lastArg);

  if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
  }

  const overlayCanvas = headerCanvas;
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const overlayHeight = totalHeaderHeight + 1;

  if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {
    overlayCanvas.width = width * dpr;
    overlayCanvas.height = overlayHeight * dpr;
    overlayCanvas.style.width = width + "px";
    overlayCanvas.style.height = overlayHeight + "px";
  }

  if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {
    bufferA.width = width * dpr;
    bufferA.height = height * dpr;
  }

  if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {
    bufferB.width = width * dpr;
    bufferB.height = height * dpr;
  }

  const last = lastBlitData.current;
  if (canBlit === true && cellXOffset === (last == null ? void 0 : last.cellXOffset) && cellYOffset === (last == null ? void 0 : last.cellYOffset) && translateX === (last == null ? void 0 : last.translateX) && translateY === (last == null ? void 0 : last.translateY)) return;
  let mainCtx = null;

  if (doubleBuffer) {
    mainCtx = canvas.getContext("2d", {
      alpha: false
    });
  }

  const overlayCtx = overlayCanvas.getContext("2d", {
    alpha: false
  });
  let targetBuffer;

  if (!doubleBuffer) {
    targetBuffer = canvas;
  } else if (damage !== void 0) {
    targetBuffer = (last == null ? void 0 : last.lastBuffer) === "b" ? bufferB : bufferA;
  } else {
    targetBuffer = (last == null ? void 0 : last.lastBuffer) === "b" ? bufferA : bufferB;
  }

  const targetCtx = targetBuffer.getContext("2d", {
    alpha: false
  });
  const blitSource = doubleBuffer ? targetBuffer === bufferA ? bufferB : bufferA : canvas;
  if (overlayCtx === null || targetCtx === null) return;
  const getRowHeight = typeof rowHeight === "number" ? () => rowHeight : rowHeight;
  overlayCtx.save();
  overlayCtx.beginPath();
  targetCtx.save();
  targetCtx.beginPath();
  overlayCtx.textBaseline = "middle";
  targetCtx.textBaseline = "middle";

  if (dpr !== 1) {
    overlayCtx.scale(dpr, dpr);
    targetCtx.scale(dpr, dpr);
  }

  const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
  let drawRegions = [];
  const mustDrawFocusOnHeader = drawFocus && ((_b = selection.current) == null ? void 0 : _b.cell[1]) === cellYOffset && translateY === 0;

  const drawHeaderTexture = () => {
    var _a2, _b2;

    drawGridHeaders(overlayCtx, effectiveCols, enableGroups, hoverInfo, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, theme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode);
    drawGridLines(overlayCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, void 0, void 0, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme, true);
    overlayCtx.beginPath();
    overlayCtx.moveTo(0, overlayHeight - 0.5);
    overlayCtx.lineTo(width, overlayHeight - 0.5);
    overlayCtx.strokeStyle = blend((_b2 = (_a2 = theme.headerBottomBorderColor) != null ? _a2 : theme.horizontalBorderColor) != null ? _b2 : theme.borderColor, theme.bgHeader);
    overlayCtx.stroke();

    if (mustDrawFocusOnHeader) {
      drawFocusRing(overlayCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
    }
  };

  if (damage !== void 0) {
    let doHeaders = false;
    damage = damage.filter(x => {
      doHeaders = doHeaders || x[1] < 0;
      return x[1] < 0 || intersectRect(cellXOffset, cellYOffset, effectiveCols.length, 300, x[0], x[1], 1, 1) || intersectRect(0, cellYOffset, freezeColumns, 300, x[0], x[1], 1, 1) || trailingRowType && intersectRect(cellXOffset, rows - 1, effectiveCols.length, 1, x[0], x[1], 1, 1);
    });

    if (damage.length > 0) {
      clipDamage(targetCtx, effectiveCols, width, height, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, true);
      targetCtx.fillStyle = theme.bgCell;
      targetCtx.fillRect(0, totalHeaderHeight + 1, width, height - totalHeaderHeight - 1);
      drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);

      if (fillHandle && drawFocus && selection.current !== void 0 && damage.some(x => {
        var _a2, _b2;

        return x[0] === ((_a2 = selection.current) == null ? void 0 : _a2.cell[0]) && x[1] === ((_b2 = selection.current) == null ? void 0 : _b2.cell[1]);
      })) {
        drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows);
      }
    }

    if (doHeaders) {
      clipDamage(overlayCtx, effectiveCols, width, totalHeaderHeight, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType, damage, false);
      drawHeaderTexture();
    }

    targetCtx.restore();
    overlayCtx.restore();

    if (mainCtx !== null) {
      mainCtx.fillStyle = theme.bgCell;
      mainCtx.fillRect(0, 0, width, height);
      mainCtx.drawImage(targetCtx.canvas, 0, 0);
    }

    return;
  }

  if (canBlit !== true || cellXOffset !== (last == null ? void 0 : last.cellXOffset) || translateX !== (last == null ? void 0 : last.translateX) || mustDrawFocusOnHeader !== (last == null ? void 0 : last.mustDrawFocusOnHeader)) {
    drawHeaderTexture();
  }

  if (canBlit === true) {
    assert(blitSource !== void 0 && last !== void 0);
    const {
      regions
    } = blitLastFrame(targetCtx, blitSource, last, cellXOffset, cellYOffset, translateX, translateY, trailingRowType === "sticky", width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, rowHeight, doubleBuffer);
    drawRegions = regions;
  } else if (canBlit !== false) {
    assert(last !== void 0);
    const resizedCol = canBlit;
    drawRegions = blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedCol);
  }

  overdrawStickyBoundaries(targetCtx, effectiveCols, width, height, trailingRowType === "sticky", rows, verticalBorder, getRowHeight, theme);
  const focusRedraw = drawFocus ? drawFocusRing(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, trailingRowType, fillHandle, rows) : void 0;
  const highlightRedraw = drawHighlightRings(targetCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, trailingRowType === "sticky", rows, highlightRegions);
  targetCtx.fillStyle = theme.bgCell;

  if (drawRegions.length > 0) {
    targetCtx.beginPath();

    for (const r of drawRegions) {
      targetCtx.rect(r.x, r.y, r.width, r.height);
    }

    targetCtx.clip();
    targetCtx.fill();
    targetCtx.beginPath();
  } else {
    targetCtx.fillRect(0, 0, width, height);
  }

  const spans = drawCells(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, trailingRowType, drawRegions, damage, selection, prelightCells, highlightRegions, drawCustomCell, imageLoader, spriteManager, hoverValues, hoverInfo, hyperWrapping, theme, enqueue, getCellRenderer);
  drawBlanks(targetCtx, effectiveCols, mappedColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowThemeOverride, selection.rows, disabledRows, trailingRowType, drawRegions, damage, theme);
  drawGridLines(targetCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, trailingRowType, rows, theme);
  focusRedraw == null ? void 0 : focusRedraw();
  highlightRedraw == null ? void 0 : highlightRedraw();

  if (mainCtx !== null) {
    mainCtx.fillStyle = theme.bgCell;
    mainCtx.fillRect(0, 0, width, height);
    mainCtx.drawImage(targetCtx.canvas, 0, 0);
  }

  const lastRowDrawn = getLastRow(effectiveCols, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, trailingRowType);
  imageLoader == null ? void 0 : imageLoader.setWindow({
    x: cellXOffset,
    y: cellYOffset,
    width: effectiveCols.length,
    height: lastRowDrawn - cellYOffset
  }, freezeColumns);
  lastBlitData.current = {
    cellXOffset,
    cellYOffset,
    translateX,
    translateY,
    mustDrawFocusOnHeader,
    lastBuffer: doubleBuffer ? targetBuffer === bufferA ? "a" : "b" : void 0
  };
  targetCtx.restore();
  overlayCtx.restore();
}

function walkRowsInCol(startRow, drawY, height, rows, getRowHeight, trailingRowType, cb) {
  let y = drawY;
  let row = startRow;
  let doSticky = trailingRowType === "sticky";

  while (y < height || doSticky) {
    const doingSticky = doSticky && y >= height;

    if (doingSticky) {
      doSticky = false;
      row = rows - 1;
    }

    const rh = getRowHeight(row);

    if (doingSticky) {
      y = height - rh;
    }

    const isMovedStickyRow = doSticky && row === rows - 1;

    if (!isMovedStickyRow && cb(y, row, rh, doingSticky, trailingRowType !== "none" && row === rows - 1) === true) {
      break;
    }

    if (doingSticky) {
      break;
    }

    y += rh;
    row++;
  }
}

function walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, cb) {
  let x = 0;
  let clipX = 0;
  const drawY = totalHeaderHeight + translateY;

  for (const c of effectiveCols) {
    const drawX = c.sticky ? clipX : x + translateX;

    if (cb(c, drawX, drawY, clipX, cellYOffset) === true) {
      break;
    }

    x += c.width;
    clipX += c.sticky ? c.width : 0;
  }
}

function walkGroups(effectiveCols, width, translateX, groupHeaderHeight, cb) {
  var _a;

  let x = 0;
  let clipX = 0;

  for (let index = 0; index < effectiveCols.length; index++) {
    const startCol = effectiveCols[index];
    let end = index + 1;
    let boxWidth = startCol.width;

    if (startCol.sticky) {
      clipX += boxWidth;
    }

    while (end < effectiveCols.length && isGroupEqual(effectiveCols[end].group, startCol.group) && effectiveCols[end].sticky === effectiveCols[index].sticky) {
      const endCol = effectiveCols[end];
      boxWidth += endCol.width;
      end++;
      index++;

      if (endCol.sticky) {
        clipX += endCol.width;
      }
    }

    const t = startCol.sticky ? 0 : translateX;
    const localX = x + t;
    const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);
    const w = Math.min(boxWidth - delta, width - (localX + delta));
    cb([startCol.sourceIndex, effectiveCols[end - 1].sourceIndex], (_a = startCol.group) != null ? _a : "", localX + delta, 0, w, groupHeaderHeight);
    x += boxWidth;
  }
}


var hoverTime = 80;

function easeOutCubic(x) {
  const x1 = x - 1;
  return x1 * x1 * x1 + 1;
}

var AnimationManager = class {
  constructor(callback) {
    this.callback = callback;
    this.currentHoveredItem = void 0;
    this.leavingItems = [];

    this.areSameItems = (left, right) => {
      return (left == null ? void 0 : left[0]) === (right == null ? void 0 : right[0]) && (left == null ? void 0 : left[1]) === (right == null ? void 0 : right[1]);
    };

    this.addToLeavingItems = item => {
      const isAlreadyLeaving = this.leavingItems.some(i => this.areSameItems(i.item, item.item));

      if (isAlreadyLeaving) {
        return;
      }

      this.leavingItems.push(item);
    };

    this.removeFromLeavingItems = item => {
      var _a;

      const leavingItem = this.leavingItems.find(e => this.areSameItems(e.item, item));
      this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);
      return (_a = leavingItem == null ? void 0 : leavingItem.hoverAmount) != null ? _a : 0;
    };

    this.cleanUpLeavingElements = () => {
      this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);
    };

    this.shouldStep = () => {
      const hasLeavingItems = this.leavingItems.length > 0;
      const currentHoveredIsAnimating = this.currentHoveredItem !== void 0 && this.currentHoveredItem.hoverAmount < 1;
      return hasLeavingItems || currentHoveredIsAnimating;
    };

    this.getAnimatingItems = () => {
      if (this.currentHoveredItem !== void 0) {
        return [...this.leavingItems, this.currentHoveredItem];
      }

      return this.leavingItems.map(x => ({ ...x,
        hoverAmount: easeOutCubic(x.hoverAmount)
      }));
    };

    this.step = timestamp => {
      if (this.lastAnimationTime === void 0) {
        this.lastAnimationTime = timestamp;
      } else {
        const step = timestamp - this.lastAnimationTime;
        const delta = step / hoverTime;

        for (const item of this.leavingItems) {
          item.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(item.hoverAmount - delta, 0, 1);
        }

        if (this.currentHoveredItem !== void 0) {
          this.currentHoveredItem.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(this.currentHoveredItem.hoverAmount + delta, 0, 1);
        }

        const animating = this.getAnimatingItems();
        this.callback(animating);
        this.cleanUpLeavingElements();
      }

      if (this.shouldStep()) {
        this.lastAnimationTime = timestamp;
        window.requestAnimationFrame(this.step);
      } else {
        this.lastAnimationTime = void 0;
      }
    };

    this.setHovered = item => {
      var _a;

      if (this.areSameItems((_a = this.currentHoveredItem) == null ? void 0 : _a.item, item)) {
        return;
      }

      if (this.currentHoveredItem !== void 0) {
        this.addToLeavingItems(this.currentHoveredItem);
      }

      if (item !== void 0) {
        const hoverAmount = this.removeFromLeavingItems(item);
        this.currentHoveredItem = {
          item,
          hoverAmount
        };
      } else {
        this.currentHoveredItem = void 0;
      }

      if (this.lastAnimationTime === void 0) {
        window.requestAnimationFrame(this.step);
      }
    };
  }

};
var Lazy = class {
  constructor(fn) {
    this.fn = fn;
  }

  get value() {
    var _a;

    return (_a = this.val) != null ? _a : this.val = this.fn();
  }

};

function lazy(fn) {
  return new Lazy(fn);
}

var browserIsFirefox = lazy(() => window.navigator.userAgent.includes("Firefox"));
var browserIsSafari = lazy(() => window.navigator.userAgent.includes("Mac OS") && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome"));
var browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith("mac"));


function hasItem(arr, item) {
  for (const element of arr) {
    if (element[0] === item[0] && element[1] === item[1]) return true;
  }

  return false;
}

function useAnimationQueue(draw) {
  const queue = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const seq = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const drawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);
  drawRef.current = draw;
  const loop = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    const requeue = () => window.requestAnimationFrame(fn);

    const fn = () => {
      const toDraw = queue.current;
      queue.current = [];
      drawRef.current(toDraw);

      if (queue.current.length > 0) {
        seq.current++;
      } else {
        seq.current = 0;
      }
    };

    window.requestAnimationFrame(seq.current > 600 ? requeue : fn);
  }, []);
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(item => {
    if (hasItem(queue.current, item)) return;

    if (queue.current.length === 0) {
      loop();
    }

    queue.current.push(item);
  }, [loop]);
}

var getRowData = (cell, getCellRenderer) => {
  var _a;

  if (cell.kind === GridCellKind.Custom) return cell.copyData;
  const r = getCellRenderer == null ? void 0 : getCellRenderer(cell);
  return (_a = r == null ? void 0 : r.getAccessibilityString(cell)) != null ? _a : "";
};

var DataGrid = (p, forwardedRef) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;

  const {
    width,
    height,
    accessibilityHeight,
    columns,
    cellXOffset: cellXOffsetReal,
    cellYOffset,
    headerHeight,
    fillHandle = false,
    groupHeaderHeight,
    rowHeight,
    rows,
    getCellContent,
    getRowThemeOverride,
    onHeaderMenuClick,
    enableGroups,
    isFilling,
    onCanvasFocused,
    onCanvasBlur,
    isFocused,
    selection,
    freezeColumns,
    onContextMenu,
    trailingRowType,
    fixedShadowX = true,
    fixedShadowY = true,
    drawFocusRing: drawFocusRing2 = true,
    onMouseDown,
    onMouseUp,
    onMouseMoveRaw,
    onMouseMove,
    onItemHovered,
    dragAndDropState,
    firstColAccessible,
    onKeyDown,
    onKeyUp,
    highlightRegions,
    canvasRef,
    onDragStart,
    onDragEnd,
    eventTargetRef,
    isResizing,
    isDragging,
    isDraggable = false,
    allowResize,
    disabledRows,
    getGroupDetails,
    theme,
    prelightCells,
    headerIcons,
    verticalBorder,
    drawHeader: drawHeaderCallback,
    drawCustomCell,
    onCellFocused,
    onDragOverCell,
    onDrop,
    onDragLeave,
    imageWindowLoader,
    smoothScrollX = false,
    smoothScrollY = false,
    experimental,
    getCellRenderer
  } = p;
  const translateX = (_a = p.translateX) != null ? _a : 0;
  const translateY = (_b = p.translateY) != null ? _b : 0;
  const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const imageWindowLoaderInternal = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new image_window_loader_default(), []);
  const imageLoader = imageWindowLoader != null ? imageWindowLoader : imageWindowLoaderInternal;
  const damageRegion = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [scrolling, setScrolling] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const hoverValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);
  const lastBlitData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [hoveredItemInfo, setHoveredItemInfo] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [hoveredOnEdge, setHoveredOnEdge] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const overlayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const [lastWasTouch, setLastWasTouch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const lastWasTouchRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lastWasTouch);
  lastWasTouchRef.current = lastWasTouch;
  const spriteManager = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new SpriteManager(headerIcons, () => {
    lastArgsRef.current = void 0;
    lastDrawRef.current();
  }), [headerIcons]);
  const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;
  const scrollingStopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);
  const disableFirefoxRescaling = (experimental == null ? void 0 : experimental.enableFirefoxRescaling) !== true;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (!browserIsFirefox.value || window.devicePixelRatio === 1 || disableFirefoxRescaling) return;

    if (scrollingStopRef.current !== -1) {
      setScrolling(true);
    }

    window.clearTimeout(scrollingStopRef.current);
    scrollingStopRef.current = window.setTimeout(() => {
      setScrolling(false);
      scrollingStopRef.current = -1;
    }, 200);
  }, [cellYOffset, cellXOffset, translateX, translateY, disableFirefoxRescaling]);
  const mappedColumns = useMappedColumns(columns, freezeColumns);
  const getBoundsForItem = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, row) => {
    const rect = canvas.getBoundingClientRect();

    if (col >= mappedColumns.length || row >= rows) {
      return void 0;
    }

    const scale = rect.width / width;
    const result = computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType === "sticky", mappedColumns, rowHeight);

    if (scale !== 1) {
      result.x *= scale;
      result.y *= scale;
      result.width *= scale;
      result.height *= scale;
    }

    result.x += rect.x;
    result.y += rect.y;
    return result;
  }, [width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, trailingRowType, mappedColumns, rowHeight]);
  const getMouseArgsForPosition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, posX, posY, ev) => {
    var _a2, _b2;

    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / width;
    const x = (posX - rect.left) / scale;
    const y = (posY - rect.top) / scale;
    const edgeDetectionBuffer = 5;
    const effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, void 0, translateX);
    let button = 0;

    if (ev instanceof MouseEvent) {
      button = ev.button;
    }

    const col = getColumnIndexForX(x, effectiveCols, translateX);
    const row = getRowIndexForY(y, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType === "sticky");
    const shiftKey = (ev == null ? void 0 : ev.shiftKey) === true;
    const ctrlKey = (ev == null ? void 0 : ev.ctrlKey) === true;
    const metaKey = (ev == null ? void 0 : ev.metaKey) === true;
    const isTouch = ev !== void 0 && !(ev instanceof MouseEvent);
    const edgeSize = 20;
    const scrollEdge = [Math.abs(x) < edgeSize ? -1 : Math.abs(rect.width - x) < edgeSize ? 1 : 0, Math.abs(y) < edgeSize ? -1 : Math.abs(rect.height - y) < edgeSize ? 1 : 0];
    let result;

    if (col === -1 || y < 0 || x < 0 || row === void 0 || x > width || y > height) {
      const horizontal = x > width ? -1 : x < 0 ? 1 : 0;
      const vertical = y > height ? 1 : y < 0 ? -1 : 0;
      let isEdge = false;

      if (col === -1 && row === -1) {
        const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);
        assert(b !== void 0);
        isEdge = posX < b.x + b.width + edgeDetectionBuffer;
      }

      result = {
        kind: outOfBoundsKind,
        location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row != null ? row : rows - 1],
        direction: [horizontal, vertical],
        shiftKey,
        ctrlKey,
        metaKey,
        isEdge,
        isTouch,
        button,
        scrollEdge
      };
    } else if (row <= -1) {
      let bounds = getBoundsForItem(canvas, col, row);
      assert(bounds !== void 0);
      let isEdge = bounds !== void 0 && bounds.x + bounds.width - posX <= edgeDetectionBuffer;
      const previousCol = col - 1;

      if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {
        isEdge = true;
        bounds = getBoundsForItem(canvas, previousCol, row);
        assert(bounds !== void 0);
        result = {
          kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,
          location: [previousCol, row],
          bounds,
          group: (_a2 = mappedColumns[previousCol].group) != null ? _a2 : "",
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      } else {
        result = {
          kind: enableGroups && row === -2 ? groupHeaderKind : headerKind,
          group: (_b2 = mappedColumns[col].group) != null ? _b2 : "",
          location: [col, row],
          bounds,
          isEdge,
          shiftKey,
          ctrlKey,
          metaKey,
          isTouch,
          localEventX: posX - bounds.x,
          localEventY: posY - bounds.y,
          button,
          scrollEdge
        };
      }
    } else {
      const bounds = getBoundsForItem(canvas, col, row);
      assert(bounds !== void 0);
      const isEdge = bounds !== void 0 && bounds.x + bounds.width - posX < edgeDetectionBuffer;
      const isFillHandle = fillHandle && bounds !== void 0 && bounds.x + bounds.width - posX < 6 && bounds.y + bounds.height - posY < 6;
      result = {
        kind: "cell",
        location: [col, row],
        bounds,
        isEdge,
        shiftKey,
        ctrlKey,
        isFillHandle,
        metaKey,
        isTouch,
        localEventX: posX - bounds.x,
        localEventY: posY - bounds.y,
        button,
        scrollEdge
      };
    }

    return result;
  }, [mappedColumns, cellXOffset, width, translateX, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, trailingRowType, getBoundsForItem, fillHandle]);

  function isSameItem(item, other) {
    if (item === other) return true;
    return (item == null ? void 0 : item.kind) === (other == null ? void 0 : other.kind) && (item == null ? void 0 : item.location[0]) === (other == null ? void 0 : other.location[0]) && (item == null ? void 0 : item.location[1]) === (other == null ? void 0 : other.location[1]);
  }

  const [hoveredItem] = hoveredItemInfo != null ? hoveredItemInfo : [];
  const enqueueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(_item => {});
  const hoverInfoRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(hoveredItemInfo);
  hoverInfoRef.current = hoveredItemInfo;
  const [bufferA, bufferB] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [document.createElement("canvas"), document.createElement("canvas")];
  }, []);
  const lastArgsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const draw = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2;

    const canvas = ref.current;
    const overlay = overlayRef.current;
    if (canvas === null || overlay === null) return;
    const last = lastArgsRef.current;
    const current = {
      canvas,
      bufferA,
      bufferB,
      headerCanvas: overlay,
      width,
      height,
      cellXOffset,
      cellYOffset,
      translateX: Math.round(translateX),
      translateY: Math.round(translateY),
      mappedColumns,
      enableGroups,
      freezeColumns,
      dragAndDropState,
      theme,
      headerHeight,
      groupHeaderHeight,
      disabledRows: disabledRows != null ? disabledRows : CompactSelection.empty(),
      rowHeight,
      verticalBorder,
      isResizing,
      isFocused,
      selection,
      fillHandle,
      lastRowSticky: trailingRowType,
      rows,
      drawFocus: drawFocusRing2,
      getCellContent,
      getGroupDetails: getGroupDetails != null ? getGroupDetails : name => ({
        name
      }),
      getRowThemeOverride,
      drawCustomCell,
      drawHeaderCallback,
      prelightCells,
      highlightRegions,
      imageLoader,
      lastBlitData,
      damage: damageRegion.current,
      hoverValues: hoverValues.current,
      hoverInfo: hoverInfoRef.current,
      spriteManager,
      scrolling,
      hyperWrapping: (_a2 = experimental == null ? void 0 : experimental.hyperWrapping) != null ? _a2 : false,
      touchMode: lastWasTouch,
      enqueue: enqueueRef.current,
      renderStrategy: (_b2 = experimental == null ? void 0 : experimental.renderStrategy) != null ? _b2 : browserIsSafari.value ? "double-buffer" : "single-buffer",
      getCellRenderer
    };

    if (current.damage === void 0) {
      lastArgsRef.current = current;
      drawGrid(current, last);
    } else {
      drawGrid(current, void 0);
    }
  }, [bufferA, bufferB, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, enableGroups, freezeColumns, dragAndDropState, theme, headerHeight, groupHeaderHeight, disabledRows, rowHeight, verticalBorder, isResizing, isFocused, selection, fillHandle, trailingRowType, rows, drawFocusRing2, getCellContent, getGroupDetails, getRowThemeOverride, drawCustomCell, drawHeaderCallback, prelightCells, highlightRegions, imageLoader, spriteManager, scrolling, experimental == null ? void 0 : experimental.hyperWrapping, experimental == null ? void 0 : experimental.renderStrategy, lastWasTouch, getCellRenderer]);
  const lastDrawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    draw();
    lastDrawRef.current = draw;
  }, [draw]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const fn = async () => {
      var _a2;

      if (((_a2 = document == null ? void 0 : document.fonts) == null ? void 0 : _a2.ready) === void 0) return;
      await document.fonts.ready;
      lastArgsRef.current = void 0;
      lastDrawRef.current();
    };

    void fn();
  }, []);
  const damageInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(locations => {
    damageRegion.current = locations;
    lastDrawRef.current();
    damageRegion.current = void 0;
  }, []);
  const enqueue = useAnimationQueue(damageInternal);
  enqueueRef.current = enqueue;
  const damage = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cells => {
    damageInternal(cells.map(x => x.cell));
  }, [damageInternal]);
  imageLoader.setCallback(damageInternal);
  const [overFill, setOverFill] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [hCol, hRow] = hoveredItem != null ? hoveredItem : [];
  const headerHovered = hCol !== void 0 && hRow === -1;
  const groupHeaderHovered = hCol !== void 0 && hRow === -2;
  let clickableInnerCellHovered = false;
  let editableBoolHovered = false;
  let cursorOverride;

  if (hCol !== void 0 && hRow !== void 0 && hRow > -1) {
    const cell = getCellContent([hCol, hRow]);
    clickableInnerCellHovered = cell.kind === InnerGridCellKind.NewRow || cell.kind === InnerGridCellKind.Marker && cell.markerKind !== "number";
    editableBoolHovered = cell.kind === GridCellKind.Boolean && booleanCellIsEditable(cell);
    cursorOverride = cell.cursor;
  }

  const canDrag = hoveredOnEdge != null ? hoveredOnEdge : false;
  const cursor = isDragging ? "grabbing" : canDrag || isResizing ? "col-resize" : overFill || isFilling ? "crosshair" : cursorOverride !== void 0 ? cursorOverride : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered ? "pointer" : "default";
  const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    contain: "strict",
    display: "block",
    cursor
  }), [cursor]);
  const lastSetCursor = react__WEBPACK_IMPORTED_MODULE_0__.useRef("default");
  const target = eventTargetRef == null ? void 0 : eventTargetRef.current;

  if (target !== null && target !== void 0 && lastSetCursor.current !== style.cursor) {
    target.style.cursor = lastSetCursor.current = style.cursor;
  }

  const groupHeaderActionForEvent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((group, bounds, localEventX, localEventY) => {
    if (getGroupDetails === void 0) return void 0;
    const groupDesc = getGroupDetails(group);

    if (groupDesc.actions !== void 0) {
      const boxes = getActionBoundsForGroup(bounds, groupDesc.actions);

      for (const [i, box] of boxes.entries()) {
        if (pointInRect(box, localEventX + bounds.x, localEventY + box.y)) {
          return groupDesc.actions[i];
        }
      }
    }

    return void 0;
  }, [getGroupDetails]);
  const isOverHeaderMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, clientX, clientY) => {
    const header = columns[col];

    if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge != null ? hoveredOnEdge : false)) {
      const headerBounds = getBoundsForItem(canvas, col, -1);
      assert(headerBounds !== void 0);
      const menuBounds = getHeaderMenuBounds(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height);

      if (clientX > menuBounds.x && clientX < menuBounds.x + menuBounds.width && clientY > menuBounds.y && clientY < menuBounds.y + menuBounds.height) {
        return headerBounds;
      }
    }

    return void 0;
  }, [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]);
  const downTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const downPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    const canvas = ref.current;
    const eventTarget = eventTargetRef == null ? void 0 : eventTargetRef.current;
    if (canvas === null || ev.target !== canvas && ev.target !== eventTarget) return;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.touches[0].clientX;
      clientY = ev.touches[0].clientY;
    }

    if (ev.target === eventTarget && eventTarget !== null) {
      const bounds = eventTarget.getBoundingClientRect();
      if (clientX > bounds.left + eventTarget.clientWidth) return;
      if (clientY > bounds.top + eventTarget.clientHeight) return;
    }

    const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);
    downPosition.current = args.location;

    if (args.isTouch) {
      downTime.current = Date.now();
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== void 0) {
      return;
    } else if (args.kind === groupHeaderKind) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== void 0) {
        return;
      }
    }

    onMouseDown == null ? void 0 : onMouseDown(args);

    if (!args.isTouch && isDraggable !== true && isDraggable !== args.kind) {
      ev.preventDefault();
    }
  }, [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]);
  useEventListener("touchstart", onMouseDownImpl, window, false);
  useEventListener("mousedown", onMouseDownImpl, window, false);
  const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a2, _b2;

    const canvas = ref.current;
    if (onMouseUp === void 0 || canvas === null) return;
    const eventTarget = eventTargetRef == null ? void 0 : eventTargetRef.current;
    const isOutside = ev.target !== canvas && ev.target !== eventTarget;
    let clientX;
    let clientY;

    if (ev instanceof MouseEvent) {
      clientX = ev.clientX;
      clientY = ev.clientY;
    } else {
      clientX = ev.changedTouches[0].clientX;
      clientY = ev.changedTouches[0].clientY;
    }

    let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);

    if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {
      args = { ...args,
        isLongTouch: true
      };
    }

    if (lastWasTouchRef.current !== args.isTouch) {
      setLastWasTouch(args.isTouch);
    }

    if (!isOutside && ev.cancelable) {
      ev.preventDefault();
    }

    if (args.kind === headerKind && isOverHeaderMenu(canvas, args.location[0], clientX, clientY)) {
      const [col] = args.location;
      const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);

      if (headerBounds !== void 0) {
        if (args.button === 0 && ((_a2 = downPosition.current) == null ? void 0 : _a2[0]) === col && ((_b2 = downPosition.current) == null ? void 0 : _b2[1]) === -1) {
          onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col, headerBounds);
        } else {
          onMouseUp(args, true);
        }

        return;
      }
    } else if (args.kind === groupHeaderKind) {
      const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);

      if (action !== void 0) {
        if (args.button === 0) {
          action.onClick(args);
        }

        return;
      }
    }

    onMouseUp(args, isOutside);
  }, [onMouseUp, eventTargetRef, getMouseArgsForPosition, isOverHeaderMenu, onHeaderMenuClick, groupHeaderActionForEvent]);
  useEventListener("mouseup", onMouseUpImpl, window, false);
  useEventListener("touchend", onMouseUpImpl, window, false);
  const onContextMenuImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    const canvas = ref.current;
    if (canvas === null || onContextMenu === void 0) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);
    onContextMenu(args, () => {
      if (ev.cancelable) ev.preventDefault();
    });
  }, [getMouseArgsForPosition, onContextMenu]);
  useEventListener("contextmenu", onContextMenuImpl, (_c = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _c : null, false);
  const onAnimationFrame = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(values => {
    damageRegion.current = values.map(x => x.item);
    hoverValues.current = values;
    lastDrawRef.current();
    damageRegion.current = void 0;
  }, []);
  const animManagerValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new AnimationManager(onAnimationFrame), [onAnimationFrame]);
  const animationManager = react__WEBPACK_IMPORTED_MODULE_0__.useRef(animManagerValue);
  animationManager.current = animManagerValue;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const am = animationManager.current;

    if (hoveredItem === void 0 || hoveredItem[1] < 0) {
      am.setHovered(hoveredItem);
      return;
    }

    const cell = getCellContent(hoveredItem);
    const r = getCellRenderer(cell);
    am.setHovered(r === void 0 && cell.kind === GridCellKind.Custom || (r == null ? void 0 : r.needsHover) === true ? hoveredItem : void 0);
  }, [getCellContent, getCellRenderer, hoveredItem]);
  const hoveredRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a2;

    const canvas = ref.current;
    if (canvas === null) return;
    const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);

    if (!isSameItem(args, hoveredRef.current)) {
      onItemHovered == null ? void 0 : onItemHovered(args);
      setHoveredItemInfo(args.kind === outOfBoundsKind ? void 0 : [args.location, [args.localEventX, args.localEventY]]);
      hoveredRef.current = args;
    } else if (args.kind === "cell" || args.kind === headerKind || args.kind === groupHeaderKind) {
      const newInfo = [args.location, [args.localEventX, args.localEventY]];
      setHoveredItemInfo(newInfo);
      hoverInfoRef.current = newInfo;

      if (args.kind === "cell") {
        const toCheck = getCellContent(args.location);

        if (toCheck.kind === GridCellKind.Custom || ((_a2 = getCellRenderer(toCheck)) == null ? void 0 : _a2.needsHoverPosition) === true) {
          damageInternal([args.location]);
        }
      } else if (args.kind === groupHeaderKind) {
        damageInternal([args.location]);
      }
    }

    setHoveredOnEdge(args.kind === headerKind && args.isEdge && allowResize === true);

    if (fillHandle && selection.current !== void 0) {
      const [col, row] = selection.current.cell;
      const sb = getBoundsForItem(canvas, col, row);
      const x = ev.clientX;
      const y = ev.clientY;
      assert(sb !== void 0);
      setOverFill(x >= sb.x + sb.width - 6 && x <= sb.x + sb.width && y >= sb.y + sb.height - 6 && y <= sb.y + sb.height);
    } else {
      setOverFill(false);
    }

    onMouseMoveRaw == null ? void 0 : onMouseMoveRaw(ev);
    onMouseMove(args);
  }, [getMouseArgsForPosition, allowResize, fillHandle, selection, onMouseMoveRaw, onMouseMove, onItemHovered, getCellContent, getCellRenderer, damageInternal, getBoundsForItem]);
  useEventListener("mousemove", onMouseMoveImpl, window, true);
  const onKeyDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== void 0) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyDown == null ? void 0 : onKeyDown({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => void 0,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyDown, selection, getBoundsForItem]);
  const onKeyUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;
    if (canvas === null) return;
    let bounds;

    if (selection.current !== void 0) {
      bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);
    }

    onKeyUp == null ? void 0 : onKeyUp({
      bounds,
      stopPropagation: () => event.stopPropagation(),
      preventDefault: () => event.preventDefault(),
      cancel: () => void 0,
      ctrlKey: event.ctrlKey,
      metaKey: event.metaKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      key: event.key,
      keyCode: event.keyCode,
      rawEvent: event
    });
  }, [onKeyUp, selection, getBoundsForItem]);
  const refImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {
    ref.current = instance;

    if (canvasRef !== void 0) {
      canvasRef.current = instance;
    }
  }, [canvasRef]);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || isDraggable === false || isResizing) {
      event.preventDefault();
      return;
    }

    let dragMime;
    let dragData;
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);

    if (isDraggable !== true && args.kind !== isDraggable) {
      event.preventDefault();
      return;
    }

    const setData = (mime, payload) => {
      dragMime = mime;
      dragData = payload;
    };

    let dragImage;
    let dragImageX;
    let dragImageY;

    const setDragImage = (image, x, y) => {
      dragImage = image;
      dragImageX = x;
      dragImageY = y;
    };

    let prevented = false;
    onDragStart == null ? void 0 : onDragStart({ ...args,
      setData,
      setDragImage,
      preventDefault: () => prevented = true,
      defaultPrevented: () => prevented
    });

    if (!prevented && dragMime !== void 0 && dragData !== void 0 && event.dataTransfer !== null) {
      event.dataTransfer.setData(dragMime, dragData);
      event.dataTransfer.effectAllowed = "copyLink";

      if (dragImage !== void 0 && dragImageX !== void 0 && dragImageY !== void 0) {
        event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);
      } else {
        const [col, row] = args.location;

        if (row !== void 0) {
          const offscreen = document.createElement("canvas");
          const boundsForDragTarget = getBoundsForItem(canvas, col, row);
          assert(boundsForDragTarget !== void 0);
          offscreen.width = boundsForDragTarget.width;
          offscreen.height = boundsForDragTarget.height;
          const ctx = offscreen.getContext("2d");

          if (ctx !== null) {
            ctx.textBaseline = "middle";

            if (row === -1) {
              ctx.font = `${theme.headerFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgHeader;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawHeader(ctx, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, mappedColumns[col], false, theme, false, false, 0, spriteManager, drawHeaderCallback, false);
            } else {
              ctx.font = `${theme.baseFontStyle} ${theme.fontFamily}`;
              ctx.fillStyle = theme.bgCell;
              ctx.fillRect(0, 0, offscreen.width, offscreen.height);
              drawCell(ctx, row, getCellContent([col, row]), 0, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, false, theme, drawCustomCell, imageLoader, spriteManager, 1, void 0, false, 0, void 0, void 0, getCellRenderer);
            }
          }

          offscreen.style.left = "-100%";
          offscreen.style.position = "absolute";
          document.body.append(offscreen);
          event.dataTransfer.setDragImage(offscreen, boundsForDragTarget.width / 2, boundsForDragTarget.height / 2);
          window.setTimeout(() => {
            offscreen.remove();
          }, 0);
        }
      }
    } else {
      event.preventDefault();
    }
  }, [isDraggable, isResizing, getMouseArgsForPosition, onDragStart, getBoundsForItem, theme, mappedColumns, spriteManager, drawHeaderCallback, getCellContent, drawCustomCell, imageLoader, getCellRenderer]);
  useEventListener("dragstart", onDragStartImpl, (_d = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _d : null, false, false);
  const activeDropTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onDragOverImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    var _a2;

    const canvas = ref.current;

    if (onDrop !== void 0) {
      event.preventDefault();
    }

    if (canvas === null || onDragOverCell === void 0) {
      return;
    }

    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    const [activeCol, activeRow] = (_a2 = activeDropTarget.current) != null ? _a2 : [];

    if (activeCol !== col || activeRow !== row) {
      activeDropTarget.current = [col, row];
      onDragOverCell([col, row], event.dataTransfer);
    }
  }, [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]);
  useEventListener("dragover", onDragOverImpl, (_e = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _e : null, false, false);
  const onDragEndImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    activeDropTarget.current = void 0;
    onDragEnd == null ? void 0 : onDragEnd();
  }, [onDragEnd]);
  useEventListener("dragend", onDragEndImpl, (_f = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _f : null, false, false);
  const onDropImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const canvas = ref.current;

    if (canvas === null || onDrop === void 0) {
      return;
    }

    event.preventDefault();
    const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);
    const [rawCol, row] = args.location;
    const col = rawCol - (firstColAccessible ? 0 : 1);
    onDrop([col, row], event.dataTransfer);
  }, [firstColAccessible, getMouseArgsForPosition, onDrop]);
  useEventListener("drop", onDropImpl, (_g = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _g : null, false, false);
  const onDragLeaveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    onDragLeave == null ? void 0 : onDragLeave();
  }, [onDragLeave]);
  useEventListener("dragleave", onDragLeaveImpl, (_h = eventTargetRef == null ? void 0 : eventTargetRef.current) != null ? _h : null, false, false);
  const selectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selection);
  selectionRef.current = selection;
  const focusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const focusElement = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(el => {
    var _a2;

    if (ref.current === null || !ref.current.contains(document.activeElement)) return;

    if (el === null && selectionRef.current.current !== void 0) {
      (_a2 = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a2.focus({
        preventScroll: true
      });
    } else if (el !== null) {
      el.focus({
        preventScroll: true
      });
    }

    focusRef.current = el;
  }, [canvasRef]);
  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({
    focus: () => {
      var _a2;

      const el = focusRef.current;

      if (el === null || !document.contains(el)) {
        (_a2 = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a2.focus({
          preventScroll: true
        });
      } else {
        el.focus({
          preventScroll: true
        });
      }
    },
    getBounds: (col, row) => {
      if (canvasRef === void 0 || canvasRef.current === null) {
        return void 0;
      }

      return getBoundsForItem(canvasRef.current, col, row != null ? row : -1);
    },
    damage
  }), [canvasRef, damage, getBoundsForItem]);
  const lastFocusedSubdomNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const accessibilityTree = useDebouncedMemo(() => {
    var _a2, _b2, _c2, _d2;

    if (width < 50) return null;
    let effectiveCols = getEffectiveColumns(mappedColumns, cellXOffset, width, dragAndDropState, translateX);
    const colOffset = firstColAccessible ? 0 : -1;

    if (!firstColAccessible && ((_a2 = effectiveCols[0]) == null ? void 0 : _a2.sourceIndex) === 0) {
      effectiveCols = effectiveCols.slice(1);
    }

    const [fCol, fRow] = (_c2 = (_b2 = selection.current) == null ? void 0 : _b2.cell) != null ? _c2 : [];
    const range2 = (_d2 = selection.current) == null ? void 0 : _d2.range;
    const visibleCols = effectiveCols.map(c => c.sourceIndex);
    const visibleRows = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));

    if (fCol !== void 0 && fRow !== void 0 && !(visibleCols.includes(fCol) && visibleRows.includes(fRow))) {
      focusElement(null);
    }

    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("table", {
      key: "access-tree",
      role: "grid",
      "aria-rowcount": rows + 1,
      "aria-multiselectable": "true",
      "aria-colcount": mappedColumns.length + colOffset
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("thead", {
      role: "rowgroup"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
      role: "row",
      "aria-rowindex": 1
    }, effectiveCols.map(c => react__WEBPACK_IMPORTED_MODULE_0__.createElement("th", {
      role: "columnheader",
      "aria-selected": selection.columns.hasIndex(c.sourceIndex),
      "aria-colindex": c.sourceIndex + 1 + colOffset,
      tabIndex: -1,
      onFocus: e => {
        if (e.target === focusRef.current) return;
        return onCellFocused == null ? void 0 : onCellFocused([c.sourceIndex, -1]);
      },
      key: c.sourceIndex
    }, c.title)))), react__WEBPACK_IMPORTED_MODULE_0__.createElement("tbody", {
      role: "rowgroup"
    }, visibleRows.map(row => react__WEBPACK_IMPORTED_MODULE_0__.createElement("tr", {
      role: "row",
      "aria-selected": selection.rows.hasIndex(row),
      key: row,
      "aria-rowindex": row + 2
    }, effectiveCols.map(c => {
      const col = c.sourceIndex;
      const key = `${col},${row}`;
      const focused = fCol === col && fRow === row;
      const selected = range2 !== void 0 && col >= range2.x && col < range2.x + range2.width && row >= range2.y && row < range2.y + range2.height;
      const id = `glide-cell-${col}-${row}`;
      const cellContent = getCellContent([col, row]);
      return react__WEBPACK_IMPORTED_MODULE_0__.createElement("td", {
        key,
        role: "gridcell",
        "aria-colindex": col + 1 + colOffset,
        "aria-selected": selected,
        "aria-readonly": isInnerOnlyCell(cellContent) || !isReadWriteCell(cellContent),
        id,
        "data-testid": id,
        onClick: () => {
          const canvas = canvasRef == null ? void 0 : canvasRef.current;
          if (canvas === null || canvas === void 0) return;
          return onKeyDown == null ? void 0 : onKeyDown({
            bounds: getBoundsForItem(canvas, col, row),
            cancel: () => void 0,
            preventDefault: () => void 0,
            stopPropagation: () => void 0,
            ctrlKey: false,
            key: "Enter",
            keyCode: 13,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
        },
        onFocusCapture: e => {
          var _a3, _b3;

          if (e.target === focusRef.current || ((_a3 = lastFocusedSubdomNode.current) == null ? void 0 : _a3[0]) === col && ((_b3 = lastFocusedSubdomNode.current) == null ? void 0 : _b3[1]) === row) return;
          lastFocusedSubdomNode.current = [col, row];
          return onCellFocused == null ? void 0 : onCellFocused([col, row]);
        },
        ref: focused ? focusElement : void 0,
        tabIndex: -1
      }, getRowData(cellContent, getCellRenderer));
    })))));
  }, [width, mappedColumns, cellXOffset, dragAndDropState, translateX, rows, cellYOffset, accessibilityHeight, selection, focusElement, getCellContent, canvasRef, onKeyDown, getBoundsForItem, onCellFocused], 200);
  const stickyX = fixedShadowX ? getStickyWidth(mappedColumns, dragAndDropState) : 0;
  const opacityX = freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-translateX / 100, 0, 1);
  const absoluteOffsetY = -cellYOffset * 32 + translateY;
  const opacityY = !fixedShadowY ? 0 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-absoluteOffsetY / 100, 0, 1);
  const stickyShadow = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!opacityX && !opacityY) {
      return null;
    }

    const styleX = {
      position: "absolute",
      top: 0,
      left: stickyX,
      width: width - stickyX,
      height,
      opacity: opacityX,
      pointerEvents: "none",
      transition: !smoothScrollX ? "opacity 0.2s" : void 0,
      boxShadow: "inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)"
    };
    const styleY = {
      position: "absolute",
      top: totalHeaderHeight,
      left: 0,
      width,
      height,
      opacity: opacityY,
      pointerEvents: "none",
      transition: !smoothScrollY ? "opacity 0.2s" : void 0,
      boxShadow: "inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)"
    };
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, opacityX > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "shadow-x",
      style: styleX
    }), opacityY > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      id: "shadow-y",
      style: styleY
    }));
  }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);
  const overlayStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    position: "absolute",
    top: 0,
    left: 0
  }), []);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("canvas", {
    "data-testid": "data-grid-canvas",
    tabIndex: 0,
    onKeyDown: onKeyDownImpl,
    onKeyUp: onKeyUpImpl,
    onFocus: onCanvasFocused,
    onBlur: onCanvasBlur,
    ref: refImpl,
    style
  }, accessibilityTree), react__WEBPACK_IMPORTED_MODULE_0__.createElement("canvas", {
    ref: overlayRef,
    style: overlayStyle
  }), stickyShadow);
};

var data_grid_default = react__WEBPACK_IMPORTED_MODULE_0__.memo(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataGrid));

function offsetColumnSize(column, width, min, max) {
  var _a;

  return lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(Math.round(width - ((_a = column.growOffset) != null ? _a : 0)), Math.ceil(min), Math.floor(max));
}

var DataGridDnd = p => {
  var _a;

  const [resizeColStartX, setResizeColStartX] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [resizeCol, setResizeCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragCol, setDragCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dropCol, setDropCol] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragColActive, setDragColActive] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [dragStartX, setDragStartX] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragRow, setDragRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dropRow, setDropRow] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const [dragRowActive, setDragRowActive] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const [dragStartY, setDragStartY] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const {
    onHeaderMenuClick,
    getCellContent,
    onColumnMoved,
    onColumnResize,
    onColumnResizeStart,
    onColumnResizeEnd,
    gridRef,
    maxColumnWidth,
    minColumnWidth,
    onRowMoved,
    lockColumns,
    onMouseDown,
    onMouseUp,
    onItemHovered,
    onDragStart
  } = p;
  const canResize = ((_a = onColumnResize != null ? onColumnResize : onColumnResizeEnd) != null ? _a : onColumnResizeStart) !== void 0;
  const {
    columns,
    selection
  } = p;
  const selectedColumns = selection.columns;
  const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const [col, row] = args.location;

    if (dragCol !== void 0 && dropCol !== col && col >= lockColumns) {
      setDragColActive(true);
      setDropCol(col);
    } else if (dragRow !== void 0 && row !== void 0) {
      setDragRowActive(true);
      setDropRow(Math.max(0, row));
    } else {
      onItemHovered == null ? void 0 : onItemHovered(args);
    }
  }, [dragCol, dragRow, dropCol, onItemHovered, lockColumns]);
  const canDragCol = onColumnMoved !== void 0;
  const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b;

    if (args.button === 0) {
      const [col, row] = args.location;

      if (args.kind === "out-of-bounds" && args.isEdge && canResize) {
        const bounds = (_a2 = gridRef == null ? void 0 : gridRef.current) == null ? void 0 : _a2.getBounds(columns.length - 1, -1);

        if (bounds !== void 0) {
          setResizeColStartX(bounds.x);
          setResizeCol(columns.length - 1);
        }
      } else if (args.kind === "header" && col >= lockColumns) {
        if (args.isEdge && canResize) {
          setResizeColStartX(args.bounds.x);
          setResizeCol(col);
          onColumnResizeStart == null ? void 0 : onColumnResizeStart(columns[col], args.bounds.width, col, args.bounds.width + ((_b = columns[col].growOffset) != null ? _b : 0));
        } else if (args.kind === "header" && canDragCol) {
          setDragStartX(args.bounds.x);
          setDragCol(col);
        }
      } else if (args.kind === "cell" && lockColumns > 0 && col === 0 && row !== void 0 && onRowMoved !== void 0) {
        setDragStartY(args.bounds.y);
        setDragRow(row);
      }
    }

    onMouseDown == null ? void 0 : onMouseDown(args);
  }, [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart]);
  const onHeaderMenuClickMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, screenPosition) => {
    if (dragColActive || dragRowActive) return;
    onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col, screenPosition);
  }, [dragColActive, dragRowActive, onHeaderMenuClick]);
  const lastResizeWidthRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);
  const clearAll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    lastResizeWidthRef.current = -1;
    setDragRow(void 0);
    setDropRow(void 0);
    setDragStartY(void 0);
    setDragRowActive(false);
    setDragCol(void 0);
    setDropCol(void 0);
    setDragStartX(void 0);
    setDragColActive(false);
    setResizeCol(void 0);
    setResizeColStartX(void 0);
  }, []);
  const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, isOutside) => {
    var _a2, _b, _c;

    if (args.button === 0) {
      if (resizeCol !== void 0) {
        if ((selectedColumns == null ? void 0 : selectedColumns.hasIndex(resizeCol)) === true) {
          for (const c of selectedColumns) {
            if (c === resizeCol) continue;
            const col = columns[c];
            const newSize = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
            onColumnResize == null ? void 0 : onColumnResize(col, newSize, c, newSize + ((_a2 = col.growOffset) != null ? _a2 : 0));
          }
        }

        const ns = offsetColumnSize(columns[resizeCol], lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
        onColumnResizeEnd == null ? void 0 : onColumnResizeEnd(columns[resizeCol], ns, resizeCol, ns + ((_b = columns[resizeCol].growOffset) != null ? _b : 0));

        for (const c of selectedColumns) {
          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResizeEnd == null ? void 0 : onColumnResizeEnd(col, s, c, s + ((_c = col.growOffset) != null ? _c : 0));
        }
      }

      clearAll();

      if (dragCol !== void 0 && dropCol !== void 0) {
        onColumnMoved == null ? void 0 : onColumnMoved(dragCol, dropCol);
      }

      if (dragRow !== void 0 && dropRow !== void 0) {
        onRowMoved == null ? void 0 : onRowMoved(dragRow, dropRow);
      }
    }

    onMouseUp == null ? void 0 : onMouseUp(args, isOutside);
  }, [onMouseUp, resizeCol, dragCol, dropCol, dragRow, dropRow, selectedColumns, onColumnResizeEnd, columns, minColumnWidth, maxColumnWidth, onColumnResize, onColumnMoved, onRowMoved, clearAll]);
  const dragOffset = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (dragCol === void 0 || dropCol === void 0) return void 0;
    if (dragCol === dropCol) return void 0;
    return {
      src: dragCol,
      dest: dropCol
    };
  }, [dragCol, dropCol]);
  const onMouseMove = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    var _a2, _b;

    if (dragCol !== void 0 && dragStartX !== void 0) {
      const diff = Math.abs(event.clientX - dragStartX);

      if (diff > 20) {
        setDragColActive(true);
      }
    } else if (dragRow !== void 0 && dragStartY !== void 0) {
      const diff = Math.abs(event.clientY - dragStartY);

      if (diff > 20) {
        setDragRowActive(true);
      }
    } else if (resizeCol !== void 0 && resizeColStartX !== void 0) {
      const column = columns[resizeCol];
      const newWidth = event.clientX - resizeColStartX;
      const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);
      onColumnResize == null ? void 0 : onColumnResize(column, ns, resizeCol, ns + ((_a2 = column.growOffset) != null ? _a2 : 0));
      lastResizeWidthRef.current = newWidth;

      if ((selectedColumns == null ? void 0 : selectedColumns.first()) === resizeCol) {
        for (const c of selectedColumns) {
          if (c === resizeCol) continue;
          const col = columns[c];
          const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);
          onColumnResize == null ? void 0 : onColumnResize(col, s, c, s + ((_b = col.growOffset) != null ? _b : 0));
        }
      }
    }
  }, [dragCol, dragStartX, dragRow, dragStartY, resizeCol, resizeColStartX, columns, minColumnWidth, maxColumnWidth, onColumnResize, selectedColumns]);
  const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    if (dragRow === void 0 || dropRow === void 0) return getCellContent(cell);
    let [col, row] = cell;

    if (row === dropRow) {
      row = dragRow;
    } else {
      if (row > dropRow) row -= 1;
      if (row >= dragRow) row += 1;
    }

    return getCellContent([col, row]);
  }, [dragRow, dropRow, getCellContent]);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    onDragStart == null ? void 0 : onDragStart(args);

    if (!args.defaultPrevented()) {
      clearAll();
    }
  }, [clearAll, onDragStart]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_default, {
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    enableGroups: p.enableGroups,
    eventTargetRef: p.eventTargetRef,
    experimental: p.experimental,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    headerIcons: p.headerIcons,
    height: p.height,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isDraggable: p.isDraggable,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDrop: p.onDrop,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    width: p.width,
    getCellContent: getMangledCellContent,
    isResizing: resizeCol !== void 0,
    onHeaderMenuClick: onHeaderMenuClickMangled,
    isDragging: dragColActive,
    onItemHovered: onItemHoveredImpl,
    onDragStart: onDragStartImpl,
    onMouseDown: onMouseDownImpl,
    allowResize: onColumnResize !== void 0,
    onMouseUp: onMouseUpImpl,
    dragAndDropState: dragOffset,
    onMouseMoveRaw: onMouseMove,
    ref: gridRef
  });
};

var data_grid_dnd_default = DataGridDnd;



function useResizeDetector(initialSize) {
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const [size, setSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    width: initialSize == null ? void 0 : initialSize[0],
    height: initialSize == null ? void 0 : initialSize[1]
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    const resizeCallback = entries => {
      for (const entry of entries) {
        const {
          width,
          height
        } = entry && entry.contentRect || {};
        setSize(cv => cv.width === width && cv.height === height ? cv : {
          width,
          height
        });
      }
    };

    const resizeObserver = new window.ResizeObserver(resizeCallback);

    if (ref.current) {
      resizeObserver.observe(ref.current, void 0);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [ref.current]);
  return {
    ref,
    ...size
  };
}

var ScrollRegionStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "ScrollRegionStyle",
  class: "s1jz82f8",
  vars: {
    "s1jz82f8-0": [p => p.isSafari ? "scroll" : "auto"]
  }
});

function eatEvent(e) {
  e.stopPropagation();
}

function useTouchUpDelayed(delay) {
  const [hasTouches, setHasTouches] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const cbTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  useEventListener("touchstart", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    window.clearTimeout(cbTimer.current);
    setHasTouches(true);
  }, []), window, true, false);
  useEventListener("touchend", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {
    if (e.touches.length === 0) {
      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);
    }
  }, [delay]), window, true, false);
  return hasTouches;
}

var InfiniteScroller = p => {
  var _a, _b, _c, _d;

  const {
    children,
    clientHeight,
    scrollHeight,
    scrollWidth,
    update,
    draggable,
    className,
    preventDiagonalScrolling = false,
    paddingBottom = 0,
    paddingRight = 0,
    rightElement,
    rightElementProps,
    scrollRef,
    scrollToEnd,
    initialSize,
    minimap
  } = p;
  const padders = [];
  const rightElementSticky = (_a = rightElementProps == null ? void 0 : rightElementProps.sticky) != null ? _a : false;
  const rightElementFill = (_b = rightElementProps == null ? void 0 : rightElementProps.fill) != null ? _b : false;
  const offsetY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const lastScrollY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const scroller = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const dpr = window.devicePixelRatio;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const el = scroller.current;
    if (el === null || scrollToEnd !== true) return;
    el.scrollLeft = el.scrollWidth - el.clientWidth;
  }, [scrollToEnd]);
  const lastScrollPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
    scrollLeft: 0,
    scrollTop: 0,
    lockDirection: void 0
  });
  const rightWrapRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const hasTouches = useTouchUpDelayed(200);
  const [isIdle, setIsIdle] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);
  const idleTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === void 0) return;
    const el = scroller.current;
    if (el === null) return;
    const [lx, ly] = lastScrollPosition.current.lockDirection;

    if (lx !== void 0) {
      el.scrollLeft = lx;
    } else if (ly !== void 0) {
      el.scrollTop = ly;
    }

    lastScrollPosition.current.lockDirection = void 0;
  }, [hasTouches, isIdle]);
  const onScroll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2, _c2, _d2;

    const el = scroller.current;
    if (el === null) return;
    let scrollTop = el.scrollTop;
    let scrollLeft = el.scrollLeft;
    const lastScrollTop = lastScrollPosition.current.scrollTop;
    const lastScrollLeft = lastScrollPosition.current.scrollLeft;
    const dx = scrollLeft - lastScrollLeft;
    const dy = scrollTop - lastScrollTop;

    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === void 0) {
      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, void 0] : [void 0, lastScrollTop];
    }

    const lock = lastScrollPosition.current.lockDirection;
    scrollLeft = (_a2 = lock == null ? void 0 : lock[0]) != null ? _a2 : scrollLeft;
    scrollTop = (_b2 = lock == null ? void 0 : lock[1]) != null ? _b2 : scrollTop;
    lastScrollPosition.current.scrollLeft = scrollLeft;
    lastScrollPosition.current.scrollTop = scrollTop;
    const newY = scrollTop;
    const delta = lastScrollY.current - newY;
    const scrollableHeight = el.scrollHeight - el.clientHeight;
    lastScrollY.current = newY;

    if (scrollableHeight > 0 && (Math.abs(delta) > 2e3 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {
      const prog = newY / scrollableHeight;
      const recomputed = (scrollHeight - el.clientHeight) * prog;
      offsetY.current = recomputed - newY;
    }

    if (lock !== void 0) {
      window.clearTimeout(idleTimer.current);
      setIsIdle(false);
      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);
    }

    update({
      x: scrollLeft,
      y: newY + offsetY.current,
      width: el.clientWidth - paddingRight,
      height: el.clientHeight - paddingBottom,
      paddingRight: (_d2 = (_c2 = rightWrapRef.current) == null ? void 0 : _c2.clientWidth) != null ? _d2 : 0
    });
  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);
  const onScrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onScroll);
  onScrollRef.current = onScroll;
  const lastProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    onScroll();
  }, [onScroll, paddingBottom, paddingRight]);
  const setRefs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {
    scroller.current = instance;

    if (scrollRef !== void 0) {
      scrollRef.current = instance;
    }
  }, [scrollRef]);
  let key = 0;
  let h = 0;
  padders.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: key++,
    style: {
      width: scrollWidth,
      height: 0
    }
  }));

  while (h < scrollHeight) {
    const toAdd = Math.min(5e6, scrollHeight - h);
    padders.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      key: key++,
      style: {
        width: 0,
        height: toAdd
      }
    }));
    h += toAdd;
  }

  const {
    ref,
    width,
    height
  } = useResizeDetector(initialSize);

  if (((_c = lastProps.current) == null ? void 0 : _c.height) !== height || ((_d = lastProps.current) == null ? void 0 : _d.width) !== width) {
    window.setTimeout(() => onScrollRef.current(), 0);
    lastProps.current = {
      width,
      height
    };
  }

  if ((width != null ? width : 0) === 0 || (height != null ? height : 0) === 0) return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollRegionStyle, {
    isSafari: browserIsSafari.value
  }, minimap, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-underlay"
  }, children), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: setRefs,
    style: lastProps.current,
    draggable,
    onDragStart: e => {
      if (!draggable) {
        e.stopPropagation();
        e.preventDefault();
      }
    },
    className: "dvn-scroller " + (className != null ? className : ""),
    onScroll
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-scroll-inner" + (rightElement === void 0 ? " hidden" : "")
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-stack"
  }, padders), rightElement !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !rightElementFill && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "dvn-spacer"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    ref: rightWrapRef,
    onMouseDown: eatEvent,
    onMouseUp: eatEvent,
    onMouseMove: eatEvent,
    style: {
      height,
      maxHeight: clientHeight - Math.ceil(dpr % 1),
      position: "sticky",
      top: 0,
      paddingLeft: 1,
      marginBottom: -40,
      marginRight: paddingRight,
      flexGrow: rightElementFill ? 1 : void 0,
      right: rightElementSticky ? paddingRight != null ? paddingRight : 0 : void 0,
      pointerEvents: "auto"
    }
  }, rightElement))))));
};


var MinimapStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "MinimapStyle",
  class: "m15w2ly5"
});

var GridScroller = p => {
  var _a, _b, _c;

  const {
    columns,
    rows,
    rowHeight,
    headerHeight,
    groupHeaderHeight,
    enableGroups,
    freezeColumns,
    experimental,
    clientSize,
    className,
    onVisibleRegionChanged,
    scrollToEnd,
    scrollRef,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    overscrollX,
    overscrollY,
    showMinimap = false,
    initialSize,
    smoothScrollX = false,
    smoothScrollY = false,
    isDraggable
  } = p;
  const {
    paddingRight,
    paddingBottom
  } = experimental != null ? experimental : {};
  const [clientWidth, clientHeight] = clientSize;
  const last = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastX = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastY = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastSize = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const width = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let r = Math.max(0, overscrollX != null ? overscrollX : 0);

    for (const c of columns) {
      r += c.width;
    }

    return r;
  }, [columns, overscrollX]);
  let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;

  if (typeof rowHeight === "number") {
    height += rows * rowHeight;
  } else {
    for (let r = 0; r < rows; r++) {
      height += rowHeight(r);
    }
  }

  if (overscrollY !== void 0) {
    height += overscrollY;
  }

  const lastArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const processArgs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a2, _b2, _c2;

    if (lastArgs.current === void 0) return;
    const args = { ...lastArgs.current
    };
    let x = 0;
    let tx = args.x < 0 ? -args.x : 0;
    let cellRight = 0;
    let cellX = 0;
    args.x = args.x < 0 ? 0 : args.x;
    let stickyColWidth = 0;

    for (let i = 0; i < freezeColumns; i++) {
      stickyColWidth += columns[i].width;
    }

    for (const c of columns) {
      const cx = x - stickyColWidth;

      if (args.x >= cx + c.width) {
        x += c.width;
        cellX++;
        cellRight++;
      } else if (args.x > cx) {
        x += c.width;

        if (smoothScrollX) {
          tx += cx - args.x;
        } else {
          cellX++;
        }

        cellRight++;
      } else if (args.x + args.width > cx) {
        x += c.width;
        cellRight++;
      } else {
        break;
      }
    }

    let ty = 0;
    let cellY = 0;
    let cellBottom = 0;

    if (typeof rowHeight === "number") {
      if (smoothScrollY) {
        cellY = Math.floor(args.y / rowHeight);
        ty = cellY * rowHeight - args.y;
      } else {
        cellY = Math.ceil(args.y / rowHeight);
      }

      cellBottom = Math.ceil(args.height / rowHeight) + cellY;
      if (ty < 0) cellBottom++;
    } else {
      let y = 0;

      for (let row = 0; row < rows; row++) {
        const rh = rowHeight(row);
        const cy = y + (smoothScrollY ? 0 : rh / 2);

        if (args.y >= y + rh) {
          y += rh;
          cellY++;
          cellBottom++;
        } else if (args.y > cy) {
          y += rh;

          if (smoothScrollY) {
            ty += cy - args.y;
          } else {
            cellY++;
          }

          cellBottom++;
        } else if (args.y + args.height > rh / 2 + y) {
          y += rh;
          cellBottom++;
        } else {
          break;
        }
      }
    }

    const rect = {
      x: cellX,
      y: cellY,
      width: cellRight - cellX,
      height: cellBottom - cellY
    };
    const oldRect = last.current;

    if (oldRect === void 0 || oldRect.y !== rect.y || oldRect.x !== rect.x || oldRect.height !== rect.height || oldRect.width !== rect.width || lastX.current !== tx || lastY.current !== ty || args.width !== ((_a2 = lastSize.current) == null ? void 0 : _a2[0]) || args.height !== ((_b2 = lastSize.current) == null ? void 0 : _b2[1])) {
      onVisibleRegionChanged == null ? void 0 : onVisibleRegionChanged({
        x: cellX,
        y: cellY,
        width: cellRight - cellX,
        height: cellBottom - cellY
      }, args.width, args.height, (_c2 = args.paddingRight) != null ? _c2 : 0, tx, ty);
      last.current = rect;
      lastX.current = tx;
      lastY.current = ty;
      lastSize.current = [args.width, args.height];
    }
  }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);
  const onScrollUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    lastArgs.current = args;
    processArgs();
  }, [processArgs]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    processArgs();
  }, [processArgs]);
  const scroller = (_a = scrollRef == null ? void 0 : scrollRef.current) != null ? _a : void 0;
  const aspect = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(width / height, 2 / 3, 1.5);
  const maxSize = 200;
  const w = aspect > 1 ? maxSize : Math.ceil(maxSize * aspect);
  const h = aspect > 1 ? Math.ceil(maxSize / aspect) : maxSize;
  const hRatio = w / width;
  const vRatio = h / height;
  const vWidth = Math.min(clientWidth * Math.max(hRatio, 0.01), w);
  const vHeight = Math.min(clientHeight * Math.max(vRatio, 0.01), h);
  const left = ((_b = scroller == null ? void 0 : scroller.scrollLeft) != null ? _b : 0) / (width - clientWidth) * (w - vWidth);
  const top = ((_c = scroller == null ? void 0 : scroller.scrollTop) != null ? _c : 0) / (height - clientHeight) * (h - vHeight);
  const minimap = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!showMinimap || vWidth === 0 || vHeight === 0) return void 0;

    const handleMouse = e => {
      if (scroller === void 0) return;
      const bounds = e.currentTarget.getBoundingClientRect();
      const x = e.clientX - bounds.x - vWidth / 2;
      const y = e.clientY - bounds.y - vHeight / 2;
      const newScrollLeft = (width - scroller.clientWidth) * (x / (w - vWidth));
      const newScrollTop = (height - scroller.clientHeight) * (y / (h - vHeight));
      scroller.scrollTo({
        left: newScrollLeft,
        top: newScrollTop,
        behavior: e.type === "mousemove" ? "auto" : "smooth"
      });
    };

    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MinimapStyle, {
      style: {
        width: w,
        height: h
      },
      "data-testid": "minimap-container",
      onMouseMove: e => {
        if (e.buttons !== 1) return;
        handleMouse(e);
      },
      onClick: handleMouse
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "header"
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "locationMarker",
      onDragStart: e => e.preventDefault(),
      style: {
        left,
        top,
        width: vWidth,
        height: vHeight,
        borderRadius: Math.min(vWidth, vHeight * 0.2, 9)
      }
    }));
  }, [h, height, left, scroller, showMinimap, top, vHeight, vWidth, w, width]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(InfiniteScroller, {
    scrollRef,
    minimap,
    className,
    preventDiagonalScrolling,
    draggable: isDraggable === true || typeof isDraggable === "string",
    scrollWidth: width + (paddingRight != null ? paddingRight : 0),
    scrollHeight: height + (paddingBottom != null ? paddingBottom : 0),
    clientHeight,
    rightElement,
    paddingBottom,
    paddingRight,
    rightElementProps,
    update: onScrollUpdate,
    initialSize,
    scrollToEnd
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_dnd_default, {
    eventTargetRef: scrollRef,
    width: clientWidth,
    height: clientHeight,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    prelightCells: p.prelightCells,
    rowHeight: p.rowHeight,
    rows: p.rows,
    selection: p.selection,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY
  }));
};

var scrolling_data_grid_default = GridScroller;
var SearchWrapper = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "SearchWrapper",
  class: "sxep88s",
  vars: {
    "sxep88s-0": [p => p.showSearch ? 0 : 400, "px"]
  }
});
var upArrow = react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 244l144-144 144 144M256 120v292"
}));
var downArrow = react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "48",
  d: "M112 268l144 144 144-144M256 392V100"
}));
var closeX = react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg", {
  className: "button-icon",
  viewBox: "0 0 512 512"
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement("path", {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: "32",
  d: "M368 368L144 144M368 144L144 368"
}));
var targetSearchTimeMS = 10;

var DataGridSearch = p => {
  const {
    canvasRef,
    cellYOffset,
    rows,
    columns,
    searchInputRef,
    getCellsForSelection,
    onSearchResultsChanged,
    showSearch = false,
    onSearchClose
  } = p;
  const [searchID] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => "search-box-" + Math.round(Math.random() * 1e3));
  const [searchString, setSearchString] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
  const [searchStatus, setSearchStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const searchStatusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(searchStatus);
  searchStatusRef.current = searchStatus;
  const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new AbortController());
  const searchHandle = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [searchResults, setSearchResults] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  const cancelSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (searchHandle.current !== void 0) {
      window.cancelAnimationFrame(searchHandle.current);
      searchHandle.current = void 0;
      abortControllerRef.current.abort();
    }
  }, []);
  const cellYOffsetRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cellYOffset);
  cellYOffsetRef.current = cellYOffset;
  const beginSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(str => {
    const regex = new RegExp(str.replace(/([$()*+.?[\\\]^{|}-])/g, "\\$1"), "i");
    let startY = cellYOffsetRef.current;
    let searchStride = Math.min(10, rows);
    let rowsSearched = 0;
    setSearchStatus(void 0);
    setSearchResults([]);
    const runningResult = [];

    const tick = async () => {
      var _a, _b;

      if (getCellsForSelection === void 0) return;
      const tStart = performance.now();
      const rowsLeft = rows - rowsSearched;
      let data = getCellsForSelection({
        x: 0,
        y: startY,
        width: columns.length,
        height: Math.min(searchStride, rowsLeft, rows - startY)
      }, abortControllerRef.current.signal);

      if (typeof data === "function") {
        data = await data();
      }

      let added = false;

      for (const [row, d] of data.entries()) {
        for (const [col, cell] of d.entries()) {
          let testString;

          switch (cell.kind) {
            case GridCellKind.Text:
            case GridCellKind.Number:
              testString = cell.displayData;
              break;

            case GridCellKind.Uri:
            case GridCellKind.Markdown:
              testString = cell.data;
              break;

            case GridCellKind.Boolean:
              testString = typeof cell.data === "boolean" ? cell.data.toString() : void 0;
              break;

            case GridCellKind.Image:
            case GridCellKind.Bubble:
              testString = cell.data.join("\u{1F433}");
              break;

            case GridCellKind.Custom:
              testString = cell.copyData;
              break;
          }

          if (testString !== void 0 && regex.test(testString)) {
            runningResult.push([col, row + startY]);
            added = true;
          }
        }
      }

      const tEnd = performance.now();

      if (added) {
        setSearchResults([...runningResult]);
      }

      rowsSearched += data.length;
      assert(rowsSearched <= rows);
      const selectedIndex = (_b = (_a = searchStatusRef.current) == null ? void 0 : _a.selectedIndex) != null ? _b : -1;
      setSearchStatus({
        results: runningResult.length,
        rowsSearched,
        selectedIndex
      });
      onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(runningResult, selectedIndex);

      if (startY + searchStride >= rows) {
        startY = 0;
      } else {
        startY += searchStride;
      }

      const tElapsed = tEnd - tStart;
      const rounded = Math.max(tElapsed, 1);
      const scalar = targetSearchTimeMS / rounded;
      searchStride = Math.ceil(searchStride * scalar);

      if (rowsSearched < rows && runningResult.length < 1e3) {
        searchHandle.current = window.requestAnimationFrame(tick);
      }
    };

    cancelSearch();
    searchHandle.current = window.requestAnimationFrame(tick);
  }, [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]);
  const onClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    var _a;

    onSearchClose == null ? void 0 : onSearchClose();
    setSearchStatus(void 0);
    setSearchResults([]);
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged([], -1);
    cancelSearch();
    (_a = canvasRef == null ? void 0 : canvasRef.current) == null ? void 0 : _a.focus();
  }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);
  const onSearchChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    setSearchString(event.target.value);

    if (event.target.value === "") {
      setSearchStatus(void 0);
      setSearchResults([]);
      cancelSearch();
    } else {
      beginSearch(event.target.value);
    }
  }, [beginSearch, cancelSearch]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (showSearch && searchInputRef.current !== null) {
      setSearchString("");
      searchInputRef.current.focus({
        preventScroll: true
      });
    }
  }, [showSearch, searchInputRef]);
  const onNext = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a;

    (_a = ev == null ? void 0 : ev.stopPropagation) == null ? void 0 : _a.call(ev);
    if (searchStatus === void 0) return;
    const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [searchStatus, onSearchResultsChanged, searchResults]);
  const onPrev = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(ev => {
    var _a;

    (_a = ev == null ? void 0 : ev.stopPropagation) == null ? void 0 : _a.call(ev);
    if (searchStatus === void 0) return;
    let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;
    if (newIndex < 0) newIndex += searchStatus.results;
    setSearchStatus({ ...searchStatus,
      selectedIndex: newIndex
    });
    onSearchResultsChanged == null ? void 0 : onSearchResultsChanged(searchResults, newIndex);
  }, [onSearchResultsChanged, searchResults, searchStatus]);
  const onSearchKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if ((event.ctrlKey || event.metaKey) && event.nativeEvent.code === "KeyF" || event.key === "Escape") {
      onClose();
      event.stopPropagation();
      event.preventDefault();
    } else if (event.key === "Enter") {
      if (event.shiftKey) {
        onPrev();
      } else {
        onNext();
      }
    }
  }, [onClose, onNext, onPrev]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      cancelSearch();
    };
  }, [cancelSearch]);
  const searchbox = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a, _b, _c;

    let resultString;

    if (searchStatus !== void 0) {
      resultString = searchStatus.results >= 1e3 ? `over 1000` : `${searchStatus.results} result${searchStatus.results !== 1 ? "s" : ""}`;

      if (searchStatus.selectedIndex >= 0) {
        resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;
      }
    }

    const cancelEvent = ev => {
      ev.stopPropagation();
    };

    const rowsSearchedProgress = Math.floor(((_a = searchStatus == null ? void 0 : searchStatus.rowsSearched) != null ? _a : 0) / rows * 100);
    const progressStyle = {
      width: `${rowsSearchedProgress}%`
    };
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SearchWrapper, {
      showSearch,
      onMouseDown: cancelEvent,
      onMouseMove: cancelEvent,
      onMouseUp: cancelEvent,
      onClick: cancelEvent
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-bar-inner"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("input", {
      id: searchID,
      "aria-hidden": !showSearch,
      "data-testid": "search-input",
      ref: searchInputRef,
      onChange: onSearchChange,
      value: searchString,
      tabIndex: showSearch ? void 0 : -1,
      onKeyDownCapture: onSearchKeyDown
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Previous Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? void 0 : -1,
      onClick: onPrev,
      disabled: ((_b = searchStatus == null ? void 0 : searchStatus.results) != null ? _b : 0) === 0
    }, upArrow), react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Next Result",
      "aria-hidden": !showSearch,
      tabIndex: showSearch ? void 0 : -1,
      onClick: onNext,
      disabled: ((_c = searchStatus == null ? void 0 : searchStatus.results) != null ? _c : 0) === 0
    }, downArrow), onSearchClose !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
      "aria-label": "Close Search",
      "aria-hidden": !showSearch,
      "data-testid": "search-close-button",
      tabIndex: showSearch ? void 0 : -1,
      onClick: onClose
    }, closeX)), searchStatus !== void 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-status"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      "data-testid": "search-result-area"
    }, resultString)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-progress",
      style: progressStyle
    })) : react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "search-status"
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement("label", {
      htmlFor: searchID
    }, "Type to search")));
  }, [onClose, onNext, onPrev, onSearchChange, onSearchClose, onSearchKeyDown, rows, searchStatus, searchString, showSearch, searchID, searchInputRef]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement(scrolling_data_grid_default, {
    prelightCells: searchResults,
    accessibilityHeight: p.accessibilityHeight,
    canvasRef: p.canvasRef,
    cellXOffset: p.cellXOffset,
    cellYOffset: p.cellYOffset,
    className: p.className,
    clientSize: p.clientSize,
    columns: p.columns,
    disabledRows: p.disabledRows,
    enableGroups: p.enableGroups,
    fillHandle: p.fillHandle,
    firstColAccessible: p.firstColAccessible,
    fixedShadowX: p.fixedShadowX,
    fixedShadowY: p.fixedShadowY,
    freezeColumns: p.freezeColumns,
    getCellContent: p.getCellContent,
    getCellRenderer: p.getCellRenderer,
    getGroupDetails: p.getGroupDetails,
    getRowThemeOverride: p.getRowThemeOverride,
    groupHeaderHeight: p.groupHeaderHeight,
    headerHeight: p.headerHeight,
    highlightRegions: p.highlightRegions,
    imageWindowLoader: p.imageWindowLoader,
    initialSize: p.initialSize,
    isFilling: p.isFilling,
    isFocused: p.isFocused,
    lockColumns: p.lockColumns,
    maxColumnWidth: p.maxColumnWidth,
    minColumnWidth: p.minColumnWidth,
    onHeaderMenuClick: p.onHeaderMenuClick,
    onMouseMove: p.onMouseMove,
    onVisibleRegionChanged: p.onVisibleRegionChanged,
    overscrollX: p.overscrollX,
    overscrollY: p.overscrollY,
    preventDiagonalScrolling: p.preventDiagonalScrolling,
    rightElement: p.rightElement,
    rightElementProps: p.rightElementProps,
    rowHeight: p.rowHeight,
    rows: p.rows,
    scrollRef: p.scrollRef,
    selection: p.selection,
    showMinimap: p.showMinimap,
    theme: p.theme,
    trailingRowType: p.trailingRowType,
    translateX: p.translateX,
    translateY: p.translateY,
    verticalBorder: p.verticalBorder,
    drawCustomCell: p.drawCustomCell,
    drawFocusRing: p.drawFocusRing,
    drawHeader: p.drawHeader,
    experimental: p.experimental,
    gridRef: p.gridRef,
    headerIcons: p.headerIcons,
    isDraggable: p.isDraggable,
    onCanvasBlur: p.onCanvasBlur,
    onCanvasFocused: p.onCanvasFocused,
    onCellFocused: p.onCellFocused,
    onColumnMoved: p.onColumnMoved,
    onColumnResize: p.onColumnResize,
    onColumnResizeEnd: p.onColumnResizeEnd,
    onColumnResizeStart: p.onColumnResizeStart,
    onContextMenu: p.onContextMenu,
    onDragEnd: p.onDragEnd,
    onDragLeave: p.onDragLeave,
    onDragOverCell: p.onDragOverCell,
    onDragStart: p.onDragStart,
    onDrop: p.onDrop,
    onItemHovered: p.onItemHovered,
    onKeyDown: p.onKeyDown,
    onKeyUp: p.onKeyUp,
    onMouseDown: p.onMouseDown,
    onMouseUp: p.onMouseUp,
    onRowMoved: p.onRowMoved,
    smoothScrollX: p.smoothScrollX,
    smoothScrollY: p.smoothScrollY,
    scrollToEnd: p.scrollToEnd
  }), searchbox);
};

var data_grid_search_default = DataGridSearch;

var RenameInput = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("input")({
  name: "RenameInput",
  class: "r1kzy40b",
  vars: {
    "r1kzy40b-0": [p => Math.max(16, p.targetHeight - 10), "px"]
  }
});

var GroupRename = p => {
  const {
    bounds,
    group,
    onClose,
    canvasBounds,
    onFinish
  } = p;
  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(group);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ClickOutsideContainer, {
    style: {
      position: "absolute",
      left: bounds.x - canvasBounds.left + 1,
      top: bounds.y - canvasBounds.top,
      width: bounds.width - 2,
      height: bounds.height
    },
    className: "c1sqdbw3",
    onClickOutside: onClose
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenameInput, {
    targetHeight: bounds.height,
    "data-testid": "group-rename-input",
    value,
    onBlur: onClose,
    onFocus: e => e.target.setSelectionRange(0, value.length),
    onChange: e => setValue(e.target.value),
    onKeyDown: e => {
      if (e.key === "Enter") {
        onFinish(value);
      } else if (e.key === "Escape") {
        onClose();
      }
    },
    autoFocus: true
  }));
};


var defaultSize = 150;

function measureCell(ctx, cell, theme, getCellRenderer) {
  var _a, _b;

  if (cell.kind === GridCellKind.Custom) return defaultSize;
  const r = getCellRenderer(cell);
  return (_b = (_a = r == null ? void 0 : r.measure) == null ? void 0 : _a.call(r, ctx, cell, theme)) != null ? _b : defaultSize;
}

function measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, removeOutliers, getCellRenderer) {
  let sizes = [];

  if (selectedData !== void 0) {
    sizes.push(...selectedData.map(row => row[colIndex]).map(cell => measureCell(ctx, cell, theme, getCellRenderer)));
  }

  if (sizes.length > 5 && removeOutliers) {
    const average = sizes.reduce((a, b) => a + b) / sizes.length;
    sizes = sizes.filter(a => a < average * 2);
  }

  sizes.push(ctx.measureText(c.title).width + 16 + (c.icon === void 0 ? 0 : 28));
  const biggest = Math.max(...sizes);
  const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(biggest)));
  return { ...c,
    width: final
  };
}

function useColumnSizer(columns, rows, getCellsForSelection, clientWidth, minColumnWidth, maxColumnWidth, theme, getCellRenderer, abortController) {
  const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);
  const getCellsForSelectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellsForSelection);
  const themeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(theme);
  rowsRef.current = rows;
  getCellsForSelectionRef.current = getCellsForSelection;
  themeRef.current = theme;
  const [ctx] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    const offscreen = document.createElement("canvas");
    return offscreen.getContext("2d", {
      alpha: false
    });
  });
  const memoMap = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});
  const lastColumns = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const [selectedData, setSelectionData] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    const getCells = getCellsForSelectionRef.current;
    if (getCells === void 0 || columns.every(isSizedGridColumn)) return;
    let computeRows = Math.max(1, 10 - Math.floor(columns.length / 1e4));
    let tailRows = 0;

    if (computeRows < rowsRef.current && computeRows > 1) {
      computeRows--;
      tailRows = 1;
    }

    const computeArea = {
      x: 0,
      y: 0,
      width: columns.length,
      height: Math.min(rowsRef.current, computeRows)
    };
    const tailComputeArea = {
      x: 0,
      y: rowsRef.current - 1,
      width: columns.length,
      height: 1
    };

    const fn = async () => {
      const getResult = getCells(computeArea, abortController.signal);
      const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : void 0;
      let toSet;

      if (typeof getResult === "object") {
        toSet = getResult;
      } else {
        toSet = await resolveCellsThunk(getResult);
      }

      if (tailGetResult !== void 0) {
        if (typeof tailGetResult === "object") {
          toSet = [...toSet, ...tailGetResult];
        } else {
          toSet = [...toSet, ...(await resolveCellsThunk(tailGetResult))];
        }
      }

      lastColumns.current = columns;
      setSelectionData(toSet);
    };

    void fn();
  }, [abortController.signal, columns]);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a;

    const getRaw = () => {
      if (columns.every(isSizedGridColumn)) {
        return columns;
      }

      if (ctx === null) {
        return columns.map(c => {
          if (isSizedGridColumn(c)) return c;
          return { ...c,
            width: defaultSize
          };
        });
      }

      ctx.font = `${themeRef.current.baseFontStyle} ${themeRef.current.fontFamily}`;
      return columns.map((c, colIndex) => {
        if (isSizedGridColumn(c)) return c;

        if (memoMap.current[c.id] !== void 0) {
          return { ...c,
            width: memoMap.current[c.id]
          };
        }

        if (selectedData === void 0 || lastColumns.current !== columns || c.id === void 0) {
          return { ...c,
            width: defaultSize
          };
        }

        const r = measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, true, getCellRenderer);
        memoMap.current[c.id] = r.width;
        return r;
      });
    };

    let result = getRaw();
    let totalWidth = 0;
    let totalGrow = 0;
    const distribute = [];

    for (const [i, c] of result.entries()) {
      totalWidth += c.width;

      if (c.grow !== void 0 && c.grow > 0) {
        totalGrow += c.grow;
        distribute.push(i);
      }
    }

    if (totalWidth < clientWidth && distribute.length > 0) {
      const writeable = [...result];
      const extra = clientWidth - totalWidth;
      let remaining = extra;

      for (let di = 0; di < distribute.length; di++) {
        const i = distribute[di];
        const weighted = ((_a = result[i].grow) != null ? _a : 0) / totalGrow;
        const toAdd = di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));
        writeable[i] = { ...result[i],
          growOffset: toAdd,
          width: result[i].width + toAdd
        };
        remaining -= toAdd;
      }

      result = writeable;
    }

    return result;
  }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);
}

function checkKey(key, args) {
  if (key === void 0) return false;

  if (key.length > 1 && key.startsWith("_")) {
    const keycode = Number.parseInt(key.slice(1));
    if (keycode !== args.keyCode) return false;
  } else {
    if (key !== args.key) return false;
  }

  return true;
}

function isHotkey(hotkey, args) {
  if (hotkey.length === 0) return false;
  let wantCtrl = false;
  let wantShift = false;
  let wantAlt = false;
  let wantMeta = false;
  const split = hotkey.split("+");
  const key = split.pop();
  if (!checkKey(key, args)) return false;

  for (const accel of split) {
    switch (accel) {
      case "ctrl":
        wantCtrl = true;
        break;

      case "shift":
        wantShift = true;
        break;

      case "alt":
        wantAlt = true;
        break;

      case "meta":
        wantMeta = true;
        break;

      case "primary":
        if (browserIsOSX.value) {
          wantMeta = true;
        } else {
          wantCtrl = true;
        }

        break;
    }
  }

  return args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta;
}



function useSelectionBehavior(gridSelection, setGridSelection, rangeBehavior, columnBehavior, rowBehavior, rangeSelect) {
  const setCurrent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((value, expand, append, trigger) => {
    var _a, _b;

    if ((rangeSelect === "cell" || rangeSelect === "multi-cell") && value !== void 0) {
      value = { ...value,
        range: {
          x: value.cell[0],
          y: value.cell[1],
          width: 1,
          height: 1
        }
      };
    }

    const rangeMixable = rangeBehavior === "mixed" && (append || trigger === "drag");
    const allowColumnCoSelect = columnBehavior === "mixed" && rangeMixable;
    const allowRowCoSelect = rowBehavior === "mixed" && rangeMixable;
    let newVal = {
      current: value === void 0 ? void 0 : { ...value,
        rangeStack: trigger === "drag" ? (_b = (_a = gridSelection.current) == null ? void 0 : _a.rangeStack) != null ? _b : [] : []
      },
      columns: allowColumnCoSelect ? gridSelection.columns : CompactSelection.empty(),
      rows: allowRowCoSelect ? gridSelection.rows : CompactSelection.empty()
    };
    const addLastRange = append && (rangeSelect === "multi-rect" || rangeSelect === "multi-cell");

    if (addLastRange && newVal.current !== void 0 && gridSelection.current !== void 0) {
      newVal = { ...newVal,
        current: { ...newVal.current,
          rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range]
        }
      };
    }

    setGridSelection(newVal, expand);
  }, [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]);
  const setSelectedRows = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newRows, append, allowMixed) => {
    newRows = newRows != null ? newRows : gridSelection.rows;

    if (append !== void 0) {
      newRows = newRows.add(append);
    }

    let newVal;

    if (rowBehavior === "exclusive" && newRows.length > 0) {
      newVal = {
        current: void 0,
        columns: CompactSelection.empty(),
        rows: newRows
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const columnMixed = allowMixed && columnBehavior === "mixed";
      const current = !rangeMixed ? void 0 : gridSelection.current;
      newVal = {
        current,
        columns: columnMixed ? gridSelection.columns : CompactSelection.empty(),
        rows: newRows
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  const setSelectedColumns = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCols, append, allowMixed) => {
    newCols = newCols != null ? newCols : gridSelection.columns;

    if (append !== void 0) {
      newCols = newCols.add(append);
    }

    let newVal;

    if (columnBehavior === "exclusive" && newCols.length > 0) {
      newVal = {
        current: void 0,
        rows: CompactSelection.empty(),
        columns: newCols
      };
    } else {
      const rangeMixed = allowMixed && rangeBehavior === "mixed";
      const rowMixed = allowMixed && rowBehavior === "mixed";
      const current = !rangeMixed ? void 0 : gridSelection.current;
      newVal = {
        current,
        rows: rowMixed ? gridSelection.rows : CompactSelection.empty(),
        columns: newCols
      };
    }

    setGridSelection(newVal, false);
  }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);
  return [setCurrent, setSelectedRows, setSelectedColumns];
}



function useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortController) {
  const getCellsForSelectionDirectWhenValid = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {
    var _a;

    if (getCellsForSelectionIn === true) {
      const result = [];

      for (let y = rect.y; y < rect.y + rect.height; y++) {
        const row = [];

        for (let x = rect.x; x < rect.x + rect.width; x++) {
          if (x < 0) {
            row.push({
              kind: GridCellKind.Loading,
              allowOverlay: false
            });
          } else {
            row.push(getCellContent([x, y]));
          }
        }

        result.push(row);
      }

      return result;
    }

    return (_a = getCellsForSelectionIn == null ? void 0 : getCellsForSelectionIn(rect, abortController.signal)) != null ? _a : [];
  }, [abortController.signal, getCellContent, getCellsForSelectionIn]);
  const getCellsForSelectionDirect = getCellsForSelectionIn !== void 0 ? getCellsForSelectionDirectWhenValid : void 0;
  const getCellsForSelectionMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {
    if (getCellsForSelectionDirect === void 0) return [];
    const newRect = { ...rect,
      x: rect.x - rowMarkerOffset
    };

    if (newRect.x < 0) {
      newRect.x = 0;
      newRect.width--;
      const r = getCellsForSelectionDirect(newRect, abortController.signal);

      if (typeof r === "function") {
        return async () => (await r()).map(row => [{
          kind: GridCellKind.Loading,
          allowOverlay: false
        }, ...row]);
      }

      return r.map(row => [{
        kind: GridCellKind.Loading,
        allowOverlay: false
      }, ...row]);
    }

    return getCellsForSelectionDirect(newRect, abortController.signal);
  }, [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]);
  const getCellsForSelection = getCellsForSelectionIn !== void 0 ? getCellsForSelectionMangled : void 0;
  return [getCellsForSelection, getCellsForSelectionDirect];
}

function expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortController) {
  var _a, _b;

  const origVal = newVal;
  if (spanRangeBehavior === "allowPartial" || newVal.current === void 0) return newVal;

  if (getCellsForSelection !== void 0) {
    let isFilled = false;

    do {
      if ((newVal == null ? void 0 : newVal.current) === void 0) break;
      const r = (_a = newVal.current) == null ? void 0 : _a.range;
      const cells = [];

      if (r.width > 2) {
        const leftCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof leftCells === "function") {
          return origVal;
        }

        cells.push(...leftCells);
        const rightCells = getCellsForSelection({
          x: r.x + r.width - 1,
          y: r.y,
          width: 1,
          height: r.height
        }, abortController.signal);

        if (typeof rightCells === "function") {
          return origVal;
        }

        cells.push(...rightCells);
      } else {
        const rCells = getCellsForSelection({
          x: r.x,
          y: r.y,
          width: r.width,
          height: r.height
        }, abortController.signal);

        if (typeof rCells === "function") {
          return origVal;
        }

        cells.push(...rCells);
      }

      let left = r.x - rowMarkerOffset;
      let right = r.x + r.width - 1 - rowMarkerOffset;

      for (const row of cells) {
        for (const cell of row) {
          if (cell.span === void 0) continue;
          left = Math.min(cell.span[0], left);
          right = Math.max(cell.span[1], right);
        }
      }

      if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {
        isFilled = true;
      } else {
        newVal = {
          current: {
            cell: (_b = newVal.current.cell) != null ? _b : [0, 0],
            range: {
              x: left + rowMarkerOffset,
              y: r.y,
              width: right - left + 1,
              height: r.height
            },
            rangeStack: newVal.current.rangeStack
          },
          columns: newVal.columns,
          rows: newVal.rows
        };
      }
    } while (!isFilled);
  }

  return newVal;
}

function descape(s) {
  if (s.startsWith('"') && s.endsWith('"')) {
    s = s.slice(1, -1).replace(/""/g, '"');
  }

  return s;
}

function unquote(str) {
  var State;

  (function (State2) {
    State2[State2["None"] = 0] = "None";
    State2[State2["inString"] = 1] = "inString";
    State2[State2["inStringPostQuote"] = 2] = "inStringPostQuote";
  })(State || (State = {}));

  const result = [];
  let current = [];
  let start = 0;
  let state = 0;
  str = str.replace(/\r\n/g, "\n");
  let index = 0;

  for (const char of str) {
    switch (state) {
      case 0:
        if (char === "	" || char === "\n") {
          current.push(str.slice(start, index));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }
        } else if (char === `"`) {
          state = 1;
        }

        break;

      case 1:
        if (char === `"`) {
          state = 2;
        }

        break;

      case 2:
        if (char === '"') {
          state = 1;
        } else if (char === "	" || char === "\n") {
          current.push(descape(str.slice(start, index)));
          start = index + 1;

          if (char === "\n") {
            result.push(current);
            current = [];
          }

          state = 0;
        } else {
          state = 0;
        }

        break;
    }

    index++;
  }

  if (start < str.length) {
    current.push(descape(str.slice(start, str.length)));
  }

  result.push(current);
  return result;
}

function decodeHTML(tableEl) {
  var _a, _b;

  const walkEl = [tableEl];
  const result = [];
  let current;

  while (walkEl.length > 0) {
    const el = walkEl.pop();
    if (el === void 0) break;

    if (el instanceof HTMLTableElement || el.nodeName === "TBODY") {
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableRowElement) {
      if (current !== void 0) {
        result.push(current);
      }

      current = [];
      walkEl.push(...[...el.children].reverse());
    } else if (el instanceof HTMLTableCellElement) {
      current == null ? void 0 : current.push((_b = (_a = el.innerText) != null ? _a : el.textContent) != null ? _b : "");
    }
  }

  if (current !== void 0) {
    result.push(current);
  }

  return result;
}

function escape(str) {
  if (/[\t\n"]/.test(str)) {
    str = `"${str.replace(/"/g, '""')}"`;
  }

  return str;
}

var formatBoolean = val => {
  switch (val) {
    case true:
      return "TRUE";

    case false:
      return "FALSE";

    case BooleanIndeterminate:
      return "INDETERMINATE";

    case BooleanEmpty:
      return "";

    default:
      assertNever(val);
  }
};

function copyToClipboard(cells, columnIndexes, e) {
  var _a, _b, _c, _d;

  const formatCell = (cell, index, raw) => {
    var _a2, _b2;

    const colIndex = columnIndexes[index];
    if (cell.span !== void 0 && cell.span[0] !== colIndex) return "";

    switch (cell.kind) {
      case GridCellKind.Text:
      case GridCellKind.Number:
        return escape(raw ? (_b2 = (_a2 = cell.data) == null ? void 0 : _a2.toString()) != null ? _b2 : "" : cell.displayData);

      case GridCellKind.Markdown:
      case GridCellKind.RowID:
      case GridCellKind.Uri:
        return escape(cell.data);

      case GridCellKind.Image:
      case GridCellKind.Bubble:
        return cell.data.reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);

      case GridCellKind.Boolean:
        return formatBoolean(cell.data);

      case GridCellKind.Loading:
        return raw ? "" : "#LOADING";

      case GridCellKind.Protected:
        return raw ? "" : "************";

      case GridCellKind.Drilldown:
        return cell.data.map(i => i.text).reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);

      case GridCellKind.Custom:
        return escape(cell.copyData);

      default:
        assertNever(cell);
    }
  };

  const str = cells.map(row => row.map((a, b) => formatCell(a, b, false)).join("	")).join("\n");

  if (((_a = window.navigator.clipboard) == null ? void 0 : _a.write) !== void 0 || e !== void 0) {
    const rootEl = document.createElement("tbody");

    for (const row of cells) {
      const rowEl = document.createElement("tr");

      for (const [i, cell] of row.entries()) {
        const cellEl = document.createElement("td");

        if (cell.kind === GridCellKind.Uri) {
          const link = document.createElement("a");
          link.href = cell.data;
          link.innerText = cell.data;
          cellEl.append(link);
        } else {
          cellEl.innerText = formatCell(cell, i, true);
        }

        rowEl.append(cellEl);
      }

      rootEl.append(rowEl);
    }

    if (((_b = window.navigator.clipboard) == null ? void 0 : _b.write) !== void 0) {
      void window.navigator.clipboard.write([new ClipboardItem({
        "text/plain": new Blob([str], {
          type: "text/plain"
        }),
        "text/html": new Blob([`<table>${rootEl.outerHTML}</table>`], {
          type: "text/html"
        })
      })]);
    } else if (e !== void 0 && (e == null ? void 0 : e.clipboardData) !== null) {
      try {
        e.clipboardData.setData("text/plain", str);
        e.clipboardData.setData("text/html", `<table>${rootEl.outerHTML}</table>`);
      } catch (e2) {
        void ((_c = window.navigator.clipboard) == null ? void 0 : _c.writeText(str));
      }
    }
  } else {
    void ((_d = window.navigator.clipboard) == null ? void 0 : _d.writeText(str));
  }

  e == null ? void 0 : e.preventDefault();
}



function toCss(x) {
  if (typeof x === "string") return x;
  return `${x}px`;
}

var Wrapper = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "Wrapper",
  class: "wzg2m5k",
  vars: {
    "wzg2m5k-0": [p => p.innerWidth],
    "wzg2m5k-1": [p => p.innerHeight]
  }
});

var DataEditorContainer = p => {
  const {
    inWidth,
    inHeight,
    children,
    ...rest
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, {
    innerHeight: toCss(inHeight),
    innerWidth: toCss(inWidth),
    ...rest
  }, children);
};

function toggleBoolean(data) {
  return data !== true;
}

var booleanCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "false";
  },
  kind: GridCellKind.Boolean,
  needsHover: true,
  useLabel: false,
  needsHoverPosition: true,
  measure: () => 50,
  draw: a => drawBoolean(a, a.cell.data, booleanCellIsEditable(a.cell)),
  onDelete: c => ({ ...c,
    data: false
  }),
  onClick: e => {
    const {
      cell,
      posX: x,
      posY: y,
      bounds
    } = e;

    if (booleanCellIsEditable(cell) && Math.abs(x - bounds.width / 2) <= bounds.height / 3.4 && Math.abs(y - bounds.height / 2) <= bounds.height / 3.4) {
      return { ...cell,
        data: toggleBoolean(cell.data)
      };
    }

    return void 0;
  },
  onPaste: (toPaste, cell) => {
    let newVal = BooleanEmpty;

    if (toPaste.toLowerCase() === "true") {
      newVal = true;
    } else if (toPaste.toLowerCase() === "false") {
      newVal = false;
    } else if (toPaste.toLowerCase() === "indeterminate") {
      newVal = BooleanIndeterminate;
    }

    return newVal === cell.data ? void 0 : { ...cell,
      data: newVal
    };
  }
};

var maxPxPerMs = 2;
var msToFullSpeed = 1300;

function useAutoscroll(scrollDirection, scrollRef) {
  const speedScalar = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
  const [xDir, yDir] = scrollDirection != null ? scrollDirection : [0, 0];
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (xDir === 0 && yDir === 0) {
      speedScalar.current = 0;
      return;
    }

    let lastTime = 0;

    const scrollFn = curTime => {
      var _a;

      if (lastTime === 0) {
        lastTime = curTime;
      } else {
        const step = curTime - lastTime;
        speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);
        const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;
        (_a = scrollRef.current) == null ? void 0 : _a.scrollBy(xDir * motion, yDir * motion);
        lastTime = curTime;
      }

      t = window.requestAnimationFrame(scrollFn);
    };

    let t = window.requestAnimationFrame(scrollFn);
    return () => window.cancelAnimationFrame(t);
  }, [scrollRef, xDir, yDir]);
}



var BubblesOverlayEditorStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "BubblesOverlayEditorStyle",
  class: "b1bqsp5z"
});

var BubblesOverlayEditor = p => {
  const {
    bubbles
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(BubblesOverlayEditorStyle, null, bubbles.map((b, i) => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: i,
    className: "boe-bubble"
  }, b)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

var bubbles_overlay_editor_default = BubblesOverlayEditor;
var bubbleCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Bubble,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => drawBubbles(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(bubbles_overlay_editor_default, {
      bubbles: value.data
    });
  },
  onPaste: () => void 0
};


var DrilldownOverlayEditorStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "DrilldownOverlayEditorStyle",
  class: "df2kt4a"
});

var DrilldownOverlayEditor = p => {
  const {
    drilldowns
  } = p;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    key: i,
    className: "doe-bubble"
  }, d.img !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
    src: d.img
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, d.text))));
};

var drilldown_overlay_editor_default = DrilldownOverlayEditor;
var drilldownCellRenderer = {
  getAccessibilityString: c => c.data.map(d => d.text).join(", "),
  kind: GridCellKind.Drilldown,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== void 0 ? 18 : 0), 0) + 2 * t.cellHorizontalPadding - 4,
  draw: a => drawDrilldownCell(a, a.cell.data),
  provideEditor: () => p => {
    const {
      value
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(drilldown_overlay_editor_default, {
      drilldowns: value.data
    });
  },
  onPaste: () => void 0
};


var ImageOverlayEditorStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "ImageOverlayEditorStyle",
  class: "i1eozt10"
});


var ImageOverlayEditor = p => {
  const {
    urls,
    canWrite,
    onEditClick,
    renderImage
  } = p;
  const filtered = urls.filter(u => u !== "");

  if (filtered.length === 0) {
    return null;
  }

  const allowMove = filtered.length > 1;
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImageOverlayEditorStyle, {
    "data-testid": "GDG-default-image-overlay-editor"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_responsive_carousel__WEBPACK_IMPORTED_MODULE_12__/* .Carousel */ .lr, {
    showArrows: allowMove,
    showThumbs: false,
    swipeable: allowMove,
    emulateTouch: allowMove,
    infiniteLoop: allowMove
  }, filtered.map(url => {
    var _a;

    const innerContent = (_a = renderImage == null ? void 0 : renderImage(url)) != null ? _a : react__WEBPACK_IMPORTED_MODULE_0__.createElement("img", {
      draggable: false,
      src: url
    });
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "centering-container",
      key: url
    }, innerContent);
  })), canWrite && onEditClick && react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    className: "edit-icon",
    onClick: onEditClick
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null)));
};

var imageCellRenderer = {
  getAccessibilityString: c => c.data.join(", "),
  kind: GridCellKind.Image,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  draw: a => {
    var _a;

    return drawImage(a, (_a = a.cell.displayData) != null ? _a : a.cell.data, a.cell.rounding);
  },
  measure: (_ctx, cell) => cell.data.length * 50,
  onDelete: c => ({ ...c,
    data: []
  }),
  provideEditor: () => p => {
    const {
      value,
      onFinishedEditing,
      imageEditorOverride
    } = p;
    const ImageEditor = imageEditorOverride != null ? imageEditorOverride : ImageOverlayEditor;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImageEditor, {
      urls: value.data,
      canWrite: value.allowAdd,
      onCancel: onFinishedEditing,
      onChange: newImage => {
        onFinishedEditing({ ...value,
          data: [newImage]
        });
      }
    });
  },
  onPaste: (toPaste, cell) => {
    toPaste = toPaste.trim();
    const fragments = toPaste.split(",");
    const uris = fragments.map(f => {
      try {
        new URL(f);
        return f;
      } catch (e) {
        return void 0;
      }
    }).filter(x => x !== void 0);
    if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i])) return void 0;
    return { ...cell,
      data: uris
    };
  }
};
var loadingCellRenderer = {
  getAccessibilityString: () => "",
  kind: GridCellKind.Loading,
  needsHover: false,
  useLabel: false,
  needsHoverPosition: false,
  measure: () => 120,
  draw: () => void 0,
  onPaste: () => void 0
};




var MarkdownContainer = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "MarkdownContainer",
  class: "mlbeo71"
});
var MarkdownDiv = class extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor() {
    super(...arguments);
    this.targetElement = null;

    this.containerRefHook = element => {
      this.targetElement = element;
      this.renderMarkdownIntoDiv();
    };
  }

  renderMarkdownIntoDiv() {
    const {
      targetElement,
      props
    } = this;
    if (targetElement === null) return;
    const {
      contents,
      createNode
    } = props;
    const innerHTML = (0,marked__WEBPACK_IMPORTED_MODULE_13__/* .marked */ .TU)(contents);
    const childRange = document.createRange();
    childRange.selectNodeContents(targetElement);
    childRange.deleteContents();
    let newChild = createNode == null ? void 0 : createNode(innerHTML);

    if (newChild === void 0) {
      const childDoc = document.createElement("template");
      childDoc.innerHTML = innerHTML;
      newChild = childDoc.content;
    }

    targetElement.append(newChild);
    const tags = targetElement.getElementsByTagName("a");

    for (const tag of tags) {
      tag.target = "_blank";
      tag.rel = "noreferrer noopener";
    }
  }

  render() {
    this.renderMarkdownIntoDiv();
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownContainer, {
      ref: this.containerRefHook
    });
  }

};

var InputBox = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("textarea")({
  name: "InputBox",
  class: "ijuk0po"
});
var ShadowBox = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "ShadowBox",
  class: "saq3p5l"
});
var GrowingEntryStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "GrowingEntryStyle",
  class: "gf8vzix"
});

var GrowingEntry = props => {
  const {
    placeholder,
    value,
    onKeyDown,
    highlight,
    altNewline,
    validatedSelection,
    ...rest
  } = props;
  const {
    onChange,
    className
  } = rest;
  const inputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const useText = value != null ? value : "";
  assert(onChange !== void 0, "GrowingEntry must be a controlled input area");
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    const ta = inputRef.current;
    if (ta === null) return;
    if (ta.disabled) return;
    const length = useText.toString().length;
    ta.focus();
    ta.setSelectionRange(highlight ? 0 : length, length);
  }, []);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    var _a;

    if (validatedSelection !== void 0) {
      const range2 = typeof validatedSelection === "number" ? [validatedSelection, null] : validatedSelection;
      (_a = inputRef.current) == null ? void 0 : _a.setSelectionRange(range2[0], range2[1]);
    }
  }, [validatedSelection]);
  const onKeyDownInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {
    if (e.key === "Enter" && e.shiftKey && altNewline === true) {
      return;
    }

    onKeyDown == null ? void 0 : onKeyDown(e);
  }, [altNewline, onKeyDown]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntryStyle, {
    className: "gdg-growing-entry"
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(ShadowBox, {
    className
  }, useText + "\n"), react__WEBPACK_IMPORTED_MODULE_0__.createElement(InputBox, { ...rest,
    className: (className != null ? className : "") + " gdg-input",
    ref: inputRef,
    onKeyDown: onKeyDownInner,
    value: useText,
    placeholder,
    dir: "auto"
  }));
};

var MarkdownOverlayEditorStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "MarkdownOverlayEditorStyle",
  class: "mdwzdl1",
  vars: {
    "mdwzdl1-0": [p => p.targetWidth, "px"]
  }
});

var MarkdownOverlayEditor = p => {
  const {
    markdown,
    onChange,
    forceEditMode,
    createNode,
    targetRect,
    readonly,
    onFinish,
    validatedSelection
  } = p;
  const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(markdown === "" || forceEditMode);
  const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setEditMode(e => !e);
  }, []);
  const addLeftPad = markdown ? "ml-6" : "";

  if (editMode) {
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditorStyle, {
      targetWidth: targetRect.width - 20
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      autoFocus: true,
      highlight: false,
      validatedSelection,
      value: markdown,
      onKeyDown: e => {
        if (e.key === "Enter") e.stopPropagation();
      },
      onChange
    }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: `edit-icon checkmark-hover ${addLeftPad}`,
      onClick: () => onFinish()
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Checkmark, null)));
  }

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditorStyle, {
    targetWidth: targetRect.width
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownDiv, {
    contents: markdown,
    createNode
  }), !readonly && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "spacer"
  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: `edit-icon edit-hover ${addLeftPad}`,
    onClick: onEditClick
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null))), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "md-edit-textarea gdg-input",
    autoFocus: true
  }));
};

var markdownCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Markdown,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: prepTextCell,
  measure: (ctx, cell, t) => {
    const firstLine = cell.data.split("\n")[0];
    return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;
  },
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      target,
      onFinishedEditing,
      markdownDivCreateNode,
      forceEditMode,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkdownOverlayEditor, {
      onFinish: onFinishedEditing,
      targetRect: target,
      readonly: value.readonly === true,
      markdown: value.data,
      validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      }),
      forceEditMode,
      createNode: markdownDivCreateNode
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : { ...cell,
    data: toPaste
  }
};
var markerCellRenderer = {
  getAccessibilityString: c => c.row.toString(),
  kind: InnerGridCellKind.Marker,
  needsHover: true,
  needsHoverPosition: false,
  drawPrep: prepMarkerRowCell,
  measure: () => 44,
  draw: a => drawMarkerRowCell(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle),
  onClick: e => {
    const {
      bounds,
      cell,
      posX: x,
      posY: y
    } = e;
    const {
      width,
      height
    } = bounds;
    const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;
    const centerY = height / 2;

    if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {
      return { ...cell,
        checked: !cell.checked
      };
    }

    return void 0;
  },
  onPaste: () => void 0
};
var newRowCellRenderer = {
  getAccessibilityString: () => "",
  kind: InnerGridCellKind.NewRow,
  needsHover: true,
  needsHoverPosition: false,
  measure: () => 200,
  draw: a => drawNewRowCell(a, a.cell.hint, a.cell.icon),
  onPaste: () => void 0
};

var NumberOverlayEditor = react__WEBPACK_IMPORTED_MODULE_0__.lazy(async () => await Promise.all(/* import() */[__webpack_require__.e(333), __webpack_require__.e(636)]).then(__webpack_require__.bind(__webpack_require__, "./packages/core/dist/js/number-overlay-editor-XTHZJK22.js")));
var numberCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Number,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: prepTextCell,
  draw: a => drawTextCell(a, a.cell.displayData, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.displayData).width + 16,
  onDelete: c => ({ ...c,
    data: void 0
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
      fallback: null
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(NumberOverlayEditor, {
      highlight: isHighlighted,
      disabled: value.readonly === true,
      value: value.data,
      validatedSelection,
      onChange: x => {
        var _a;

        return onChange({ ...value,
          data: Number.isNaN((_a = x.floatValue) != null ? _a : 0) ? 0 : x.floatValue
        });
      }
    }));
  },
  onPaste: (toPaste, cell) => {
    const newNumber = Number.parseFloat(toPaste);
    if (Number.isNaN(newNumber) || cell.data === newNumber) return void 0;
    return { ...cell,
      data: newNumber
    };
  }
};
var protectedCellRenderer = {
  getAccessibilityString: () => "",
  measure: () => 108,
  kind: GridCellKind.Protected,
  needsHover: false,
  needsHoverPosition: false,
  draw: drawProtectedCell,
  onPaste: () => void 0
};

var rowIDCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.RowID,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: (a, b) => prepTextCell(a, b, a.theme.textLight),
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly !== false,
      value: value.data,
      validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: () => void 0
};

var textCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Text,
  needsHover: false,
  needsHoverPosition: false,
  drawPrep: prepTextCell,
  useLabel: true,
  draw: a => (drawTextCell(a, a.cell.displayData, a.cell.contentAlign, a.cell.allowWrapping, a.hyperWrapping), true),
  measure: (ctx, cell, t) => {
    const lines = cell.displayData.split("\n").slice(0, cell.allowWrapping === true ? void 0 : 1);
    return Math.max(...lines.map(l => ctx.measureText(l).width + 2 * t.cellHorizontalPadding));
  },
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      isHighlighted,
      onChange,
      value,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      highlight: isHighlighted,
      autoFocus: value.readonly !== true,
      disabled: value.readonly === true,
      altNewline: true,
      value: value.data,
      validatedSelection,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : { ...cell,
    data: toPaste
  }
};


var UriOverlayEditorStyle = (0,_chunk_TRLYFRER_js__WEBPACK_IMPORTED_MODULE_8__/* .styled_default */ .d)("div")({
  name: "UriOverlayEditorStyle",
  class: "uf0sjo8"
});

var UriOverlayEditor = p => {
  const {
    uri,
    onChange,
    forceEditMode,
    readonly,
    validatedSelection
  } = p;
  const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(uri === "" || forceEditMode);
  const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setEditMode(true);
  }, []);

  if (editMode) {
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GrowingEntry, {
      validatedSelection,
      highlight: true,
      autoFocus: true,
      value: uri,
      onChange
    });
  }

  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(UriOverlayEditorStyle, null, react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "link-area",
    href: uri,
    target: "_blank",
    rel: "noopener noreferrer"
  }, uri), !readonly && react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "edit-icon",
    onClick: onEditClick
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditPencil, null)), react__WEBPACK_IMPORTED_MODULE_0__.createElement("textarea", {
    className: "gdg-input",
    autoFocus: true
  }));
};

var uri_overlay_editor_default = UriOverlayEditor;
var uriCellRenderer = {
  getAccessibilityString: c => {
    var _a, _b;

    return (_b = (_a = c.data) == null ? void 0 : _a.toString()) != null ? _b : "";
  },
  kind: GridCellKind.Uri,
  needsHover: false,
  needsHoverPosition: false,
  useLabel: true,
  drawPrep: prepTextCell,
  draw: a => drawTextCell(a, a.cell.data, a.cell.contentAlign),
  measure: (ctx, cell) => ctx.measureText(cell.data).width + 16,
  onDelete: c => ({ ...c,
    data: ""
  }),
  provideEditor: () => p => {
    const {
      onChange,
      value,
      forceEditMode,
      validatedSelection
    } = p;
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(uri_overlay_editor_default, {
      forceEditMode,
      uri: value.data,
      validatedSelection,
      readonly: value.readonly === true,
      onChange: e => onChange({ ...value,
        data: e.target.value
      })
    });
  },
  onPaste: (toPaste, cell) => toPaste === cell.data ? void 0 : { ...cell,
    data: toPaste
  }
};
var CellRenderers = {
  [InnerGridCellKind.Marker]: markerCellRenderer,
  [InnerGridCellKind.NewRow]: newRowCellRenderer,
  [GridCellKind.Boolean]: booleanCellRenderer,
  [GridCellKind.Bubble]: bubbleCellRenderer,
  [GridCellKind.Drilldown]: drilldownCellRenderer,
  [GridCellKind.Image]: imageCellRenderer,
  [GridCellKind.Loading]: loadingCellRenderer,
  [GridCellKind.Markdown]: markdownCellRenderer,
  [GridCellKind.Number]: numberCellRenderer,
  [GridCellKind.Protected]: protectedCellRenderer,
  [GridCellKind.RowID]: rowIDCellRenderer,
  [GridCellKind.Text]: textCellRenderer,
  [GridCellKind.Uri]: uriCellRenderer
};
var idCounter = 0;

function getSpanStops(cells) {
  return lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(cells).filter(c => c.span !== void 0).map(c => {
    var _a, _b, _c, _d;

    return lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(((_b = (_a = c.span) == null ? void 0 : _a[0]) != null ? _b : 0) + 1, ((_d = (_c = c.span) == null ? void 0 : _c[1]) != null ? _d : 0) + 1);
  })));
}

function shiftSelection(input, offset) {
  if (input === void 0 || offset === 0 || input.columns.length === 0 && input.current === void 0) return input;
  return {
    current: input.current === void 0 ? void 0 : {
      cell: [input.current.cell[0] + offset, input.current.cell[1]],
      range: { ...input.current.range,
        x: input.current.range.x + offset
      },
      rangeStack: input.current.rangeStack.map(r => ({ ...r,
        x: r.x + offset
      }))
    },
    rows: input.rows,
    columns: input.columns.offset(offset)
  };
}

var keybindingDefaults = {
  selectAll: true,
  selectRow: true,
  selectColumn: true,
  downFill: false,
  rightFill: false,
  pageUp: false,
  pageDown: false,
  clear: true,
  copy: true,
  paste: true,
  search: false,
  first: true,
  last: true
};
var loadingCell2 = {
  kind: GridCellKind.Loading,
  allowOverlay: false
};
var emptyGridSelection = {
  columns: CompactSelection.empty(),
  rows: CompactSelection.empty(),
  current: void 0
};

var DataEditorImpl = (p, forwardedRef) => {
  var _a, _b, _c, _d, _e;

  const [gridSelectionInner, setGridSelectionInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(emptyGridSelection);
  const [overlay, setOverlay] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const searchInputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const canvasRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const [mouseState, setMouseState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const scrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const lastSent = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const {
    rowMarkers = "none",
    rowHeight = 34,
    headerHeight = 36,
    rowMarkerWidth: rowMarkerWidthRaw,
    imageEditorOverride,
    getRowThemeOverride,
    markdownDivCreateNode
  } = p;
  const {
    width,
    height,
    columns: columnsIn,
    rows,
    getCellContent,
    onCellClicked,
    onCellActivated,
    onFinishedEditing,
    coercePasteValue,
    drawHeader: drawHeaderIn,
    onHeaderClicked,
    spanRangeBehavior = "default",
    onGroupHeaderClicked,
    onCellContextMenu,
    className,
    theme,
    onHeaderContextMenu,
    getCellsForSelection: getCellsForSelectionIn,
    onGroupHeaderContextMenu,
    onGroupHeaderRenamed,
    onCellEdited,
    onCellsEdited,
    onKeyDown: onKeyDownIn,
    onKeyUp: onKeyUpIn,
    keybindings: keybindingsIn,
    onRowAppended,
    onColumnMoved,
    validateCell: validateCellIn,
    highlightRegions: highlightRegionsIn,
    drawCell: drawCell2,
    rangeSelect = "rect",
    columnSelect = "multi",
    rowSelect = "multi",
    rangeSelectionBlending = "exclusive",
    columnSelectionBlending = "exclusive",
    rowSelectionBlending = "exclusive",
    onDelete: onDeleteIn,
    onDragStart,
    onMouseMove,
    onPaste,
    groupHeaderHeight = headerHeight,
    freezeColumns = 0,
    rowSelectionMode = "auto",
    rowMarkerStartIndex = 1,
    onHeaderMenuClick,
    getGroupDetails,
    onSearchClose: onSearchCloseIn,
    onItemHovered,
    onSelectionCleared,
    showSearch: showSearchIn,
    onVisibleRegionChanged,
    gridSelection: gridSelectionOuter,
    onGridSelectionChange,
    minColumnWidth: minColumnWidthIn = 50,
    maxColumnWidth: maxColumnWidthIn = 500,
    maxColumnAutoWidth: maxColumnAutoWidthIn,
    provideEditor,
    trailingRowOptions,
    scrollOffsetX,
    scrollOffsetY,
    verticalBorder,
    onDragOverCell,
    onDrop,
    onColumnResize: onColumnResizeIn,
    onColumnResizeEnd: onColumnResizeEndIn,
    onColumnResizeStart: onColumnResizeStartIn,
    customRenderers: additionalRenderers,
    fillHandle,
    drawFocusRing: drawFocusRing2,
    experimental,
    fixedShadowX,
    fixedShadowY,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX,
    overscrollY,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    scrollToEnd
  } = p;
  const minColumnWidth = Math.max(minColumnWidthIn, 20);
  const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);
  const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn != null ? maxColumnAutoWidthIn : maxColumnWidth, minColumnWidth);
  const keybindings = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return keybindingsIn === void 0 ? keybindingDefaults : { ...keybindingDefaults,
      ...keybindingsIn
    };
  }, [keybindingsIn]);
  const rowMarkerWidth = rowMarkerWidthRaw != null ? rowMarkerWidthRaw : rows > 1e4 ? 48 : rows > 1e3 ? 44 : rows > 100 ? 36 : 32;
  const hasRowMarkers = rowMarkers !== "none";
  const rowMarkerOffset = hasRowMarkers ? 1 : 0;
  const showTrailingBlankRow = onRowAppended !== void 0;
  const lastRowSticky = (trailingRowOptions == null ? void 0 : trailingRowOptions.sticky) === true;
  const [showSearchInner, setShowSearchInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const showSearch = showSearchIn != null ? showSearchIn : showSearchInner;
  const onSearchClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (onSearchCloseIn !== void 0) {
      onSearchCloseIn();
    } else {
      setShowSearchInner(false);
    }
  }, [onSearchCloseIn]);
  const gridSelectionOuterMangled = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return gridSelectionOuter === void 0 ? void 0 : shiftSelection(gridSelectionOuter, rowMarkerOffset);
  }, [gridSelectionOuter, rowMarkerOffset]);
  const gridSelection = gridSelectionOuterMangled != null ? gridSelectionOuterMangled : gridSelectionInner;
  const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new AbortController());
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => {
      abortControllerRef == null ? void 0 : abortControllerRef.current.abort();
    };
  }, []);
  const [getCellsForSelection, getCellsForSeletionDirect] = useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortControllerRef.current);
  const validateCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue, prevValue) => {
    if (validateCellIn === void 0) return true;
    const item = [cell[0] - rowMarkerOffset, cell[1]];
    return validateCellIn == null ? void 0 : validateCellIn(item, newValue, prevValue);
  }, [rowMarkerOffset, validateCellIn]);
  const expectedExternalGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useRef(gridSelectionOuter);
  const setGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal, expand) => {
    if (expand) {
      newVal = expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortControllerRef.current);
    }

    if (onGridSelectionChange !== void 0) {
      expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);
      onGridSelectionChange(expectedExternalGridSelection.current);
    } else {
      setGridSelectionInner(newVal);
    }
  }, [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]);
  const onColumnResize = whenDefined(onColumnResizeIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeIn == null ? void 0 : onColumnResizeIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeEnd = whenDefined(onColumnResizeEndIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeEndIn == null ? void 0 : onColumnResizeEndIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeEndIn, rowMarkerOffset, columnsIn]));
  const onColumnResizeStart = whenDefined(onColumnResizeStartIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {
    onColumnResizeStartIn == null ? void 0 : onColumnResizeStartIn(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);
  }, [onColumnResizeStartIn, rowMarkerOffset, columnsIn]));
  const drawHeader2 = whenDefined(drawHeaderIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2;

    return (_a2 = drawHeaderIn == null ? void 0 : drawHeaderIn({ ...args,
      columnIndex: args.columnIndex - rowMarkerOffset
    })) != null ? _a2 : false;
  }, [drawHeaderIn, rowMarkerOffset]));
  const onDelete = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(sel => {
    if (onDeleteIn !== void 0) {
      const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));

      if (typeof result === "boolean") {
        return result;
      }

      return shiftSelection(result, rowMarkerOffset);
    }

    return true;
  }, [onDeleteIn, rowMarkerOffset]);
  const [setCurrent, setSelectedRows, setSelectedColumns] = useSelectionBehavior(gridSelection, setGridSelection, rangeSelectionBlending, columnSelectionBlending, rowSelectionBlending, rangeSelect);
  const mergedTheme = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return { ...getDataEditorTheme(),
      ...theme
    };
  }, [theme]);
  const [clientSize, setClientSize] = react__WEBPACK_IMPORTED_MODULE_0__.useState([10, 10, 0]);
  const getCellRenderer = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    if (cell.kind !== GridCellKind.Custom) {
      return CellRenderers[cell.kind];
    }

    return additionalRenderers == null ? void 0 : additionalRenderers.find(x => x.isMatch(cell));
  }, [additionalRenderers]);
  const columns = useColumnSizer(columnsIn, rows, getCellsForSeletionDirect, clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2], minColumnWidth, maxColumnAutoWidth, mergedTheme, getCellRenderer, abortControllerRef.current);
  const enableGroups = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return columns.some(c => c.group !== void 0);
  }, [columns]);
  const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;
  const numSelectedRows = gridSelection.rows.length;
  const rowMarkerHeader = rowMarkers === "none" ? "" : numSelectedRows === 0 ? headerCellUnheckedMarker : numSelectedRows === rows ? headerCellCheckedMarker : headerCellIndeterminateMarker;
  const mangledCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (rowMarkers === "none") return columns;
    return [{
      title: rowMarkerHeader,
      width: rowMarkerWidth,
      icon: void 0,
      hasMenu: false,
      style: "normal"
    }, ...columns];
  }, [columns, rowMarkerWidth, rowMarkers, rowMarkerHeader]);
  const [visibleRegionY, visibleRegionTy] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return [scrollOffsetY !== void 0 && typeof rowHeight === "number" ? Math.floor(scrollOffsetY / rowHeight) : 0, scrollOffsetY !== void 0 && typeof rowHeight === "number" ? -(scrollOffsetY % rowHeight) : 0];
  }, [scrollOffsetY, rowHeight]);
  const visibleRegionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
    height: 1,
    width: 1,
    x: 0,
    y: 0
  });
  const visibleRegionInput = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2, _b2;

    return {
      x: visibleRegionRef.current.x,
      y: visibleRegionY,
      width: (_a2 = visibleRegionRef.current.width) != null ? _a2 : 1,
      height: (_b2 = visibleRegionRef.current.height) != null ? _b2 : 1,
      ty: visibleRegionTy
    };
  }, [visibleRegionTy, visibleRegionY]);
  const hasJustScrolled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const [visibleRegion, setVisibleRegion, empty2] = useStateWithReactiveInput(visibleRegionInput);
  visibleRegionRef.current = visibleRegion;
  const vScrollReady = ((_a = visibleRegion.height) != null ? _a : 1) > 1;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (scrollOffsetY !== void 0 && scrollRef.current !== null && vScrollReady) {
      scrollRef.current.scrollTop = scrollOffsetY;

      if (scrollRef.current.scrollTop !== scrollOffsetY) {
        empty2();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetY, vScrollReady, empty2]);
  const hScrollReady = ((_b = visibleRegion.width) != null ? _b : 1) > 1;
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
    if (scrollOffsetX !== void 0 && scrollRef.current !== null && hScrollReady) {
      scrollRef.current.scrollLeft = scrollOffsetX;

      if (scrollRef.current.scrollLeft !== scrollOffsetX) {
        empty2();
      }

      hasJustScrolled.current = true;
    }
  }, [scrollOffsetX, hScrollReady, empty2]);
  const cellXOffset = visibleRegion.x + rowMarkerOffset;
  const cellYOffset = visibleRegion.y;
  const gridRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  const focus = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(immediate => {
    var _a2;

    if (immediate === true) {
      (_a2 = gridRef.current) == null ? void 0 : _a2.focus();
    } else {
      window.requestAnimationFrame(() => {
        var _a3;

        (_a3 = gridRef.current) == null ? void 0 : _a3.focus();
      });
    }
  }, []);
  const mangledRows = showTrailingBlankRow ? rows + 1 : rows;
  const mangledOnCellsEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(items => {
    const mangledItems = rowMarkerOffset === 0 ? items : items.map(x => ({ ...x,
      location: [x.location[0] - rowMarkerOffset, x.location[1]]
    }));
    const r = onCellsEdited == null ? void 0 : onCellsEdited(mangledItems);

    if (r !== true) {
      for (const i of mangledItems) onCellEdited == null ? void 0 : onCellEdited(i.location, i.value);
    }

    return r;
  }, [onCellEdited, onCellsEdited, rowMarkerOffset]);
  const highlightRegions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (highlightRegionsIn === void 0) return void 0;
    if (rowMarkerOffset === 0) return highlightRegionsIn;
    return highlightRegionsIn.map(r => {
      const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;
      if (maxWidth <= 0) return void 0;
      return {
        color: r.color,
        range: { ...r.range,
          x: r.range.x + rowMarkerOffset,
          width: Math.min(maxWidth, r.range.width)
        },
        style: r.style
      };
    }).filter(x => x !== void 0);
  }, [highlightRegionsIn, mangledCols.length, rowMarkerOffset]);
  const mangledColsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(mangledCols);
  mangledColsRef.current = mangledCols;
  const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {
    let [col, row] = _ref;

    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j;

    const isTrailing = showTrailingBlankRow && row === mangledRows - 1;
    const isRowMarkerCol = col === 0 && hasRowMarkers;

    if (isRowMarkerCol) {
      if (isTrailing) {
        return loadingCell2;
      }

      return {
        kind: InnerGridCellKind.Marker,
        allowOverlay: false,
        checked: (gridSelection == null ? void 0 : gridSelection.rows.hasIndex(row)) === true,
        markerKind: rowMarkers === "clickable-number" ? "number" : rowMarkers,
        row: rowMarkerStartIndex + row,
        drawHandle: onRowMoved !== void 0
      };
    } else if (isTrailing) {
      const isFirst = col === rowMarkerOffset;
      const maybeFirstColumnHint = isFirst ? (_a2 = trailingRowOptions == null ? void 0 : trailingRowOptions.hint) != null ? _a2 : "" : "";
      const c = mangledColsRef.current[col];

      if (((_b2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _b2.disabled) === true) {
        return loadingCell2;
      } else {
        const hint = (_d2 = (_c2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _c2.hint) != null ? _d2 : maybeFirstColumnHint;
        const icon = (_f = (_e2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _e2.addIcon) != null ? _f : trailingRowOptions == null ? void 0 : trailingRowOptions.addIcon;
        return {
          kind: InnerGridCellKind.NewRow,
          hint,
          allowOverlay: false,
          icon
        };
      }
    } else {
      const outerCol = col - rowMarkerOffset;

      if ((experimental == null ? void 0 : experimental.strict) === true) {
        const vr = visibleRegionRef.current;
        const isOutsideMainArea = vr.x > outerCol || outerCol > vr.x + vr.width || vr.y > row || row > vr.y + vr.height;
        const isSelected = outerCol === ((_h = (_g = vr.extras) == null ? void 0 : _g.selected) == null ? void 0 : _h[0]) && row === ((_i = vr.extras) == null ? void 0 : _i.selected[1]);
        const isOutsideFreezeArea = ((_j = vr.extras) == null ? void 0 : _j.freezeRegion) === void 0 || vr.extras.freezeRegion.x > outerCol || outerCol > vr.extras.freezeRegion.x + vr.extras.freezeRegion.width || vr.extras.freezeRegion.y > row || row > vr.extras.freezeRegion.y + vr.extras.freezeRegion.height;

        if (isOutsideMainArea && !isSelected && isOutsideFreezeArea) {
          return {
            kind: GridCellKind.Loading,
            allowOverlay: false
          };
        }
      }

      let result = getCellContent([outerCol, row]);

      if (rowMarkerOffset !== 0 && result.span !== void 0) {
        result = { ...result,
          span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset]
        };
      }

      return result;
    }
  }, [showTrailingBlankRow, mangledRows, hasRowMarkers, gridSelection == null ? void 0 : gridSelection.rows, onRowMoved, rowMarkers, rowMarkerOffset, trailingRowOptions == null ? void 0 : trailingRowOptions.hint, trailingRowOptions == null ? void 0 : trailingRowOptions.addIcon, experimental == null ? void 0 : experimental.strict, getCellContent, rowMarkerStartIndex]);
  const mangledGetGroupDetails = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(group => {
    var _a2, _b2;

    let result = (_a2 = getGroupDetails == null ? void 0 : getGroupDetails(group)) != null ? _a2 : {
      name: group
    };

    if (onGroupHeaderRenamed !== void 0 && group !== "") {
      result = {
        icon: result.icon,
        name: result.name,
        overrideTheme: result.overrideTheme,
        actions: [...((_b2 = result.actions) != null ? _b2 : []), {
          title: "Rename",
          icon: "renameIcon",
          onClick: e => setRenameGroup({
            group: result.name,
            bounds: e.bounds
          })
        }]
      };
    }

    return result;
  }, [getGroupDetails, onGroupHeaderRenamed]);
  const setOverlaySimple = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(val => {
    var _a2;

    const [col, row] = val.cell;
    const column = mangledCols[col];
    const groupTheme = (column == null ? void 0 : column.group) !== void 0 ? (_a2 = mangledGetGroupDetails(column.group)) == null ? void 0 : _a2.overrideTheme : void 0;
    const colTheme = column == null ? void 0 : column.themeOverride;
    const rowTheme = getRowThemeOverride == null ? void 0 : getRowThemeOverride(row);
    setOverlay({ ...val,
      theme: { ...mergedTheme,
        ...groupTheme,
        ...colTheme,
        ...rowTheme,
        ...val.content.themeOverride
      }
    });
  }, [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]);
  const reselect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((bounds, fromKeyboard, initialValue) => {
    var _a2;

    if (gridSelection.current === void 0) return;
    const [col, row] = gridSelection.current.cell;
    const c = getMangledCellContent([col, row]);

    if (c.kind !== GridCellKind.Boolean && c.allowOverlay) {
      let content = c;

      if (initialValue !== void 0) {
        switch (content.kind) {
          case GridCellKind.Number:
            {
              const d = maybe(() => initialValue === "-" ? -0 : Number.parseFloat(initialValue), 0);
              content = { ...content,
                data: Number.isNaN(d) ? 0 : d
              };
              break;
            }

          case GridCellKind.Text:
          case GridCellKind.Markdown:
          case GridCellKind.Uri:
            content = { ...content,
              data: initialValue
            };
            break;
        }
      }

      setOverlaySimple({
        target: bounds,
        content,
        initialValue,
        cell: [col, row],
        highlight: initialValue === void 0,
        forceEditMode: initialValue !== void 0
      });
    } else if (c.kind === GridCellKind.Boolean && fromKeyboard && c.readonly !== true) {
      mangledOnCellsEdited([{
        location: gridSelection.current.cell,
        value: { ...c,
          data: toggleBoolean(c.data)
        }
      }]);
      (_a2 = gridRef.current) == null ? void 0 : _a2.damage([{
        cell: gridSelection.current.cell
      }]);
    }
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]);
  const focusOnRowFromTrailingBlankRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row) => {
    var _a2;

    const bounds = (_a2 = gridRef.current) == null ? void 0 : _a2.getBounds(col, row);

    if (bounds === void 0 || scrollRef.current === null) {
      return;
    }

    const content = getMangledCellContent([col, row]);

    if (!content.allowOverlay) {
      return;
    }

    setOverlaySimple({
      target: bounds,
      content,
      initialValue: void 0,
      highlight: true,
      cell: [col, row],
      forceEditMode: true
    });
  }, [getMangledCellContent, setOverlaySimple]);
  const scrollTo = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (col, row) {
    let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "both";
    let paddingX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let paddingY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : void 0;

    var _a2;

    if (scrollRef.current !== null) {
      const grid = gridRef.current;
      const canvas = canvasRef.current;
      const trueCol = typeof col !== "number" ? col.unit === "cell" ? col.amount : void 0 : col;
      const trueRow = typeof row !== "number" ? row.unit === "cell" ? row.amount : void 0 : row;
      const desiredX = typeof col !== "number" && col.unit === "px" ? col.amount : void 0;
      const desiredY = typeof row !== "number" && row.unit === "px" ? row.amount : void 0;

      if (grid !== null && canvas !== null) {
        let targetRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        let scrollX = 0;
        let scrollY = 0;

        if (trueCol !== void 0 || trueRow !== void 0) {
          targetRect = (_a2 = grid.getBounds((trueCol != null ? trueCol : 0) + rowMarkerOffset, trueRow != null ? trueRow : 0)) != null ? _a2 : targetRect;
          if (targetRect.width === 0 || targetRect.height === 0) return;
        }

        const scrollBounds = canvas.getBoundingClientRect();

        if (desiredX !== void 0) {
          targetRect = { ...targetRect,
            x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,
            width: 1
          };
        }

        if (desiredY !== void 0) {
          targetRect = { ...targetRect,
            y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,
            height: 1
          };
        }

        if (targetRect !== void 0) {
          const bounds = {
            x: targetRect.x - paddingX,
            y: targetRect.y - paddingY,
            width: targetRect.width + 2 * paddingX,
            height: targetRect.height + 2 * paddingY
          };
          let frozenWidth = 0;

          for (let i = 0; i < freezeColumns; i++) {
            frozenWidth += columns[i].width;
          }

          let trailingRowHeight = 0;

          if (lastRowSticky) {
            trailingRowHeight = typeof rowHeight === "number" ? rowHeight : rowHeight(rows);
          }

          let sLeft = frozenWidth + scrollBounds.left + rowMarkerOffset * rowMarkerWidth;
          let sRight = scrollBounds.right;
          let sTop = scrollBounds.top + totalHeaderHeight;
          let sBottom = scrollBounds.bottom - trailingRowHeight;
          const minx = targetRect.width + paddingX * 2;

          switch (options == null ? void 0 : options.hAlign) {
            case "start":
              sRight = sLeft + minx;
              break;

            case "end":
              sLeft = sRight - minx;
              break;

            case "center":
              sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;
              sRight = sLeft + minx;
              break;
          }

          const miny = targetRect.height + paddingY * 2;

          switch (options == null ? void 0 : options.vAlign) {
            case "start":
              sBottom = sTop + miny;
              break;

            case "end":
              sTop = sBottom - miny;
              break;

            case "center":
              sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;
              sBottom = sTop + miny;
              break;
          }

          if (sLeft > bounds.x) {
            scrollX = bounds.x - sLeft;
          } else if (sRight < bounds.x + bounds.width) {
            scrollX = bounds.x + bounds.width - sRight;
          }

          if (sTop > bounds.y) {
            scrollY = bounds.y - sTop;
          } else if (sBottom < bounds.y + bounds.height) {
            scrollY = bounds.y + bounds.height - sBottom;
          }

          if (dir === "vertical" || col < freezeColumns) {
            scrollX = 0;
          } else if (dir === "horizontal") {
            scrollY = 0;
          }

          if (scrollX !== 0 || scrollY !== 0) {
            scrollRef.current.scrollTo(scrollX + scrollRef.current.scrollLeft, scrollY + scrollRef.current.scrollTop);
          }
        }
      }
    }
  }, [rowMarkerOffset, rowMarkerWidth, totalHeaderHeight, lastRowSticky, freezeColumns, columns, rowHeight, rows]);
  const focusCallback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusOnRowFromTrailingBlankRow);
  const getCellContentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellContent);
  const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);
  focusCallback.current = focusOnRowFromTrailingBlankRow;
  getCellContentRef.current = getCellContent;
  rowsRef.current = rows;
  const appendRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async col => {
    var _a2;

    const c = mangledCols[col];

    if (((_a2 = c == null ? void 0 : c.trailingRowOptions) == null ? void 0 : _a2.disabled) === true) {
      return;
    }

    const appendResult = onRowAppended == null ? void 0 : onRowAppended();
    let r = void 0;
    let bottom = true;

    if (appendResult !== void 0) {
      r = await appendResult;
      if (r === "top") bottom = false;
      if (typeof r === "number") bottom = false;
    }

    let backoff = 0;

    const doFocus = () => {
      if (rowsRef.current <= rows) {
        if (backoff < 500) {
          window.setTimeout(doFocus, backoff);
        }

        backoff = 50 + backoff * 2;
        return;
      }

      const row = typeof r === "number" ? r : bottom ? rows : 0;
      scrollTo(col - rowMarkerOffset, row);
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, false, false, "edit");
      const cell = getCellContentRef.current([col - rowMarkerOffset, row]);

      if (cell.allowOverlay && isReadWriteCell(cell) && cell.readonly !== true) {
        window.setTimeout(() => {
          focusCallback.current(col, row);
        }, 0);
      }
    };

    doFocus();
  }, [mangledCols, onRowAppended, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const getCustomNewRowTargetColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(col => {
    var _a2, _b2, _c2;

    const customTargetColumn = (_c2 = (_b2 = (_a2 = columns[col]) == null ? void 0 : _a2.trailingRowOptions) == null ? void 0 : _b2.targetColumn) != null ? _c2 : trailingRowOptions == null ? void 0 : trailingRowOptions.targetColumn;

    if (typeof customTargetColumn === "number") {
      const customTargetOffset = hasRowMarkers ? 1 : 0;
      return customTargetColumn + customTargetOffset;
    }

    if (typeof customTargetColumn === "object") {
      const maybeIndex = columnsIn.indexOf(customTargetColumn);

      if (maybeIndex >= 0) {
        const customTargetOffset = hasRowMarkers ? 1 : 0;
        return maybeIndex + customTargetOffset;
      }
    }

    return void 0;
  }, [columns, columnsIn, hasRowMarkers, trailingRowOptions == null ? void 0 : trailingRowOptions.targetColumn]);
  const lastSelectedRowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const lastSelectedColRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const themeForCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, pos) => {
    var _a2;

    const [col, row] = pos;
    return { ...mergedTheme,
      ...((_a2 = mangledCols[col]) == null ? void 0 : _a2.themeOverride),
      ...(getRowThemeOverride == null ? void 0 : getRowThemeOverride(row)),
      ...cell.themeOverride
    };
  }, [getRowThemeOverride, mangledCols, mergedTheme]);
  const handleSelect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b2, _c2, _d2;

    const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;
    const isMultiRow = isMultiKey && rowSelect === "multi";
    const isMultiCol = isMultiKey && columnSelect === "multi";
    const [col, row] = args.location;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const [cellCol, cellRow] = (_b2 = (_a2 = gridSelection.current) == null ? void 0 : _a2.cell) != null ? _b2 : [];

    if (args.kind === "cell") {
      lastSelectedColRef.current = void 0;
      lastMouseSelectLocation.current = [col, row];

      if (col === 0 && hasRowMarkers) {
        if (showTrailingBlankRow === true && row === rows || rowMarkers === "number" || rowSelect === "none") return;
        const markerCell = getMangledCellContent(args.location);

        if (markerCell.kind !== InnerGridCellKind.Marker) {
          return;
        }

        if (onRowMoved !== void 0) {
          const renderer = getCellRenderer(markerCell);
          assert((renderer == null ? void 0 : renderer.kind) === InnerGridCellKind.Marker);
          const postClick = (_c2 = renderer == null ? void 0 : renderer.onClick) == null ? void 0 : _c2.call(renderer, { ...args,
            cell: markerCell,
            posX: args.localEventX,
            posY: args.localEventY,
            bounds: args.bounds,
            theme: themeForCell(markerCell, args.location),
            preventDefault: () => void 0
          });
          if (postClick === void 0 || postClick.checked === markerCell.checked) return;
        }

        setOverlay(void 0);
        focus();
        const isSelected = selectedRows.hasIndex(row);
        const lastHighlighted = lastSelectedRowRef.current;

        if (rowSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastHighlighted !== void 0 && selectedRows.hasIndex(lastHighlighted)) {
          const newSlice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];

          if (isMultiRow || rowSelectionMode === "multi") {
            setSelectedRows(void 0, newSlice, true);
          } else {
            setSelectedRows(CompactSelection.fromSingleSelection(newSlice), void 0, isMultiRow);
          }
        } else if (isMultiRow || args.isTouch || rowSelectionMode === "multi") {
          if (isSelected) {
            setSelectedRows(selectedRows.remove(row), void 0, true);
          } else {
            setSelectedRows(void 0, row, true);
            lastSelectedRowRef.current = row;
          }
        } else if (isSelected && selectedRows.length === 1) {
          setSelectedRows(CompactSelection.empty(), void 0, isMultiKey);
        } else {
          setSelectedRows(CompactSelection.fromSingleSelection(row), void 0, isMultiKey);
          lastSelectedRowRef.current = row;
        }
      } else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {
        const customTargetColumn = getCustomNewRowTargetColumn(col);
        void appendRow(customTargetColumn != null ? customTargetColumn : col);
      } else {
        if (cellCol !== col || cellRow !== row) {
          const cell = getMangledCellContent(args.location);
          const renderer = getCellRenderer(cell);

          if ((renderer == null ? void 0 : renderer.onSelect) !== void 0) {
            let prevented = false;
            renderer.onSelect({ ...args,
              cell,
              posX: args.localEventX,
              posY: args.localEventY,
              bounds: args.bounds,
              preventDefault: () => prevented = true,
              theme: themeForCell(cell, args.location)
            });

            if (prevented) {
              return;
            }
          }

          const isLastStickyRow = lastRowSticky && row === rows;
          const startedFromLastSticky = lastRowSticky && gridSelection !== void 0 && ((_d2 = gridSelection.current) == null ? void 0 : _d2.cell[1]) === rows;

          if ((args.shiftKey || args.isLongTouch === true) && cellCol !== void 0 && cellRow !== void 0 && gridSelection.current !== void 0 && !startedFromLastSticky) {
            if (isLastStickyRow) {
              return;
            }

            const left = Math.min(col, cellCol);
            const right = Math.max(col, cellCol);
            const top = Math.min(row, cellRow);
            const bottom = Math.max(row, cellRow);
            setCurrent({ ...gridSelection.current,
              range: {
                x: left,
                y: top,
                width: right - left + 1,
                height: bottom - top + 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = void 0;
            focus();
          } else {
            setCurrent({
              cell: [col, row],
              range: {
                x: col,
                y: row,
                width: 1,
                height: 1
              }
            }, true, isMultiKey, "click");
            lastSelectedRowRef.current = void 0;
            setOverlay(void 0);
            focus();
          }
        }
      }
    } else if (args.kind === "header") {
      lastMouseSelectLocation.current = [col, row];
      setOverlay(void 0);

      if (hasRowMarkers && col === 0) {
        lastSelectedRowRef.current = void 0;
        lastSelectedColRef.current = void 0;

        if (rowSelect === "multi") {
          if (selectedRows.length !== rows) {
            setSelectedRows(CompactSelection.fromSingleSelection([0, rows]), void 0, isMultiKey);
          } else {
            setSelectedRows(CompactSelection.empty(), void 0, isMultiKey);
          }

          focus();
        }
      } else {
        const lastCol = lastSelectedColRef.current;

        if (columnSelect === "multi" && (args.shiftKey || args.isLongTouch === true) && lastCol !== void 0 && selectedColumns.hasIndex(lastCol)) {
          const newSlice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];

          if (isMultiCol) {
            setSelectedColumns(void 0, newSlice, isMultiKey);
          } else {
            setSelectedColumns(CompactSelection.fromSingleSelection(newSlice), void 0, isMultiKey);
          }
        } else if (isMultiCol) {
          if (selectedColumns.hasIndex(col)) {
            setSelectedColumns(selectedColumns.remove(col), void 0, isMultiKey);
          } else {
            setSelectedColumns(void 0, col, isMultiKey);
          }

          lastSelectedColRef.current = col;
        } else if (columnSelect !== "none") {
          setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, isMultiKey);
          lastSelectedColRef.current = col;
        }

        lastSelectedRowRef.current = void 0;
        focus();
      }
    } else if (args.kind === groupHeaderKind) {
      lastMouseSelectLocation.current = [col, row];
    } else if (args.kind === outOfBoundsKind) {
      setGridSelection(emptyGridSelection, false);
      setOverlay(void 0);
      focus();
      onSelectionCleared == null ? void 0 : onSelectionCleared();
      lastSelectedRowRef.current = void 0;
      lastSelectedColRef.current = void 0;
    }
  }, [appendRow, columnSelect, focus, getCellRenderer, getCustomNewRowTargetColumn, getMangledCellContent, gridSelection, hasRowMarkers, lastRowSticky, onSelectionCleared, onRowMoved, rowMarkerOffset, rowMarkers, rowSelect, rowSelectionMode, rows, setCurrent, setGridSelection, setSelectedColumns, setSelectedRows, showTrailingBlankRow, themeForCell]);
  const lastMouseSelectLocation = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const touchDownArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef(visibleRegion);
  const mouseDownData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  const onMouseDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    var _a2, _b2;

    isPrevented.current = false;
    touchDownArgs.current = visibleRegionRef.current;

    if (args.button !== 0) {
      mouseDownData.current = void 0;
      return;
    }

    const time = performance.now();
    const wasDoubleClick = time - ((_b2 = (_a2 = mouseDownData.current) == null ? void 0 : _a2.time) != null ? _b2 : -1e3) < 250;
    mouseDownData.current = {
      wasDoubleClick,
      time,
      location: args.location
    };
    const fh = args.kind === "cell" && args.isFillHandle;
    if (!fh && args.kind !== "cell" && args.isEdge) return;
    setMouseState({
      previousSelection: gridSelection,
      fillHandle: fh
    });
    lastMouseSelectLocation.current = void 0;

    if (!args.isTouch) {
      handleSelect(args);
    }
  }, [gridSelection, handleSelect]);
  const [renameGroup, setRenameGroup] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const handleGroupHeaderSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.kind !== groupHeaderKind || columnSelect !== "multi") {
      return;
    }

    const isMultiKey = browserIsOSX.value ? args.metaKey : args.ctrlKey;
    const [col] = args.location;
    const selectedColumns = gridSelection.columns;
    if (col < rowMarkerOffset) return;
    const needle = mangledCols[col];
    let start = col;
    let end = col;

    for (let i = col - 1; i >= rowMarkerOffset; i--) {
      if (!isGroupEqual(needle.group, mangledCols[i].group)) break;
      start--;
    }

    for (let i = col + 1; i < mangledCols.length; i++) {
      if (!isGroupEqual(needle.group, mangledCols[i].group)) break;
      end++;
    }

    focus();

    if (isMultiKey) {
      if (selectedColumns.hasAll([start, end + 1])) {
        let newVal = selectedColumns;

        for (let index = start; index <= end; index++) {
          newVal = newVal.remove(index);
        }

        setSelectedColumns(newVal, void 0, isMultiKey);
      } else {
        setSelectedColumns(void 0, [start, end + 1], isMultiKey);
      }
    } else {
      setSelectedColumns(CompactSelection.fromSingleSelection([start, end + 1]), void 0, isMultiKey);
    }
  }, [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]);
  const fillDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(reverse => {
    var _a2;

    if (gridSelection.current === void 0) return;
    const v = [];
    const r = gridSelection.current.range;

    for (let x = 0; x < r.width; x++) {
      const fillCol = x + r.x;
      const fillVal = getMangledCellContent([fillCol, reverse ? r.y + r.height - 1 : r.y]);
      if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;

      for (let y = 1; y < r.height; y++) {
        const fillRow = reverse ? r.y + r.height - (y + 1) : y + r.y;
        const target = [fillCol, fillRow];
        v.push({
          location: target,
          value: { ...fillVal
          }
        });
      }
    }

    mangledOnCellsEdited(v);
    (_a2 = gridRef.current) == null ? void 0 : _a2.damage(v.map(c => ({
      cell: c.location
    })));
  }, [getMangledCellContent, gridSelection, mangledOnCellsEdited]);
  const isPrevented = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const onContextMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, preventDefault) => {
    const clickLocation = args.location[0] - rowMarkerOffset;

    if (args.kind === "header") {
      onHeaderContextMenu == null ? void 0 : onHeaderContextMenu(clickLocation, { ...args,
        preventDefault
      });
    }

    if (args.kind === groupHeaderKind) {
      if (clickLocation < 0) {
        return;
      }

      onGroupHeaderContextMenu == null ? void 0 : onGroupHeaderContextMenu(clickLocation, { ...args,
        preventDefault
      });
    }

    if (args.kind === "cell") {
      onCellContextMenu == null ? void 0 : onCellContextMenu([clickLocation, args.location[1]], { ...args,
        preventDefault
      });
    }
  }, [onCellContextMenu, onGroupHeaderContextMenu, onHeaderContextMenu, rowMarkerOffset]);
  const normalSizeColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async col => {
    var _a2;

    if (((_a2 = mouseDownData.current) == null ? void 0 : _a2.wasDoubleClick) === true && getCellsForSelection !== void 0 && onColumnResize !== void 0) {
      const start = visibleRegionRef.current.y;
      const end = visibleRegionRef.current.height;
      let cells = getCellsForSelection({
        x: col,
        y: start,
        width: 1,
        height: Math.min(end, rows - start)
      }, abortControllerRef.current.signal);

      if (typeof cells !== "object") {
        cells = await cells();
      }

      const inputCol = columns[col - rowMarkerOffset];
      const offscreen = document.createElement("canvas");
      const ctx = offscreen.getContext("2d", {
        alpha: false
      });

      if (ctx !== null) {
        ctx.font = `${mergedTheme.baseFontStyle} ${mergedTheme.fontFamily}`;
        const newCol = measureColumn(ctx, mergedTheme, inputCol, 0, cells, minColumnWidth, maxColumnWidth, false, getCellRenderer);
        onColumnResize == null ? void 0 : onColumnResize(inputCol, newCol.width, col, newCol.width);
      }
    }
  }, [columns, getCellsForSelection, maxColumnWidth, mergedTheme, minColumnWidth, onColumnResize, rowMarkerOffset, rows, getCellRenderer]);
  const [scrollDir, setScrollDir] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  const onMouseUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, isOutside) => {
    var _a2, _b2, _c2;

    const mouse = mouseState;
    setMouseState(void 0);
    setScrollDir(void 0);
    if (isOutside) return;

    if ((mouse == null ? void 0 : mouse.fillHandle) === true && gridSelection.current !== void 0) {
      fillDown(gridSelection.current.cell[1] !== gridSelection.current.range.y);
      return;
    }

    const [col, row] = args.location;
    const [lastMouseDownCol, lastMouseDownRow] = (_a2 = lastMouseSelectLocation.current) != null ? _a2 : [];

    const preventDefault = () => {
      isPrevented.current = true;
    };

    const handleMaybeClick = a => {
      var _a3, _b3, _c3;

      if (a.isTouch || lastMouseDownCol === col && lastMouseDownRow === row) {
        onCellClicked == null ? void 0 : onCellClicked([col - rowMarkerOffset, row], { ...a,
          preventDefault
        });
      }

      if (!isPrevented.current) {
        const c = getMangledCellContent(args.location);
        const r = getCellRenderer(c);

        if (r !== void 0 && r.onClick !== void 0) {
          const newVal = r.onClick({ ...a,
            cell: c,
            posX: a.localEventX,
            posY: a.localEventY,
            bounds: a.bounds,
            theme: themeForCell(c, args.location),
            preventDefault
          });

          if (newVal !== void 0 && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {
            mangledOnCellsEdited([{
              location: a.location,
              value: newVal
            }]);
            (_a3 = gridRef.current) == null ? void 0 : _a3.damage([{
              cell: a.location
            }]);
          }
        }

        if (!isPrevented.current && ((_c3 = (_b3 = mouse == null ? void 0 : mouse.previousSelection) == null ? void 0 : _b3.current) == null ? void 0 : _c3.cell) !== void 0 && gridSelection.current !== void 0) {
          const [selectedCol, selectedRow] = gridSelection.current.cell;
          const [prevCol, prevRow] = mouse.previousSelection.current.cell;

          if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {
            onCellActivated == null ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
            reselect(a.bounds, false);
            return true;
          }
        }
      }

      return false;
    };

    const clickLocation = args.location[0] - rowMarkerOffset;

    if (args.isTouch) {
      const vr = visibleRegionRef.current;
      const touchVr = touchDownArgs.current;

      if (vr.x !== touchVr.x || vr.y !== touchVr.y) {
        return;
      }

      if (args.isLongTouch === true) {
        if (args.kind === "cell" && ((_b2 = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _b2.cell[0]) === col && ((_c2 = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _c2.cell[1]) === row) {
          onCellContextMenu == null ? void 0 : onCellContextMenu([clickLocation, args.location[1]], { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === "header" && gridSelection.columns.hasIndex(col)) {
          onHeaderContextMenu == null ? void 0 : onHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        } else if (args.kind === groupHeaderKind) {
          if (clickLocation < 0) {
            return;
          }

          onGroupHeaderContextMenu == null ? void 0 : onGroupHeaderContextMenu(clickLocation, { ...args,
            preventDefault
          });
          return;
        }
      }

      if (args.kind === "cell") {
        if (!handleMaybeClick(args)) {
          handleSelect(args);
        }
      } else if (args.kind === groupHeaderKind) {
        onGroupHeaderClicked == null ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      } else {
        if (args.kind === headerKind) {
          onHeaderClicked == null ? void 0 : onHeaderClicked(clickLocation, { ...args,
            preventDefault
          });
        }

        handleSelect(args);
      }

      return;
    }

    if (args.kind === "header") {
      if (clickLocation < 0) {
        return;
      }

      if (args.isEdge) {
        void normalSizeColumn(col);
      } else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onHeaderClicked == null ? void 0 : onHeaderClicked(clickLocation, { ...args,
          preventDefault
        });
      }
    }

    if (args.kind === groupHeaderKind) {
      if (clickLocation < 0) {
        return;
      }

      if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {
        onGroupHeaderClicked == null ? void 0 : onGroupHeaderClicked(clickLocation, { ...args,
          preventDefault
        });

        if (!isPrevented.current) {
          handleGroupHeaderSelection(args);
        }
      }
    }

    if (args.kind === "cell" && args.button === 0) {
      handleMaybeClick(args);
    }

    lastMouseSelectLocation.current = void 0;
  }, [mouseState, rowMarkerOffset, gridSelection, onCellClicked, fillDown, getMangledCellContent, getCellRenderer, themeForCell, mangledOnCellsEdited, onCellActivated, reselect, onCellContextMenu, onHeaderContextMenu, onGroupHeaderContextMenu, handleSelect, onGroupHeaderClicked, normalSizeColumn, onHeaderClicked, handleGroupHeaderSelection]);
  const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    const a = { ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    };
    onMouseMove == null ? void 0 : onMouseMove(a);
    setScrollDir(cv => {
      var _a2, _b2;

      if (args.scrollEdge[0] === (cv == null ? void 0 : cv[0]) && args.scrollEdge[1] === cv[1]) return cv;
      return mouseState === void 0 || ((_b2 = (_a2 = mouseDownData.current) == null ? void 0 : _a2.location[0]) != null ? _b2 : 0) < rowMarkerOffset ? void 0 : args.scrollEdge;
    });
  }, [mouseState, onMouseMove, rowMarkerOffset]);
  useAutoscroll(scrollDir, scrollRef);
  const onHeaderMenuClickInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, screenPosition) => {
    onHeaderMenuClick == null ? void 0 : onHeaderMenuClick(col - rowMarkerOffset, screenPosition);
  }, [onHeaderMenuClick, rowMarkerOffset]);
  const currentCell = (_c = gridSelection == null ? void 0 : gridSelection.current) == null ? void 0 : _c.cell;
  const onVisibleRegionChangedImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((region, clientWidth, clientHeight, rightElWidth, tx, ty) => {
    let selected = currentCell;

    if (selected !== void 0) {
      selected = [selected[0] - rowMarkerOffset, selected[1]];
    }

    const newRegion = {
      x: region.x - rowMarkerOffset,
      y: region.y,
      width: region.width,
      height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,
      tx,
      ty,
      extras: {
        selected,
        freezeRegion: freezeColumns === 0 ? void 0 : {
          x: 0,
          y: region.y,
          width: freezeColumns,
          height: region.height
        }
      }
    };
    setClientSize([clientWidth, clientHeight, rightElWidth]);
    setVisibleRegion(newRegion);
    onVisibleRegionChanged == null ? void 0 : onVisibleRegionChanged(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);
  }, [currentCell, rowMarkerOffset, showTrailingBlankRow, rows, freezeColumns, setVisibleRegion, onVisibleRegionChanged]);
  const onColumnMovedImpl = whenDefined(onColumnMoved, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((startIndex, endIndex) => {
    onColumnMoved == null ? void 0 : onColumnMoved(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);

    if (columnSelect !== "none") {
      setSelectedColumns(CompactSelection.fromSingleSelection(endIndex), void 0, true);
    }
  }, [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]));
  const isActivelyDragging = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (args.location[0] === 0 && rowMarkerOffset > 0) {
      args.preventDefault();
      return;
    }

    onDragStart == null ? void 0 : onDragStart({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });

    if (!args.defaultPrevented()) {
      isActivelyDragging.current = true;
    }

    setMouseState(void 0);
  }, [onDragStart, rowMarkerOffset]);
  const onDragEnd = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    isActivelyDragging.current = false;
  }, []);
  const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(args => {
    if (mouseState !== void 0 && gridSelection.current !== void 0 && !isActivelyDragging.current && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
      const [selectedCol, selectedRow] = gridSelection.current.cell;
      let [col, row] = args.location;

      if (row < 0) {
        row = visibleRegionRef.current.y;
      }

      const startedFromLastStickyRow = lastRowSticky && selectedRow === rows;
      if (startedFromLastStickyRow) return;
      const landedOnLastStickyRow = lastRowSticky && row === rows;

      if (landedOnLastStickyRow) {
        if (args.kind === outOfBoundsKind) row--;else return;
      }

      col = Math.max(col, rowMarkerOffset);
      const deltaX = col - selectedCol;
      const deltaY = row - selectedRow;
      const newRange = {
        x: deltaX >= 0 ? selectedCol : col,
        y: deltaY >= 0 ? selectedRow : row,
        width: Math.abs(deltaX) + 1,
        height: Math.abs(deltaY) + 1
      };
      setCurrent({ ...gridSelection.current,
        range: newRange
      }, true, false, "drag");
    }

    onItemHovered == null ? void 0 : onItemHovered({ ...args,
      location: [args.location[0] - rowMarkerOffset, args.location[1]]
    });
  }, [mouseState, gridSelection, rangeSelect, onItemHovered, rowMarkerOffset, lastRowSticky, rows, setCurrent]);
  const adjustSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(direction2 => {
    if (gridSelection.current === void 0) return;
    const [x, y] = direction2;
    const [col, row] = gridSelection.current.cell;
    const old = gridSelection.current.range;
    let left = old.x;
    let right = old.x + old.width;
    let top = old.y;
    let bottom = old.y + old.height;

    if (y !== 0) {
      switch (y) {
        case 2:
          {
            bottom = rows;
            top = row;
            scrollTo(0, bottom, "vertical");
            break;
          }

        case -2:
          {
            top = 0;
            bottom = row + 1;
            scrollTo(0, top, "vertical");
            break;
          }

        case 1:
          {
            if (top < row) {
              top++;
              scrollTo(0, top, "vertical");
            } else {
              bottom = Math.min(rows, bottom + 1);
              scrollTo(0, bottom, "vertical");
            }

            break;
          }

        case -1:
          {
            if (bottom > row + 1) {
              bottom--;
              scrollTo(0, bottom, "vertical");
            } else {
              top = Math.max(0, top - 1);
              scrollTo(0, top, "vertical");
            }

            break;
          }

        default:
          {
            assertNever(y);
          }
      }
    }

    if (x !== 0) {
      if (x === 2) {
        right = mangledCols.length;
        left = col;
        scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
      } else if (x === -2) {
        left = rowMarkerOffset;
        right = col + 1;
        scrollTo(left - rowMarkerOffset, 0, "horizontal");
      } else {
        let disallowed = [];

        if (getCellsForSelection !== void 0) {
          const cells = getCellsForSelection({
            x: left,
            y: top,
            width: right - left - rowMarkerOffset,
            height: bottom - top
          }, abortControllerRef.current.signal);

          if (typeof cells === "object") {
            disallowed = getSpanStops(cells);
          }
        }

        if (x === 1) {
          let done = false;

          if (left < col) {
            if (disallowed.length > 0) {
              const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(left + 1, col + 1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== void 0) {
                left = target;
                done = true;
              }
            } else {
              left++;
              done = true;
            }

            if (done) scrollTo(left, 0, "horizontal");
          }

          if (!done) {
            right = Math.min(mangledCols.length, right + 1);
            scrollTo(right - 1 - rowMarkerOffset, 0, "horizontal");
          }
        } else if (x === -1) {
          let done = false;

          if (right > col + 1) {
            if (disallowed.length > 0) {
              const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(right - 1, col, -1).find(n => !disallowed.includes(n - rowMarkerOffset));

              if (target !== void 0) {
                right = target;
                done = true;
              }
            } else {
              right--;
              done = true;
            }

            if (done) scrollTo(right - rowMarkerOffset, 0, "horizontal");
          }

          if (!done) {
            left = Math.max(rowMarkerOffset, left - 1);
            scrollTo(left - rowMarkerOffset, 0, "horizontal");
          }
        } else {
          assertNever(x);
        }
      }
    }

    setCurrent({
      cell: gridSelection.current.cell,
      range: {
        x: left,
        y: top,
        width: right - left,
        height: bottom - top
      }
    }, true, false, "keyboard-select");
  }, [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]);
  const updateSelectedCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row, fromEditingTrailingRow, freeMove) => {
    const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);
    col = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);
    row = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(row, 0, rowMax);
    if (col === (currentCell == null ? void 0 : currentCell[0]) && row === (currentCell == null ? void 0 : currentCell[1])) return false;

    if (freeMove && gridSelection.current !== void 0) {
      const newStack = [...gridSelection.current.rangeStack];

      if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {
        newStack.push(gridSelection.current.range);
      }

      setGridSelection({ ...gridSelection,
        current: {
          cell: [col, row],
          range: {
            x: col,
            y: row,
            width: 1,
            height: 1
          },
          rangeStack: newStack
        }
      }, true);
    } else {
      setCurrent({
        cell: [col, row],
        range: {
          x: col,
          y: row,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-nav");
    }

    if (lastSent.current !== void 0 && lastSent.current[0] === col && lastSent.current[1] === row) {
      lastSent.current = void 0;
    }

    scrollTo(col - rowMarkerOffset, row);
    return true;
  }, [mangledRows, rowMarkerOffset, columns.length, currentCell, gridSelection, scrollTo, setGridSelection, setCurrent]);
  const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newValue, movement) => {
    if ((overlay == null ? void 0 : overlay.cell) !== void 0 && newValue !== void 0 && isEditableGridCell(newValue)) {
      mangledOnCellsEdited([{
        location: overlay.cell,
        value: newValue
      }]);
      window.requestAnimationFrame(() => {
        var _a2;

        (_a2 = gridRef.current) == null ? void 0 : _a2.damage([{
          cell: overlay.cell
        }]);
      });
    }

    focus(true);
    setOverlay(void 0);
    const [movX, movY] = movement;

    if (gridSelection.current !== void 0 && (movX !== 0 || movY !== 0)) {
      const isEditingTrailingRow = gridSelection.current.cell[1] === mangledRows - 1 && newValue !== void 0;
      updateSelectedCell(lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1), lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[1] + movY, 0, mangledRows - 1), isEditingTrailingRow, false);
    }

    onFinishedEditing == null ? void 0 : onFinishedEditing(newValue, movement);
  }, [overlay == null ? void 0 : overlay.cell, focus, gridSelection, onFinishedEditing, mangledOnCellsEdited, mangledRows, updateSelectedCell, mangledCols.length]);
  const overlayID = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return `gdg-overlay-${idCounter++}`;
  }, []);
  const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    const fn = async () => {
      var _a2, _b2, _c2, _d2, _e2;

      let cancelled = false;

      if (onKeyDownIn !== void 0) {
        onKeyDownIn({ ...event,
          cancel: () => {
            cancelled = true;
          }
        });
      }

      if (cancelled) return;

      const cancel = () => {
        event.stopPropagation();
        event.preventDefault();
      };

      const overlayOpen = overlay !== void 0;
      const {
        altKey,
        shiftKey,
        metaKey,
        ctrlKey,
        key,
        bounds
      } = event;
      const isOSX = browserIsOSX.value;
      const isPrimaryKey = isOSX ? metaKey : ctrlKey;
      const isDeleteKey = key === "Delete" || isOSX && key === "Backspace";
      const vr = visibleRegionRef.current;
      const selectedColumns = gridSelection.columns;
      const selectedRows = gridSelection.rows;

      if (key === "Escape") {
        if (overlayOpen) {
          setOverlay(void 0);
        } else if (keybindings.clear) {
          setGridSelection(emptyGridSelection, false);
          onSelectionCleared == null ? void 0 : onSelectionCleared();
        }

        return;
      } else if (isHotkey("primary+a", event) && keybindings.selectAll) {
        if (!overlayOpen) {
          setGridSelection({
            columns: CompactSelection.empty(),
            rows: CompactSelection.empty(),
            current: {
              cell: (_b2 = (_a2 = gridSelection.current) == null ? void 0 : _a2.cell) != null ? _b2 : [rowMarkerOffset, 0],
              range: {
                x: rowMarkerOffset,
                y: 0,
                width: columnsIn.length,
                height: rows
              },
              rangeStack: []
            }
          }, false);
        } else {
          const el = document.getElementById(overlayID);

          if (el !== null) {
            const s = window.getSelection();
            const r = document.createRange();
            r.selectNodeContents(el);
            s == null ? void 0 : s.removeAllRanges();
            s == null ? void 0 : s.addRange(r);
          }
        }

        cancel();
        return;
      } else if (isHotkey("primary+f", event) && keybindings.search) {
        cancel();
        (_c2 = searchInputRef == null ? void 0 : searchInputRef.current) == null ? void 0 : _c2.focus({
          preventScroll: true
        });
        setShowSearchInner(true);
      }

      function deleteRange(r) {
        var _a3, _b3, _c3;

        focus();
        const editList = [];

        for (let x = r.x; x < r.x + r.width; x++) {
          for (let y = r.y; y < r.y + r.height; y++) {
            const cellValue = getCellContent([x - rowMarkerOffset, y]);
            if (!cellValue.allowOverlay && cellValue.kind !== GridCellKind.Boolean) continue;
            let newVal = void 0;

            if (cellValue.kind === GridCellKind.Custom) {
              const editor = provideEditor == null ? void 0 : provideEditor(cellValue);

              if (isObjectEditorCallbackResult(editor)) {
                newVal = (_a3 = editor == null ? void 0 : editor.deletedValue) == null ? void 0 : _a3.call(editor, cellValue);
              }
            } else if (isEditableGridCell(cellValue) && cellValue.allowOverlay || cellValue.kind === GridCellKind.Boolean) {
              const toDelete = getCellRenderer(cellValue);
              newVal = (_b3 = toDelete == null ? void 0 : toDelete.onDelete) == null ? void 0 : _b3.call(toDelete, cellValue);
            }

            if (newVal !== void 0 && !isInnerOnlyCell(newVal) && isEditableGridCell(newVal)) {
              editList.push({
                location: [x, y],
                value: newVal
              });
            }
          }
        }

        mangledOnCellsEdited(editList);
        (_c3 = gridRef.current) == null ? void 0 : _c3.damage(editList.map(x => ({
          cell: x.location
        })));
      }

      if (isDeleteKey) {
        const callbackResult = (_d2 = onDelete == null ? void 0 : onDelete(gridSelection)) != null ? _d2 : true;
        cancel();

        if (callbackResult !== false) {
          const toDelete = callbackResult === true ? gridSelection : callbackResult;

          if (toDelete.current !== void 0) {
            deleteRange(toDelete.current.range);

            for (const r of toDelete.current.rangeStack) {
              deleteRange(r);
            }
          }

          for (const r of toDelete.rows) {
            deleteRange({
              x: rowMarkerOffset,
              y: r,
              width: mangledCols.length - rowMarkerOffset,
              height: 1
            });
          }

          for (const col2 of toDelete.columns) {
            deleteRange({
              x: col2,
              y: 0,
              width: 1,
              height: rows
            });
          }
        }

        return;
      }

      if (gridSelection.current === void 0) return;
      let [col, row] = gridSelection.current.cell;
      let freeMove = false;

      if (keybindings.selectColumn && isHotkey("ctrl+ ", event) && columnSelect !== "none") {
        if (selectedColumns.hasIndex(col)) {
          setSelectedColumns(selectedColumns.remove(col), void 0, true);
        } else {
          if (columnSelect === "single") {
            setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, true);
          } else {
            setSelectedColumns(void 0, col, true);
          }
        }
      } else if (keybindings.selectRow && isHotkey("shift+ ", event) && rowSelect !== "none") {
        if (selectedRows.hasIndex(row)) {
          setSelectedRows(selectedRows.remove(row), void 0, true);
        } else {
          if (rowSelect === "single") {
            setSelectedRows(CompactSelection.fromSingleSelection(row), void 0, true);
          } else {
            setSelectedRows(void 0, row, true);
          }
        }
      } else if ((isHotkey("Enter", event) || isHotkey(" ", event) || isHotkey("shift+Enter", event)) && bounds !== void 0) {
        if (overlayOpen) {
          setOverlay(void 0);

          if (isHotkey("Enter", event)) {
            row++;
          } else if (isHotkey("shift+Enter", event)) {
            row--;
          }
        } else if (row === rows && showTrailingBlankRow) {
          window.setTimeout(() => {
            const customTargetColumn = getCustomNewRowTargetColumn(col);
            void appendRow(customTargetColumn != null ? customTargetColumn : col);
          }, 0);
        } else {
          onCellActivated == null ? void 0 : onCellActivated([col - rowMarkerOffset, row]);
          reselect(bounds, true);
          cancel();
        }
      } else if (keybindings.downFill && isHotkey("primary+_68", event) && gridSelection.current.range.height > 1) {
        fillDown(false);
        cancel();
      } else if (keybindings.rightFill && isHotkey("primary+_82", event) && gridSelection.current.range.width > 1) {
        const editList = [];
        const r = gridSelection.current.range;

        for (let y = 0; y < r.height; y++) {
          const fillRow = y + r.y;
          const fillVal = getMangledCellContent([r.x, fillRow]);
          if (isInnerOnlyCell(fillVal) || !isReadWriteCell(fillVal)) continue;

          for (let x = 1; x < r.width; x++) {
            const fillCol = x + r.x;
            const target = [fillCol, fillRow];
            editList.push({
              location: target,
              value: { ...fillVal
              }
            });
          }
        }

        mangledOnCellsEdited(editList);
        (_e2 = gridRef.current) == null ? void 0 : _e2.damage(editList.map(c => ({
          cell: c.location
        })));
        cancel();
      } else if (keybindings.pageDown && isHotkey("PageDown", event)) {
        row += Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.pageUp && isHotkey("PageUp", event)) {
        row -= Math.max(1, visibleRegionRef.current.height - 4);
        cancel();
      } else if (keybindings.first && isHotkey("primary+Home", event)) {
        setOverlay(void 0);
        row = 0;
        col = 0;
      } else if (keybindings.last && isHotkey("primary+End", event)) {
        setOverlay(void 0);
        row = Number.MAX_SAFE_INTEGER;
        col = Number.MAX_SAFE_INTEGER;
      } else if (keybindings.first && isHotkey("primary+shift+Home", event)) {
        setOverlay(void 0);
        adjustSelection([-2, -2]);
      } else if (keybindings.last && isHotkey("primary+shift+End", event)) {
        setOverlay(void 0);
        adjustSelection([2, 2]);
      } else if (key === "ArrowDown") {
        if (ctrlKey && altKey) {
          return;
        }

        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, isPrimaryKey && !altKey ? 2 : 1]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          if (isPrimaryKey && !altKey) {
            row = rows - 1;
          } else {
            row += 1;
          }
        }
      } else if (key === "ArrowUp" || key === "Home") {
        const asPrimary = key === "Home" || isPrimaryKey;
        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([0, asPrimary && !altKey ? -2 : -1]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          row += asPrimary && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "ArrowRight" || key === "End") {
        const asPrimary = key === "End" || isPrimaryKey;
        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([asPrimary && !altKey ? 2 : 1, 0]);
        } else {
          if (altKey && !asPrimary) {
            freeMove = true;
          }

          col += asPrimary && !altKey ? Number.MAX_SAFE_INTEGER : 1;
        }
      } else if (key === "ArrowLeft") {
        setOverlay(void 0);

        if (shiftKey && (rangeSelect === "rect" || rangeSelect === "multi-rect")) {
          adjustSelection([isPrimaryKey && !altKey ? -2 : -1, 0]);
        } else {
          if (altKey && !isPrimaryKey) {
            freeMove = true;
          }

          col += isPrimaryKey && !altKey ? Number.MIN_SAFE_INTEGER : -1;
        }
      } else if (key === "Tab") {
        setOverlay(void 0);

        if (shiftKey) {
          col--;
        } else {
          col++;
        }
      } else if (!metaKey && !ctrlKey && gridSelection.current !== void 0 && key.length === 1 && /[ -~]/g.test(key) && bounds !== void 0 && isReadWriteCell(getCellContent([col - rowMarkerOffset, Math.max(0, row - 1)]))) {
        if ((!lastRowSticky || row !== rows) && (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)) {
          return;
        }

        reselect(bounds, true, key);
        cancel();
      }

      const moved = updateSelectedCell(col, row, false, freeMove);

      if (moved) {
        cancel();
      }
    };

    void fn();
  }, [onKeyDownIn, overlay, gridSelection, keybindings.selectAll, keybindings.search, keybindings.selectColumn, keybindings.selectRow, keybindings.downFill, keybindings.rightFill, keybindings.pageDown, keybindings.pageUp, keybindings.first, keybindings.last, keybindings.clear, columnSelect, rowSelect, getCellContent, rowMarkerOffset, updateSelectedCell, setGridSelection, onSelectionCleared, columnsIn.length, rows, overlayID, focus, mangledOnCellsEdited, provideEditor, getCellRenderer, onDelete, mangledCols.length, setSelectedColumns, setSelectedRows, showTrailingBlankRow, getCustomNewRowTargetColumn, appendRow, onCellActivated, reselect, fillDown, getMangledCellContent, adjustSelection, rangeSelect, lastRowSticky]);
  const onPasteInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async e => {
    var _a2, _b2, _c2, _d2, _e2, _f, _g;

    if (!keybindings.paste) return;

    function pasteToCell(inner, target2, toPaste) {
      var _a3, _b3;

      if (!isInnerOnlyCell(inner) && isReadWriteCell(inner) && inner.readonly !== true) {
        const coerced = coercePasteValue == null ? void 0 : coercePasteValue(toPaste, inner);

        if (coerced !== void 0 && isEditableGridCell(coerced)) {
          if (coerced.kind !== inner.kind) {
            console.warn("Coercion should not change cell kind.");
          }

          return {
            location: target2,
            value: coerced
          };
        }

        const r = getCellRenderer(inner);
        if (r === void 0) return void 0;

        if (r.kind === GridCellKind.Custom) {
          assert(inner.kind === GridCellKind.Custom);
          const newVal = (_a3 = r.onPaste) == null ? void 0 : _a3.call(r, toPaste, inner);
          if (newVal === void 0) return void 0;
          return {
            location: target2,
            value: { ...inner,
              data: newVal
            }
          };
        } else {
          const newVal = (_b3 = r.onPaste) == null ? void 0 : _b3.call(r, toPaste, inner);
          if (newVal === void 0) return void 0;
          assert(newVal.kind === inner.kind);
          return {
            location: target2,
            value: newVal
          };
        }
      }

      return void 0;
    }

    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;
    const focused = ((_a2 = scrollRef.current) == null ? void 0 : _a2.contains(document.activeElement)) === true || ((_b2 = canvasRef.current) == null ? void 0 : _b2.contains(document.activeElement)) === true;
    let target = (_c2 = gridSelection.current) == null ? void 0 : _c2.cell;

    if (target === void 0 && selectedColumns.length === 1) {
      target = [(_d2 = selectedColumns.first()) != null ? _d2 : 0, 0];
    }

    if (target === void 0 && selectedRows.length === 1) {
      target = [rowMarkerOffset, (_e2 = selectedRows.first()) != null ? _e2 : 0];
    }

    if (focused && target !== void 0) {
      let data;
      let text;
      const textPlain = "text/plain";
      const textHtml = "text/html";

      if (navigator.clipboard.read !== void 0) {
        const clipboardContent = await navigator.clipboard.read();

        for (const item of clipboardContent) {
          if (item.types.includes(textHtml)) {
            const htmlBlob = await item.getType(textHtml);
            const html = await htmlBlob.text();
            const fragment = document.createElement("html");
            fragment.innerHTML = html;
            const el = fragment.querySelector("table");

            if (el !== null) {
              data = decodeHTML(el);
              break;
            }
          }

          if (item.types.includes(textPlain)) {
            text = await (await item.getType(textPlain)).text();
          }
        }
      } else if (navigator.clipboard.readText !== void 0) {
        text = await navigator.clipboard.readText();
      } else if (e !== void 0 && (e == null ? void 0 : e.clipboardData) !== null) {
        if (e.clipboardData.types.includes(textHtml)) {
          const html = e.clipboardData.getData(textHtml);
          const fragment = document.createElement("html");
          fragment.innerHTML = html;
          const el = fragment.querySelector("table");

          if (el !== null) {
            data = decodeHTML(el);
          }
        }

        if (data === void 0 && e.clipboardData.types.includes(textPlain)) {
          text = e.clipboardData.getData(textPlain);
        }
      } else {
        return;
      }

      const [gridCol, gridRow] = target;
      const editList = [];

      do {
        if (onPaste === void 0) {
          const cellData = getMangledCellContent(target);
          const newVal = pasteToCell(cellData, target, (_f = text != null ? text : data == null ? void 0 : data.map(r => r.join("	")).join("	")) != null ? _f : "");

          if (newVal !== void 0) {
            editList.push(newVal);
          }

          break;
        }

        if (data === void 0) {
          if (text === void 0) return;
          data = unquote(text);
        }

        if (onPaste === false || typeof onPaste === "function" && (onPaste == null ? void 0 : onPaste([target[0] - rowMarkerOffset, target[1]], data)) !== true) {
          return;
        }

        for (const [row, dataRow] of data.entries()) {
          if (row + gridRow >= rows) break;

          for (const [col, dataItem] of dataRow.entries()) {
            const index = [col + gridCol, row + gridRow];
            const cellData = getMangledCellContent(index);
            const newVal = pasteToCell(cellData, index, dataItem);

            if (newVal !== void 0) {
              editList.push(newVal);
            }
          }
        }
      } while (false);

      mangledOnCellsEdited(editList);
      (_g = gridRef.current) == null ? void 0 : _g.damage(editList.map(c => ({
        cell: c.location
      })));
    }
  }, [coercePasteValue, getCellRenderer, getMangledCellContent, gridSelection, keybindings.paste, mangledOnCellsEdited, onPaste, rowMarkerOffset, rows]);
  useEventListener("paste", onPasteInternal, window, false, true);
  const onCopy = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (e, ignoreFocus) => {
    var _a2, _b2;

    if (!keybindings.copy) return;
    const focused = ignoreFocus === true || ((_a2 = scrollRef.current) == null ? void 0 : _a2.contains(document.activeElement)) === true || ((_b2 = canvasRef.current) == null ? void 0 : _b2.contains(document.activeElement)) === true;
    const selectedColumns = gridSelection.columns;
    const selectedRows = gridSelection.rows;

    if (focused && getCellsForSelection !== void 0) {
      if (gridSelection.current !== void 0) {
        let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);

        if (typeof thunk !== "object") {
          thunk = await thunk();
        }

        copyToClipboard(thunk, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(gridSelection.current.range.x - rowMarkerOffset, gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset), e);
      } else if (selectedRows !== void 0 && selectedRows.length > 0) {
        const toCopy = [...selectedRows];
        const cells = toCopy.map(rowIndex => {
          const thunk = getCellsForSelection({
            x: rowMarkerOffset,
            y: rowIndex,
            width: columnsIn.length - rowMarkerOffset,
            height: 1
          }, abortControllerRef.current.signal);

          if (typeof thunk === "object") {
            return thunk[0];
          }

          return thunk().then(v => v[0]);
        });

        if (cells.some(x => x instanceof Promise)) {
          const settled = await Promise.all(cells);
          copyToClipboard(settled, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length), e);
        } else {
          copyToClipboard(cells, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length), e);
        }
      } else if (selectedColumns.length > 0) {
        const results = [];
        const cols = [];

        for (const col of selectedColumns) {
          let thunk = getCellsForSelection({
            x: col,
            y: 0,
            width: 1,
            height: rows
          }, abortControllerRef.current.signal);

          if (typeof thunk !== "object") {
            thunk = await thunk();
          }

          results.push(thunk);
          cols.push(col - rowMarkerOffset);
        }

        if (results.length === 1) {
          copyToClipboard(results[0], cols, e);
        } else {
          const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));
          copyToClipboard(toCopy, cols, e);
        }
      }
    }
  }, [columnsIn.length, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows]);
  useEventListener("copy", onCopy, window, false, false);
  const onSearchResultsChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((results, navIndex) => {
    if (results.length === 0 || navIndex === -1) return;
    const [col, row] = results[navIndex];

    if (lastSent.current !== void 0 && lastSent.current[0] === col && lastSent.current[1] === row) {
      return;
    }

    lastSent.current = [col, row];
    updateSelectedCell(col, row, false, false);
  }, [updateSelectedCell]);
  const [outCol, outRow] = (_e = (_d = gridSelectionOuter == null ? void 0 : gridSelectionOuter.current) == null ? void 0 : _d.cell) != null ? _e : [];
  const scrollToRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(scrollTo);
  scrollToRef.current = scrollTo;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    var _a2, _b2, _c2, _d2;

    if (outCol !== void 0 && outRow !== void 0 && (outCol !== ((_b2 = (_a2 = expectedExternalGridSelection.current) == null ? void 0 : _a2.current) == null ? void 0 : _b2.cell[0]) || outRow !== ((_d2 = (_c2 = expectedExternalGridSelection.current) == null ? void 0 : _c2.current) == null ? void 0 : _d2.cell[1]))) {
      scrollToRef.current(outCol, outRow);
    }
  }, [outCol, outRow]);
  const disabledRows = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (showTrailingBlankRow === true && (trailingRowOptions == null ? void 0 : trailingRowOptions.tint) === true) {
      return CompactSelection.fromSingleSelection(mangledRows - 1);
    }

    return CompactSelection.empty();
  }, [mangledRows, showTrailingBlankRow, trailingRowOptions == null ? void 0 : trailingRowOptions.tint]);
  const mangledVerticalBorder = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(col => {
    var _a2;

    return typeof verticalBorder === "boolean" ? verticalBorder : (_a2 = verticalBorder == null ? void 0 : verticalBorder(col - rowMarkerOffset)) != null ? _a2 : true;
  }, [rowMarkerOffset, verticalBorder]);
  const renameGroupNode = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (renameGroup === void 0 || canvasRef.current === null) return null;
    const {
      bounds,
      group
    } = renameGroup;
    const canvasBounds = canvasRef.current.getBoundingClientRect();
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(GroupRename, {
      bounds,
      group,
      canvasBounds,
      onClose: () => setRenameGroup(void 0),
      onFinish: newVal => {
        setRenameGroup(void 0);
        onGroupHeaderRenamed == null ? void 0 : onGroupHeaderRenamed(group, newVal);
      }
    });
  }, [onGroupHeaderRenamed, renameGroup]);
  const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));
  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({
    appendRow: col => appendRow(col + rowMarkerOffset),
    updateCells: damageList => {
      var _a2;

      if (rowMarkerOffset !== 0) {
        damageList = damageList.map(x => ({
          cell: [x.cell[0] + rowMarkerOffset, x.cell[1]]
        }));
      }

      return (_a2 = gridRef.current) == null ? void 0 : _a2.damage(damageList);
    },
    getBounds: (col, row) => {
      var _a2;

      return (_a2 = gridRef.current) == null ? void 0 : _a2.getBounds(col + rowMarkerOffset, row);
    },
    focus: () => {
      var _a2;

      return (_a2 = gridRef.current) == null ? void 0 : _a2.focus();
    },
    emit: async e => {
      switch (e) {
        case "delete":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: false,
            key: "Delete",
            keyCode: 46,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;

        case "fill-right":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: true,
            key: "r",
            keyCode: 82,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;

        case "fill-down":
          onKeyDown({
            bounds: void 0,
            cancel: () => void 0,
            stopPropagation: () => void 0,
            preventDefault: () => void 0,
            ctrlKey: true,
            key: "d",
            keyCode: 68,
            metaKey: false,
            shiftKey: false,
            altKey: false,
            rawEvent: void 0
          });
          break;

        case "copy":
          await onCopy(void 0, true);
          break;

        case "paste":
          await onPasteInternal();
          break;
      }
    },
    scrollTo
  }), [appendRow, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]);
  const [selCol, selRow] = currentCell != null ? currentCell : [];
  const onCellFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cell => {
    const [col, row] = cell;

    if (row === -1) {
      if (columnSelect !== "none") {
        setSelectedColumns(CompactSelection.fromSingleSelection(col), void 0, false);
        focus();
      }

      return;
    }

    if (selCol === col && selRow === row) return;
    setCurrent({
      cell,
      range: {
        x: col,
        y: row,
        width: 1,
        height: 1
      }
    }, true, false, "keyboard-nav");
    scrollTo(col, row);
  }, [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]);
  const [isFocused, setIsFocused] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  const setIsFocusedDebounced = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__(val => {
    setIsFocused(val);
  }, 5));
  const onCanvasFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setIsFocusedDebounced.current(true);

    if (gridSelection.current === void 0 && gridSelection.columns.length === 0 && gridSelection.rows.length === 0 && mouseState === void 0) {
      setCurrent({
        cell: [rowMarkerOffset, cellYOffset],
        range: {
          x: rowMarkerOffset,
          y: cellYOffset,
          width: 1,
          height: 1
        }
      }, true, false, "keyboard-select");
    }
  }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);
  const onFocusOut = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    setIsFocusedDebounced.current(false);
  }, []);
  const [idealWidth, idealHeight] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    var _a2;

    let h;
    const scrollbarWidth = (_a2 = experimental == null ? void 0 : experimental.scrollbarWidthOverride) != null ? _a2 : getScrollBarWidth();
    const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);

    if (typeof rowHeight === "number") {
      h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;
    } else {
      let avg = 0;
      const toAverage = Math.min(rowsCountWithTrailingRow, 10);

      for (let i = 0; i < toAverage; i++) {
        avg += rowHeight(i);
      }

      avg = Math.floor(avg / toAverage);
      h = totalHeaderHeight + rowsCountWithTrailingRow * avg;
    }

    h += scrollbarWidth;
    const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;
    return [`${Math.min(1e5, w)}px`, `${Math.min(1e5, h)}px`];
  }, [mangledCols, experimental == null ? void 0 : experimental.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThemeContext.Provider, {
    value: mergedTheme
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataEditorContainer, {
    style: makeCSSStyle(mergedTheme),
    className,
    inWidth: width != null ? width : idealWidth,
    inHeight: height != null ? height : idealHeight
  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_search_default, {
    fillHandle,
    drawFocusRing: drawFocusRing2,
    experimental,
    fixedShadowX,
    fixedShadowY,
    getRowThemeOverride: p.getRowThemeOverride,
    headerIcons,
    imageWindowLoader,
    initialSize,
    isDraggable,
    onDragLeave,
    onRowMoved,
    overscrollX,
    overscrollY,
    preventDiagonalScrolling,
    rightElement,
    rightElementProps,
    showMinimap,
    smoothScrollX,
    smoothScrollY,
    className,
    enableGroups,
    onCanvasFocused,
    onCanvasBlur: onFocusOut,
    canvasRef,
    onContextMenu,
    theme: mergedTheme,
    cellXOffset,
    cellYOffset,
    accessibilityHeight: visibleRegion.height,
    onDragEnd,
    columns: mangledCols,
    drawCustomCell: drawCell2,
    drawHeader: drawHeader2,
    disabledRows,
    freezeColumns: mangledFreezeColumns,
    lockColumns: rowMarkerOffset,
    firstColAccessible: rowMarkerOffset === 0,
    getCellContent: getMangledCellContent,
    minColumnWidth,
    maxColumnWidth,
    searchInputRef,
    showSearch,
    onSearchClose,
    highlightRegions,
    getCellsForSelection,
    getGroupDetails: mangledGetGroupDetails,
    headerHeight,
    isFocused,
    groupHeaderHeight: enableGroups ? groupHeaderHeight : 0,
    trailingRowType: !showTrailingBlankRow ? "none" : (trailingRowOptions == null ? void 0 : trailingRowOptions.sticky) === true ? "sticky" : "appended",
    onColumnResize,
    onColumnResizeEnd,
    onColumnResizeStart,
    onCellFocused,
    onColumnMoved: onColumnMovedImpl,
    onDragStart: onDragStartImpl,
    onHeaderMenuClick: onHeaderMenuClickInner,
    onItemHovered: onItemHoveredImpl,
    isFilling: (mouseState == null ? void 0 : mouseState.fillHandle) === true,
    onMouseMove: onMouseMoveImpl,
    onKeyDown,
    onKeyUp: onKeyUpIn,
    onMouseDown,
    onMouseUp,
    onDragOverCell,
    onDrop,
    onSearchResultsChanged,
    onVisibleRegionChanged: onVisibleRegionChangedImpl,
    clientSize: [clientSize[0], clientSize[1]],
    rowHeight,
    rows: mangledRows,
    scrollRef,
    selection: gridSelection,
    translateX: visibleRegion.tx,
    translateY: visibleRegion.ty,
    verticalBorder: mangledVerticalBorder,
    gridRef,
    getCellRenderer,
    scrollToEnd
  }), renameGroupNode, overlay !== void 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(data_grid_overlay_editor_default, { ...overlay,
    validateCell,
    id: overlayID,
    getCellRenderer,
    className: (experimental == null ? void 0 : experimental.isSubGrid) === true ? "click-outside-ignore" : void 0,
    provideEditor,
    imageEditorOverride,
    onFinishEditing,
    markdownDivCreateNode
  })));
};

var DataEditor = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataEditorImpl);


function inflate(input) {
  return { ...input,
    kind: GridCellKind.Custom
  };
}

function useCustomCells(cells) {
  return {
    customRenderers: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => cells.map(inflate), [cells])
  };
}



/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, [320], () => (__webpack_exec__("./node_modules/@storybook/core-client/dist/esm/globals/polyfills.js"), __webpack_exec__("./node_modules/@storybook/core-client/dist/esm/globals/globals.js"), __webpack_exec__("./storybook-init-framework-entry.js"), __webpack_exec__("./node_modules/@storybook/react/dist/esm/client/docs/config-generated-config-entry.js"), __webpack_exec__("./node_modules/@storybook/react/dist/esm/client/preview/config-generated-config-entry.js"), __webpack_exec__("./.storybook/preview.js-generated-config-entry.js"), __webpack_exec__("./generated-stories-entry.cjs")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);
//# sourceMappingURL=main.068cf821.iframe.bundle.js.map